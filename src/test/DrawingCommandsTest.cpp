#include "DrawingCommandsTest.h"
NS_TEST_BEGIN
DrawingCommandsTest::DrawingCommandsTest()
{
}

void DrawingCommandsTest::run()
{
}

DrawingCommandsTest::~DrawingCommandsTest()
{
}

void DrawingCommandsTest::PrimitiveShadingTest()
{
    /*
    概述 参见1741
    Drawing commands为带有draw的命令，调用该命令会执行绑定的graphics pipeline，所以在该命令执行之前，必须先绑定graphics pipeline以及pipeline中的shader。
    
    每个绘制由0个或多个顶点和0个或多个实例组成，这些实例由设备处理，并进行图元的组装，图元的组装根据VkPipelineInputAssemblyStateCreateInfo的信息进行。
    
    */

    VkPipelineInputAssemblyStateCreateInfo pipelineInputAssemblyStateCreateInfo{
        .sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO,
        .pNext = nullptr,
        .flags = 0,//保留未来使用
        .topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST,// VkPrimitiveTopology值，定义图元的拓扑类型
        .primitiveRestartEnable = VK_TRUE/*
        控制是否将一个特殊的顶点索引值视为重新启动图元组装的开关
        在 (vkCmdDrawIndexed, vkCmdDrawMultiIndexedEXT, 以及 vkCmdDrawIndexedIndirect)中使用
        这个特殊的索引值为:
        0xFFFFFFFF >> 当vkCmdBindIndexBuffer2KHR或者vkCmdBindIndexBuffer的indexType参数为VK_INDEX_TYPE_UINT32时
        0xFFFF >> 当vkCmdBindIndexBuffer2KHR或者vkCmdBindIndexBuffer的indexType参数为 VK_INDEX_TYPE_UINT16时

        不允许进行“list”拓扑的重新组装，除非primitiveTopologyPatchListRestart 或者 primitiveTopologyListRestart 中的一个特性开启
        */
    };
    /*
    VkPipelineInputAssemblyStateCreateInfo有效用法:
    1.如果primitiveTopologyListRestart 特性未开启，且topology 为VK_PRIMITIVE_TOPOLOGY_POINT_LIST, VK_PRIMITIVE_TOPOLOGY_LINE_LIST,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST, VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY, 或者
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY，则primitiveRestartEnable 必须为VK_FALSE。
    2.如果primitiveTopologyPatchListRestart 特性未开启，且topology 为VK_PRIMITIVE_TOPOLOGY_PATCH_LIST，则primitiveRestartEnable 必须为VK_FALSE。
    3.如果geometryShader 特性未开启，则topology 不能为VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY,
    VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY 或者
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY
    4.如果tessellationShader 特性未开启，则topology 不能为VK_PRIMITIVE_TOPOLOGY_PATCH_LIST。
    5.如果VK_KHR_portability_subset 扩展被启用，且VkPhysicalDevicePortabilitySubsetFeaturesKHR::triangleFans 特性为VK_FALSE，则topology 不能为VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN。
    */

    VkCommandBuffer commandBuffer{/*假设这是一个有效的VkCommandBuffer*/ };

    //动态控制是否将一个特殊的顶点索引值视为重新启动图元组装的开关  , 等同于vkCmdSetPrimitiveRestartEnableEXT
    //这个命令在使用shader objects 绘制或者pipeline以动态状态含VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE创建下有效
	vkCmdSetPrimitiveRestartEnable(commandBuffer, 
        VK_TRUE/*primitiveRestartEnable,控制是否将一个特殊的顶点索引值视为重新启动图元组装的开关,等价于VkPipelineInputAssemblyStateCreateInfo::primitiveRestartEnable */);
    /*
    vkCmdSetPrimitiveRestartEnable有效用法:
    1.以下至少需要有一个开启
           >  extendedDynamicState2 特性开启
           >  shaderObject 特性开启
           >  创建commandBuffer所在的VkInstance的VkApplicationInfo::apiVersion 要大于等于Version 1.3

    */



    // Primitive Topologies  参见1744
    {
        //Primitive topology决定了如何将连续的顶点组织成图元，并决定了在图形管道开始时使用的图元的类型,后续可能在tessellation 或者 geometry 阶段中改变图元类型，在mesh shading中有效的图元在mesh shader中定义。
        VkPrimitiveTopology primitiveTopology = VkPrimitiveTopology::VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
        /*
        VkPrimitiveTopology:

        VK_PRIMITIVE_TOPOLOGY_POINT_LIST:   指明一系列离散的点图元.
        VK_PRIMITIVE_TOPOLOGY_LINE_LIST:   指明一系列离散的线图元.
        VK_PRIMITIVE_TOPOLOGY_LINE_STRIP:   指明一系列相连的共享一个顶点的线图元
        VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST:   指明一系列离散的三角形图元.
        VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP:   指明一系列相连的共享一条边的三角形图元.
        VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN:   指明一系列相连的共享一个共同顶点的三角形图元，如果VK_KHR_portability_subset拓展开启，且VkPhysicalDevicePortabilitySubsetFeaturesKHR::triangleFans为VK_FALSE，
                则不支持改图元类型，即VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN 不能使用
        VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY:   指明一系列离散的带邻接关系的线图元
        VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY:   指明一系列相连的带邻接关系的线图元，即连续的线图元间共享三个顶点
        VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY:   指明一系列离散的带邻接关系的三角形图元
        VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY:   指明相连的带邻接关系的三角形图元，即连续的三角形图元间共享一条边
        VK_PRIMITIVE_TOPOLOGY_PATCH_LIST:   指明离散的 patch 图元.

        
        邻接关系不会影响图元类型，只是这些邻接关系数据会在geometry shader中使用
        */


        //动态设置图元类型   等价于vkCmdSetPrimitiveTopologyEXT，该命令只有在VkPipelineDynamicStateCreateInfo::pDynamicStates中动态开启VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY了才有效，否则将使用VkPipelineInputAssemblyStateCreateInfo::topology
        vkCmdSetPrimitiveTopology(commandBuffer, VK_PRIMITIVE_TOPOLOGY_LINE_LIST);
        /*
        vkCmdSetPrimitiveTopology有效用法:
        1.以下至少需要有一个开启
               >  extendedDynamicState 特性开启
               >  shaderObject 特性开启
               >  创建commandBuffer所在的VkInstance的VkApplicationInfo::apiVersion 要大于等于Version 1.3
        
        */




        //Topology Class 拓扑类型表   参见p1747 

        // Point Lists 点列表，类型VK_PRIMITIVE_TOPOLOGY_POINT_LIST ，每个连续的点定义一个顶点，总共图元数vertexCount  参见p1747 

        //  Line Lists 线列表，类型 VK_PRIMITIVE_TOPOLOGY_LINE_LIST ，每一对连续的点定义一条线，总共图元数vertexCount / 2 . 参见p1748    涉及provokingVertexMode

        //Line Strips 线列表，类型 VK_PRIMITIVE_TOPOLOGY_LINE_STRIP ，每一个点和其后续一个点定义一条线，总共图元数(0,vertexCount-1). 参见p1748
    
        //Triangle Lists 三角形列表，类型 VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST ，每连续的一组三个顶点组成一个三角形，总共图元数vertexCount / 3. 参见p1749   涉及provokingVertexMode
        
        //Triangle Strips 三角形列表，类型 VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP ，每个点和后续两个顶点组成一个三角形，总共图元数vertexCount - 2 . 参见p1750   涉及provokingVertexMode
    
        // Triangle Fans 三角形列表，类型 VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN ，所有三角形围绕一个公共顶点，公共顶点为V0，总共图元数vertexCount - 2 . 参见p1751   涉及provokingVertexMode

        // Line Lists With Adjacency线列表，类型  VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY ，每连续的一组四个顶点组成一条线以及其邻接数据，中间两个点为线图元，首尾两个点为邻接数据，总共图元数vertexCount / 4. 参见p1751   涉及provokingVertexMode
    
        //Line Strips With Adjacency线列表，类型  VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY ，所有点的中间每一个点和其后续一个点定义一条线，所有顶点的首尾两个点为线图元，总共图元数vertexCount - 3. 参见p1752   涉及provokingVertexMode
    
        //Triangle Lists With Adjacency 三角形列表，类型  VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY ，每连续的一组六个顶点组成一个三角形以及其邻接数据，第一个，第三个，第五个点组成三角形，其余三个点为邻接数据，总共图元数vertexCount / 6. 参见p1752   涉及provokingVertexMode
    
        //Triangle Strips With Adjacency 三角形列表，类型  VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY ，每一个点和其后续五个点定义一个三角形，第一个，第三个，第五个点组成三角形，其余三个点为邻接数据，总共图元数(vertexCount - 4) / 2. 参见p1752   涉及provokingVertexMode
    
        //Patch Lists patch列表，类型  VK_PRIMITIVE_TOPOLOGY_PATCH_LIST ，每连续的一组 m 个顶点组成一个patch，m 由 VkPipelineTessellationStateCreateInfo::patchControlPoints指定，总共图元数vertexCount / m. 参见p1755 
    }



    //Primitive Order  图元的顺序  参见p1756


    // Programmable Primitive Shading 可编程图元绘制  参见p1756
    {
        //一旦完成图元组装，pipeline便进入vertex shader阶段，如果绘制为multiple instances,则对于每个instance，这些图元会重复发送到vertex shader阶段，该阶段会接受来自图元装配阶段的每个顶点都含有的两个输入参数vertexIndex 以及 instanceIndex
        /*
        非索引绘制命令:vkCmdDraw ， vkCmdDrawIndirect， vkCmdDrawIndirectCount ，vkCmdDrawIndirectCountKHR， vkCmdDrawIndirectCountAMD，vkCmdDrawMultiEXT
        索引绘制命令: vkCmdDrawIndexed, vkCmdDrawIndexedIndirect, vkCmdDrawIndexedIndirectCount, vkCmdDrawIndexedIndirectCountKHR, vkCmdDrawIndexedIndirectCountAMD, vkCmdDrawMultiIndexedEXT
        */


        VkIndexType indexType = VK_INDEX_TYPE_UINT16;//指定索引的类型以及字节大小
        /*
        VkIndexType:
        VK_INDEX_TYPE_UINT16:    指明索引为16-bit unsigned integer值.
        VK_INDEX_TYPE_UINT32:    指明索引为32-bit unsigned integer值.
        VK_INDEX_TYPE_NONE_KHR:    指明没有提供索引数据.
        VK_INDEX_TYPE_UINT8_KHR:    指明索引为8-bit unsigned integer值.

        
        */

        //绑定索引缓冲区
        vkCmdBindIndexBuffer(commandBuffer, VkBuffer{/*假设这是一个有效的VkBuffer，表示顶点索引缓存区*/ }/*buffer,指定要绑定的buffer*/,
            0/*offset,用于索引缓冲区索引地址计算的起始字节偏移量*/, indexType/*indexType，指明索引的类型和大小*/);
        /*
        vkCmdBindIndexBuffer有效用法:
        1.offset必须小于buffer的大小
        2.offset + buffer内部VkDeviceMemory的基地址，必须是indexType指明的字节大小的整数倍
        3.buffer必须以VK_BUFFER_USAGE_INDEX_BUFFER_BIT 创建
        4.如果buffer是non-sparse的，则其必须已经绑定到完整连续单独的VkDeviceMemory上了
        5.indexType不能为VK_INDEX_TYPE_NONE_KHR
        6.如果indexType为VK_INDEX_TYPE_UINT8_KHR，则indexTypeUint8 特性必须开启
        7.如果maintenance6 没有开启，则buffer不能为VK_NULL_HANDLE
        8.如果buffer为VK_NULL_HANDLE，则offset必须为0
        */


        //绑定索引缓冲区以及其大小
        vkCmdBindIndexBuffer2KHR(commandBuffer, VkBuffer{/*假设这是一个有效的VkBuffer，表示顶点索引缓存区*/ }/*buffer,指定要绑定的buffer*/,
            0/*offset,用于索引缓冲区索引地址计算的起始字节偏移量*/,1/*size,为buffer中要绑定的内存大小*/, indexType/*indexType，指明索引的类型和大小*/);
        /*
        vkCmdBindIndexBuffer2KHR有效用法:
        1.offset必须小于buffer的大小
        2.offset + buffer内部VkDeviceMemory的基地址，必须是indexType指明的字节大小的整数倍
        3.buffer必须以VK_BUFFER_USAGE_INDEX_BUFFER_BIT 创建
        4.如果buffer是non-sparse的，则其必须已经绑定到完整连续单独的VkDeviceMemory上了
        5.indexType不能为VK_INDEX_TYPE_NONE_KHR
        6.如果indexType为VK_INDEX_TYPE_UINT8_KHR，则indexTypeUint8 特性必须开启
        7.如果maintenance6 没有开启，则buffer不能为VK_NULL_HANDLE
        8.如果buffer为VK_NULL_HANDLE，则offset必须为0
        9.如果size不为VK_WHOLE_SIZE,则（1）size必须为indexType指定的字节大小的整数倍
                                      （2）offset + size必须小于buffer的大小
        */



        //记录一个非索引绘制命令，  当执行这个命令，pipeline将以顶点索引为firstVertex开始组装vertexCount个顶点，以firstInstance开始绘制instanceCount个instance
        vkCmdDraw(commandBuffer, 1/*vertexCount,指明要绘制的顶点个数*/, 1/*instanceCount,指明要绘制的instances个数*/,
            0/*firstVertex,指明要绘制的第一个顶点的索引*/, 0/*firstInstance,指明要绘制的第一个instance的ID*/);
        /*
        vkCmdDraw有效用法:
        1.如果一个VkSampler以其magFilter或者minFilter等于VK_FILTER_LINEAR创建，则（1）如果reductionMode为VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE，如果用于采样一个VkImageView作为该命令的结果的compareEnable为VK_FALSE，则该image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT
                                                                                 （2）如果reductionMode为VK_SAMPLER_REDUCTION_MODE_MIN 或者VK_SAMPLER_REDUCTION_MODE_MAX之一 用于采样一个VkImageView作为该命令的结果，则该image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT
        2.如果一个VkSampler以其mipmapMode 等于VK_SAMPLER_MIPMAP_MODE_LINEAR创建，则（1）如果reductionMode为VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE，如果用于采样一个VkImageView作为该命令的结果的compareEnable为VK_FALSE，则该image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT
                                                                                 （2）如果reductionMode为VK_SAMPLER_REDUCTION_MODE_MIN 或者VK_SAMPLER_REDUCTION_MODE_MAX之一 用于采样一个VkImageView作为该命令的结果，则该image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT
        3.如果一个VkSampler以其unnormalizedCoordinates等于VK_TRUE用于采样一个VkImageView作为该命令的结果创建，则（1）该image view的levelCount以及layerCount必须为1
                                                                                                                （2）该image view的viewType必须为VK_IMAGE_VIEW_TYPE_1D 或者 VK_IMAGE_VIEW_TYPE_2D
        4.如果一个VkImageView的采样带depth comparison操作，则image view的format features必须包含VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT
        5.如果一个VkImageView使用atomic operations作为该命令的结果进行访问，则image view的format features必须包含VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT
        6.如果一个VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER类型的 descriptor使用atomic operations作为该命令的结果进行访问，则storage texel buffer的format features必须包含VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT
        7.如果一个以VK_FILTER_CUBIC_EXT进行采样的VkImageView作为该命令的结果，则image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT
        8.如果VK_EXT_filter_cubic拓展没有开启，且有任何一个以VK_FILTER_CUBIC_EXT进行采样的VkImageView作为该命令的结果，则其VkImageViewType不能为VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, 或者 VK_IMAGE_VIEW_TYPE_CUBE_ARRAY
        9.任何一个以VK_FILTER_CUBIC_EXT进行采样的作为该命令的结果的VkImageView，其VkImageViewType和format 必须支持cubic filtering，参见vkGetPhysicalDeviceImageFormatProperties2返回的VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic
        10.任何一个以VK_FILTER_CUBIC_EXT进行采样且reduction mode为VK_SAMPLER_REDUCTION_MODE_MIN 或者 VK_SAMPLER_REDUCTION_MODE_MAX之一的作为该命令的结果的VkImageView，其VkImageViewType和format 必须支持带minmax filtering的cubic filtering，参见vkGetPhysicalDeviceImageFormatProperties2返回的VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax
        11.如果cubicRangeClamp特性没有开启，则有任何一个以VK_FILTER_CUBIC_EXT进行采样VkImageView的作为该命令的结果，VkSamplerReductionModeCreateInfo::reductionMode不能为VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM
        12.任何一个以VkSamplerReductionModeCreateInfo::reductionMode为VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM进行采样的作为该命令的结果的VkImageView必须以VK_FILTER_CUBIC_EXT进行采样
        13.如果selectableCubicWeights特性没有开启，则有任何一个以VK_FILTER_CUBIC_EXT进行采样VkImageView的作为该命令的结果，VkSamplerCubicWeightsCreateInfoQCOM::cubicWeights必须为VK_CUBIC_FILTER_WEIGHTS_CATMULL_ROM_QCOM
        14.任何一个以VkImageCreateInfo::flags含VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV创建的采样作为该命令结果的VkImage必须以VkSamplerAddressMode为VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE 进行采样
        15.对于任何作为storage image写入的VkImageView，且其OpTypeImage的format未知，则该image view的 format features必须包含VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT
        16.对于任何作为storage image读取的VkImageView，且其OpTypeImage的format未知，则该image view的 format features必须包含VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT
        17.对于任何作为storage storage texel buffer写入的VkBufferView，且其OpTypeImage的format未知，则该buffer view的 buffer features必须包含VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT
        18.对于任何作为storage storage texel buffer读取的VkBufferView，且其OpTypeImage的format未知，则该buffer view的 buffer features必须包含VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT
        19.对于每个在绑定的shader中静态使用的set n，一个descriptor set必须被绑定到相同pipeline bind point的set n处，该set n必须和创建当前VkPipeline的VkPipelineLayout或者和创建当前VkShaderEXT的VkDescriptorSetLayout 数组的set n处的布局兼容，参见Pipeline Layout Compatibility p1280
        20.对于每个在绑定的shader中静态使用的push constant，一个push constant值必须被绑定到相同pipeline bind point的对应处，该push constant必须和创建当前VkPipeline的VkPipelineLayout或者和创建当前VkShaderEXT的VkDescriptorSetLayout 数组中的对应处的布局兼容，参见Pipeline Layout Compatibility p1280
        21.如果maintenance4特性没有开启，则对于每个在绑定的shader中静态使用的push constant，一个push constant值必须被设置到相同pipeline bind point的对应处，该push constant必须和创建当前VkPipeline的VkPipelineLayout或者和创建当前VkShaderEXT的VkDescriptorSetLayout 数组中的对应处的布局兼容，参见Pipeline Layout Compatibility p1280
        22.每一个通过vkCmdBindDescriptorSets绑定的descriptor set的descriptors,如果是被不以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建的，且已经绑定到该命令使用的pipeline bind point的VkPipeline静态使用的，则这些descriptors必须是有效的，参见 descriptor validity p1328
        23.如果通过vkCmdBindDescriptorSets指定绑定到pipeline bind point的VkPipeline要使用的descriptors，则绑定的VkPipeline不能以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建
		24.在vkCmdSetDescriptorBufferOffsetsEXT中指定绑定的descriptor buffers的descriptors，则（1）如果绑定到pipeline bind point的该命令会使用的VkPipeline以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建，且这些descriptors是动态使用的，则这些descriptors必须是有效的
                                                                                              （2）如果绑定到pipeline bind point的对应stage的该命令会使用的VkShaderEXT，且这些descriptors是动态使用的，则这些descriptors必须是有效的
        25.在vkCmdSetDescriptorBufferOffsetsEXT中指定的descriptors在绑定到pipeline bind point的VkPipeline中使用，则VkPipeline必须以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建
        26.如果一个descriptor在以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建的VkPipeline中动态使用，则descriptor memory必须是驻留内存
		27.如果一个descriptor在以其VkDescriptorSetLayout以VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建的VkShaderEXT中动态使用，则descriptor memory必须是驻留内存
        28.如果shaderObject 特性没有开启，一个有效的pipeline必须绑定到这个命令使用的绑定到pipeline bind point上
		29.如果一个pipeline绑定到该命令使用的pipeline bind point上，则不能有任何动态state 设置命令设置任何该VkPipeline 中没有指定的动态 state
		30.如果一个VkPipeline绑定到该命令使用的pipeline bind point上 或者任何一个会访问一个使用unnormalized coordinates的VkSampler的 VkShaderEXT绑定到该命令使用的pipeline bind point上的pipeline的对应stage，则
                                                                                    （1）在任何shader stage中，VkSampler不能用来采样任何类型为VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY 或者 VK_IMAGE_VIEW_TYPE_CUBE_ARRAY的VkImageView
                                                                                    （2）在任何shader stage中，该VkSampler不能和任何带有名字中带有ImplicitLod，Dref 或者 Proj 的SPIR-V OpImageSample* 或者 OpImageSparseSample*指令一起使用
                                                                                    （3）在任何shader stage中，该VkSampler不能和任何包含 LOD bias或者offset 值 的SPIR-V OpImageSample* or OpImageSparseSample*指令一起使用
		31.如果shaderObject开启，一个有效的pipeline必须绑定到该命令使用的pipeline bind point上或者一个有效的shader objects以及VK_NULL_HANDLE的组合必须绑定到该命令使用的pipeline bind point每一个支持的shader stage上
        32.如何绑定到该命令使用的pipeline bind point上的VkPipeline的任何stage会访问一个uniform buffer，且该stage对uniformBuffers不以启用VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT或者VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT 创建，且robustBufferAccess特性未开启，则该stage就不能访问绑定到相同pipeline bind point的descriptor set指定的buffer范围外的值
		33.如果robustBufferAccess特性未开启，且任何会访问uniform buffer的绑定到该命令使用的pipeline bind point上对应shader stage的VkShaderEXT，则其不能访问绑定到相同pipeline bind point的descriptor set指定的buffer范围外的值
        34.如何绑定到该命令使用的pipeline bind point上的VkPipeline的任何stage会访问一个storage buffer，且该stage对storageBuffers不以启用VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT或者VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT 创建，且robustBufferAccess特性未开启，则该stage就不能访问绑定到相同pipeline bind point的descriptor set指定的buffer范围外的值
		35.如果robustBufferAccess特性未开启，且任何会访问storage buffer的绑定到该命令使用的pipeline bind point上对应shader stage的VkShaderEXT，则其不能访问绑定到相同pipeline bind point的descriptor set指定的buffer范围外的值
        36.如果commandBuffer 是一个unprotected command buffer，且protectedNoFault 未支持，则任何绑定的shaders访问的资源不能是一个protected resource
        37.如果一个绑定的shader访问一个VkSampler 或者 VkImageView ，且启用了sampler Y′C BCR conversion，则只能使用OpImageSample* 或者 OpImageSparseSample*指令，不能使用ConstOffset 以及 Offset操作符
        38.如果一个VkImageView作为该命令的结果进行访问，则（1）image view 的viewType 必须匹配Instruction/Sampler/Image View Validation p1481中描述的OpTypeImage的Dim操作符
                                                          （2）image view 的foamrt的numeric type 必须匹配OpTypeImage的Sampled Type操作符
        39.如果一个VkImageView以一个不是VK_FORMAT_A8_UNORM_KHR的format创建且通过OpImageWrite作为该命令的结果进行访问，则该命令的Texel 操作符的Type必须至少包含和 image view的 format含有的components的个数相同的components个数
		40.如果一个VkImageView以VK_FORMAT_A8_UNORM_KHR的format创建且通过OpImageWrite作为该命令的结果进行访问，则该命令的Texel 操作符的Type必须包含4个components
		41.如果一个VkBufferView通过OpImageWrite作为该命令的结果进行访问，则该命令的Texel 操作符的Type必须至少包含和 buffer view的 format含有的components的个数相同的components个数
		42.如果一个带64-bit component的VkFormat的VkImageView作为该命令的结果进行访问，则该命令的OpTypeImage操作符的SampledType的宽度必须为64
		43.如果一个带少于64-bit component的VkFormat的VkImageView作为该命令的结果进行访问，则该命令的OpTypeImage操作符的SampledType的宽度必须为32
		44.如果一个带64-bit component的VkFormat的VkBufferView作为该命令的结果进行访问，则该命令的OpTypeImage操作符的SampledType的宽度必须为64位
		45.如果一个带少于64-bit component的VkFormat的VkBufferView作为该命令的结果进行访问，则该命令的OpTypeImage操作符的SampledType的宽度必须为32
		46.如果sparseImageInt64Atomics 特性未开启，则以VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT创建的VkImage对象不能被SampledType宽度为64位的OpTypeImage的atomic instructions访问
		47.如果sparseImageInt64Atomics 特性未开启，则以VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT创建的VkBuffer对象不能被SampledType宽度为64位的OpTypeImage的atomic instructions访问
		48.如果OpImageWeightedSampleQCOM用来采样一个作为该命令的结果的VkImageView，则该image view的format features必须包含VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM
        49.如果OpImageWeightedSampleQCOM用来采样一个作为该命令的结果的sample weight image的VkImageView，则该image view的format features必须包含VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM
		50.如果OpImageBoxFilterQCOM用来采样一个作为该命令的结果的VkImageView，则该image view的format features必须包含VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM
        51.如果OpImageBlockMatchSSDQCOM，或者 OpImageBlockMatchSADQCOM用来读取一个作为该命令的结果的VkImageView，则（1）该image view的format features必须包含VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM
                                                                                                                   （2）如果是读取的reference image，指定的reference coordinates不能在integer texel coordinate validation 时候失败
        52.如果OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchWindowSSDQCOM, OpImageBlockMatchWindowSADQCOM, OpImageBlockMatchGatherSSDQCOM,
                                                    OpImageBlockMatchGatherSADQCOM, OpImageBlockMatchSSDQCOM, 或者 OpImageBlockMatchSADQCOM用来采样一个作为该命令的结果的VkImageView，则该VkSampler必须以VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM创建
        53.如果任何除了OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchWindowSSDQCOM, OpImageBlockMatchWindowSADQCOM, OpImageBlockMatchGatherSSDQCOM, OpImageBlockMatchGatherSADQCOM, OpImageBlockMatchSSDQCOM, 或者 OpImageBlockMatchSADQCOM之外的指令使用VkSampler进行采样作为该命令的结果，则该sampler不能以VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM 创建
		54.如果OpImageBlockMatchWindow*QCOM or OpImageBlockMatchGather*QCOM指令用来读取VkImageView作为该命令的结果，则（1）VkImageView的format features必须包含VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM
                                                                                                                      （2）VkImageView的format必须只含有一个component
        55.如果OpImageBlockMatchWindow*QCOM or OpImageBlockMatchGather*QCOM指令用来读取一个引用的image作为该命令的结果，则指定的 reference coordinates不能在integer texel coordinate validation 时候失败
        56.任何该命令执行的shader invocation必须已经终止
        57.如果有一个类型位为VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM, VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, 或者 VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT中任意一个的descriptor作为该命令的结果进行访问，则该descriptor所指的image subresource的layout必须和该descriptor被写入时的layout相同。
        58.当前的 render pass  必须和绑定到VK_PIPELINE_BIND_POINT_GRAPHICS上的VkPipeline 创建时候的VkGraphicsPipelineCreateInfo中指定的renderPass兼容
        59.当前的 render pass  的subpass index必须和绑定到VK_PIPELINE_BIND_POINT_GRAPHICS上的VkPipeline 创建时候的VkGraphicsPipelineCreateInfo中指定的subpass相同
		60.如果任何shader静态访问一个input attachment，则有效的descriptor必须通过VkDescriptorSet被绑定到该pipeline中
		61.如果任何该pipeline执行shader以SubpassData的Dim操作符访问一个OpTypeImage变量，则该变量必须被一个对应当前subpass的input attachment的InputAttachmentIndex修饰
		62.在subpass中访问的Input attachment views必须以和该subpass相同定义的VkFormat创建，且必须以一个和当前绑定的VkFramebuffer的该附件引用的subpass的pInputAttachments[InputAttachmentIndex]附件兼容的VkImageView创建，参见Fragment Input Attachment Compatibility p1408
        63.在动态render pass中访问以VkRenderingInputAttachmentIndexInfoKHR的InputAttachmentIndex，或者VkRenderingInputAttachmentIndexInfoKHR:pDepthInputAttachmentIndex 或者 VkRenderingInputAttachmentIndexInfoKHR:pStencilInputAttachmentIndex为NULL情况下不指定InputAttachmentIndex的引用的Input attachment views，必须以和VkRenderingInfo中对应color, depth, 或者 stencil attachment兼容的VkImageView创建
        64.如果VkRenderingInputAttachmentIndexInfoKHR::pDepthInputAttachmentIndex 以及 VkRenderingInputAttachmentIndexInfoKHR::pStencilInputAttachmentIndex不为NULL，则在动态render pass中通过shader object访问Input attachment views必须指明InputAttachmentIndex
        65.如果在动态render pass中通过shader object访问Input attachment views指明了InputAttachmentIndex，则InputAttachmentIndex必须匹配VkRenderingInputAttachmentIndexInfoKHR中的index
        66.当前render pass所用的附件对应的image subresource底层内存的写入只能作为该命令的一个附件写入
        67.如果一个color attachment在之前的该subpass的命令中以load, store, 或者 resolve operations进行了写入，则其layout不为VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT，且有当前绑定的pipeline设有VK_PIPELINE_CREATE_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT，或者
                                        最后的vkCmdSetAttachmentFeedbackLoopEnableEXT调用包含VK_IMAGE_ASPECT_COLOR_BIT以及 没有绑定的pipeline 或者绑定的pipeline以VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT创建，则该附件只能以附件进行访问的，这两种情况中之一
        68.如果一个depth attachment在之前的该subpass的命令中以load, store, 或者 resolve operations进行了写入，则其layout不为VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT，且有当前绑定的pipeline设有VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT，或者
                                        最后的vkCmdSetAttachmentFeedbackLoopEnableEXT调用包含VK_IMAGE_ASPECT_DEPTH_BIT以及 没有绑定的pipeline 或者绑定的pipeline以VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT创建，则该附件只能以附件进行访问的，这两种情况中之一
        69.如果一个stencil attachment在之前的该subpass的命令中以load, store, 或者 resolve operations进行了写入，则其layout不为VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT，且有当前绑定的pipeline设有VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT，或者
                                        最后的vkCmdSetAttachmentFeedbackLoopEnableEXT调用包含VK_IMAGE_ASPECT_STENCIL_BIT以及 没有绑定的pipeline 或者绑定的pipeline以VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT创建，则该附件只能以附件进行访问的，这两种情况中之一
        70.如果一个attachment在之前的该subpass的命令中以load, store, 或者 resolve operations进行了写入,则该附件就不能再以除作为一个附件，storage image或者sampled image被该命令访问
        71.如果在之前的命令的subpass中以用作附件外的方式访问访问了一个当权subpass的附件所对的image subresource，则该命令就不能再将该image subresource用作附件进行写入
        72.如果当前render pass使用一个depth/stencil attachment，则（1）如果depth aspect的layout为read-only的layout，则不能启用depth writes
                                                                  （2）如果stencil aspect的layout为read-only的layout，front 以及 back writeMask不为0，且stencil 测试开启，则所有stencil 操作必须为VK_STENCIL_OP_KEEP
        73.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_VIEWPORT动态state开启创建，则vkCmdSetViewport必须在该命令之前设置
                                        （2）以VK_DYNAMIC_STATE_SCISSOR动态state开启创建，则vkCmdSetScissor必须在该命令之前设置
                                        （3）以VK_DYNAMIC_STATE_LINE_WIDTH动态state开启创建，则vkCmdSetLineWidth必须在该命令之前设置
                                        （4）以VK_DYNAMIC_STATE_DEPTH_BIAS动态state开启创建，则vkCmdSetDepthBias或者vkCmdSetDepthBias2EXT 必须在该命令之前设置
                                        （5）以VK_DYNAMIC_STATE_BLEND_CONSTANTS动态state开启创建，则vkCmdSetBlendConstants 必须在该命令之前设置
                                        （6）以VK_DYNAMIC_STATE_DEPTH_BOUNDS动态state开启创建，且如果当前depthBoundsTestEnable为VK_TRUE， 则vkCmdSetDepthBounds 必须在该命令之前设置
                                        （7）以VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK动态state开启创建，且如果当前stencilTestEnable为VK_TRUE， 则vkCmdSetStencilCompareMask 必须在该命令之前设置
                                        （8）以VK_DYNAMIC_STATE_STENCIL_WRITE_MASK动态state开启创建，且如果当前stencilTestEnable为VK_TRUE， 则vkCmdSetStencilWriteMask 必须在该命令之前设置
                                        （9）以VK_DYNAMIC_STATE_STENCIL_REFERENCE动态state开启创建，且如果当前stencilTestEnable为VK_TRUE， 则vkCmdSetStencilReference 必须在该命令之前设置
                                        （10）以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT动态state开启创建， 则vkCmdSetSampleLocationsEXT 必须在该命令之前设置
                                        （11）以VK_DYNAMIC_STATE_CULL_MODE动态state开启创建， 则vkCmdSetCullMode 必须在该命令之前设置
                                        （12）以VK_DYNAMIC_STATE_FRONT_FACE动态state开启创建， 则vkCmdSetFrontFace 必须在该命令之前设置
                                        （13）以VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE动态state开启创建， 则vkCmdSetDepthTestEnable 必须在该命令之前设置
                                        （14）以VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE动态state开启创建， 则vkCmdSetDepthWriteEnable 必须在该命令之前设置
                                        （15）以VK_DYNAMIC_STATE_DEPTH_COMPARE_OP动态state开启创建， 则vkCmdSetDepthCompareOp 必须在该命令之前设置
                                        （16）以VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE动态state开启创建， 则vkCmdSetDepthBoundsTestEnable 必须在该命令之前设置
                                        （17）以VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE动态state开启创建， 则vkCmdSetStencilTestEnable 必须在该命令之前设置
                                        （18）以VK_DYNAMIC_STATE_STENCIL_OP动态state开启创建， 则vkCmdSetStencilOp 必须在该命令之前设置
                                        （19）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT但不以VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT 动态state开启创建， 则vkCmdSetViewportWithCount 必须在该命令之前设置，且vkCmdSetViewportWithCount设置的viewportCount必须匹配pipeline的VkPipelineViewportStateCreateInfo::scissorCount
                                        （20）以VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT但不以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT 动态state开启创建， 则vkCmdSetScissorWithCount 必须在该命令之前设置，且vkCmdSetScissorWithCount设置的scissorCount必须匹配pipeline的VkPipelineViewportStateCreateInfo::viewportCount
                                        （21）以VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT和VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT 动态state同时开启创建， 则vkCmdSetViewportWithCount以及vkCmdSetScissorWithCount 必须在该命令之前设置，且vkCmdSetViewportWithCount设置的viewportCount必须匹配vkCmdSetScissorWithCount设置的scissorCount
                                        （22）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT但不以VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV 动态state开启创建， 则绑定的pipeline必须以VkPipelineViewportWScalingStateCreateInfoNV::viewportCount 大于等于最近vkCmdSetViewportWithCount设置的viewportCount创建
                                        （23）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT和VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV 动态state开启创建， 则最近调用的vkCmdSetViewportWScalingNV设置的viewportCount 必须大于等于最近vkCmdSetViewportWithCount设置的viewportCount
                                        （24）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT但不以VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV 动态state开启创建， 则绑定的pipeline必须以VkPipelineViewportShadingRateImageStateCreateInfoNV::viewportCount 大于等于最近vkCmdSetViewportWithCount设置的viewportCount创建
                                        （25）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT和VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV 动态state开启创建， 则最近调用的vkCmdSetViewportShadingRatePaletteNV设置的viewportCount 必须大于等于最近vkCmdSetViewportWithCount设置的viewportCount
                                        （26）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT动态state开启且VkPipelineViewportStateCreateInfo的pNext中含有一个VkPipelineViewportSwizzleStateCreateInfoNV 创建， 则绑定的pipeline必须以VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount 大于等于最近vkCmdSetViewportWithCount设置的viewportCount创建
                                        （27）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT动态state开启且VkPipelineViewportStateCreateInfo的pNext中含有一个VkPipelineViewportExclusiveScissorStateCreateInfoNV 创建， 则绑定的pipeline必须以VkPipelineViewportExclusiveScissorStateCreateInfoNV::exclusiveScissorCount 大于等于最近vkCmdSetViewportWithCount设置的viewportCount创建
                                        （28）以VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_ENABLE_NV动态state开启创建， 则vkCmdSetExclusiveScissorEnableNV 必须在该命令之前设置
                                        （29）以VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV动态state开启创建， 则vkCmdSetExclusiveScissorNV 必须在该命令之前设置
                                        （30）以VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE动态state开启创建， 则vkCmdSetRasterizerDiscardEnable 必须在该命令之前设置
                                        （31）以VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE动态state开启创建， 则vkCmdSetDepthBiasEnable 必须在该命令之前设置
                                        （32）以VK_DYNAMIC_STATE_LOGIC_OP_EXT动态state开启创建， 则vkCmdSetLogicOpEXT 必须在该命令之前设置且参数logicOp必须是一个有效的VkLogicOp值
        74.如果一个shader object绑定到任何graphics stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                        （1）如果最靠近当前命令的vkCmdSetPolygonModeEXT设置polygonMode为VK_POLYGON_MODE_LINE或者是任何line topology，则vkCmdSetLineWidth必须在该命令之前设置
                                        （2）如果最靠近当前命令的vkCmdSetDepthBiasEnable设置depthBiasEnable为VK_TRUE，则vkCmdSetDepthBias 或者 vkCmdSetDepthBias2EXT必须在该命令之前设置
                                        （3）如果最靠近当前命令的vkCmdSetDepthBoundsTestEnable设置depthBoundsTestEnable为VK_TRUE，则vkCmdSetDepthBounds必须在该命令之前设置
                                        （4）如果最靠近当前命令的vkCmdSetStencilTestEnable设置stencilTestEnable为VK_TRUE，则vkCmdSetStencilCompareMask必须在该命令之前设置
                                        （5）如果最靠近当前命令的vkCmdSetStencilTestEnable设置stencilTestEnable为VK_TRUE，则vkCmdSetStencilWriteMask必须在该命令之前设置
                                        （6）如果最靠近当前命令的vkCmdSetStencilTestEnable设置stencilTestEnable为VK_TRUE，则vkCmdSetStencilReference必须在该命令之前设置
                                        （7）如果最靠近当前命令的vkCmdSetSampleLocationsEnableEXT设置sampleLocationsEnable为VK_TRUE，则vkCmdSetSampleLocationsEXT必须在该命令之前设置
                                        （8）则vkCmdSetCullMode必须在该命令之前设置
                                        （9）则vkCmdSetFrontFace必须在该命令之前设置
                                        （10）则vkCmdSetDepthTestEnable 必须在该命令之前设置
                                        （11）则vkCmdSetDepthWriteEnable 必须在该命令之前设置
                                        （12）如果最靠近当前命令的vkCmdSetDepthTestEnable设置depthTestEnable为VK_TRUE，则vkCmdSetDepthCompareOp 必须在该命令之前设置
                                        （13）则vkCmdSetDepthBoundsTestEnable 必须在该命令之前设置
                                        （14）则vkCmdSetStencilTestEnable 必须在该命令之前设置
                                        （15）如果最靠近当前命令的vkCmdSetStencilTestEnable设置stencilTestEnable为VK_TRUE，则vkCmdSetStencilOp 必须在该命令之前设置
                                        （16）
                                        （17）如果shadingRateImage特性开启，则vkCmdSetCoarseSampleOrderNV 必须在该命令之前设置
                                        （18）如果shadingRateImage特性开启，且最靠近当前命令的vkCmdSetShadingRateImageEnableNV设置shadingRateImageEnable为VK_TRUE，则vkCmdSetViewportShadingRatePaletteNV 必须在该命令之前设置
                                        （19）如果shadingRateImage特性开启，且最靠近当前命令的vkCmdSetShadingRateImageEnableNV设置shadingRateImageEnable为VK_TRUE，则最近的vkCmdSetViewportShadingRatePaletteNV设置的viewportCount 必须大于等于vkCmdSetViewportWithCount设置的viewportCount
                                        （20）则vkCmdSetDepthBiasEnable必须在该命令之前设置
        75.如果一个输出line primitives的shader object绑定到VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或者 VK_SHADER_STAGE_GEOMETRY_BIT，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则vkCmdSetLineWidth必须在该命令之前设置
        76.如果一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最靠近当前命令的vkCmdSetColorBlendEnableEXT设置pColorBlendEnables任何元素为VK_TRUE，且
                            最靠近当前命令的vkCmdSetColorBlendEquationEXT设置pColorBlendEquations相同元素的VkColorBlendEquationEXT的VkBlendFactor成员为VK_BLEND_FACTOR_CONSTANT_COLOR, VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR, VK_BLEND_FACTOR_CONSTANT_ALPHA, 或者 VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA，则vkCmdSetBlendConstants必须在该命令之前设置
        77.如果该命令记录在开启了multiview的render pass instance中，则最大的instance 索引必须小于等于VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex
        78.如果绑定的graphics pipeline以VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable设置为VK_TRUE创建且当前的subpass含有一个 depth/stencil attachment，则该attachment必须以VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT创建
        >>78.5  .如果一个shader object绑定到任何graphics stage，则则（1）vkCmdSetViewportWithCount 和vkCmdSetScissorWithCount 必须同时在该命令之前设置，且vkCmdSetViewportWithCount设置的viewportCount必须匹配vkCmdSetScissorWithCount设置的scissorCount
                                                                    （2）则vkCmdSetRasterizerDiscardEnable 必须在该命令之前设置
        79.如果VK_NV_clip_space_w_scaling拓展开启，且shader object绑定到任何graphics stage，且最近的vkCmdSetViewportWScalingEnableNV设置viewportWScalingEnable为VK_TRUE，则（1）vkCmdSetViewportWScalingNV必须在该命令前设置
                                                                                                                                                                           （2）最近vkCmdSetViewportWScalingNV设置的viewportCount必须大于等于vkCmdSetViewportWithCount设置的viewportCount
        80.如果exclusiveScissor 特性开启，且shader object绑定到任何graphics stage，，则（1）vkCmdSetExclusiveScissorEnableNV必须在该命令前设置
                                                                                       （2）最近的vkCmdSetExclusiveScissorEnableNV调用设置的pExclusiveScissorEnables中的任何元素为VK_TRUE,则vkCmdSetExclusiveScissorNV必须在该命令前设置
        81.如果一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最靠近当前命令的vkCmdSetLogicOpEnableEXT设置logicOpEnable任何元素为VK_TRUE，则vkCmdSetLogicOpEXT 必须在该命令之前设置且参数logicOp必须是一个有效的VkLogicOp值
        82.如果primitiveFragmentShadingRateWithMultipleViewports限制不支持，则（1）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT动态state开启创建，且任何该pipeline的shader stage会写入PrimitiveShadingRateKHR built-in修饰的变量，则vkCmdSetViewportWithCount 必须在该命令之前设置且参数viewportCount必须是1
                                                                              （2）任何绑定的graphics pipeline的shader stage会写入PrimitiveShadingRateKHR built-in修饰的变量，则vkCmdSetViewportWithCount 必须在该命令之前设置且参数viewportCount必须是1
        83.如果graphics pipeline中未开启rasterization，则对subpass中的每个color attachment，如果其对应的image view 的format features不包含VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT，则pColorBlendState中其对应pAttachments中元素的blendEnable必须为VK_FALSE
        84.如果一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则对于render pass中的每个color attachment，如果其对应的image view 的format features不包含VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT， 则最近的vkCmdSetColorBlendEnableEXT设置的pColorBlendEnables中该附件的对应元素必须为VK_FALSE
        85.如果graphics pipeline中未开启rasterization，有VK_AMD_mixed_attachment_samples拓展未开启，VK_NV_framebuffer_mixed_samples拓展未开启，multisampledRenderToSingleSampled特性未开启，则当前绑定的pipeline的rasterizationSamples必须和当前subpass的color 以及/或者 depth/stencil attachments的相同
        86.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且有VK_AMD_mixed_attachment_samples拓展未开启，VK_NV_framebuffer_mixed_samples拓展未开启，multisampledRenderToSingleSampled特性未开启，则最近vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples必须和当前subpass的color 以及/或者 depth/stencil attachments的相同
        87.如果一个shader object绑定到任何graphics stage，则当前的render pass instance必须以vkCmdBeginRendering开始
        88.如果当前的render pass instance以vkCmdBeginRendering开始，（1）如果pDepthAttachment的imageView不为VK_NULL_HANDLE，且pDepthAttachment的layout不为VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL，则该命令不能写入任何值到depth attachment
                                                                    （2）如果pStencilAttachment的imageView不为VK_NULL_HANDLE，且pStencilAttachment的layout不为VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL，则该命令不能写入任何值到stencil attachment
                                                                    （3）如果pDepthAttachment的imageView不为VK_NULL_HANDLE，且pDepthAttachment的layout为VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL，则该命令不能写入任何值到depth attachment
                                                                    （4）如果pStencilAttachment的imageView不为VK_NULL_HANDLE，且pStencilAttachment的layout为VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL，则该命令不能写入任何值到stencil attachment
                                                                    （5）如果pDepthAttachment的imageView不为VK_NULL_HANDLE，且pDepthAttachment的layout为VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL，则该命令不能写入任何值到depth attachment
                                                                    （6）如果pStencilAttachment的imageView不为VK_NULL_HANDLE，且pStencilAttachment的layout为VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL，则该命令不能写入任何值到stencil attachment
                                                                    （7）则当前绑定的graphics pipeline必须以含VkPipelineRenderingCreateInfo::viewMask等于VkRenderingInfo::viewMask创建
                                                                    （8）如果带有VkRenderingInfo::colorAttachmentCount为1，则没有shader object绑定到任何graphics stage，且一个color attachment的 resolve mode为VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID，则VkRenderingInfo::pColorAttachments中每个resolveImageView不为VK_NULL_HANDLE的元素其对应image必须以和创建当前绑定的pipeline 相同的VkExternalFormatANDROID::externalFormat创建
                                                                    （9）如果没有shader object绑定到任何graphics stage，如果绑定的graphics pipeline以一个非零值VkExternalFormatANDROID::externalFormat创建且启用VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态设置，则vkCmdSetColorBlendEnableEXT必须在该命令前设置blend enable为VK_FALSE
                                                                    （10）如果没有shader object绑定到任何graphics stage，如果绑定的graphics pipeline以一个非零值VkExternalFormatANDROID::externalFormat创建且启用VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态设置，则vkCmdSetRasterizationSamplesEXT必须在该命令前设置rasterizationSamples为VK_SAMPLE_COUNT_1_BIT
                                                                    （11）如果没有shader object绑定到任何graphics stage，如果绑定的graphics pipeline以一个非零值VkExternalFormatANDROID::externalFormat创建且启用VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR动态设置，则vkCmdSetFragmentShadingRateKHR必须在该命令前设置pFragmentSize->width为1，pFragmentSize->height为1
        89.如果dynamicRenderingUnusedAttachments特性未开启，且当前的render pass instance以vkCmdBeginRendering开始，则
                                                                （1）当前绑定的graphics pipeline必须以含VkPipelineRenderingCreateInfo::colorAttachmentCount等于VkRenderingInfo::colorAttachmentCount创建
                                                                （2）如果VkRenderingInfo::colorAttachmentCount大于0，则VkRenderingInfo::pColorAttachments 中每一个其imageView不为VK_NULL_HANDLE的元素的VkImageView必须以VkFormat对应绑定的graphics pipeline的VkPipelineRenderingCreateInfo::pColorAttachmentFormats指明的format创建
                                                                （3）如果VkRenderingInfo::colorAttachmentCount大于0，则VkRenderingInfo::pColorAttachments 中每一个其imageView为VK_NULL_HANDLE的元素对应绑定的graphics pipeline的VkPipelineRenderingCreateInfo::pColorAttachmentFormats指明的format必须为VK_FORMAT_UNDEFINED
                                                                （4）如果VkRenderingInfo::pDepthAttachment->imageView为VK_NULL_HANDLE，则创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::depthAttachmentFormat必须为VK_FORMAT_UNDEFINED
                                                                （5）如果VkRenderingInfo::pDepthAttachment->imageView不为VK_NULL_HANDLE，则创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::depthAttachmentFormat必须和创建VkRenderingInfo::pDepthAttachment->imageView的VkFormat相同
                                                                （6）如果VkRenderingInfo::pStencilAttachment->imageView为VK_NULL_HANDLE，则创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::stencilAttachmentFormat必须为VK_FORMAT_UNDEFINED
                                                                （7）如果VkRenderingInfo::pStencilAttachment->imageView不为VK_NULL_HANDLE，则创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::stencilAttachmentFormat必须和创建VkRenderingInfo::pStencilAttachment->imageView的VkFormat相同
        90.如果dynamicRenderingUnusedAttachments特性开启，且当前的render pass instance以vkCmdBeginRendering开始，则
                                                                （1）如果VkRenderingInfo::colorAttachmentCount大于0，则VkRenderingInfo::pColorAttachments 中每一个其imageView不为VK_NULL_HANDLE的元素的VkImageView必须以VkFormat对应绑定的graphics pipeline的VkPipelineRenderingCreateInfo::pColorAttachmentFormats指明的format创建，或者是对应元素为VK_FORMAT_UNDEFINED创建
                                                                （2）如果VkRenderingInfo::pDepthAttachment->imageView不为VK_NULL_HANDLE，且创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::depthAttachmentFormat和创建VkRenderingInfo::pDepthAttachment->imageView的VkFormat不同，则该format必须为VK_FORMAT_UNDEFINED
                                                                （3）如果VkRenderingInfo::pStencilAttachment->imageView不为VK_NULL_HANDLE，且创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::stencilAttachmentFormat和创建VkRenderingInfo::pStencilAttachment->imageView的VkFormat不同，则该format必须为VK_FORMAT_UNDEFINED
        91.如果没有shader object绑定到任何graphics stage，且当前的render pass instance以vkCmdBeginRendering开始且VkRenderingInfo::colorAttachmentCount为1，且一个color attachment的 resolve mode为VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID，则VkRenderingInfo::pColorAttachments中每个resolveImageView不为VK_NULL_HANDLE的元素其对应image必须以和创建当前绑定的pipeline 相同的VkExternalFormatANDROID::externalFormat创建
        92.如果有一个shader object绑定到任何graphics stage，且当前的render pass 包含一个使用VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID resolve mode的color attachment，则（1）vkCmdSetColorBlendEnableEXT必须在该命令前设置blend enable为VK_FALSE
                                                                                                                                                                                 （2）则vkCmdSetRasterizationSamplesEXT必须在该命令前设置rasterizationSamples为VK_SAMPLE_COUNT_1_BIT
                                                                                                                                                                                 （3）则vkCmdSetFragmentShadingRateKHR必须在该命令前设置pFragmentSize->width为1，pFragmentSize->height为1
        93.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT动态state开启创建， 则vkCmdSetColorWriteEnableEXT 必须在该命令之前设置，且设置的attachmentCount必须大于等于创建当前绑定的pipeline的VkPipelineColorBlendStateCreateInfo::attachmentCount                                                                                                                                                                    
                                        （2）以VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT动态state开启创建， 则vkCmdSetDiscardRectangleEXT 必须在该命令之前为每个VkPipelineDiscardRectangleStateCreateInfoEXT::discardRectangleCount指明的discard rectangle 设置
                                        （3）以VK_DYNAMIC_STATE_DISCARD_RECTANGLE_ENABLE_EXT动态state开启创建， 则vkCmdSetDiscardRectangleEnableEXT 必须在该命令之前设置
                                        （4）以VK_DYNAMIC_STATE_DISCARD_RECTANGLE_MODE_EXT动态state开启创建， 则vkCmdSetDiscardRectangleModeEXT 必须在该命令之前设置
        94.如果有一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                        （1）如果colorWriteEnable特性在device上开启，则vkCmdSetColorWriteEnableEXT 必须在该命令之前设置，且设置的attachmentCount必须大于等于当前render pass instance的color attachment的数量
                                        （2）如果VK_EXT_discard_rectangles拓展开启，且最近的vkCmdSetDiscardRectangleEnableEXT设置discardRectangleEnable为VK_TRUE， 则vkCmdSetDiscardRectangleEXT 必须在该命令之前设置
                                        （3）如果VK_EXT_discard_rectangles拓展开启， 则vkCmdSetDiscardRectangleEnableEXT 必须在该命令之前设置
                                        （4）如果VK_EXT_discard_rectangles拓展开启， 则最近的vkCmdSetDiscardRectangleEnableEXT设置discardRectangleEnable为VK_TRUE，则vkCmdSetDiscardRectangleModeEXT 必须在该命令之前设置
        95.如果当前的render pass instance以vkCmdBeginRendering开始，则（1）如果VkRenderingFragmentShadingRateAttachmentInfoKHR::imageView不为VK_NULL_HANDLE，则当前绑定的graphics pipeline必须以VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR创建
                                                                      （2）如果VkRenderingFragmentDensityMapAttachmentInfoEXT::imageView不为VK_NULL_HANDLE，则当前绑定的graphics pipeline必须以VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT创建
                                                                      （3）且含VkRenderingInfo::colorAttachmentCount大于0，如果当前的绑定的pipeline以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，则VkRenderingInfo::pColorAttachments中每个imageView不为VK_NULL_HANDLE的元素的imageView，必须以当前pipeline的VkAttachmentSampleCountInfoAMD 或者 VkAttachmentSampleCountInfoNV中的pColorAttachmentSamples中对应元素的sample count进行创建
                                                                      （4）如果当前的绑定的pipeline以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且VkRenderingInfo::pDepthAttachment中的imageView不为VK_NULL_HANDLE，则当前pipeline的VkAttachmentSampleCountInfoAMD 或者 VkAttachmentSampleCountInfoNV中的depthStencilAttachmentSamples必须等于创建VkRenderingInfo::pDepthAttachment->imageView的sample count
                                                                      （5）如果当前的绑定的pipeline以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且VkRenderingInfo::pStencilAttachment中的imageView不为VK_NULL_HANDLE，则当前pipeline的VkAttachmentSampleCountInfoAMD 或者 VkAttachmentSampleCountInfoNV中的depthStencilAttachmentSamples必须等于创建VkRenderingInfo::pStencilAttachment->imageView的sample count
                                                                      （6）且含VkRenderingInfo::colorAttachmentCount大于0，如果当前的绑定的pipeline不以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且multisampledRenderToSingleSampled特性没有开启，则VkRenderingInfo::pColorAttachments中每个imageView不为VK_NULL_HANDLE的元素的imageView，其创建的sample count必须等于当前绑定的graphics pipeline的rasterizationSamples
                                                                      （7）如果当前的绑定的pipeline不以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且VkRenderingInfo::pDepthAttachment中的imageView不为VK_NULL_HANDLE，且multisampledRenderToSingleSampled特性没有开启，则当前pipeline的rasterizationSamples 必须等于创建VkRenderingInfo::pDepthAttachment->imageView的sample count
                                                                      （8）如果当前的绑定的pipeline不以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且VkRenderingInfo::pStencilAttachment中的imageView不为VK_NULL_HANDLE，且multisampledRenderToSingleSampled特性没有开启，则当前pipeline的rasterizationSamples 必须等于创建VkRenderingInfo::pStencilAttachment->imageView的sample count
                                                                      （9）当前绑定的pipeline必须VkGraphicsPipelineCreateInfo::renderPass为VK_NULL_HANDLE创建
                                                                      （10）如果绑定的pipeline的fragment shader静态写入一个color attachment，且color write mask不为0，启用了color writes，且该附件对应的VkRenderingInfo::pColorAttachments->imageView 不为VK_NULL_HANDLE，则对应的创建pipeline的VkPipelineRenderingCreateInfo::pColorAttachmentFormats中的元素不能为VK_FORMAT_UNDEFINED
                                                                      （11）如果绑定的pipeline启用了depth test，启用了depth writes，且VkRenderingInfo::pDepthAttachment->imageView 不为VK_NULL_HANDLE，则创建pipeline的VkPipelineRenderingCreateInfo::depthAttachmentFormat不能为VK_FORMAT_UNDEFINED
                                                                      （12）如果绑定的pipeline启用了stencil test，且VkRenderingInfo::pStencilAttachment->imageView 不为VK_NULL_HANDLE，则创建pipeline的VkPipelineRenderingCreateInfo::stencilAttachmentFormat不能为VK_FORMAT_UNDEFINED
        96.如果该命令在以vkCmdBeginRendering开始的render pass instance中调用，且VkRenderingInfo的pNext中包含一个multisampledRenderToSingleSampledEnable设为VK_TRUE的VkMultisampledRenderToSingleSampledInfoEXT，则当前绑定的graphics pipeline的rasterizationSamples必须等于VkMultisampledRenderToSingleSampledInfoEXT::rasterizationSamples
        97.如果primitivesGeneratedQueryWithRasterizerDiscard特性未开启，且VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query激活，则不能启用rasterization discard
        98如果primitivesGeneratedQueryWithNonZeroStreams特性未开启，且VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query激活，则 绑定的graphics pipeline不能以VkPipelineRasterizationStateStreamCreateInfoEXT::rasterizationStream为非零值创建
        98.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_TESSELLATION_DOMAIN_ORIGIN_EXT动态state开启创建，则vkCmdSetTessellationDomainOriginEXT必须在该命令之前设置   
                                        （2）以VK_DYNAMIC_STATE_DEPTH_CLAMP_ENABLE_EXT动态state开启创建，则vkCmdSetDepthClampEnableEXT必须在该命令之前设置   
                                        （3）以VK_DYNAMIC_STATE_POLYGON_MODE_EXT动态state开启创建，则vkCmdSetPolygonModeEXT必须在该命令之前设置  
                                        （4）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，则vkCmdSetRasterizationSamplesEXT必须在该命令之前设置  
                                        （5）以VK_DYNAMIC_STATE_SAMPLE_MASK_EXT动态state开启创建，则vkCmdSetSampleMaskEXT必须在该命令之前设置  
                                        （6）以VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT动态state开启创建，则vkCmdSetAlphaToCoverageEnableEXT必须在该命令之前设置
                                        （7）以VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT动态state开启创建，则最近的vkCmdSetAlphaToCoverageEnableEXT设置alphaToCoverageEnable为VK_TRUE，则Fragment Output Interface中 Index 0的Location 0必须有一个含alpha Component的变量
                                        （8）以VK_DYNAMIC_STATE_ALPHA_TO_ONE_ENABLE_EXT动态state开启创建，则vkCmdSetAlphaToOneEnableEXT必须在该命令之前设置 
                                        （9）以VK_DYNAMIC_STATE_LOGIC_OP_ENABLE_EXT动态state开启创建，则vkCmdSetLogicOpEnableEXT必须在该命令之前设置
                                        （10）以VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态state开启创建，则vkCmdSetColorBlendEnableEXT必须在该命令之前设置
                                        （11）以VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT动态state开启创建，则vkCmdSetColorBlendEquationEXT必须在该命令之前设置
                                        （12）以VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT动态state开启创建，则vkCmdSetColorWriteMaskEXT必须在该命令之前设置
        
        99.如果一个shader object绑定到VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT stage，则vkCmdSetTessellationDomainOriginEXT必须在该命令之前设置   
        100.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                                        （1）如果depthClamp特性启用，则vkCmdSetDepthClampEnableEXT必须在该命令之前设置   
                                                        （2）则vkCmdSetPolygonModeEXT必须在该命令之前设置   
                                                        （3）则vkCmdSetRasterizationSamplesEXT必须在该命令之前设置 
                                                        （4）则vkCmdSetSampleMaskEXT必须在该命令之前设置 
                                                        （5）则vkCmdSetAlphaToCoverageEnableEXT必须在该命令之前设置 
                                                        （6）如果alphaToOne特性启用，则vkCmdSetAlphaToOneEnableEXT必须在该命令之前设置   

        101.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetAlphaToCoverageEnableEXT设置alphaToCoverageEnable为VK_TRUE，则Fragment Output Interface中 Index 0的Location 0必须有一个含alpha Component的变量
        102.如果一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                            （1）如果logicOp特性开启 ,vkCmdSetLogicOpEnableEXT必须在该命令之前设置   
                                            （2）如果绑定了color attachments，则vkCmdSetColorBlendEnableEXT必须在该命令之前设置
                                            （3）如果最近的vkCmdSetColorBlendEnableEXT设置任何附件在pColorBlendEnables中的值为VK_TRUE ，则vkCmdSetColorBlendEquationEXT必须在该命令之前设置
                                            （4）如果绑定了color attachments，则vkCmdSetColorWriteMaskEXT必须在该命令之前设置
        103.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT动态state开启创建，则vkCmdSetRasterizationStreamEXT必须在该命令之前设置
                                         （2）以VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT动态state开启创建，则vkCmdSetConservativeRasterizationModeEXT必须在该命令之前设置
                                         （3）以VK_DYNAMIC_STATE_EXTRA_PRIMITIVE_OVERESTIMATION_SIZE_EXT动态state开启创建，则vkCmdSetExtraPrimitiveOverestimationSizeEXT必须在该命令之前设置
                                         （4）以VK_DYNAMIC_STATE_DEPTH_CLIP_ENABLE_EXT动态state开启创建，则vkCmdSetDepthClipEnableEXT必须在该命令之前设置
                                         （5）以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT动态state开启创建，则vkCmdSetSampleLocationsEnableEXT必须在该命令之前设置
                                         （6）以VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT动态state开启创建，则vkCmdSetColorBlendAdvancedEXT必须在该命令之前设置
                                         （7）以VK_DYNAMIC_STATE_PROVOKING_VERTEX_MODE_EXT动态state开启创建，则vkCmdSetProvokingVertexModeEXT必须在该命令之前设置
                                         （8）以VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT动态state开启创建，则vkCmdSetLineRasterizationModeEXT必须在该命令之前设置
                                         （9）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT动态state开启创建，则vkCmdSetLineStippleEnableEXT必须在该命令之前设置
                                         （10）以VK_DYNAMIC_STATE_LINE_STIPPLE_KHR动态state开启创建，则vkCmdSetLineStippleKHR必须在该命令之前设置
                                         （11）以VK_DYNAMIC_STATE_DEPTH_CLIP_NEGATIVE_ONE_TO_ONE_EXT动态state开启创建，则vkCmdSetDepthClipNegativeOneToOneEXT必须在该命令之前设置
                                         （12）以VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_ENABLE_NV动态state开启创建，则vkCmdSetViewportWScalingEnableNV必须在该命令之前设置
                                         （13）以VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV动态state开启创建，则vkCmdSetViewportSwizzleNV必须在该命令之前设置
                                         （14）以VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV动态state开启创建，则vkCmdSetCoverageToColorEnableNV必须在该命令之前设置
                                         （15）以VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_LOCATION_NV动态state开启创建，则vkCmdSetCoverageToColorLocationNV必须在该命令之前设置
                                         （16）以VK_DYNAMIC_STATE_COVERAGE_MODULATION_MODE_NV动态state开启创建，则vkCmdSetCoverageModulationModeNV必须在该命令之前设置
                                         （17）以VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV动态state开启创建，则vkCmdSetCoverageModulationTableEnableNV必须在该命令之前设置
                                         （18）以VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_NV动态state开启创建，则vkCmdSetCoverageModulationTableNV必须在该命令之前设置
                                         （19）以VK_DYNAMIC_STATE_SHADING_RATE_IMAGE_ENABLE_NV动态state开启创建，则vkCmdSetShadingRateImageEnableNV必须在该命令之前设置
                                         （20）以VK_DYNAMIC_STATE_REPRESENTATIVE_FRAGMENT_TEST_ENABLE_NV动态state开启创建，则vkCmdSetRepresentativeFragmentTestEnableNV必须在该命令之前设置
                                         （21）以VK_DYNAMIC_STATE_COVERAGE_REDUCTION_MODE_NV动态state开启创建，则vkCmdSetCoverageReductionModeNV必须在该命令之前设置
        
        104.如果一个shader object绑定到VK_SHADER_STAGE_GEOMETRY_BIT stage，且如果geometryStreams 特性开启，则vkCmdSetRasterizationStreamEXT必须在该命令之前设置
        105.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                （1）如果VK_EXT_conservative_rasterization 拓展开启，vkCmdSetConservativeRasterizationModeEXT必须在该命令之前设置
								（2）如果VK_EXT_conservative_rasterization 拓展开启，且最近的vkCmdSetConservativeRasterizationModeEXT设置conservativeRasterizationMode为VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT，则vkCmdSetExtraPrimitiveOverestimationSizeEXT必须在该命令之前设置
		                        （3）如果VK_EXT_sample_locations 拓展开启，则vkCmdSetSampleLocationsEnableEXT必须在该命令之前设置
        106.如果一个shader object绑定到任何graphics stage，且depthClipEnable 特性开启，则vkCmdSetDepthClipEnableEXT必须在该命令之前设置
		107.如果如果一个shader object绑定到任何VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且如果VK_EXT_blend_operation_advanced 拓展开启，则vkCmdSetColorBlendEquationEXT 和 vkCmdSetColorBlendAdvancedEXT中至少一个必须在该命令之前设置
		108.如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，如果VK_EXT_provoking_vertex拓展开启， 则vkCmdSetProvokingVertexModeEXT必须在该命令之前设置
		109.如果VK_KHR_line_rasterization 或者 VK_EXT_line_rasterization拓展开启，则（1）如果一个shader object绑定到任意一个graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetPolygonModeEXT设置polygonMode 为VK_POLYGON_MODE_LINE ，则vkCmdSetLineRasterizationModeEXT必须在该命令之前设置
                                                                                    （2）如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetPrimitiveTopology设置primitiveTopology 为任何line topology ，则vkCmdSetLineRasterizationModeEXT必须在该命令之前设置
		                                                                            （3）如果一个输出为line primitive的shader object绑定到VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或 VK_SHADER_STAGE_GEOMETRY_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则vkCmdSetLineRasterizationModeEXT必须在该命令之前设置
                                                                                    （4）如果一个shader object绑定到任意一个graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetPolygonModeEXT设置polygonMode 为VK_POLYGON_MODE_LINE ，则vkCmdSetLineStippleEnableEXT必须在该命令之前设置
                                                                                    （5）如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetPrimitiveTopology设置primitiveTopology 为任何line topology ，则vkCmdSetLineStippleEnableEXT必须在该命令之前设置
                                                                                    （6）如果一个输出为line primitive的shader object绑定到VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或 VK_SHADER_STAGE_GEOMETRY_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则vkCmdSetLineStippleEnableEXT必须在该命令之前设置
                                                                                    （7）如果一个shader object绑定到任意一个graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetLineStippleEnableEXT设置stippledLineEnable 为VK_TRUE ，则vkCmdSetLineStippleEXT必须在该命令之前设置
        110.如果一个shader object绑定到任何graphics stage，（1）如果depthClipControl 特性开启，则vkCmdSetDepthClipNegativeOneToOneEXT必须在该命令之前设置
                                                           （2）VK_NV_clip_space_w_scaling 拓展开启，则vkCmdSetViewportWScalingEnableNV必须在该命令之前设置
                                                           （3）VK_NV_viewport_swizzle 拓展开启，则vkCmdSetViewportSwizzleNV必须在该命令之前设置
        111.如果如果一个shader object绑定到任何VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                            （1）如果VK_NV_fragment_coverage_to_color 拓展开启，则vkCmdSetCoverageToColorEnableNV 必须在该命令之前设置
                            （2）如果VK_NV_fragment_coverage_to_color 拓展开启，且最近的vkCmdSetCoverageToColorEnableNV 设置coverageToColorEnable 为VK_TRUE，则vkCmdSetCoverageToColorLocationNV 必须在该命令之前设置
		                    （3）如果pipelineFragmentShadingRate 特性开启，则vkCmdSetFragmentShadingRateKHR 必须在该命令之前设置
        112.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                    （1）如果VK_NV_framebuffer_mixed_samples 拓展开启，则vkCmdSetCoverageModulationModeNV 必须在该命令之前设置
                                    （2）如果VK_NV_framebuffer_mixed_samples 拓展开启，且最近的vkCmdSetCoverageModulationModeNV设置coverageModulationMode为任何除VK_COVERAGE_MODULATION_MODE_NONE_NV之外的值，则vkCmdSetCoverageModulationTableEnableNV 必须在该命令之前设置
                                    （3）如果VK_NV_framebuffer_mixed_samples 拓展开启，最近的vkCmdSetCoverageModulationTableEnableNV设置coverageModulationTableEnable为VK_TRUE，则vkCmdSetCoverageModulationTableNV 必须在该命令之前设置
                                    （4）如果shadingRateImage 特性开启，则vkCmdSetShadingRateImageEnableNV 必须在该命令之前设置
                                    （5）如果representativeFragmentTest 特性开启，则vkCmdSetRepresentativeFragmentTestEnableNV 必须在该命令之前设置
                                    （6）如果coverageReductionMode 特性开启，则vkCmdSetCoverageReductionModeNV 必须在该命令之前设置
        113.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态state开启创建，且最近的vkCmdSetColorBlendEnableEXT设置任何附件在pColorBlendEnables中的值为VK_TRUE 则subpas中这些附件对应的image view的format features中必须包含VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT
			                             （2）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，且当前subpass不使用任何color和/或者 depth/stencil attachments，则最后的vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples必须符合zero￾attachment subpass的规则
                                         （3）以VK_DYNAMIC_STATE_SAMPLE_MASK_EXT不以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT 动态state开启创建，则最后调用的vkCmdSetSampleMaskEXT中设置的samples参数必须大于等于创建该pipeline的VkPipelineMultisampleStateCreateInfo::rasterizationSamples
                                         （4）以VK_DYNAMIC_STATE_SAMPLE_MASK_EXT和 VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT 动态state开启创建，则最后调用的vkCmdSetSampleMaskEXT中设置的samples参数必须大于等于最后的vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples
                                         （5）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，且VK_AMD_mixed_attachment_samples和VK_NV_framebuffer_mixed_samples拓展都没有开启，则最后的vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples必须等于subpass中color和/或者 depth/stencil attachments使用的相同
			                             （6）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，或者一个shader object绑定到任意graphics stage，且当前的subpass包含一个multisampledRenderToSingleSampledEnable 为VK_TRUE的VkMultisampledRenderToSingleSampledInfoEXT，则最后的vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples必须等于该VkMultisampledRenderToSingleSampledInfoEXT中的对应成员
                                         （7）以VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态state开启创建，则vkCmdSetColorBlendEnableEXT 必须在该命令之前设置，且vkCmdSetColorBlendEnableEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定值
                                         （8）以VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT动态state开启创建，则vkCmdSetColorBlendEquationEXT 必须在该命令之前设置，且vkCmdSetColorBlendEquationEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定blend equations
		                                 （9）以VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT动态state开启创建，则vkCmdSetColorWriteMaskEXT 必须在该命令之前设置，且vkCmdSetColorWriteMaskEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定color write mask
                                         （10）以VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT动态state开启创建，则vkCmdSetColorBlendAdvancedEXT 必须在该命令之前设置，且vkCmdSetColorBlendAdvancedEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活blend的color attachments指定advanced blend equations
                                         （11）以VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT和VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态state开启创建，且最后的vkCmdSetColorBlendEnableEXT和vkCmdSetColorBlendAdvancedEXT设置启用了advanced blending，则当前subpass中激活的color attachments的数量不能超过advancedBlendMaxColorAttachments
		                                 （12）以VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT动态state开启创建，且如果primitivesGeneratedQueryWithNonZeroStreams特性未开启且VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query已经激活，则最后的vkCmdSetRasterizationStreamEXT必须设置rasterizationStream为0
		                                 （13）以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT但不以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，则最后的vkCmdSetSampleLocationsEXT设置的pSampleLocationsInfo->sampleLocationsPerPixel必须等于创建pipeline的VkPipelineMultisampleStateCreateInfo::rasterizationSamples
                                         （14）以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT和VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，则最后的vkCmdSetSampleLocationsEXT设置的pSampleLocationsInfo->sampleLocationsPerPixel必须等于最后vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples
		                                 （15）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT但不以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT动态state开启创建，且绑定的pipeline的VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable为VK_TRUE 或者以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT动态state开启，则sampleLocationsInfo.sampleLocationsPerPixel 必须等于最后vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples
		                                 （16）以VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV动态state开启创建，且最后的vkCmdSetCoverageToColorEnableNV设置coverageToColorEnable为VK_TRUE，则当前subpass必须有color attachment，且该attachment的format必须为VK_FORMAT_R8_UINT, VK_FORMAT_R8_SINT, VK_FORMAT_R16_UINT, VK_FORMAT_R16_SINT, VK_FORMAT_R32_UINT, 或者 VK_FORMAT_R32_SINT，且该attachment的location 有最后的vkCmdSetCoverageToColorLocationNV设置的coverageToColorLocation决定
		                                 （17）以VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV和VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT 动态state开启创建，且如果VK_NV_coverage_reduction_mode 拓展开启，则当前的 coverageReductionMode，rasterizationSamples 以及color 以及 depth/stencil attachments（如果subpass有）的sample count必须是有效的返回值vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV的值的组合
		                                 （18）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT但不以VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV 动态state开启创建，则绑定的graphics pipeline的VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount 必须大于等于最后vkCmdSetViewportWithCount设置的viewportCount
                                         （19）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT和VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV 动态state开启创建，则最后vkCmdSetViewportSwizzleNV设置的viewportCount 必须大于等于最后vkCmdSetViewportWithCount设置的viewportCount
		                                 （20）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT或者 VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT 动态state开启创建，如果当前的stippledLineEnable为VK_TRUE，且当前的lineRasterizationMode为VK_LINE_RASTERIZATION_MODE_RECTANGULAR_KHR，则stippledRectangularLines 特性必须开启
                                         （21）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT或者 VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT 动态state开启创建，如果当前的stippledLineEnable为VK_TRUE，且当前的lineRasterizationMode为VK_LINE_RASTERIZATION_MODE_BRESENHAM_KHR，则stippledBresenhamLines 特性必须开启
                                         （22）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT或者 VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT 动态state开启创建，如果当前的stippledLineEnable为VK_TRUE，且当前的lineRasterizationMode为VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_KHR，则stippledSmoothLines 特性必须开启
                                         （23）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT或者 VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT 动态state开启创建，如果当前的stippledLineEnable为VK_TRUE，且当前的lineRasterizationMode为VK_LINE_RASTERIZATION_MODE_DEFAULT_KHR，则stippledRectangularLines 特性必须开启且VkPhysicalDeviceLimits::strictLines 必须为VK_TRUE
		                                 （24）以VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT 动态state开启创建，且conservativePointAndLineRasterization不支持，最后的 pre-rasterization shader stage输出的有效图元拓扑为点或者线，则最后vkCmdSetConservativeRasterizationModeEXT设置的conservativeRasterizationMode 必须为VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT
                                         （25）以VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT 动态state开启创建，则vkCmdSetAttachmentFeedbackLoopEnableEXT 必须在该命令之前调用
        114.如果一个shader object绑定到 VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                                                                            （1）则vkCmdSetColorBlendEnableEXT 必须在该命令之前设置，且vkCmdSetColorBlendEnableEXT指定的firstAttachment开始的attachmentCount的值必须为当前subpass所有激活的color attachments指定
                                                                                            （2）则vkCmdSetColorBlendEquationEXT 必须在该命令之前设置，且vkCmdSetColorBlendEquationEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定blend equations
                                                                                            （3）则vkCmdSetColorWriteMaskEXT 必须在该命令之前设置，且vkCmdSetColorWriteMaskEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定color write mask
		                                                                                    （4）如果VK_NV_fragment_coverage_to_color拓展开启， 最后的vkCmdSetCoverageToColorEnableNV设置coverageToColorEnable为VK_TRUE，则当前subpass必须有color attachment，且该attachment的format必须为VK_FORMAT_R8_UINT, VK_FORMAT_R8_SINT, VK_FORMAT_R16_UINT, VK_FORMAT_R16_SINT, VK_FORMAT_R32_UINT, 或者 VK_FORMAT_R32_SINT，且该attachment的location 有最后的vkCmdSetCoverageToColorLocationNV设置的coverageToColorLocation决定  
        115.如果一个shader object绑定到 VK_SHADER_STAGE_FRAGMENT_BIT stage，（1）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT动态state开启创建，且最近的vkCmdSetSampleLocationsEnableEXT设置sampleLocationsEnable为VK_TRUE，且该subpass含有depth/stencil attachment，则该附件必须以VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT创建
                                                                            （2）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT和VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT 动态state开启创建，且最近的vkCmdSetSampleLocationsEnableEXT设置sampleLocationsEnable为VK_TRUE，则 最后vkCmdSetSampleLocationsEXT设置的sampleLocationsInfo.sampleLocationGridSize.width以及height 必须等于被调用vkGetPhysicalDeviceMultisamplePropertiesEXT传入rasterizationSamples返回的VkMultisamplePropertiesEXT::sampleLocationGridSize.width以及height一一对应均匀整除
		                                                                    （3）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT 动态state开启创建，且最近的vkCmdSetSampleLocationsEnableEXT设置sampleLocationsEnable为VK_TRUE，则fragment shader代码中不能静态使用扩展指令InterpolateAtSample
                                                                            （4）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT但不以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT 动态state开启创建，且绑定的pipeline的VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable为VK_TRUE 或者以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT动态state开启，则 最后vkCmdSetRasterizationSamplesEXT设置的sampleLocationsInfo.sampleLocationGridSize.width以及height 必须等于被调用vkGetPhysicalDeviceMultisamplePropertiesEXT传入和vkCmdSetRasterizationSamplesEXT设置的相同rasterizationSamples的samples返回的VkMultisamplePropertiesEXT::sampleLocationGridSize.width以及height一一对应均匀整除
		116.如果一个shader object绑定到任何graphics stage，（1）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV 动态state开启创建，且最近的vkCmdSetCoverageModulationTableEnableNV设置coverageModulationTableEnable为VK_TRUE，则最近的vkCmdSetCoverageModulationTableNV 设置的coverageModulationTableCount 必须等于当前rasterizationSamples除以当前subppas的color samples
		                                                   （2）如果VK_NV_viewport_swizzle 拓展开启，则最后vkCmdSetViewportSwizzleNV设置的viewportCount 必须大于等于最后vkCmdSetViewportWithCount设置的viewportCount
        117.如果VK_NV_framebuffer_mixed_samples 拓展开启，且如果在绑定的graphics pipeline中当前subpass有一个depth/stencil attachment以及dep test, stencil test, 或depth bounds test 启用，则当前rasterizationSamples 必须等于depth/stencil attachment的sample count
		118.如果VK_NV_framebuffer_mixed_samples 拓展开启，且如果最后的vkCmdSetRasterizationSamplesEXT设置的当前subpass的任何color attachments的rasterizationSamples 都大于 color samples，则sampleShadingEnable 必须为VK_FALSE
        119.如果当前绑定的graphics pipeline以VkGraphicsPipelineCreateInfo::pStages中的元素的VkPipelineShaderStageCreateInfo::stage设置为VK_SHADER_STAGE_VERTEX_BIT, VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT, VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或者 VK_SHADER_STAGE_GEOMETRY_BIT创建，则Mesh Shader Queries 不能激活
        120.如果dynamic state继承自VkCommandBufferInheritanceViewportScissorInfoNV，则这些动态state的设置必须在该命令之前设置
        121.如果没有绑定graphics pipeline，则（1）vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_VERTEX_BIT
                                             （2）如果tessellationShader 特性开启，vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT，VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT
                                             （3）如果geometryShader 特性开启，vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_GEOMETRY_BIT
                                             （4）vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_FRAGMENT_BIT
                                             （5）如果taskShader 特性开启，vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_TASK_BIT_EXT
                                             （6）如果meshShader 特性开启，vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_MESH_BIT_EXT
		                                     （8）如果至少taskShader 和 meshShader一个特性开启，VK_SHADER_STAGE_VERTEX_BIT 或者VK_SHADER_STAGE_MESH_BIT_EXT stages中的一个必须含有有效的VkShaderEXT绑定，另外一个则不含有VkShaderEXT绑定
		                                     （9）如果taskShader 和 meshShader特性同时开启，且一个有效的VkShaderEXT 绑定到VK_SHADER_STAGE_MESH_BIT_EXT stage，且该VkShaderEXT不以VK_SHADER_CREATE_NO_TASK_SHADER_BIT_EXT 创建，则一个有效的VkShaderEXT必须绑定到VK_SHADER_STAGE_TASK_BIT_EXT stage
                                             （10）如果taskShader 和 meshShader特性同时开启，且一个有效的VkShaderEXT 绑定到VK_SHADER_STAGE_MESH_BIT_EXT stage，且该VkShaderEXT以VK_SHADER_CREATE_NO_TASK_SHADER_BIT_EXT 创建，则不能有VkShaderEXT绑定到VK_SHADER_STAGE_TASK_BIT_EXT stage
		                                     （11）如果一个有效的VkShaderEXT 绑定到VK_SHADER_STAGE_VERTEX_BIT stage，则不能有VkShaderEXT绑定到VK_SHADER_STAGE_TASK_BIT_EXT stage或者VK_SHADER_STAGE_MESH_BIT_EXT stage中的一个
		122.如果任何绑定的graphics shader以VK_SHADER_CREATE_LINK_STAGE_BIT_EXT 创建，（1）所有在相同vkCreateShadersEXT中以VK_SHADER_CREATE_LINK_STAGE_BIT_EXT创建的shaders必须也要绑定
		                                                                             （2）任何相同vkCreateShadersEXT中不以VK_SHADER_CREATE_LINK_STAGE_BIT_EXT创建的shaders不能有任何VkShaderEXT绑定
		123.所有绑定的graphics shader objects 必须以相同或者相同定义的push constant ranges创建
        124.所有绑定的graphics shader objects 必须以相同或者相同定义的descriptor set layouts的数组创建
		125.如果当前的render pass instance以vkCmdBeginRendering开始，且VkRenderingInfo::colorAttachmentCount为1，且有一个resolve mode为 VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID 的color attachment，且绑定了fragment shader，则DepthReplacing 和 StencilRefReplacingEXT execution modes 不能声明
		126.如果一个shader object绑定到 VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则 （1）如果attachmentFeedbackLoopDynamicState 特性开启，则 vkCmdSetAttachmentFeedbackLoopEnableEXT 必须在该命令之前调用
		127.如果包含一个fragment shader stage的绑定的graphics pipeline，（1）且该pipeline以VkPipelineDynamicStateCreateInfo::pDynamicStates中设置有VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE创建，且该fragment shader声明了EarlyFragmentTests execution mode且使用了OpDepthAttachmentReadEXT，则最后vkCmdSetDepthWriteEnable 设置的 depthWriteEnable 必须为VK_FALSE
                                                                        （2）且该pipeline以VkPipelineDynamicStateCreateInfo::pDynamicStates中设置有VK_DYNAMIC_STATE_STENCIL_WRITE_MASK创建，且该fragment shader声明了EarlyFragmentTests execution mode且使用了OpStencilAttachmentReadEXT，则最后vkCmdSetStencilWriteMask 设置的 writeMask 必须为0
		128.如果一个shader object绑定到任何graphics stage 或者绑定的graphics pipeline 以VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT 动态state开启创建，且任何color attachment的format为VK_FORMAT_E5B9G9R9_UFLOAT_PACK32，则vkCmdSetColorWriteMaskEXT设置的pColorWriteMasks参数的对应元素必须包含VK_COLOR_COMPONENT_R_BIT, VK_COLOR_COMPONENT_G_BIT, 和 VK_COLOR_COMPONENT_B_BIT，或者都不包含
		129.如果任何附件开启了blending，且该附件的source 或者 destination blend factors使用第二个颜色输入，则该命令执行的Fragment Execution Model静态使用的任何输出output attachment的Location的最大值必须小于maxFragmentDualSrcAttachments
		130.如果当前的render pass instance以vkCmdBeginRendering开始，（1）如果没有任何shader object绑定到任何graphics stage，则vkCmdSetRenderingAttachmentLocationsKHR 设置的VkRenderingAttachmentLocationInfoKHR::pColorAttachmentLocations中的每个元素必须匹配设置在当前绑定的graphics pipeline中的对应元素
                                                                     （2）如果没有任何shader object绑定到任何graphics stage，绑定的graphics pipeline中的input attchment 索引中映射的附件必须匹配在当前render pass instance的VkRenderingInputAttachmentIndexInfoKHR中设置的
        131.如果当前的render pass instance以vkCmdBeginRendering开始且以VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT标志开始，则绑定的graphics pipeline必须以VK_PIPELINE_CREATE_2_ENABLE_LEGACY_DITHERING_BIT_EXT创建
        132.如果绑定的graphics pipeline以VK_PIPELINE_CREATE_2_ENABLE_LEGACY_DITHERING_BIT_EXT创建，则当前的render pass 必须以vkCmdBeginRendering开始且以VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT标志开始
        133.如果commandBuffer是protected command buffer且protectedNoFault不支持，（1）则任何绑定到pipeline bind point的VkPipeline写入的resource资源不能是unprotected resource
                                                                                 （2）则任何绑定到pipeline bind point的VkPipeline的除了framebuffer-space 以及 compute stages之外的pipeline stage不能写入任何resource
        134.如果该命令使用的任何绑定到pipeline bind point的VkPipeline的shader stages使用RayQueryKHR capability，则commandBuffer不能是一个protected command buffer
        135.所有在vertex shader entry point 的 interface通过声明的vertex input variables访问的vertex input bindings必须是有效的buffer绑定或者为VK_NULL_HANDLE绑定
        136.如果nullDescriptor 特性未开启，则所有在vertex shader entry point 的 interface通过声明的vertex input variables访问的vertex input bindings不能为VK_NULL_HANDLE绑定
        137.如果robustBufferAccess 特性未开启，且pipeline的创建不对vertexInputs以VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT开启创建，则对于指定的vertex buffer binding，任何获取的顶点属性数据必须包含在对应的vertex buffer binding中，参见Vertex Input Description p2586
        138.如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage或者绑定的graphics pipeline以VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY动态state开启创建，则vkCmdSetPrimitiveTopology必须在该命令前设置
        140.如果绑定的graphics pipeline以VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY动态state开启创建，且dynamicPrimitiveTopologyUnrestricted为VK_FALSE，则vkCmdSetPrimitiveTopology设置的primitiveTopology 必须和pipeline创建的VkPipelineInputAssemblyStateCreateInfo::topology相同
        141.如果绑定的graphics pipeline以VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT但不以VK_DYNAMIC_STATE_VERTEX_INPUT_EXT 动态state开启创建，则vkCmdBindVertexBuffers2EXT必须在该命令前设置，且pStrides参数不能为NULL
        142.如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage或者绑定的graphics pipeline以VK_DYNAMIC_STATE_VERTEX_INPUT_EXT动态state开启创建，则
                                            （1）vkCmdSetVertexInputEXT必须在该命令前设置
                                            （2）所有以Input storage class修饰的Vertex Execution Model OpEntryPoint中的变量其Location必须包含在VkVertexInputAttributeDescription2EXT::location指定的location
                                            （3）如果满足legacyVertexAttributes未开启或者Vertex Execution Model OpEntryPoint中给定对应Location的Input variable的 SPIR-V Type为64-bit的中的一个，则Vertex Execution Model OpEntryPoint中对应Location的所有Input variable的numeric type必须和VkVertexInputAttributeDescription2EXT::format的相同
                                            （4）如果VkVertexInputAttributeDescription2EXT::format含有64-bit 分量，Vertex Execution Model OpEntryPoint中对应Location的所有Input variable的scalar width必须是64-bit的
                                            （5）如果Vertex Execution Model OpEntryPoint中对应Location的Input variable的scalar width是64-bit的，则对应VkVertexInputAttributeDescription2EXT::format必须含有64-bit 分量
                                            （6）如果VkVertexInputAttributeDescription2EXT::format含有64-bit 分量，则Vertex Execution Model OpEntryPoint中对应Location的所有Input variable不能使用该format未呈现的分量
        143.如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage且最近的vkCmdSetPrimitiveTopology设置primitiveTopology为VK_PRIMITIVE_TOPOLOGY_PATCH_LIST，或者绑定的graphics pipeline以VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT动态state开启创建，则vkCmdSetPatchControlPointsEXT必须在该命令前设置
        144.如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage或者绑定的graphics pipeline以VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE动态state开启创建，则vkCmdSetPrimitiveRestartEnable必须在该命令前设置
        145.如果primitiveTopologyListRestart特性未开启，且topology 为VK_PRIMITIVE_TOPOLOGY_POINT_LIST, VK_PRIMITIVE_TOPOLOGY_LINE_LIST, VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST, VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY, 或者 VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY，
                    且有一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage或者绑定的graphics pipeline以VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE动态state开启创建，则vkCmdSetPrimitiveRestartEnable必须设置为VK_FALSE
        146.绑定的graphics pipeline不能以VkGraphicsPipelineCreateInfo::pStages中元素的VkPipelineShaderStageCreateInfo::stage设置为VK_SHADER_STAGE_TASK_BIT_EXT 或者 VK_SHADER_STAGE_MESH_BIT_EXT创建
        147.不能有shader object绑定到VK_SHADER_STAGE_TASK_BIT_EXT或者 VK_SHADER_STAGE_MESH_BIT_EXT中的一个stage
        148.如果绑定的graphics pipeline 以VkGraphicsPipelineCreateInfo::pVertexInputState->pNext中包含一个VkPipelineVertexInputDivisorStateCreateInfoKHR创建，且VkPipelineVertexInputDivisorStateCreateInfoKHR::pVertexBindingDivisors任何元素为除数为1外的值，且VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR::supportsNonZeroFirstInstance 为VK_FALSE，则firstInstance必须为0
        149.如果shader objects用于绘制或者绑定的graphics pipeline以VK_DYNAMIC_STATE_VERTEX_INPUT_EXT动态state开启创建，且vkCmdSetVertexInputEXT设置的pVertexBindingDescriptions中设置该动态state的任何元素有为除数为1外的值，且VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR::supportsNonZeroFirstInstance 为VK_FALSE，则firstInstance必须为0
        */
        


        //记录一个索引的绘制命令    绘制的第一个索引计算为 firstIndex × indexSize + offset，其中offset由 vkCmdBindIndexBuffer 或者 vkCmdBindIndexBuffer2KHR指定的偏移量指定，indexSize由绑定索引缓冲命令的indexType指定
        //当执行这个命令，pipeline将以顶点索引缓冲区中获取的第一个顶点索引开始组装indexCount个顶点，以firstInstance开始绘制instanceCount个instance
        vkCmdDrawIndexed(commandBuffer, 1/*indexCount，要绘制的顶点数*/, 1/*instanceCount,要绘制的instance数*/,
                    0/*firstIndex， 是 index buffer中的起始索引*/, 0/*vertexOffset， 是在索引vertex buffer之前添加到计算顶点索引值的一个偏移值*/, 
                    0/*firstInstance,是第一个要绘制的instance的ID*/);
        /*
        vkCmdDrawIndexed有效用法:
        1.如果一个VkSampler以其magFilter或者minFilter等于VK_FILTER_LINEAR创建，则（1）如果reductionMode为VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE，如果用于采样一个VkImageView作为该命令的结果的compareEnable为VK_FALSE，则该image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT
                                                                                 （2）如果reductionMode为VK_SAMPLER_REDUCTION_MODE_MIN 或者VK_SAMPLER_REDUCTION_MODE_MAX之一 用于采样一个VkImageView作为该命令的结果，则该image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT
        2.如果一个VkSampler以其 mipmapMode等于VK_SAMPLER_MIPMAP_MODE_LINEAR创建，则（1）如果reductionMode为VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE，如果用于采样一个VkImageView作为该命令的结果的compareEnable为VK_FALSE，则该image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT
                                                                                 （2）如果reductionMode为VK_SAMPLER_REDUCTION_MODE_MIN 或者VK_SAMPLER_REDUCTION_MODE_MAX之一 用于采样一个VkImageView作为该命令的结果，则该image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT
        3.如果一个VkSampler以其unnormalizedCoordinates等于VK_TRUE用于采样一个VkImageView作为该命令的结果创建，则（1）该image view的levelCount以及layerCount必须为1
                                                                                                                （2）该image view的viewType必须为VK_IMAGE_VIEW_TYPE_1D 或者 VK_IMAGE_VIEW_TYPE_2D
        4.如果一个VkImageView的采样带depth comparison操作，则image view的format features必须包含VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT
        5.如果一个VkImageView使用atomic operations作为该命令的结果进行访问，则image view的format features必须包含VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT
        6.如果一个VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER类型的 descriptor使用atomic operations作为该命令的结果进行访问，则storage texel buffer的format features必须包含VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT
        7.如果一个以VK_FILTER_CUBIC_EXT进行采样的VkImageView作为该命令的结果，则image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT
        8.如果VK_EXT_filter_cubic拓展没有开启，且有任何一个以VK_FILTER_CUBIC_EXT进行采样的VkImageView作为该命令的结果，则其VkImageViewType不能为VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, 或者 VK_IMAGE_VIEW_TYPE_CUBE_ARRAY
        9.任何一个以VK_FILTER_CUBIC_EXT进行采样的作为该命令的结果的VkImageView，其VkImageViewType和format 必须支持cubic filtering，参见vkGetPhysicalDeviceImageFormatProperties2返回的VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic
        10.任何一个以VK_FILTER_CUBIC_EXT进行采样且reduction mode为VK_SAMPLER_REDUCTION_MODE_MIN 或者 VK_SAMPLER_REDUCTION_MODE_MAX之一的作为该命令的结果的VkImageView，其VkImageViewType和format 必须支持带minmax filtering的cubic filtering，参见vkGetPhysicalDeviceImageFormatProperties2返回的VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax
        11.如果cubicRangeClamp特性没有开启，则有任何一个以VK_FILTER_CUBIC_EXT进行采样VkImageView的作为该命令的结果，VkSamplerReductionModeCreateInfo::reductionMode不能为VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM
        12.任何一个以VkSamplerReductionModeCreateInfo::reductionMode为VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM进行采样的作为该命令的结果的VkImageView必须以VK_FILTER_CUBIC_EXT进行采样
        13.如果selectableCubicWeights特性没有开启，则有任何一个以VK_FILTER_CUBIC_EXT进行采样VkImageView的作为该命令的结果，VkSamplerCubicWeightsCreateInfoQCOM::cubicWeights必须为VK_CUBIC_FILTER_WEIGHTS_CATMULL_ROM_QCOM
        14.任何一个以VkImageCreateInfo::flags含VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV创建的采样作为该命令结果的VkImage必须以VkSamplerAddressMode为VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE 进行采样
        15.对于任何作为storage image写入的VkImageView，且其OpTypeImage的format未知，则该image view的 format features必须包含VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT
        16.对于任何作为storage image读取的VkImageView，且其OpTypeImage的format未知，则该image view的 format features必须包含VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT
        17.对于任何作为storage storage texel buffer写入的VkBufferView，且其OpTypeImage的format未知，则该buffer view的 buffer features必须包含VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT
        18.对于任何作为storage storage texel buffer读取的VkBufferView，且其OpTypeImage的format未知，则该buffer view的 buffer features必须包含VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT
        19.对于每个在绑定的shader中静态使用的set n，一个descriptor set必须被绑定到相同pipeline bind point的set n处，该set n必须和创建当前VkPipeline的VkPipelineLayout或者和创建当前VkShaderEXT的VkDescriptorSetLayout 数组的set n处的布局兼容，参见Pipeline Layout Compatibility p1280
        20.对于每个在绑定的shader中静态使用的push constant，一个push constant值必须被绑定到相同pipeline bind point的对应处，该push constant必须和创建当前VkPipeline的VkPipelineLayout或者和创建当前VkShaderEXT的VkDescriptorSetLayout 数组中的对应处的布局兼容，参见Pipeline Layout Compatibility p1280
        21.如果maintenance4特性没有开启，则对于每个在绑定的shader中静态使用的push constant，一个push constant值必须被设置到相同pipeline bind point的对应处，该push constant必须和创建当前VkPipeline的VkPipelineLayout或者和创建当前VkShaderEXT的VkDescriptorSetLayout 数组中的对应处的布局兼容，参见Pipeline Layout Compatibility p1280
        22.每一个通过vkCmdBindDescriptorSets绑定的descriptor set的descriptors,如果是被不以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建的，且已经绑定到该命令使用的pipeline bind point的VkPipeline静态使用的，则这些descriptors必须是有效的，参见 descriptor validity p1328
        23.如果通过vkCmdBindDescriptorSets指定绑定到pipeline bind point的VkPipeline要使用的descriptors，则绑定的VkPipeline不能以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建
        24.在vkCmdSetDescriptorBufferOffsetsEXT中指定绑定的descriptor buffers的descriptors，则（1）如果绑定到pipeline bind point的该命令会使用的VkPipeline以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建，且这些descriptors是动态使用的，则这些descriptors必须是有效的
                                                                                              （2）如果绑定到pipeline bind point的对应stage的该命令会使用的VkShaderEXT，且这些descriptors是动态使用的，则这些descriptors必须是有效的
        25.在vkCmdSetDescriptorBufferOffsetsEXT中指定的descriptors在绑定到pipeline bind point的VkPipeline中使用，则VkPipeline必须以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建
        26.如果一个descriptor在以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建的VkPipeline中动态使用，则descriptor memory必须是驻留内存
        27.如果一个descriptor在以其VkDescriptorSetLayout以VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建的VkShaderEXT中动态使用，则descriptor memory必须是驻留内存
        28.如果shaderObject 特性没有开启，一个有效的pipeline必须绑定到这个命令使用的绑定到pipeline bind point上
        29.如果一个pipeline绑定到该命令使用的pipeline bind point上，则不能有任何动态state 设置命令设置任何该VkPipeline 中没有指定的动态 state
        30.如果一个VkPipeline绑定到该命令使用的pipeline bind point上 或者任何一个会访问一个使用unnormalized coordinates的VkSampler的 VkShaderEXT绑定到该命令使用的pipeline bind point上的pipeline的对应stage，则
                                                                                    （1）在任何shader stage中，VkSampler不能用来采样任何类型为VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY 或者 VK_IMAGE_VIEW_TYPE_CUBE_ARRAY的VkImageView
                                                                                    （2）在任何shader stage中，该VkSampler不能和任何带有名字中带有ImplicitLod，Dref 或者 Proj 的SPIR-V OpImageSample* 或者 OpImageSparseSample*指令一起使用
                                                                                    （3）在任何shader stage中，该VkSampler不能和任何包含 LOD bias或者offset 值 的SPIR-V OpImageSample* or OpImageSparseSample*指令一起使用
		31.如果shaderObject开启，一个有效的pipeline必须绑定到该命令使用的pipeline bind point上或者一个有效的shader objects以及VK_NULL_HANDLE的组合必须绑定到该命令使用的pipeline bind point每一个支持的shader stage上
        32.如何绑定到该命令使用的pipeline bind point上的VkPipeline的任何stage会访问一个uniform buffer，且该stage对uniformBuffers不以启用VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT或者VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT 创建，且robustBufferAccess特性未开启，则该stage就不能访问绑定到相同pipeline bind point的descriptor set指定的buffer范围外的值
		33.如果robustBufferAccess特性未开启，且任何会访问uniform buffer的绑定到该命令使用的pipeline bind point上对应shader stage的VkShaderEXT，则其不能访问绑定到相同pipeline bind point的descriptor set指定的buffer范围外的值
        34.如何绑定到该命令使用的pipeline bind point上的VkPipeline的任何stage会访问一个storage buffer，且该stage对storageBuffers不以启用VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT或者VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT 创建，且robustBufferAccess特性未开启，则该stage就不能访问绑定到相同pipeline bind point的descriptor set指定的buffer范围外的值
		35.如果robustBufferAccess特性未开启，且任何会访问storage buffer的绑定到该命令使用的pipeline bind point上对应shader stage的VkShaderEXT，则其不能访问绑定到相同pipeline bind point的descriptor set指定的buffer范围外的值
        36.如果commandBuffer 是一个unprotected command buffer，且protectedNoFault 未支持，则任何绑定的shaders访问的资源不能是一个protected resource
        37.如果一个绑定的shader访问一个VkSampler 或者 VkImageView ，且启用了sampler Y′C BCR conversion，则只能使用OpImageSample* 或者 OpImageSparseSample*指令，不能使用ConstOffset 以及 Offset操作符
        38.如果一个VkImageView作为该命令的结果进行访问，则（1）image view 的viewType 必须匹配Instruction/Sampler/Image View Validation p1481中描述的OpTypeImage的Dim操作符
                                                          （2）image view 的foamrt的numeric type 必须匹配OpTypeImage的Sampled Type操作符
        39.如果一个VkImageView以一个不是VK_FORMAT_A8_UNORM_KHR的format创建且通过OpImageWrite作为该命令的结果进行访问，则该命令的Texel 操作符的Type必须至少包含和 image view的 format含有的components的个数相同的components个数
		40.如果一个VkImageView以VK_FORMAT_A8_UNORM_KHR的format创建且通过OpImageWrite作为该命令的结果进行访问，则该命令的Texel 操作符的Type必须包含4个components
		41.如果一个VkBufferView通过OpImageWrite作为该命令的结果进行访问，则该命令的Texel 操作符的Type必须至少包含和 buffer view的 format含有的components的个数相同的components个数
		42.如果一个带64-bit component的VkFormat的VkImageView作为该命令的结果进行访问，则该命令的OpTypeImage操作符的SampledType的宽度必须为64
		43.如果一个带少于64-bit component的VkFormat的VkImageView作为该命令的结果进行访问，则该命令的OpTypeImage操作符的SampledType的宽度必须为32
	    44.如果一个带64-bit component的VkFormat的VkBufferView作为该命令的结果进行访问，则该命令的OpTypeImage操作符的SampledType的宽度必须为64位
		45.如果一个带少于64-bit component的VkFormat的VkBufferView作为该命令的结果进行访问，则该命令的OpTypeImage操作符的SampledType的宽度必须为32
		46.如果sparseImageInt64Atomics 特性未开启，则以VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT创建的VkImage对象不能被SampledType宽度为64位的OpTypeImage的atomic instructions访问
		47.如果sparseImageInt64Atomics 特性未开启，则以VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT创建的VkBuffer对象不能被SampledType宽度为64位的OpTypeImage的atomic instructions访问
		48.如果OpImageWeightedSampleQCOM用来采样一个作为该命令的结果的VkImageView，则该image view的format features必须包含VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM
        49.如果OpImageWeightedSampleQCOM用来采样一个作为该命令的结果的sample weight image的VkImageView，则该image view的format features必须包含VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM
		50.如果OpImageBoxFilterQCOM用来采样一个作为该命令的结果的VkImageView，则该image view的format features必须包含VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM
        51.如果OpImageBlockMatchSSDQCOM，或者 OpImageBlockMatchSADQCOM用来读取一个作为该命令的结果的VkImageView，则（1）该image view的format features必须包含VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM
                                                                                                                   （2）如果是读取的reference image，指定的reference coordinates不能在integer texel coordinate validation 时候失败
        52.如果OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchWindowSSDQCOM, OpImageBlockMatchWindowSADQCOM, OpImageBlockMatchGatherSSDQCOM,
                                                    OpImageBlockMatchGatherSADQCOM, OpImageBlockMatchSSDQCOM, 或者 OpImageBlockMatchSADQCOM用来采样一个作为该命令的结果的VkImageView，则该VkSampler必须以VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM创建
        53.如果任何除了OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchWindowSSDQCOM, OpImageBlockMatchWindowSADQCOM, OpImageBlockMatchGatherSSDQCOM, OpImageBlockMatchGatherSADQCOM, OpImageBlockMatchSSDQCOM, 或者 OpImageBlockMatchSADQCOM之外的指令使用VkSampler进行采样作为该命令的结果，则该sampler不能以VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM 创建
		54.如果OpImageBlockMatchWindow*QCOM or OpImageBlockMatchGather*QCOM指令用来读取VkImageView作为该命令的结果，则（1）VkImageView的format features必须包含VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM
                                                                                                                      （2）VkImageView的format必须只含有一个component
        55.如果OpImageBlockMatchWindow*QCOM or OpImageBlockMatchGather*QCOM指令用来读取一个引用的image作为该命令的结果，则指定的 reference coordinates不能在integer texel coordinate validation 时候失败
        56.任何该命令执行的shader invocation必须已经终止
        57.如果有一个类型位为VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM, VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, 或者 VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT中任意一个的descriptor作为该命令的结果进行访问，则该descriptor所指的image subresource的layout必须和该descriptor被写入时的layout相同。
        58.当前的 render pass  必须和绑定到VK_PIPELINE_BIND_POINT_GRAPHICS上的VkPipeline 创建时候的VkGraphicsPipelineCreateInfo中指定的renderPass兼容
        59.当前的 render pass  的subpass index必须和绑定到VK_PIPELINE_BIND_POINT_GRAPHICS上的VkPipeline 创建时候的VkGraphicsPipelineCreateInfo中指定的subpass相同
		60.如果任何shader静态访问一个input attachment，则有效的descriptor必须通过VkDescriptorSet被绑定到该pipeline中
		61.如果任何该pipeline执行shader以SubpassData的Dim操作符访问一个OpTypeImage变量，则该变量必须被一个对应当前subpass的input attachment的InputAttachmentIndex修饰
		62.在subpass中访问的Input attachment views必须以和该subpass相同定义的VkFormat创建，且必须以一个和当前绑定的VkFramebuffer的该附件引用的subpass的pInputAttachments[InputAttachmentIndex]附件兼容的VkImageView创建，参见Fragment Input Attachment Compatibility p1408
        63.在动态render pass中访问以VkRenderingInputAttachmentIndexInfoKHR的InputAttachmentIndex，或者VkRenderingInputAttachmentIndexInfoKHR:pDepthInputAttachmentIndex 或者 VkRenderingInputAttachmentIndexInfoKHR:pStencilInputAttachmentIndex为NULL情况下不指定InputAttachmentIndex的引用的Input attachment views，必须以和VkRenderingInfo中对应color, depth, 或者 stencil attachment兼容的VkImageView创建
        64.如果VkRenderingInputAttachmentIndexInfoKHR::pDepthInputAttachmentIndex 以及 VkRenderingInputAttachmentIndexInfoKHR::pStencilInputAttachmentIndex不为NULL，则在动态render pass中通过shader object访问Input attachment views必须指明InputAttachmentIndex
        65.如果在动态render pass中通过shader object访问Input attachment views指明了InputAttachmentIndex，则InputAttachmentIndex必须匹配VkRenderingInputAttachmentIndexInfoKHR中的index
        66.当前render pass所用的附件对应的image subresource底层内存的写入只能作为该命令的一个附件写入
        67.如果一个color attachment在之前的该subpass的命令中以load, store, 或者 resolve operations进行了写入，则其layout不为VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT，且有当前绑定的pipeline设有VK_PIPELINE_CREATE_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT，或者
                                        最后的vkCmdSetAttachmentFeedbackLoopEnableEXT调用包含VK_IMAGE_ASPECT_COLOR_BIT以及 没有绑定的pipeline 或者绑定的pipeline以VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT创建，则该附件只能以附件进行访问的，这两种情况中之一
        68.如果一个depth attachment在之前的该subpass的命令中以load, store, 或者 resolve operations进行了写入，则其layout不为VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT，且有当前绑定的pipeline设有VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT，或者
                                        最后的vkCmdSetAttachmentFeedbackLoopEnableEXT调用包含VK_IMAGE_ASPECT_DEPTH_BIT以及 没有绑定的pipeline 或者绑定的pipeline以VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT创建，则该附件只能以附件进行访问的，这两种情况中之一
        69.如果一个stencil attachment在之前的该subpass的命令中以load, store, 或者 resolve operations进行了写入，则其layout不为VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT，且有当前绑定的pipeline设有VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT，或者
                                        最后的vkCmdSetAttachmentFeedbackLoopEnableEXT调用包含VK_IMAGE_ASPECT_STENCIL_BIT以及 没有绑定的pipeline 或者绑定的pipeline以VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT创建，则该附件只能以附件进行访问的，这两种情况中之一
        70.如果一个attachment在之前的该subpass的命令中以load, store, 或者 resolve operations进行了写入,则该附件就不能再以除作为一个附件，storage image或者sampled image被该命令访问
        71.如果在之前的命令的subpass中以用作附件外的方式访问访问了一个当权subpass的附件所对的image subresource，则该命令就不能再将该image subresource用作附件进行写入
        72.如果当前render pass使用一个depth/stencil attachment，则（1）如果depth aspect的layout为read-only的layout，则不能启用depth writes
                                                                  （2）如果stencil aspect的layout为read-only的layout，front 以及 back writeMask不为0，且stencil 测试开启，则所有stencil 操作必须为VK_STENCIL_OP_KEEP
        73.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_VIEWPORT动态state开启创建，则vkCmdSetViewport必须在该命令之前设置
                                        （2）以VK_DYNAMIC_STATE_SCISSOR动态state开启创建，则vkCmdSetScissor必须在该命令之前设置
                                        （3）以VK_DYNAMIC_STATE_LINE_WIDTH动态state开启创建，则vkCmdSetLineWidth必须在该命令之前设置
                                        （4）以VK_DYNAMIC_STATE_DEPTH_BIAS动态state开启创建，则vkCmdSetDepthBias或者vkCmdSetDepthBias2EXT 必须在该命令之前设置
                                        （5）以VK_DYNAMIC_STATE_BLEND_CONSTANTS动态state开启创建，则vkCmdSetBlendConstants 必须在该命令之前设置
                                        （6）以VK_DYNAMIC_STATE_DEPTH_BOUNDS动态state开启创建，且如果当前depthBoundsTestEnable为VK_TRUE， 则vkCmdSetDepthBounds 必须在该命令之前设置
                                        （7）以VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK动态state开启创建，且如果当前stencilTestEnable为VK_TRUE， 则vkCmdSetStencilCompareMask 必须在该命令之前设置
                                        （8）以VK_DYNAMIC_STATE_STENCIL_WRITE_MASK动态state开启创建，且如果当前stencilTestEnable为VK_TRUE， 则vkCmdSetStencilWriteMask 必须在该命令之前设置
                                        （9）以VK_DYNAMIC_STATE_STENCIL_REFERENCE动态state开启创建，且如果当前stencilTestEnable为VK_TRUE， 则vkCmdSetStencilReference 必须在该命令之前设置
                                        （10）以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT动态state开启创建， 则vkCmdSetSampleLocationsEXT 必须在该命令之前设置
                                        （11）以VK_DYNAMIC_STATE_CULL_MODE动态state开启创建， 则vkCmdSetCullMode 必须在该命令之前设置
                                        （12）以VK_DYNAMIC_STATE_FRONT_FACE动态state开启创建， 则vkCmdSetFrontFace 必须在该命令之前设置
                                        （13）以VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE动态state开启创建， 则vkCmdSetDepthTestEnable 必须在该命令之前设置
                                        （14）以VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE动态state开启创建， 则vkCmdSetDepthWriteEnable 必须在该命令之前设置
                                        （15）以VK_DYNAMIC_STATE_DEPTH_COMPARE_OP动态state开启创建， 则vkCmdSetDepthCompareOp 必须在该命令之前设置
                                        （16）以VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE动态state开启创建， 则vkCmdSetDepthBoundsTestEnable 必须在该命令之前设置
                                        （17）以VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE动态state开启创建， 则vkCmdSetStencilTestEnable 必须在该命令之前设置
                                        （18）以VK_DYNAMIC_STATE_STENCIL_OP动态state开启创建， 则vkCmdSetStencilOp 必须在该命令之前设置
                                        （19）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT但不以VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT 动态state开启创建， 则vkCmdSetViewportWithCount 必须在该命令之前设置，且vkCmdSetViewportWithCount设置的viewportCount必须匹配pipeline的VkPipelineViewportStateCreateInfo::scissorCount
                                        （20）以VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT但不以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT 动态state开启创建， 则vkCmdSetScissorWithCount 必须在该命令之前设置，且vkCmdSetScissorWithCount设置的scissorCount必须匹配pipeline的VkPipelineViewportStateCreateInfo::viewportCount
                                        （21）以VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT和VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT 动态state同时开启创建， 则vkCmdSetViewportWithCount以及vkCmdSetScissorWithCount 必须在该命令之前设置，且vkCmdSetViewportWithCount设置的viewportCount必须匹配vkCmdSetScissorWithCount设置的scissorCount
                                        （22）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT但不以VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV 动态state开启创建， 则绑定的pipeline必须以VkPipelineViewportWScalingStateCreateInfoNV::viewportCount 大于等于最近vkCmdSetViewportWithCount设置的viewportCount创建
                                        （23）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT和VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV 动态state开启创建， 则最近调用的vkCmdSetViewportWScalingNV设置的viewportCount 必须大于等于最近vkCmdSetViewportWithCount设置的viewportCount
                                        （24）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT但不以VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV 动态state开启创建， 则绑定的pipeline必须以VkPipelineViewportShadingRateImageStateCreateInfoNV::viewportCount 大于等于最近vkCmdSetViewportWithCount设置的viewportCount创建
                                        （25）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT和VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV 动态state开启创建， 则最近调用的vkCmdSetViewportShadingRatePaletteNV设置的viewportCount 必须大于等于最近vkCmdSetViewportWithCount设置的viewportCount
                                        （26）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT动态state开启且VkPipelineViewportStateCreateInfo的pNext中含有一个VkPipelineViewportSwizzleStateCreateInfoNV 创建， 则绑定的pipeline必须以VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount 大于等于最近vkCmdSetViewportWithCount设置的viewportCount创建
                                        （27）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT动态state开启且VkPipelineViewportStateCreateInfo的pNext中含有一个VkPipelineViewportExclusiveScissorStateCreateInfoNV 创建， 则绑定的pipeline必须以VkPipelineViewportExclusiveScissorStateCreateInfoNV::exclusiveScissorCount 大于等于最近vkCmdSetViewportWithCount设置的viewportCount创建
                                        （28）以VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_ENABLE_NV动态state开启创建， 则vkCmdSetExclusiveScissorEnableNV 必须在该命令之前设置
                                        （29）以VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV动态state开启创建， 则vkCmdSetExclusiveScissorNV 必须在该命令之前设置
                                        （30）以VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE动态state开启创建， 则vkCmdSetRasterizerDiscardEnable 必须在该命令之前设置
                                        （31）以VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE动态state开启创建， 则vkCmdSetDepthBiasEnable 必须在该命令之前设置
                                        （32）以VK_DYNAMIC_STATE_LOGIC_OP_EXT动态state开启创建， 则vkCmdSetLogicOpEXT 必须在该命令之前设置且参数logicOp必须是一个有效的VkLogicOp值
        74.如果一个shader object绑定到任何graphics stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                        （1）如果最靠近当前命令的vkCmdSetPolygonModeEXT设置polygonMode为VK_POLYGON_MODE_LINE或者是任何line topology，则vkCmdSetLineWidth必须在该命令之前设置
                                        （2）如果最靠近当前命令的vkCmdSetDepthBiasEnable设置depthBiasEnable为VK_TRUE，则vkCmdSetDepthBias 或者 vkCmdSetDepthBias2EXT必须在该命令之前设置
                                        （3）如果最靠近当前命令的vkCmdSetDepthBoundsTestEnable设置depthBoundsTestEnable为VK_TRUE，则vkCmdSetDepthBounds必须在该命令之前设置
                                        （4）如果最靠近当前命令的vkCmdSetStencilTestEnable设置stencilTestEnable为VK_TRUE，则vkCmdSetStencilCompareMask必须在该命令之前设置
                                        （5）如果最靠近当前命令的vkCmdSetStencilTestEnable设置stencilTestEnable为VK_TRUE，则vkCmdSetStencilWriteMask必须在该命令之前设置
                                        （6）如果最靠近当前命令的vkCmdSetStencilTestEnable设置stencilTestEnable为VK_TRUE，则vkCmdSetStencilReference必须在该命令之前设置
                                        （7）如果最靠近当前命令的vkCmdSetSampleLocationsEnableEXT设置sampleLocationsEnable为VK_TRUE，则vkCmdSetSampleLocationsEXT必须在该命令之前设置
                                        （8）则vkCmdSetCullMode必须在该命令之前设置
                                        （9）则vkCmdSetFrontFace必须在该命令之前设置
                                        （10）则vkCmdSetDepthTestEnable 必须在该命令之前设置
                                        （11）则vkCmdSetDepthWriteEnable 必须在该命令之前设置
                                        （12）如果最靠近当前命令的vkCmdSetDepthTestEnable设置depthTestEnable为VK_TRUE，则vkCmdSetDepthCompareOp 必须在该命令之前设置
                                        （13）则vkCmdSetDepthBoundsTestEnable 必须在该命令之前设置
                                        （14）则vkCmdSetStencilTestEnable 必须在该命令之前设置
                                        （15）如果最靠近当前命令的vkCmdSetStencilTestEnable设置stencilTestEnable为VK_TRUE，则vkCmdSetStencilOp 必须在该命令之前设置
                                        （16）
                                        （17）如果shadingRateImage特性开启，则vkCmdSetCoarseSampleOrderNV 必须在该命令之前设置
                                        （18）如果shadingRateImage特性开启，且最靠近当前命令的vkCmdSetShadingRateImageEnableNV设置shadingRateImageEnable为VK_TRUE，则vkCmdSetViewportShadingRatePaletteNV 必须在该命令之前设置
                                        （19）如果shadingRateImage特性开启，且最靠近当前命令的vkCmdSetShadingRateImageEnableNV设置shadingRateImageEnable为VK_TRUE，则最近的vkCmdSetViewportShadingRatePaletteNV设置的viewportCount 必须大于等于vkCmdSetViewportWithCount设置的viewportCount
                                        （20）则vkCmdSetDepthBiasEnable必须在该命令之前设置
        75.如果一个输出line primitives的shader object绑定到VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或者 VK_SHADER_STAGE_GEOMETRY_BIT，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则vkCmdSetLineWidth必须在该命令之前设置
        76.如果一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最靠近当前命令的vkCmdSetColorBlendEnableEXT设置pColorBlendEnables任何元素为VK_TRUE，且
                            最靠近当前命令的vkCmdSetColorBlendEquationEXT设置pColorBlendEquations相同元素的VkColorBlendEquationEXT的VkBlendFactor成员为VK_BLEND_FACTOR_CONSTANT_COLOR, VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR, VK_BLEND_FACTOR_CONSTANT_ALPHA, 或者 VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA，则vkCmdSetBlendConstants必须在该命令之前设置
        77.如果该命令记录在开启了multiview的render pass instance中，则最大的instance 索引必须小于等于VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex
        78.如果绑定的graphics pipeline以VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable设置为VK_TRUE创建且当前的subpass含有一个 depth/stencil attachment，则该attachment必须以VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT创建
        >>78.5  .如果一个shader object绑定到任何graphics stage，则则（1）vkCmdSetViewportWithCount 和vkCmdSetScissorWithCount 必须同时在该命令之前设置，且vkCmdSetViewportWithCount设置的viewportCount必须匹配vkCmdSetScissorWithCount设置的scissorCount
                                                                   （2）则vkCmdSetRasterizerDiscardEnable 必须在该命令之前设置
        79.如果VK_NV_clip_space_w_scaling拓展开启，且shader object绑定到任何graphics stage，且最近的vkCmdSetViewportWScalingEnableNV设置viewportWScalingEnable为VK_TRUE，则（1）vkCmdSetViewportWScalingNV必须在该命令前设置
                                                                                                                                                                           （2）最近vkCmdSetViewportWScalingNV设置的viewportCount必须大于等于vkCmdSetViewportWithCount设置的viewportCount
        80.如果exclusiveScissor 特性开启，且shader object绑定到任何graphics stage，，则（1）vkCmdSetExclusiveScissorEnableNV必须在该命令前设置
                                                                                       （2）最近的vkCmdSetExclusiveScissorEnableNV调用设置的pExclusiveScissorEnables中的任何元素为VK_TRUE,则vkCmdSetExclusiveScissorNV必须在该命令前设置
        81.如果一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最靠近当前命令的vkCmdSetLogicOpEnableEXT设置logicOpEnable任何元素为VK_TRUE，则vkCmdSetLogicOpEXT 必须在该命令之前设置且参数logicOp必须是一个有效的VkLogicOp值
        82.如果primitiveFragmentShadingRateWithMultipleViewports限制不支持，则（1）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT动态state开启创建，且任何该pipeline的shader stage会写入PrimitiveShadingRateKHR built-in修饰的变量，则vkCmdSetViewportWithCount 必须在该命令之前设置且参数viewportCount必须是1
                                                                              （2）任何绑定的graphics pipeline的shader stage会写入PrimitiveShadingRateKHR built-in修饰的变量，则vkCmdSetViewportWithCount 必须在该命令之前设置且参数viewportCount必须是1
        83.如果graphics pipeline中未开启rasterization，则对subpass中的每个color attachment，如果其对应的image view 的format features不包含VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT，则pColorBlendState中其对应pAttachments中元素的blendEnable必须为VK_FALSE
        84.如果一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则对于render pass中的每个color attachment，如果其对应的image view 的format features不包含VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT， 则最近的vkCmdSetColorBlendEnableEXT设置的pColorBlendEnables中该附件的对应元素必须为VK_FALSE
        85.如果graphics pipeline中未开启rasterization，有VK_AMD_mixed_attachment_samples拓展未开启，VK_NV_framebuffer_mixed_samples拓展未开启，multisampledRenderToSingleSampled特性未开启，则当前绑定的pipeline的rasterizationSamples必须和当前subpass的color 以及/或者 depth/stencil attachments的相同
        86.如果一个shader object绑定到任何graphics stage，（1）如果最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且有VK_AMD_mixed_attachment_samples拓展未开启，VK_NV_framebuffer_mixed_samples拓展未开启，multisampledRenderToSingleSampled特性未开启，则最近vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples必须和当前subpass的color 以及/或者 depth/stencil attachments的相同
                                                          （2）vkCmdSetRasterizerDiscardEnable必须在该命令前设置
        87.如果一个shader object绑定到任何graphics stage，则当前的render pass instance必须以vkCmdBeginRendering开始
        88.如果当前的render pass instance以vkCmdBeginRendering开始，（1）如果pDepthAttachment的imageView不为VK_NULL_HANDLE，且pDepthAttachment的layout不为VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL，则该命令不能写入任何值到depth attachment
                                                                    （2）如果pStencilAttachment的imageView不为VK_NULL_HANDLE，且pStencilAttachment的layout不为VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL，则该命令不能写入任何值到stencil attachment
                                                                    （3）如果pDepthAttachment的imageView不为VK_NULL_HANDLE，且pDepthAttachment的layout为VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL，则该命令不能写入任何值到depth attachment
                                                                    （4）如果pStencilAttachment的imageView不为VK_NULL_HANDLE，且pStencilAttachment的layout为VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL，则该命令不能写入任何值到stencil attachment
                                                                    （5）如果pDepthAttachment的imageView不为VK_NULL_HANDLE，且pDepthAttachment的layout为VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL，则该命令不能写入任何值到depth attachment
                                                                    （6）如果pStencilAttachment的imageView不为VK_NULL_HANDLE，且pStencilAttachment的layout为VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL，则该命令不能写入任何值到stencil attachment
                                                                    （7）则当前绑定的graphics pipeline必须以含VkPipelineRenderingCreateInfo::viewMask等于VkRenderingInfo::viewMask创建
                                                                    （8）如果带有VkRenderingInfo::colorAttachmentCount为1，则没有shader object绑定到任何graphics stage，且一个color attachment的 resolve mode为VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID，则VkRenderingInfo::pColorAttachments中每个resolveImageView不为VK_NULL_HANDLE的元素其对应image必须以和创建当前绑定的pipeline 相同的VkExternalFormatANDROID::externalFormat创建
                                                                    （9）如果没有shader object绑定到任何graphics stage，如果绑定的graphics pipeline以一个非零值VkExternalFormatANDROID::externalFormat创建且启用VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态设置，则vkCmdSetColorBlendEnableEXT必须在该命令前设置blend enable为VK_FALSE
                                                                    （10）如果没有shader object绑定到任何graphics stage，如果绑定的graphics pipeline以一个非零值VkExternalFormatANDROID::externalFormat创建且启用VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态设置，则vkCmdSetRasterizationSamplesEXT必须在该命令前设置rasterizationSamples为VK_SAMPLE_COUNT_1_BIT
                                                                    （11）如果没有shader object绑定到任何graphics stage，如果绑定的graphics pipeline以一个非零值VkExternalFormatANDROID::externalFormat创建且启用VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR动态设置，则vkCmdSetFragmentShadingRateKHR必须在该命令前设置pFragmentSize->width为1，pFragmentSize->height为1
        89.如果dynamicRenderingUnusedAttachments特性未开启，且当前的render pass instance以vkCmdBeginRendering开始，则
                                                                （1）当前绑定的graphics pipeline必须以含VkPipelineRenderingCreateInfo::colorAttachmentCount等于VkRenderingInfo::colorAttachmentCount创建
                                                                （2）如果VkRenderingInfo::colorAttachmentCount大于0，则VkRenderingInfo::pColorAttachments 中每一个其imageView不为VK_NULL_HANDLE的元素的VkImageView必须以VkFormat对应绑定的graphics pipeline的VkPipelineRenderingCreateInfo::pColorAttachmentFormats指明的format创建
                                                                （3）如果VkRenderingInfo::colorAttachmentCount大于0，则VkRenderingInfo::pColorAttachments 中每一个其imageView为VK_NULL_HANDLE的元素对应绑定的graphics pipeline的VkPipelineRenderingCreateInfo::pColorAttachmentFormats指明的format必须为VK_FORMAT_UNDEFINED
                                                                （4）如果VkRenderingInfo::pDepthAttachment->imageView为VK_NULL_HANDLE，则创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::depthAttachmentFormat必须为VK_FORMAT_UNDEFINED
                                                                （5）如果VkRenderingInfo::pDepthAttachment->imageView不为VK_NULL_HANDLE，则创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::depthAttachmentFormat必须和创建VkRenderingInfo::pDepthAttachment->imageView的VkFormat相同
                                                                （6）如果VkRenderingInfo::pStencilAttachment->imageView为VK_NULL_HANDLE，则创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::stencilAttachmentFormat必须为VK_FORMAT_UNDEFINED
                                                                （7）如果VkRenderingInfo::pStencilAttachment->imageView不为VK_NULL_HANDLE，则创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::stencilAttachmentFormat必须和创建VkRenderingInfo::pStencilAttachment->imageView的VkFormat相同
        90.如果dynamicRenderingUnusedAttachments特性开启，且当前的render pass instance以vkCmdBeginRendering开始，则
                                                                （1）如果VkRenderingInfo::colorAttachmentCount大于0，则VkRenderingInfo::pColorAttachments 中每一个其imageView不为VK_NULL_HANDLE的元素的VkImageView必须以VkFormat对应绑定的graphics pipeline的VkPipelineRenderingCreateInfo::pColorAttachmentFormats指明的format创建，或者是对应元素为VK_FORMAT_UNDEFINED创建
                                                                （2）如果VkRenderingInfo::pDepthAttachment->imageView不为VK_NULL_HANDLE，且创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::depthAttachmentFormat和创建VkRenderingInfo::pDepthAttachment->imageView的VkFormat不同，则该format必须为VK_FORMAT_UNDEFINED
                                                                （3）如果VkRenderingInfo::pStencilAttachment->imageView不为VK_NULL_HANDLE，且创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::stencilAttachmentFormat和创建VkRenderingInfo::pStencilAttachment->imageView的VkFormat不同，则该format必须为VK_FORMAT_UNDEFINED
        91.如果没有shader object绑定到任何graphics stage，且当前的render pass instance以vkCmdBeginRendering开始且VkRenderingInfo::colorAttachmentCount为1，且一个color attachment的 resolve mode为VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID，则VkRenderingInfo::pColorAttachments中每个resolveImageView不为VK_NULL_HANDLE的元素其对应image必须以和创建当前绑定的pipeline 相同的VkExternalFormatANDROID::externalFormat创建
        92.如果有一个shader object绑定到任何graphics stage，且当前的render pass 包含一个使用VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID resolve mode的color attachment，则（1）vkCmdSetColorBlendEnableEXT必须在该命令前设置blend enable为VK_FALSE
                                                                                                                                                                                 （2）则vkCmdSetRasterizationSamplesEXT必须在该命令前设置rasterizationSamples为VK_SAMPLE_COUNT_1_BIT
                                                                                                                                                                                 （3）则vkCmdSetFragmentShadingRateKHR必须在该命令前设置pFragmentSize->width为1，pFragmentSize->height为1
        93.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT动态state开启创建， 则vkCmdSetColorWriteEnableEXT 必须在该命令之前设置，且设置的attachmentCount必须大于等于创建当前绑定的pipeline的VkPipelineColorBlendStateCreateInfo::attachmentCount
                                        （2）以VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT动态state开启创建， 则vkCmdSetDiscardRectangleEXT 必须在该命令之前为每个VkPipelineDiscardRectangleStateCreateInfoEXT::discardRectangleCount指明的discard rectangle 设置
                                        （3）以VK_DYNAMIC_STATE_DISCARD_RECTANGLE_ENABLE_EXT动态state开启创建， 则vkCmdSetDiscardRectangleEnableEXT 必须在该命令之前设置
                                        （4）以VK_DYNAMIC_STATE_DISCARD_RECTANGLE_MODE_EXT动态state开启创建， 则vkCmdSetDiscardRectangleModeEXT 必须在该命令之前设置
        94.如果有一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                        （1）如果colorWriteEnable特性在device上开启，则vkCmdSetColorWriteEnableEXT 必须在该命令之前设置，且设置的attachmentCount必须大于等于当前render pass instance的color attachment的数量
                                        （2）如果VK_EXT_discard_rectangles拓展开启，且最近的vkCmdSetDiscardRectangleEnableEXT设置discardRectangleEnable为VK_TRUE， 则vkCmdSetDiscardRectangleEXT 必须在该命令之前设置
                                        （3）如果VK_EXT_discard_rectangles拓展开启， 则vkCmdSetDiscardRectangleEnableEXT 必须在该命令之前设置
                                        （4）如果VK_EXT_discard_rectangles拓展开启， 则最近的vkCmdSetDiscardRectangleEnableEXT设置discardRectangleEnable为VK_TRUE，则vkCmdSetDiscardRectangleModeEXT 必须在该命令之前设置
        95.如果当前的render pass instance以vkCmdBeginRendering开始，则（1）如果VkRenderingFragmentShadingRateAttachmentInfoKHR::imageView不为VK_NULL_HANDLE，则当前绑定的graphics pipeline必须以VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR创建
                                                                      （2）如果VkRenderingFragmentDensityMapAttachmentInfoEXT::imageView不为VK_NULL_HANDLE，则当前绑定的graphics pipeline必须以VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT创建
                                                                      （3）且含VkRenderingInfo::colorAttachmentCount大于0，如果当前的绑定的pipeline以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，则VkRenderingInfo::pColorAttachments中每个imageView不为VK_NULL_HANDLE的元素的imageView，必须以当前pipeline的VkAttachmentSampleCountInfoAMD 或者 VkAttachmentSampleCountInfoNV中的pColorAttachmentSamples中对应元素的sample count进行创建
                                                                      （4）如果当前的绑定的pipeline以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且VkRenderingInfo::pDepthAttachment中的imageView不为VK_NULL_HANDLE，则当前pipeline的VkAttachmentSampleCountInfoAMD 或者 VkAttachmentSampleCountInfoNV中的depthStencilAttachmentSamples必须等于创建VkRenderingInfo::pDepthAttachment->imageView的sample count
                                                                      （5）如果当前的绑定的pipeline以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且VkRenderingInfo::pStencilAttachment中的imageView不为VK_NULL_HANDLE，则当前pipeline的VkAttachmentSampleCountInfoAMD 或者 VkAttachmentSampleCountInfoNV中的depthStencilAttachmentSamples必须等于创建VkRenderingInfo::pStencilAttachment->imageView的sample count
                                                                      （6）且含VkRenderingInfo::colorAttachmentCount大于0，如果当前的绑定的pipeline不以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且multisampledRenderToSingleSampled特性没有开启，则VkRenderingInfo::pColorAttachments中每个imageView不为VK_NULL_HANDLE的元素的imageView，其创建的sample count必须等于当前绑定的graphics pipeline的rasterizationSamples
                                                                      （7）如果当前的绑定的pipeline不以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且VkRenderingInfo::pDepthAttachment中的imageView不为VK_NULL_HANDLE，且multisampledRenderToSingleSampled特性没有开启，则当前pipeline的rasterizationSamples 必须等于创建VkRenderingInfo::pDepthAttachment->imageView的sample count
                                                                      （8）如果当前的绑定的pipeline不以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且VkRenderingInfo::pStencilAttachment中的imageView不为VK_NULL_HANDLE，且multisampledRenderToSingleSampled特性没有开启，则当前pipeline的rasterizationSamples 必须等于创建VkRenderingInfo::pStencilAttachment->imageView的sample count
                                                                      （9）当前绑定的pipeline必须VkGraphicsPipelineCreateInfo::renderPass为VK_NULL_HANDLE创建
                                                                      （10）如果绑定的pipeline的fragment shader静态写入一个color attachment，且color write mask不为0，启用了color writes，且该附件对应的VkRenderingInfo::pColorAttachments->imageView 不为VK_NULL_HANDLE，则对应的创建pipeline的VkPipelineRenderingCreateInfo::pColorAttachmentFormats中的元素不能为VK_FORMAT_UNDEFINED
                                                                      （11）如果绑定的pipeline启用了depth test，启用了depth writes，且VkRenderingInfo::pDepthAttachment->imageView 不为VK_NULL_HANDLE，则创建pipeline的VkPipelineRenderingCreateInfo::depthAttachmentFormat不能为VK_FORMAT_UNDEFINED
                                                                      （12）如果绑定的pipeline启用了stencil test，且VkRenderingInfo::pStencilAttachment->imageView 不为VK_NULL_HANDLE，则创建pipeline的VkPipelineRenderingCreateInfo::stencilAttachmentFormat不能为VK_FORMAT_UNDEFINED
        96.如果该命令在以vkCmdBeginRendering开始的render pass instance中调用，且VkRenderingInfo的pNext中包含一个multisampledRenderToSingleSampledEnable设为VK_TRUE的VkMultisampledRenderToSingleSampledInfoEXT，则当前绑定的graphics pipeline的rasterizationSamples必须等于VkMultisampledRenderToSingleSampledInfoEXT::rasterizationSamples
        97.如果primitivesGeneratedQueryWithRasterizerDiscard特性未开启，且VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query激活，则不能启用rasterization discard，
        98.如果primitivesGeneratedQueryWithNonZeroStreams特性未开启，且VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query激活，则 绑定的graphics pipeline不能以VkPipelineRasterizationStateStreamCreateInfoEXT::rasterizationStream为非零值创建
        98.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_TESSELLATION_DOMAIN_ORIGIN_EXT动态state开启创建，则vkCmdSetTessellationDomainOriginEXT必须在该命令之前设置
                                        （2）以VK_DYNAMIC_STATE_DEPTH_CLAMP_ENABLE_EXT动态state开启创建，则vkCmdSetDepthClampEnableEXT必须在该命令之前设置
                                        （3）以VK_DYNAMIC_STATE_POLYGON_MODE_EXT动态state开启创建，则vkCmdSetPolygonModeEXT必须在该命令之前设置
                                        （4）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，则vkCmdSetRasterizationSamplesEXT必须在该命令之前设置
                                        （5）以VK_DYNAMIC_STATE_SAMPLE_MASK_EXT动态state开启创建，则vkCmdSetSampleMaskEXT必须在该命令之前设置
                                        （6）以VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT动态state开启创建，则vkCmdSetAlphaToCoverageEnableEXT必须在该命令之前设置
                                        （7）以VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT动态state开启创建，则最近的vkCmdSetAlphaToCoverageEnableEXT设置alphaToCoverageEnable为VK_TRUE，则Fragment Output Interface中 Index 0的Location 0必须有一个含alpha Component的变量
                                        （8）以VK_DYNAMIC_STATE_ALPHA_TO_ONE_ENABLE_EXT动态state开启创建，则vkCmdSetAlphaToOneEnableEXT必须在该命令之前设置
                                        （9）以VK_DYNAMIC_STATE_LOGIC_OP_ENABLE_EXT动态state开启创建，则vkCmdSetLogicOpEnableEXT必须在该命令之前设置
                                        （10）以VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态state开启创建，则vkCmdSetColorBlendEnableEXT必须在该命令之前设置
                                        （11）以VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT动态state开启创建，则vkCmdSetColorBlendEquationEXT必须在该命令之前设置
                                        （12）以VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT动态state开启创建，则vkCmdSetColorWriteMaskEXT必须在该命令之前设置

        99.如果一个shader object绑定到VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT stage，则vkCmdSetTessellationDomainOriginEXT必须在该命令之前设置
        100.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                                        （1）如果depthClamp特性启用，则vkCmdSetDepthClampEnableEXT必须在该命令之前设置
                                                        （2）则vkCmdSetPolygonModeEXT必须在该命令之前设置
                                                        （3）则vkCmdSetRasterizationSamplesEXT必须在该命令之前设置
                                                        （4）则vkCmdSetSampleMaskEXT必须在该命令之前设置
                                                        （5）则vkCmdSetAlphaToCoverageEnableEXT必须在该命令之前设置
                                                        （6）如果alphaToOne特性启用，则vkCmdSetAlphaToOneEnableEXT必须在该命令之前设置

        101.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetAlphaToCoverageEnableEXT设置alphaToCoverageEnable为VK_TRUE，则Fragment Output Interface中 Index 0的Location 0必须有一个含alpha Component的变量
        102.如果一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                            （1）如果logicOp特性开启 ,则vkCmdSetLogicOpEnableEXT必须在该命令之前设置
                                            （2）如果绑定了color attachments，则vkCmdSetColorBlendEnableEXT必须在该命令之前设置
                                            （3）如果最近的vkCmdSetColorBlendEnableEXT设置任何附件在pColorBlendEnables中的值为VK_TRUE ，则vkCmdSetColorBlendEquationEXT必须在该命令之前设置
                                            （4）如果绑定了color attachments，则vkCmdSetColorWriteMaskEXT必须在该命令之前设置
        103.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT动态state开启创建，则vkCmdSetRasterizationStreamEXT必须在该命令之前设置
                                         （2）以VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT动态state开启创建，则vkCmdSetConservativeRasterizationModeEXT必须在该命令之前设置
                                         （3）以VK_DYNAMIC_STATE_EXTRA_PRIMITIVE_OVERESTIMATION_SIZE_EXT动态state开启创建，则vkCmdSetExtraPrimitiveOverestimationSizeEXT必须在该命令之前设置
                                         （4）以VK_DYNAMIC_STATE_DEPTH_CLIP_ENABLE_EXT动态state开启创建，则vkCmdSetDepthClipEnableEXT必须在该命令之前设置
                                         （5）以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT动态state开启创建，则vkCmdSetSampleLocationsEnableEXT必须在该命令之前设置
                                         （6）以VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT动态state开启创建，则vkCmdSetColorBlendAdvancedEXT必须在该命令之前设置
                                         （7）以VK_DYNAMIC_STATE_PROVOKING_VERTEX_MODE_EXT动态state开启创建，则vkCmdSetProvokingVertexModeEXT必须在该命令之前设置
                                         （8）以VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT动态state开启创建，则vkCmdSetLineRasterizationModeEXT必须在该命令之前设置
                                         （9）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT动态state开启创建，则vkCmdSetLineStippleEnableEXT必须在该命令之前设置
                                         （10）以VK_DYNAMIC_STATE_LINE_STIPPLE_KHR动态state开启创建，则vkCmdSetLineStippleKHR必须在该命令之前设置
                                         （11）以VK_DYNAMIC_STATE_DEPTH_CLIP_NEGATIVE_ONE_TO_ONE_EXT动态state开启创建，则vkCmdSetDepthClipNegativeOneToOneEXT必须在该命令之前设置
                                         （12）以VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_ENABLE_NV动态state开启创建，则vkCmdSetViewportWScalingEnableNV必须在该命令之前设置
                                         （13）以VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV动态state开启创建，则vkCmdSetViewportSwizzleNV必须在该命令之前设置
                                         （14）以VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV动态state开启创建，则vkCmdSetCoverageToColorEnableNV必须在该命令之前设置
                                         （15）以VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_LOCATION_NV动态state开启创建，则vkCmdSetCoverageToColorLocationNV必须在该命令之前设置
                                         （16）以VK_DYNAMIC_STATE_COVERAGE_MODULATION_MODE_NV动态state开启创建，则vkCmdSetCoverageModulationModeNV必须在该命令之前设置
                                         （17）以VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV动态state开启创建，则vkCmdSetCoverageModulationTableEnableNV必须在该命令之前设置
                                         （18）以VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_NV动态state开启创建，则vkCmdSetCoverageModulationTableNV必须在该命令之前设置
                                         （19）以VK_DYNAMIC_STATE_SHADING_RATE_IMAGE_ENABLE_NV动态state开启创建，则vkCmdSetShadingRateImageEnableNV必须在该命令之前设置
                                         （20）以VK_DYNAMIC_STATE_REPRESENTATIVE_FRAGMENT_TEST_ENABLE_NV动态state开启创建，则vkCmdSetRepresentativeFragmentTestEnableNV必须在该命令之前设置
                                         （21）以VK_DYNAMIC_STATE_COVERAGE_REDUCTION_MODE_NV动态state开启创建，则vkCmdSetCoverageReductionModeNV必须在该命令之前设置

        104.如果一个shader object绑定到VK_SHADER_STAGE_GEOMETRY_BIT stage，且如果geometryStreams 特性开启，则vkCmdSetRasterizationStreamEXT必须在该命令之前设置
        105.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                （1）如果VK_EXT_conservative_rasterization 拓展开启，则vkCmdSetConservativeRasterizationModeEXT必须在该命令之前设置
                                （2）如果VK_EXT_conservative_rasterization 拓展开启，且最近的vkCmdSetConservativeRasterizationModeEXT设置conservativeRasterizationMode为VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT，则vkCmdSetExtraPrimitiveOverestimationSizeEXT必须在该命令之前设置
                                （3）如果VK_EXT_sample_locations 拓展开启，则vkCmdSetSampleLocationsEnableEXT必须在该命令之前设置
        106.如果一个shader object绑定到任何graphics stage，且depthClipEnable 特性开启，则vkCmdSetDepthClipEnableEXT必须在该命令之前设置
        107.如果如果一个shader object绑定到任何VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且如果VK_EXT_blend_operation_advanced 拓展开启，则vkCmdSetColorBlendEquationEXT 和 vkCmdSetColorBlendAdvancedEXT中至少一个必须在该命令之前设置
        108.如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，如果VK_EXT_provoking_vertex拓展开启， 则vkCmdSetProvokingVertexModeEXT必须在该命令之前设置
        109.如果VK_KHR_line_rasterization 或者 VK_EXT_line_rasterization拓展开启，则（1）如果一个shader object绑定到任意一个graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetPolygonModeEXT设置polygonMode 为VK_POLYGON_MODE_LINE ，则vkCmdSetLineRasterizationModeEXT必须在该命令之前设置
                                                                                    （2）如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetPrimitiveTopology设置primitiveTopology 为任何line topology ，则vkCmdSetLineRasterizationModeEXT必须在该命令之前设置
                                                                                    （3）如果一个输出为line primitive的shader object绑定到VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或 VK_SHADER_STAGE_GEOMETRY_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则vkCmdSetLineRasterizationModeEXT必须在该命令之前设置
                                                                                    （4）如果一个shader object绑定到任意一个graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetPolygonModeEXT设置polygonMode 为VK_POLYGON_MODE_LINE ，则vkCmdSetLineStippleEnableEXT必须在该命令之前设置
                                                                                    （5）如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetPrimitiveTopology设置primitiveTopology 为任何line topology ，则vkCmdSetLineStippleEnableEXT必须在该命令之前设置
                                                                                    （6）如果一个输出为line primitive的shader object绑定到VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或 VK_SHADER_STAGE_GEOMETRY_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则vkCmdSetLineStippleEnableEXT必须在该命令之前设置
                                                                                    （7）如果一个shader object绑定到任意一个graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetLineStippleEnableEXT设置stippledLineEnable 为VK_TRUE ，则vkCmdSetLineStippleEXT必须在该命令之前设置
        110.如果一个shader object绑定到任何graphics stage，（1）如果depthClipControl 特性开启，则vkCmdSetDepthClipNegativeOneToOneEXT必须在该命令之前设置
                                                           （2）VK_NV_clip_space_w_scaling 拓展开启，则vkCmdSetViewportWScalingEnableNV必须在该命令之前设置
                                                           （3）VK_NV_viewport_swizzle 拓展开启，则vkCmdSetViewportSwizzleNV必须在该命令之前设置
        111.如果如果一个shader object绑定到任何VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                            （1）如果VK_NV_fragment_coverage_to_color 拓展开启，则vkCmdSetCoverageToColorEnableNV 必须在该命令之前设置
                            （2）如果VK_NV_fragment_coverage_to_color 拓展开启，且最近的vkCmdSetCoverageToColorEnableNV 设置coverageToColorEnable 为VK_TRUE，则vkCmdSetCoverageToColorLocationNV 必须在该命令之前设置
                            （3）如果pipelineFragmentShadingRate 特性开启，则vkCmdSetFragmentShadingRateKHR 必须在该命令之前设置
        112.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                    （1）如果VK_NV_framebuffer_mixed_samples 拓展开启，则vkCmdSetCoverageModulationModeNV 必须在该命令之前设置
                                    （2）如果VK_NV_framebuffer_mixed_samples 拓展开启，且最近的vkCmdSetCoverageModulationModeNV设置coverageModulationMode为任何除VK_COVERAGE_MODULATION_MODE_NONE_NV之外的值，则vkCmdSetCoverageModulationTableEnableNV 必须在该命令之前设置
                                    （3）如果VK_NV_framebuffer_mixed_samples 拓展开启，最近的vkCmdSetCoverageModulationTableEnableNV设置coverageModulationTableEnable为VK_TRUE，则vkCmdSetCoverageModulationTableNV 必须在该命令之前设置
                                    （4）如果shadingRateImage 特性开启，则vkCmdSetShadingRateImageEnableNV 必须在该命令之前设置
                                    （5）如果representativeFragmentTest 特性开启，则vkCmdSetRepresentativeFragmentTestEnableNV 必须在该命令之前设置
                                    （6）如果coverageReductionMode 特性开启，则vkCmdSetCoverageReductionModeNV 必须在该命令之前设置
        113.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态state开启创建，且最近的vkCmdSetColorBlendEnableEXT设置任何附件在pColorBlendEnables中的值为VK_TRUE 则subpas中这些附件对应的image view的format features中必须包含VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT
                                         （2）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，且当前subpass不使用任何color和/或者 depth/stencil attachments，则最后的vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples必须符合zero￾attachment subpass的规则
                                         （3）以VK_DYNAMIC_STATE_SAMPLE_MASK_EXT不以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT 动态state开启创建，则最后调用的vkCmdSetSampleMaskEXT中设置的samples参数必须大于等于创建该pipeline的VkPipelineMultisampleStateCreateInfo::rasterizationSamples
                                         （4）以VK_DYNAMIC_STATE_SAMPLE_MASK_EXT和 VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT 动态state开启创建，则最后调用的vkCmdSetSampleMaskEXT中设置的samples参数必须大于等于最后的vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples
                                         （5）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，且VK_AMD_mixed_attachment_samples和VK_NV_framebuffer_mixed_samples拓展都没有开启，则最后的vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples必须等于subpass中color和/或者 depth/stencil attachments使用的相同
                                         （6）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，或者一个shader object绑定到任意graphics stage，且当前的subpass包含一个multisampledRenderToSingleSampledEnable 为VK_TRUE的VkMultisampledRenderToSingleSampledInfoEXT，则最后的vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples必须等于该VkMultisampledRenderToSingleSampledInfoEXT中的对应成员
                                         （7）以VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态state开启创建，则vkCmdSetColorBlendEnableEXT 必须在该命令之前设置，且vkCmdSetColorBlendEnableEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定值
                                         （8）以VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT动态state开启创建，则vkCmdSetColorBlendEquationEXT 必须在该命令之前设置，且vkCmdSetColorBlendEquationEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定blend equations
                                         （9）以VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT动态state开启创建，则vkCmdSetColorWriteMaskEXT 必须在该命令之前设置，且vkCmdSetColorWriteMaskEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定color write mask
                                         （10）以VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT动态state开启创建，则vkCmdSetColorBlendAdvancedEXT 必须在该命令之前设置，且vkCmdSetColorBlendAdvancedEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活blend的color attachments指定advanced blend equations
                                         （11）以VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT和VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态state开启创建，且最后的vkCmdSetColorBlendEnableEXT和vkCmdSetColorBlendAdvancedEXT设置启用了advanced blending，则当前subpass中激活的color attachments的数量不能超过advancedBlendMaxColorAttachments
                                         （12）以VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT动态state开启创建，且如果primitivesGeneratedQueryWithNonZeroStreams特性未开启且VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query已经激活，则最后的vkCmdSetRasterizationStreamEXT必须设置rasterizationStream为0
                                         （13）以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT但不以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，则最后的vkCmdSetSampleLocationsEXT设置的pSampleLocationsInfo->sampleLocationsPerPixel必须等于创建pipeline的VkPipelineMultisampleStateCreateInfo::rasterizationSamples
                                         （14）以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT和VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，则最后的vkCmdSetSampleLocationsEXT设置的pSampleLocationsInfo->sampleLocationsPerPixel必须等于最后vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples
                                         （15）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT但不以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT动态state开启创建，且绑定的pipeline的VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable为VK_TRUE 或者以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT动态state开启，则sampleLocationsInfo.sampleLocationsPerPixel 必须等于最后vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples
                                         （16）以VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV动态state开启创建，且最后的vkCmdSetCoverageToColorEnableNV设置coverageToColorEnable为VK_TRUE，则当前subpass必须有color attachment，且该attachment的format必须为VK_FORMAT_R8_UINT, VK_FORMAT_R8_SINT, VK_FORMAT_R16_UINT, VK_FORMAT_R16_SINT, VK_FORMAT_R32_UINT, 或者 VK_FORMAT_R32_SINT，且该attachment的location 有最后的vkCmdSetCoverageToColorLocationNV设置的coverageToColorLocation决定
                                         （17）以VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV和VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT 动态state开启创建，且如果VK_NV_coverage_reduction_mode 拓展开启，则当前的 coverageReductionMode，rasterizationSamples 以及color 以及 depth/stencil attachments（如果subpass有）的sample count必须是有效的返回值vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV的值的组合
                                         （18）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT但不以VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV 动态state开启创建，则绑定的graphics pipeline的VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount 必须大于等于最后vkCmdSetViewportWithCount设置的viewportCount
                                         （19）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT和VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV 动态state开启创建，则最后vkCmdSetViewportSwizzleNV设置的viewportCount 必须大于等于最后vkCmdSetViewportWithCount设置的viewportCount
                                         （20）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT或者 VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT 动态state开启创建，如果当前的stippledLineEnable为VK_TRUE，且当前的lineRasterizationMode为VK_LINE_RASTERIZATION_MODE_RECTANGULAR_KHR，则stippledRectangularLines 特性必须开启
                                         （21）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT或者 VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT 动态state开启创建，如果当前的stippledLineEnable为VK_TRUE，且当前的lineRasterizationMode为VK_LINE_RASTERIZATION_MODE_BRESENHAM_KHR，则stippledBresenhamLines 特性必须开启
                                         （22）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT或者 VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT 动态state开启创建，如果当前的stippledLineEnable为VK_TRUE，且当前的lineRasterizationMode为VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_KHR，则stippledSmoothLines 特性必须开启
                                         （23）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT或者 VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT 动态state开启创建，如果当前的stippledLineEnable为VK_TRUE，且当前的lineRasterizationMode为VK_LINE_RASTERIZATION_MODE_DEFAULT_KHR，则stippledRectangularLines 特性必须开启且VkPhysicalDeviceLimits::strictLines 必须为VK_TRUE
                                         （24）以VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT 动态state开启创建，且conservativePointAndLineRasterization不支持，最后的 pre-rasterization shader stage输出的有效图元拓扑为点或者线，则最后vkCmdSetConservativeRasterizationModeEXT设置的conservativeRasterizationMode 必须为VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT
                                         （25）以VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT 动态state开启创建，则vkCmdSetAttachmentFeedbackLoopEnableEXT 必须在该命令之前调用
        114.如果一个shader object绑定到 VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                                                                            （1）则vkCmdSetColorBlendEnableEXT 必须在该命令之前设置，且vkCmdSetColorBlendEnableEXT指定的firstAttachment开始的attachmentCount的值必须为当前subpass所有激活的color attachments指定
                                                                                            （2）则vkCmdSetColorBlendEquationEXT 必须在该命令之前设置，且vkCmdSetColorBlendEquationEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定blend equations
                                                                                            （3）则vkCmdSetColorWriteMaskEXT 必须在该命令之前设置，且vkCmdSetColorWriteMaskEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定color write mask
                                                                                            （4）如果VK_NV_fragment_coverage_to_color拓展开启， 最后的vkCmdSetCoverageToColorEnableNV设置coverageToColorEnable为VK_TRUE，则当前subpass必须有color attachment，且该attachment的format必须为VK_FORMAT_R8_UINT, VK_FORMAT_R8_SINT, VK_FORMAT_R16_UINT, VK_FORMAT_R16_SINT, VK_FORMAT_R32_UINT, 或者 VK_FORMAT_R32_SINT，且该attachment的location 有最后的vkCmdSetCoverageToColorLocationNV设置的coverageToColorLocation决定
        115.如果一个shader object绑定到 VK_SHADER_STAGE_FRAGMENT_BIT stage，（1）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT动态state开启创建，且最近的vkCmdSetSampleLocationsEnableEXT设置sampleLocationsEnable为VK_TRUE，且该subpass含有depth/stencil attachment，则该附件必须以VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT创建
                                                                            （2）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT和VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT 动态state开启创建，且最近的vkCmdSetSampleLocationsEnableEXT设置sampleLocationsEnable为VK_TRUE，则 最后vkCmdSetSampleLocationsEXT设置的sampleLocationsInfo.sampleLocationGridSize.width以及height 必须等于被调用vkGetPhysicalDeviceMultisamplePropertiesEXT传入rasterizationSamples返回的VkMultisamplePropertiesEXT::sampleLocationGridSize.width以及height一一对应均匀整除
                                                                            （3）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT 动态state开启创建，且最近的vkCmdSetSampleLocationsEnableEXT设置sampleLocationsEnable为VK_TRUE，则fragment shader代码中不能静态使用扩展指令InterpolateAtSample
                                                                            （4）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT但不以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT 动态state开启创建，且绑定的pipeline的VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable为VK_TRUE 或者以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT动态state开启，则 最后vkCmdSetRasterizationSamplesEXT设置的sampleLocationsInfo.sampleLocationGridSize.width以及height 必须等于被调用vkGetPhysicalDeviceMultisamplePropertiesEXT传入和vkCmdSetRasterizationSamplesEXT设置的相同rasterizationSamples的samples返回的VkMultisamplePropertiesEXT::sampleLocationGridSize.width以及height一一对应均匀整除
        116.如果一个shader object绑定到任何graphics stage，（1）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV 动态state开启创建，且最近的vkCmdSetCoverageModulationTableEnableNV设置coverageModulationTableEnable为VK_TRUE，则最近的vkCmdSetCoverageModulationTableNV 设置的coverageModulationTableCount 必须等于当前rasterizationSamples除以当前subppas的color samples
                                                           （2）如果VK_NV_viewport_swizzle 拓展开启，则最后vkCmdSetViewportSwizzleNV设置的viewportCount 必须大于等于最后vkCmdSetViewportWithCount设置的viewportCount
        117.如果VK_NV_framebuffer_mixed_samples 拓展开启，且如果在绑定的graphics pipeline中当前subpass有一个depth/stencil attachment以及dep test, stencil test, 或depth bounds test 启用，则当前rasterizationSamples 必须等于depth/stencil attachment的sample count
        118.如果VK_NV_framebuffer_mixed_samples 拓展开启，且如果最后的vkCmdSetRasterizationSamplesEXT设置的当前subpass的任何color attachments的rasterizationSamples 都大于 color samples，则sampleShadingEnable 必须为VK_FALSE
        119.如果当前绑定的graphics pipeline以VkGraphicsPipelineCreateInfo::pStages中的元素的VkPipelineShaderStageCreateInfo::stage设置为VK_SHADER_STAGE_VERTEX_BIT, VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT, VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或者 VK_SHADER_STAGE_GEOMETRY_BIT创建，则Mesh Shader Queries 不能激活
        120.如果dynamic state继承自VkCommandBufferInheritanceViewportScissorInfoNV，则这些动态state的设置必须在该命令之前设置
        121.如果没有绑定graphics pipeline，则（1）vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_VERTEX_BIT
                                             （2）如果tessellationShader 特性开启，vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT，VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT
                                             （3）如果geometryShader 特性开启，vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_GEOMETRY_BIT
                                             （4）vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_FRAGMENT_BIT
                                             （5）如果taskShader 特性开启，vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_TASK_BIT_EXT
                                             （6）如果meshShader 特性开启，vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_MESH_BIT_EXT
                                             （8）如果至少taskShader 和 meshShader一个特性开启，VK_SHADER_STAGE_VERTEX_BIT 或者VK_SHADER_STAGE_MESH_BIT_EXT stages中的一个必须含有有效的VkShaderEXT绑定，另外一个则不含有VkShaderEXT绑定
                                             （9）如果taskShader 和 meshShader特性同时开启，且一个有效的VkShaderEXT 绑定到VK_SHADER_STAGE_MESH_BIT_EXT stage，且该VkShaderEXT不以VK_SHADER_CREATE_NO_TASK_SHADER_BIT_EXT 创建，则一个有效的VkShaderEXT必须绑定到VK_SHADER_STAGE_TASK_BIT_EXT stage
                                             （10）如果taskShader 和 meshShader特性同时开启，且一个有效的VkShaderEXT 绑定到VK_SHADER_STAGE_MESH_BIT_EXT stage，且该VkShaderEXT以VK_SHADER_CREATE_NO_TASK_SHADER_BIT_EXT 创建，则不能有VkShaderEXT绑定到VK_SHADER_STAGE_TASK_BIT_EXT stage
                                             （11）如果一个有效的VkShaderEXT 绑定到VK_SHADER_STAGE_VERTEX_BIT stage，则不能有VkShaderEXT绑定到VK_SHADER_STAGE_TASK_BIT_EXT stage或者VK_SHADER_STAGE_MESH_BIT_EXT stage中的一个
        122.如果任何绑定的graphics shader以VK_SHADER_CREATE_LINK_STAGE_BIT_EXT 创建，（1）所有在相同vkCreateShadersEXT中以VK_SHADER_CREATE_LINK_STAGE_BIT_EXT创建的shaders必须也要绑定
                                                                                     （2）任何相同vkCreateShadersEXT中不以VK_SHADER_CREATE_LINK_STAGE_BIT_EXT创建的shaders不能有任何VkShaderEXT绑定
        123.所有绑定的graphics shader objects 必须以相同或者相同定义的push constant ranges创建
        124.所有绑定的graphics shader objects 必须以相同或者相同定义的descriptor set layouts的数组创建
        125.如果当前的render pass instance以vkCmdBeginRendering开始，且VkRenderingInfo::colorAttachmentCount为1，且有一个resolve mode为 VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID 的color attachment，且绑定了fragment shader，则DepthReplacing 和 StencilRefReplacingEXT execution modes 不能声明
        126.如果一个shader object绑定到 VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则 （1）如果attachmentFeedbackLoopDynamicState 特性开启，则 vkCmdSetAttachmentFeedbackLoopEnableEXT 必须在该命令之前调用
        127.如果包含一个fragment shader stage的绑定的graphics pipeline，（1）且该pipeline以VkPipelineDynamicStateCreateInfo::pDynamicStates中设置有VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE创建，且该fragment shader声明了EarlyFragmentTests execution mode且使用了OpDepthAttachmentReadEXT，则最后vkCmdSetDepthWriteEnable 设置的 depthWriteEnable 必须为VK_FALSE
                                                                        （2）且该pipeline以VkPipelineDynamicStateCreateInfo::pDynamicStates中设置有VK_DYNAMIC_STATE_STENCIL_WRITE_MASK创建，且该fragment shader声明了EarlyFragmentTests execution mode且使用了OpStencilAttachmentReadEXT，则最后vkCmdSetStencilWriteMask 设置的 writeMask 必须为0
        128.如果一个shader object绑定到任何graphics stage 或者绑定的graphics pipeline 以VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT 动态state开启创建，且任何color attachment的format为VK_FORMAT_E5B9G9R9_UFLOAT_PACK32，则vkCmdSetColorWriteMaskEXT设置的pColorWriteMasks参数的对应元素必须包含VK_COLOR_COMPONENT_R_BIT, VK_COLOR_COMPONENT_G_BIT, 和 VK_COLOR_COMPONENT_B_BIT，或者都不包含
        129.如果任何附件开启了blending，且该附件的source 或者 destination blend factors使用第二个颜色输入，则该命令执行的Fragment Execution Model静态使用的任何输出output attachment的Location的最大值必须小于maxFragmentDualSrcAttachments
        130.如果当前的render pass instance以vkCmdBeginRendering开始，（1）如果没有任何shader object绑定到任何graphics stage，则vkCmdSetRenderingAttachmentLocationsKHR 设置的VkRenderingAttachmentLocationInfoKHR::pColorAttachmentLocations中的每个元素必须匹配设置在当前绑定的graphics pipeline中的对应元素
                                                                     （2）如果没有任何shader object绑定到任何graphics stage，绑定的graphics pipeline中的input attchment 索引中映射的附件必须匹配在当前render pass instance的VkRenderingInputAttachmentIndexInfoKHR中设置的
        131.如果当前的render pass instance以vkCmdBeginRendering开始且以VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT标志开始，则绑定的graphics pipeline必须以VK_PIPELINE_CREATE_2_ENABLE_LEGACY_DITHERING_BIT_EXT创建
        132.如果绑定的graphics pipeline以VK_PIPELINE_CREATE_2_ENABLE_LEGACY_DITHERING_BIT_EXT创建，则当前的render pass 必须以vkCmdBeginRendering开始且以VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT标志开始
        133.如果commandBuffer是protected command buffer且protectedNoFault不支持，（1）则任何绑定到pipeline bind point的VkPipeline写入的resource资源不能是unprotected resource
                                                                                 （2）则任何绑定到pipeline bind point的VkPipeline的除了framebuffer-space 以及 compute stages之外的pipeline stage不能写入任何resource
        134.如果该命令使用的任何绑定到pipeline bind point的VkPipeline的shader stages使用RayQueryKHR capability，则commandBuffer不能是一个protected command buffer
        135.所有在vertex shader entry point 的 interface通过声明的vertex input variables访问的vertex input bindings必须是有效的buffer绑定或者为VK_NULL_HANDLE绑定
        136.如果nullDescriptor 特性未开启，则所有在vertex shader entry point 的 interface通过声明的vertex input variables访问的vertex input bindings不能为VK_NULL_HANDLE绑定
        137.如果robustBufferAccess 特性未开启，且pipeline的创建不对vertexInputs以VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT开启创建，则对于指定的vertex buffer binding，任何获取的顶点属性数据必须包含在对应的vertex buffer binding中，参见Vertex Input Description p2586
        138.如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage或者绑定的graphics pipeline以VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY动态state开启创建，则vkCmdSetPrimitiveTopology必须在该命令前设置
        140.如果绑定的graphics pipeline以VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY动态state开启创建，且dynamicPrimitiveTopologyUnrestricted为VK_FALSE，则vkCmdSetPrimitiveTopology设置的primitiveTopology 必须和pipeline创建的VkPipelineInputAssemblyStateCreateInfo::topology相同
        141.如果绑定的graphics pipeline以VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT但不以VK_DYNAMIC_STATE_VERTEX_INPUT_EXT 动态state开启创建，则vkCmdBindVertexBuffers2EXT必须在该命令前设置，且pStrides参数不能为NULL
        142.如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage或者绑定的graphics pipeline以VK_DYNAMIC_STATE_VERTEX_INPUT_EXT动态state开启创建，则
                        （1）vkCmdSetVertexInputEXT必须在该命令前设置
                        （2）所有以Input storage class修饰的Vertex Execution Model OpEntryPoint中的变量其Location必须包含在VkVertexInputAttributeDescription2EXT::location指定的location中
                        （3）如果满足legacyVertexAttributes未开启或者Vertex Execution Model OpEntryPoint中给定对应Location的Input variable的 SPIR-V Type为64-bit的中的一个，则Vertex Execution Model OpEntryPoint中对应Location的所有Input variable的numeric type必须和VkVertexInputAttributeDescription2EXT::format的相同
                        （4）如果VkVertexInputAttributeDescription2EXT::format含有64-bit 分量，Vertex Execution Model OpEntryPoint中对应Location的所有Input variable的scalar width必须是64-bit的
                        （5）如果Vertex Execution Model OpEntryPoint中对应Location的Input variable的scalar width是64-bit的，则对应VkVertexInputAttributeDescription2EXT::format必须含有64-bit 分量
                        （6）如果VkVertexInputAttributeDescription2EXT::format含有64-bit 分量，则Vertex Execution Model OpEntryPoint中对应Location的所有Input variable不能使用该format未呈现的分量
        143.如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage且最近的vkCmdSetPrimitiveTopology设置primitiveTopology为VK_PRIMITIVE_TOPOLOGY_PATCH_LIST，或者绑定的graphics pipeline以VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT动态state开启创建，则vkCmdSetPatchControlPointsEXT必须在该命令前设置
        144.如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage或者绑定的graphics pipeline以VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE动态state开启创建，则vkCmdSetPrimitiveRestartEnable必须在该命令前设置
        145.如果primitiveTopologyListRestart特性未开启，且topology 为VK_PRIMITIVE_TOPOLOGY_POINT_LIST, VK_PRIMITIVE_TOPOLOGY_LINE_LIST, VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST, VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY, 或者 VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY，
                    且有一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage或者绑定的graphics pipeline以VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE动态state开启创建，则vkCmdSetPrimitiveRestartEnable必须设置为VK_FALSE
        146.绑定的graphics pipeline不能以VkGraphicsPipelineCreateInfo::pStages中元素的VkPipelineShaderStageCreateInfo::stage设置为VK_SHADER_STAGE_TASK_BIT_EXT 或者 VK_SHADER_STAGE_MESH_BIT_EXT创建
        147.不能有shader object绑定到VK_SHADER_STAGE_TASK_BIT_EXT或者 VK_SHADER_STAGE_MESH_BIT_EXT中的一个stage
		148.如果maintenance6 未开启，一个有效的index buffer必须被绑定
		149.如果robustBufferAccess2 未开启，则(indexSize × (firstIndex + indexCount) + offset)  必须小于等于绑定的index buffer的大小，其中indexSize 取决于indexType，index buffer, indexType, offset 都通过vkCmdBindIndexBuffer指定
        150.如果绑定的graphics pipeline 以VkGraphicsPipelineCreateInfo::pVertexInputState->pNext中包含一个VkPipelineVertexInputDivisorStateCreateInfoKHR创建，且VkPipelineVertexInputDivisorStateCreateInfoKHR::pVertexBindingDivisors任何元素为除数为1外的值，且VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR::supportsNonZeroFirstInstance 为VK_FALSE，则firstInstance必须为0
        151.如果shader objects用于绘制或者绑定的graphics pipeline以VK_DYNAMIC_STATE_VERTEX_INPUT_EXT动态state开启创建，且vkCmdSetVertexInputEXT设置的pVertexBindingDescriptions中设置该动态state的任何元素有为除数为1外的值，且VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR::supportsNonZeroFirstInstance 为VK_FALSE，则firstInstance必须为0
		152.如果robustBufferAccess2 未开启，则(indexSize × (firstIndex + indexCount) + offset)  必须小于等于绑定的index buffer的大小，其中indexSize 取决于indexType，index buffer, indexType, offset 都通过vkCmdBindIndexBuffer或者vkCmdBindIndexBuffer2KHR 指定，如果使用vkCmdBindIndexBuffer2KHR绑定index buffer，则vkCmdBindIndexBuffer2KHR::size指定index buffer的大小
        */


        VkMultiDrawInfoEXT multiDrawInfoEXT{};//该结构体中的参数等价于 vkCmdDraw中的firstVertex 以及vertexCount
        multiDrawInfoEXT.firstVertex = 0;//是要绘制的第一个顶点
        multiDrawInfoEXT.vertexCount = 1;//是要绘制的顶点数
        //记录一组state不会改变的顺序绘制    该命令顺序绘制pVertexInfo中VkMultiDrawInfoEXT元素指定的绘制信息，图元装配按照vkCmdDraw的方式，对每个绘制从firstInstance开始画instanceCount个实例
        vkCmdDrawMultiEXT(commandBuffer, 1/*drawCount, 要绘制的VkMultiDrawInfoEXT个数,可以为0.*/, &multiDrawInfoEXT/* pVertexInfo,一组VkMultiDrawInfoEXT指针数组，指明要绘制顶点信息.*/, 
            1/*instanceCount，为每次绘制要绘制的instance数量*/, 0/*firstInstance，为每次绘制的第一个绘制的instance的ID.*/, 1/*stride,是pVertexInfo中连续元素之前的字节步长.*/);
        /*
        
         vkCmdDrawMultiEXT有效用法:
        1.如果一个VkSampler以其magFilter或者minFilter等于VK_FILTER_LINEAR创建，则（1）如果reductionMode为VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE，如果用于采样一个VkImageView作为该命令的结果的compareEnable为VK_FALSE，则该image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT
                                                                                 （2）如果reductionMode为VK_SAMPLER_REDUCTION_MODE_MIN 或者VK_SAMPLER_REDUCTION_MODE_MAX之一 用于采样一个VkImageView作为该命令的结果，则该image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT
        2.如果一个VkSampler以其mipmapMode 等于VK_SAMPLER_MIPMAP_MODE_LINEAR创建，则（1）如果reductionMode为VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE，如果用于采样一个VkImageView作为该命令的结果的compareEnable为VK_FALSE，则该image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT
                                                                                 （2）如果reductionMode为VK_SAMPLER_REDUCTION_MODE_MIN 或者VK_SAMPLER_REDUCTION_MODE_MAX之一 用于采样一个VkImageView作为该命令的结果，则该image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT
        3.如果一个VkSampler以其unnormalizedCoordinates等于VK_TRUE用于采样一个VkImageView作为该命令的结果创建，则（1）该image view的levelCount以及layerCount必须为1
                                                                                                                （2）该image view的viewType必须为VK_IMAGE_VIEW_TYPE_1D 或者 VK_IMAGE_VIEW_TYPE_2D
        4.如果一个VkImageView的采样带depth comparison操作，则image view的format features必须包含VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT
        5.如果一个VkImageView使用atomic operations作为该命令的结果进行访问，则image view的format features必须包含VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT
        6.如果一个VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER类型的 descriptor使用atomic operations作为该命令的结果进行访问，则storage texel buffer的format features必须包含VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT
        7.如果一个以VK_FILTER_CUBIC_EXT进行采样的VkImageView作为该命令的结果，则image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT
        8.如果VK_EXT_filter_cubic拓展没有开启，且有任何一个以VK_FILTER_CUBIC_EXT进行采样的VkImageView作为该命令的结果，则其VkImageViewType不能为VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, 或者 VK_IMAGE_VIEW_TYPE_CUBE_ARRAY
        9.任何一个以VK_FILTER_CUBIC_EXT进行采样的作为该命令的结果的VkImageView，其VkImageViewType和format 必须支持cubic filtering，参见vkGetPhysicalDeviceImageFormatProperties2返回的VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic
        10.任何一个以VK_FILTER_CUBIC_EXT进行采样且reduction mode为VK_SAMPLER_REDUCTION_MODE_MIN 或者 VK_SAMPLER_REDUCTION_MODE_MAX之一的作为该命令的结果的VkImageView，其VkImageViewType和format 必须支持带minmax filtering的cubic filtering，参见vkGetPhysicalDeviceImageFormatProperties2返回的VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax
        11.如果cubicRangeClamp特性没有开启，则有任何一个以VK_FILTER_CUBIC_EXT进行采样VkImageView的作为该命令的结果，VkSamplerReductionModeCreateInfo::reductionMode不能为VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM
        12.任何一个以VkSamplerReductionModeCreateInfo::reductionMode为VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM进行采样的作为该命令的结果的VkImageView必须以VK_FILTER_CUBIC_EXT进行采样
        13.如果selectableCubicWeights特性没有开启，则有任何一个以VK_FILTER_CUBIC_EXT进行采样VkImageView的作为该命令的结果，VkSamplerCubicWeightsCreateInfoQCOM::cubicWeights必须为VK_CUBIC_FILTER_WEIGHTS_CATMULL_ROM_QCOM
        14.任何一个以VkImageCreateInfo::flags含VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV创建的采样作为该命令结果的VkImage必须以VkSamplerAddressMode为VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE 进行采样
        15.对于任何作为storage image写入的VkImageView，且其OpTypeImage的format未知，则该image view的 format features必须包含VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT
        16.对于任何作为storage image读取的VkImageView，且其OpTypeImage的format未知，则该image view的 format features必须包含VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT
        17.对于任何作为storage storage texel buffer写入的VkBufferView，且其OpTypeImage的format未知，则该buffer view的 buffer features必须包含VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT
        18.对于任何作为storage storage texel buffer读取的VkBufferView，且其OpTypeImage的format未知，则该buffer view的 buffer features必须包含VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT
        19.对于每个在绑定的shader中静态使用的set n，一个descriptor set必须被绑定到相同pipeline bind point的set n处，该set n必须和创建当前VkPipeline的VkPipelineLayout或者和创建当前VkShaderEXT的VkDescriptorSetLayout 数组的set n处的布局兼容，参见Pipeline Layout Compatibility p1280
        20.对于每个在绑定的shader中静态使用的push constant，一个push constant值必须被绑定到相同pipeline bind point的对应处，该push constant必须和创建当前VkPipeline的VkPipelineLayout或者和创建当前VkShaderEXT的VkDescriptorSetLayout 数组中的对应处的布局兼容，参见Pipeline Layout Compatibility p1280
        21.如果maintenance4特性没有开启，则对于每个在绑定的shader中静态使用的push constant，一个push constant值必须被设置到相同pipeline bind point的对应处，该push constant必须和创建当前VkPipeline的VkPipelineLayout或者和创建当前VkShaderEXT的VkDescriptorSetLayout 数组中的对应处的布局兼容，参见Pipeline Layout Compatibility p1280
        22.每一个通过vkCmdBindDescriptorSets绑定的descriptor set的descriptors,如果是被不以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建的，且已经绑定到该命令使用的pipeline bind point的VkPipeline静态使用的，则这些descriptors必须是有效的，参见 descriptor validity p1328
        23.如果通过vkCmdBindDescriptorSets指定绑定到pipeline bind point的VkPipeline要使用的descriptors，则绑定的VkPipeline不能以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建
		24.在vkCmdSetDescriptorBufferOffsetsEXT中指定绑定的descriptor buffers的descriptors，则（1）如果绑定到pipeline bind point的该命令会使用的VkPipeline以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建，且这些descriptors是动态使用的，则这些descriptors必须是有效的
                                                                                              （2）如果绑定到pipeline bind point的对应stage的该命令会使用的VkShaderEXT，且这些descriptors是动态使用的，则这些descriptors必须是有效的
        25.在vkCmdSetDescriptorBufferOffsetsEXT中指定的descriptors在绑定到pipeline bind point的VkPipeline中使用，则VkPipeline必须以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建
        26.如果一个descriptor在以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建的VkPipeline中动态使用，则descriptor memory必须是驻留内存
		27.如果一个descriptor在以其VkDescriptorSetLayout以VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建的VkShaderEXT中动态使用，则descriptor memory必须是驻留内存
        28.如果shaderObject 特性没有开启，一个有效的pipeline必须绑定到这个命令使用的绑定到pipeline bind point上
		29.如果一个pipeline绑定到该命令使用的pipeline bind point上，则不能有任何动态state 设置命令设置任何该VkPipeline 中没有指定的动态 state
		30.如果一个VkPipeline绑定到该命令使用的pipeline bind point上 或者任何一个会访问一个使用unnormalized coordinates的VkSampler的 VkShaderEXT绑定到该命令使用的pipeline bind point上的pipeline的对应stage，则
                                                                                    （1）在任何shader stage中，VkSampler不能用来采样任何类型为VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY 或者 VK_IMAGE_VIEW_TYPE_CUBE_ARRAY的VkImageView
                                                                                    （2）在任何shader stage中，该VkSampler不能和任何带有名字中带有ImplicitLod，Dref 或者 Proj 的SPIR-V OpImageSample* 或者 OpImageSparseSample*指令一起使用
                                                                                    （3）在任何shader stage中，该VkSampler不能和任何包含 LOD bias或者offset 值 的SPIR-V OpImageSample* or OpImageSparseSample*指令一起使用
		31.如果shaderObject开启，一个有效的pipeline必须绑定到该命令使用的pipeline bind point上或者一个有效的shader objects以及VK_NULL_HANDLE的组合必须绑定到该命令使用的pipeline bind point每一个支持的shader stage上
        32.如何绑定到该命令使用的pipeline bind point上的VkPipeline的任何stage会访问一个uniform buffer，且该stage对uniformBuffers不以启用VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT或者VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT 创建，且robustBufferAccess特性未开启，则该stage就不能访问绑定到相同pipeline bind point的descriptor set指定的buffer范围外的值
		33.如果robustBufferAccess特性未开启，且任何会访问uniform buffer的绑定到该命令使用的pipeline bind point上对应shader stage的VkShaderEXT，则其不能访问绑定到相同pipeline bind point的descriptor set指定的buffer范围外的值
        34.如何绑定到该命令使用的pipeline bind point上的VkPipeline的任何stage会访问一个storage buffer，且该stage对storageBuffers不以启用VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT或者VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT 创建，且robustBufferAccess特性未开启，则该stage就不能访问绑定到相同pipeline bind point的descriptor set指定的buffer范围外的值
		35.如果robustBufferAccess特性未开启，且任何会访问storage buffer的绑定到该命令使用的pipeline bind point上对应shader stage的VkShaderEXT，则其不能访问绑定到相同pipeline bind point的descriptor set指定的buffer范围外的值
        36.如果commandBuffer 是一个unprotected command buffer，且protectedNoFault 未支持，则任何绑定的shaders访问的资源不能是一个protected resource
        37.如果一个绑定的shader访问一个VkSampler 或者 VkImageView ，且启用了sampler Y′C BCR conversion，则只能使用OpImageSample* 或者 OpImageSparseSample*指令，不能使用ConstOffset 以及 Offset操作符
        38.如果一个VkImageView作为该命令的结果进行访问，则（1）image view 的viewType 必须匹配Instruction/Sampler/Image View Validation p1481中描述的OpTypeImage的Dim操作符
                                                          （2）image view 的foamrt的numeric type 必须匹配OpTypeImage的Sampled Type操作符
        39.如果一个VkImageView以一个不是VK_FORMAT_A8_UNORM_KHR的format创建且通过OpImageWrite作为该命令的结果进行访问，则该命令的Texel 操作符的Type必须至少包含和 image view的 format含有的components的个数相同的components个数
		40.如果一个VkImageView以VK_FORMAT_A8_UNORM_KHR的format创建且通过OpImageWrite作为该命令的结果进行访问，则该命令的Texel 操作符的Type必须包含4个components
		41.如果一个VkBufferView通过OpImageWrite作为该命令的结果进行访问，则该命令的Texel 操作符的Type必须至少包含和 buffer view的 format含有的components的个数相同的components个数
		42.如果一个带64-bit component的VkFormat的VkImageView作为该命令的结果进行访问，则该命令的OpTypeImage操作符的SampledType的宽度必须为64
		43.如果一个带少于64-bit component的VkFormat的VkImageView作为该命令的结果进行访问，则该命令的OpTypeImage操作符的SampledType的宽度必须为32
		44.如果一个带64-bit component的VkFormat的VkBufferView作为该命令的结果进行访问，则该命令的OpTypeImage操作符的SampledType的宽度必须为64位
		45.如果一个带少于64-bit component的VkFormat的VkBufferView作为该命令的结果进行访问，则该命令的OpTypeImage操作符的SampledType的宽度必须为32
		46.如果sparseImageInt64Atomics 特性未开启，则以VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT创建的VkImage对象不能被SampledType宽度为64位的OpTypeImage的atomic instructions访问
		47.如果sparseImageInt64Atomics 特性未开启，则以VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT创建的VkBuffer对象不能被SampledType宽度为64位的OpTypeImage的atomic instructions访问
		48.如果OpImageWeightedSampleQCOM用来采样一个作为该命令的结果的VkImageView，则该image view的format features必须包含VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM
        49.如果OpImageWeightedSampleQCOM用来采样一个作为该命令的结果的sample weight image的VkImageView，则该image view的format features必须包含VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM
		50.如果OpImageBoxFilterQCOM用来采样一个作为该命令的结果的VkImageView，则该image view的format features必须包含VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM
        51.如果OpImageBlockMatchSSDQCOM，或者 OpImageBlockMatchSADQCOM用来读取一个作为该命令的结果的VkImageView，则（1）该image view的format features必须包含VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM
                                                                                                                   （2）如果是读取的reference image，指定的reference coordinates不能在integer texel coordinate validation 时候失败
        52.如果OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchWindowSSDQCOM, OpImageBlockMatchWindowSADQCOM, OpImageBlockMatchGatherSSDQCOM,
                                                    OpImageBlockMatchGatherSADQCOM, OpImageBlockMatchSSDQCOM, 或者 OpImageBlockMatchSADQCOM用来采样一个作为该命令的结果的VkImageView，则该VkSampler必须以VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM创建
        53.如果任何除了OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchWindowSSDQCOM, OpImageBlockMatchWindowSADQCOM, OpImageBlockMatchGatherSSDQCOM, OpImageBlockMatchGatherSADQCOM, OpImageBlockMatchSSDQCOM, 或者 OpImageBlockMatchSADQCOM之外的指令使用VkSampler进行采样作为该命令的结果，则该sampler不能以VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM 创建
		54.如果OpImageBlockMatchWindow*QCOM or OpImageBlockMatchGather*QCOM指令用来读取VkImageView作为该命令的结果，则（1）VkImageView的format features必须包含VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM
                                                                                                                      （2）VkImageView的format必须只含有一个component
        55.如果OpImageBlockMatchWindow*QCOM or OpImageBlockMatchGather*QCOM指令用来读取一个引用的image作为该命令的结果，则指定的 reference coordinates不能在integer texel coordinate validation 时候失败
        56.任何该命令执行的shader invocation必须已经终止
        57.如果有一个类型位为VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM, VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, 或者 VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT中任意一个的descriptor作为该命令的结果进行访问，则该descriptor所指的image subresource的layout必须和该descriptor被写入时的layout相同。
        58.当前的 render pass  必须和绑定到VK_PIPELINE_BIND_POINT_GRAPHICS上的VkPipeline 创建时候的VkGraphicsPipelineCreateInfo中指定的renderPass兼容
        59.当前的 render pass  的subpass index必须和绑定到VK_PIPELINE_BIND_POINT_GRAPHICS上的VkPipeline 创建时候的VkGraphicsPipelineCreateInfo中指定的subpass相同
		60.如果任何shader静态访问一个input attachment，则有效的descriptor必须通过VkDescriptorSet被绑定到该pipeline中
		61.如果任何该pipeline执行shader以SubpassData的Dim操作符访问一个OpTypeImage变量，则该变量必须被一个对应当前subpass的input attachment的InputAttachmentIndex修饰
		62.在subpass中访问的Input attachment views必须以和该subpass相同定义的VkFormat创建，且必须以一个和当前绑定的VkFramebuffer的该附件引用的subpass的pInputAttachments[InputAttachmentIndex]附件兼容的VkImageView创建，参见Fragment Input Attachment Compatibility p1408
        63.在动态render pass中访问以VkRenderingInputAttachmentIndexInfoKHR的InputAttachmentIndex，或者VkRenderingInputAttachmentIndexInfoKHR:pDepthInputAttachmentIndex 或者 VkRenderingInputAttachmentIndexInfoKHR:pStencilInputAttachmentIndex为NULL情况下不指定InputAttachmentIndex的引用的Input attachment views，必须以和VkRenderingInfo中对应color, depth, 或者 stencil attachment兼容的VkImageView创建
        64.如果VkRenderingInputAttachmentIndexInfoKHR::pDepthInputAttachmentIndex 以及 VkRenderingInputAttachmentIndexInfoKHR::pStencilInputAttachmentIndex不为NULL，则在动态render pass中通过shader object访问Input attachment views必须指明InputAttachmentIndex
        65.如果在动态render pass中通过shader object访问Input attachment views指明了InputAttachmentIndex，则InputAttachmentIndex必须匹配VkRenderingInputAttachmentIndexInfoKHR中的index
        66.当前render pass所用的附件对应的image subresource底层内存的写入只能作为该命令的一个附件写入
        67.如果一个color attachment在之前的该subpass的命令中以load, store, 或者 resolve operations进行了写入，则其layout不为VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT，且有当前绑定的pipeline设有VK_PIPELINE_CREATE_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT，或者
                                        最后的vkCmdSetAttachmentFeedbackLoopEnableEXT调用包含VK_IMAGE_ASPECT_COLOR_BIT以及 没有绑定的pipeline 或者绑定的pipeline以VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT创建，则该附件只能以附件进行访问的，这两种情况中之一
        68.如果一个depth attachment在之前的该subpass的命令中以load, store, 或者 resolve operations进行了写入，则其layout不为VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT，且有当前绑定的pipeline设有VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT，或者
                                        最后的vkCmdSetAttachmentFeedbackLoopEnableEXT调用包含VK_IMAGE_ASPECT_DEPTH_BIT以及 没有绑定的pipeline 或者绑定的pipeline以VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT创建，则该附件只能以附件进行访问的，这两种情况中之一
        69.如果一个stencil attachment在之前的该subpass的命令中以load, store, 或者 resolve operations进行了写入，则其layout不为VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT，且有当前绑定的pipeline设有VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT，或者
                                        最后的vkCmdSetAttachmentFeedbackLoopEnableEXT调用包含VK_IMAGE_ASPECT_STENCIL_BIT以及 没有绑定的pipeline 或者绑定的pipeline以VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT创建，则该附件只能以附件进行访问的，这两种情况中之一
        70.如果一个attachment在之前的该subpass的命令中以load, store, 或者 resolve operations进行了写入,则该附件就不能再以除作为一个附件，storage image或者sampled image被该命令访问
        71.如果在之前的命令的subpass中以用作附件外的方式访问访问了一个当权subpass的附件所对的image subresource，则该命令就不能再将该image subresource用作附件进行写入
        72.如果当前render pass使用一个depth/stencil attachment，则（1）如果depth aspect的layout为read-only的layout，则不能启用depth writes
                                                                  （2）如果stencil aspect的layout为read-only的layout，front 以及 back writeMask不为0，且stencil 测试开启，则所有stencil 操作必须为VK_STENCIL_OP_KEEP
        73.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_VIEWPORT动态state开启创建，则vkCmdSetViewport必须在该命令之前设置
                                        （2）以VK_DYNAMIC_STATE_SCISSOR动态state开启创建，则vkCmdSetScissor必须在该命令之前设置
                                        （3）以VK_DYNAMIC_STATE_LINE_WIDTH动态state开启创建，则vkCmdSetLineWidth必须在该命令之前设置
                                        （4）以VK_DYNAMIC_STATE_DEPTH_BIAS动态state开启创建，则vkCmdSetDepthBias或者vkCmdSetDepthBias2EXT 必须在该命令之前设置
                                        （5）以VK_DYNAMIC_STATE_BLEND_CONSTANTS动态state开启创建，则vkCmdSetBlendConstants 必须在该命令之前设置
                                        （6）以VK_DYNAMIC_STATE_DEPTH_BOUNDS动态state开启创建，且如果当前depthBoundsTestEnable为VK_TRUE， 则vkCmdSetDepthBounds 必须在该命令之前设置
                                        （7）以VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK动态state开启创建，且如果当前stencilTestEnable为VK_TRUE， 则vkCmdSetStencilCompareMask 必须在该命令之前设置
                                        （8）以VK_DYNAMIC_STATE_STENCIL_WRITE_MASK动态state开启创建，且如果当前stencilTestEnable为VK_TRUE， 则vkCmdSetStencilWriteMask 必须在该命令之前设置
                                        （9）以VK_DYNAMIC_STATE_STENCIL_REFERENCE动态state开启创建，且如果当前stencilTestEnable为VK_TRUE， 则vkCmdSetStencilReference 必须在该命令之前设置
                                        （10）以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT动态state开启创建， 则vkCmdSetSampleLocationsEXT 必须在该命令之前设置
                                        （11）以VK_DYNAMIC_STATE_CULL_MODE动态state开启创建， 则vkCmdSetCullMode 必须在该命令之前设置
                                        （12）以VK_DYNAMIC_STATE_FRONT_FACE动态state开启创建， 则vkCmdSetFrontFace 必须在该命令之前设置
                                        （13）以VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE动态state开启创建， 则vkCmdSetDepthTestEnable 必须在该命令之前设置
                                        （14）以VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE动态state开启创建， 则vkCmdSetDepthWriteEnable 必须在该命令之前设置
                                        （15）以VK_DYNAMIC_STATE_DEPTH_COMPARE_OP动态state开启创建， 则vkCmdSetDepthCompareOp 必须在该命令之前设置
                                        （16）以VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE动态state开启创建， 则vkCmdSetDepthBoundsTestEnable 必须在该命令之前设置
                                        （17）以VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE动态state开启创建， 则vkCmdSetStencilTestEnable 必须在该命令之前设置
                                        （18）以VK_DYNAMIC_STATE_STENCIL_OP动态state开启创建， 则vkCmdSetStencilOp 必须在该命令之前设置
                                        （19）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT但不以VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT 动态state开启创建， 则vkCmdSetViewportWithCount 必须在该命令之前设置，且vkCmdSetViewportWithCount设置的viewportCount必须匹配pipeline的VkPipelineViewportStateCreateInfo::scissorCount
                                        （20）以VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT但不以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT 动态state开启创建， 则vkCmdSetScissorWithCount 必须在该命令之前设置，且vkCmdSetScissorWithCount设置的scissorCount必须匹配pipeline的VkPipelineViewportStateCreateInfo::viewportCount
                                        （21）以VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT和VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT 动态state同时开启创建， 则vkCmdSetViewportWithCount以及vkCmdSetScissorWithCount 必须在该命令之前设置，且vkCmdSetViewportWithCount设置的viewportCount必须匹配vkCmdSetScissorWithCount设置的scissorCount
                                        （22）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT但不以VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV 动态state开启创建， 则绑定的pipeline必须以VkPipelineViewportWScalingStateCreateInfoNV::viewportCount 大于等于最近vkCmdSetViewportWithCount设置的viewportCount创建
                                        （23）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT和VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV 动态state开启创建， 则最近调用的vkCmdSetViewportWScalingNV设置的viewportCount 必须大于等于最近vkCmdSetViewportWithCount设置的viewportCount
                                        （24）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT但不以VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV 动态state开启创建， 则绑定的pipeline必须以VkPipelineViewportShadingRateImageStateCreateInfoNV::viewportCount 大于等于最近vkCmdSetViewportWithCount设置的viewportCount创建
                                        （25）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT和VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV 动态state开启创建， 则最近调用的vkCmdSetViewportShadingRatePaletteNV设置的viewportCount 必须大于等于最近vkCmdSetViewportWithCount设置的viewportCount
                                        （26）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT动态state开启且VkPipelineViewportStateCreateInfo的pNext中含有一个VkPipelineViewportSwizzleStateCreateInfoNV 创建， 则绑定的pipeline必须以VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount 大于等于最近vkCmdSetViewportWithCount设置的viewportCount创建
                                        （27）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT动态state开启且VkPipelineViewportStateCreateInfo的pNext中含有一个VkPipelineViewportExclusiveScissorStateCreateInfoNV 创建， 则绑定的pipeline必须以VkPipelineViewportExclusiveScissorStateCreateInfoNV::exclusiveScissorCount 大于等于最近vkCmdSetViewportWithCount设置的viewportCount创建
                                        （28）以VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_ENABLE_NV动态state开启创建， 则vkCmdSetExclusiveScissorEnableNV 必须在该命令之前设置
                                        （29）以VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV动态state开启创建， 则vkCmdSetExclusiveScissorNV 必须在该命令之前设置
                                        （30）以VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE动态state开启创建， 则vkCmdSetRasterizerDiscardEnable 必须在该命令之前设置
                                        （31）以VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE动态state开启创建， 则vkCmdSetDepthBiasEnable 必须在该命令之前设置
                                        （32）以VK_DYNAMIC_STATE_LOGIC_OP_EXT动态state开启创建， 则vkCmdSetLogicOpEXT 必须在该命令之前设置且参数logicOp必须是一个有效的VkLogicOp值
        74.如果一个shader object绑定到任何graphics stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                        （1）如果最靠近当前命令的vkCmdSetPolygonModeEXT设置polygonMode为VK_POLYGON_MODE_LINE或者是任何line topology，则vkCmdSetLineWidth必须在该命令之前设置
                                        （2）如果最靠近当前命令的vkCmdSetDepthBiasEnable设置depthBiasEnable为VK_TRUE，则vkCmdSetDepthBias 或者 vkCmdSetDepthBias2EXT必须在该命令之前设置
                                        （3）如果最靠近当前命令的vkCmdSetDepthBoundsTestEnable设置depthBoundsTestEnable为VK_TRUE，则vkCmdSetDepthBounds必须在该命令之前设置
                                        （4）如果最靠近当前命令的vkCmdSetStencilTestEnable设置stencilTestEnable为VK_TRUE，则vkCmdSetStencilCompareMask必须在该命令之前设置
                                        （5）如果最靠近当前命令的vkCmdSetStencilTestEnable设置stencilTestEnable为VK_TRUE，则vkCmdSetStencilWriteMask必须在该命令之前设置
                                        （6）如果最靠近当前命令的vkCmdSetStencilTestEnable设置stencilTestEnable为VK_TRUE，则vkCmdSetStencilReference必须在该命令之前设置
                                        （7）如果最靠近当前命令的vkCmdSetSampleLocationsEnableEXT设置sampleLocationsEnable为VK_TRUE，则vkCmdSetSampleLocationsEXT必须在该命令之前设置
                                        （8）则vkCmdSetCullMode必须在该命令之前设置
                                        （9）则vkCmdSetFrontFace必须在该命令之前设置
                                        （10）则vkCmdSetDepthTestEnable 必须在该命令之前设置
                                        （11）则vkCmdSetDepthWriteEnable 必须在该命令之前设置
                                        （12）如果最靠近当前命令的vkCmdSetDepthTestEnable设置depthTestEnable为VK_TRUE，则vkCmdSetDepthCompareOp 必须在该命令之前设置
                                        （13）则vkCmdSetDepthBoundsTestEnable 必须在该命令之前设置
                                        （14）则vkCmdSetStencilTestEnable 必须在该命令之前设置
                                        （15）如果最靠近当前命令的vkCmdSetStencilTestEnable设置stencilTestEnable为VK_TRUE，则vkCmdSetStencilOp 必须在该命令之前设置
                                        （16）
                                        （17）如果shadingRateImage特性开启，则vkCmdSetCoarseSampleOrderNV 必须在该命令之前设置
                                        （18）如果shadingRateImage特性开启，且最靠近当前命令的vkCmdSetShadingRateImageEnableNV设置shadingRateImageEnable为VK_TRUE，则vkCmdSetViewportShadingRatePaletteNV 必须在该命令之前设置
                                        （19）如果shadingRateImage特性开启，且最靠近当前命令的vkCmdSetShadingRateImageEnableNV设置shadingRateImageEnable为VK_TRUE，则最近的vkCmdSetViewportShadingRatePaletteNV设置的viewportCount 必须大于等于vkCmdSetViewportWithCount设置的viewportCount
                                        （20）则vkCmdSetDepthBiasEnable必须在该命令之前设置
        75.如果一个输出line primitives的shader object绑定到VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或者 VK_SHADER_STAGE_GEOMETRY_BIT，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则vkCmdSetLineWidth必须在该命令之前设置
        76.如果一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最靠近当前命令的vkCmdSetColorBlendEnableEXT设置pColorBlendEnables任何元素为VK_TRUE，且
                            最靠近当前命令的vkCmdSetColorBlendEquationEXT设置pColorBlendEquations相同元素的VkColorBlendEquationEXT的VkBlendFactor成员为VK_BLEND_FACTOR_CONSTANT_COLOR, VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR, VK_BLEND_FACTOR_CONSTANT_ALPHA, 或者 VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA，则vkCmdSetBlendConstants必须在该命令之前设置
        77.如果该命令记录在开启了multiview的render pass instance中，则最大的instance 索引必须小于等于VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex
        78.如果绑定的graphics pipeline以VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable设置为VK_TRUE创建且当前的subpass含有一个 depth/stencil attachment，则该attachment必须以VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT创建
        >>78.5  .如果一个shader object绑定到任何graphics stage，则（1）vkCmdSetViewportWithCount 和vkCmdSetScissorWithCount 必须同时在该命令之前设置，且vkCmdSetViewportWithCount设置的viewportCount必须匹配vkCmdSetScissorWithCount设置的scissorCount
                                                                  （2）则vkCmdSetRasterizerDiscardEnable 必须在该命令之前设置
        79.如果VK_NV_clip_space_w_scaling拓展开启，且shader object绑定到任何graphics stage，且最近的vkCmdSetViewportWScalingEnableNV设置viewportWScalingEnable为VK_TRUE，则（1）vkCmdSetViewportWScalingNV必须在该命令前设置
                                                                                                                                                                           （2）最近vkCmdSetViewportWScalingNV设置的viewportCount必须大于等于vkCmdSetViewportWithCount设置的viewportCount
        80.如果exclusiveScissor 特性开启，且shader object绑定到任何graphics stage，，则（1）vkCmdSetExclusiveScissorEnableNV必须在该命令前设置
                                                                                       （2）最近的vkCmdSetExclusiveScissorEnableNV调用设置的pExclusiveScissorEnables中的任何元素为VK_TRUE,则vkCmdSetExclusiveScissorNV必须在该命令前设置
        81.如果一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最靠近当前命令的vkCmdSetLogicOpEnableEXT设置logicOpEnable任何元素为VK_TRUE，则vkCmdSetLogicOpEXT 必须在该命令之前设置且参数logicOp必须是一个有效的VkLogicOp值
        82.如果primitiveFragmentShadingRateWithMultipleViewports限制不支持，则（1）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT动态state开启创建，且任何该pipeline的shader stage会写入PrimitiveShadingRateKHR built-in修饰的变量，则vkCmdSetViewportWithCount 必须在该命令之前设置且参数viewportCount必须是1
                                                                              （2）任何绑定的graphics pipeline的shader stage会写入PrimitiveShadingRateKHR built-in修饰的变量，则vkCmdSetViewportWithCount 必须在该命令之前设置且参数viewportCount必须是1
        83.如果graphics pipeline中未开启rasterization，则对subpass中的每个color attachment，如果其对应的image view 的format features不包含VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT，则pColorBlendState中其对应pAttachments中元素的blendEnable必须为VK_FALSE
        84.如果一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则对于render pass中的每个color attachment，如果其对应的image view 的format features不包含VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT， 则最近的vkCmdSetColorBlendEnableEXT设置的pColorBlendEnables中该附件的对应元素必须为VK_FALSE
        85.如果graphics pipeline中未开启rasterization，有VK_AMD_mixed_attachment_samples拓展未开启，VK_NV_framebuffer_mixed_samples拓展未开启，multisampledRenderToSingleSampled特性未开启，则当前绑定的pipeline的rasterizationSamples必须和当前subpass的color 以及/或者 depth/stencil attachments的相同
        86.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且有VK_AMD_mixed_attachment_samples拓展未开启，VK_NV_framebuffer_mixed_samples拓展未开启，multisampledRenderToSingleSampled特性未开启，则最近vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples必须和当前subpass的color 以及/或者 depth/stencil attachments的相同
        87.如果一个shader object绑定到任何graphics stage，则当前的render pass instance必须以vkCmdBeginRendering开始
        88.如果当前的render pass instance以vkCmdBeginRendering开始，（1）如果pDepthAttachment的imageView不为VK_NULL_HANDLE，且pDepthAttachment的layout不为VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL，则该命令不能写入任何值到depth attachment
                                                                    （2）如果pStencilAttachment的imageView不为VK_NULL_HANDLE，且pStencilAttachment的layout不为VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL，则该命令不能写入任何值到stencil attachment
                                                                    （3）如果pDepthAttachment的imageView不为VK_NULL_HANDLE，且pDepthAttachment的layout为VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL，则该命令不能写入任何值到depth attachment
                                                                    （4）如果pStencilAttachment的imageView不为VK_NULL_HANDLE，且pStencilAttachment的layout为VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL，则该命令不能写入任何值到stencil attachment
                                                                    （5）如果pDepthAttachment的imageView不为VK_NULL_HANDLE，且pDepthAttachment的layout为VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL，则该命令不能写入任何值到depth attachment
                                                                    （6）如果pStencilAttachment的imageView不为VK_NULL_HANDLE，且pStencilAttachment的layout为VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL，则该命令不能写入任何值到stencil attachment
                                                                    （7）则当前绑定的graphics pipeline必须以含VkPipelineRenderingCreateInfo::viewMask等于VkRenderingInfo::viewMask创建
                                                                    （8）如果带有VkRenderingInfo::colorAttachmentCount为1，则没有shader object绑定到任何graphics stage，且一个color attachment的 resolve mode为VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID，则VkRenderingInfo::pColorAttachments中每个resolveImageView不为VK_NULL_HANDLE的元素其对应image必须以和创建当前绑定的pipeline 相同的VkExternalFormatANDROID::externalFormat创建
                                                                    （9）如果没有shader object绑定到任何graphics stage，如果绑定的graphics pipeline以一个非零值VkExternalFormatANDROID::externalFormat创建且启用VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态设置，则vkCmdSetColorBlendEnableEXT必须在该命令前设置blend enable为VK_FALSE
                                                                    （10）如果没有shader object绑定到任何graphics stage，如果绑定的graphics pipeline以一个非零值VkExternalFormatANDROID::externalFormat创建且启用VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态设置，则vkCmdSetRasterizationSamplesEXT必须在该命令前设置rasterizationSamples为VK_SAMPLE_COUNT_1_BIT
                                                                    （11）如果没有shader object绑定到任何graphics stage，如果绑定的graphics pipeline以一个非零值VkExternalFormatANDROID::externalFormat创建且启用VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR动态设置，则vkCmdSetFragmentShadingRateKHR必须在该命令前设置pFragmentSize->width为1，pFragmentSize->height为1
        89.如果dynamicRenderingUnusedAttachments特性未开启，且当前的render pass instance以vkCmdBeginRendering开始，则
                                                                （1）当前绑定的graphics pipeline必须以含VkPipelineRenderingCreateInfo::colorAttachmentCount等于VkRenderingInfo::colorAttachmentCount创建
                                                                （2）如果VkRenderingInfo::colorAttachmentCount大于0，则VkRenderingInfo::pColorAttachments 中每一个其imageView不为VK_NULL_HANDLE的元素的VkImageView必须以VkFormat对应绑定的graphics pipeline的VkPipelineRenderingCreateInfo::pColorAttachmentFormats指明的format创建
                                                                （3）如果VkRenderingInfo::colorAttachmentCount大于0，则VkRenderingInfo::pColorAttachments 中每一个其imageView为VK_NULL_HANDLE的元素对应绑定的graphics pipeline的VkPipelineRenderingCreateInfo::pColorAttachmentFormats指明的format必须为VK_FORMAT_UNDEFINED
                                                                （4）如果VkRenderingInfo::pDepthAttachment->imageView为VK_NULL_HANDLE，则创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::depthAttachmentFormat必须为VK_FORMAT_UNDEFINED
                                                                （5）如果VkRenderingInfo::pDepthAttachment->imageView不为VK_NULL_HANDLE，则创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::depthAttachmentFormat必须和创建VkRenderingInfo::pDepthAttachment->imageView的VkFormat相同
                                                                （6）如果VkRenderingInfo::pStencilAttachment->imageView为VK_NULL_HANDLE，则创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::stencilAttachmentFormat必须为VK_FORMAT_UNDEFINED
                                                                （7）如果VkRenderingInfo::pStencilAttachment->imageView不为VK_NULL_HANDLE，则创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::stencilAttachmentFormat必须和创建VkRenderingInfo::pStencilAttachment->imageView的VkFormat相同
        90.如果dynamicRenderingUnusedAttachments特性开启，且当前的render pass instance以vkCmdBeginRendering开始，则
                                                                （1）如果VkRenderingInfo::colorAttachmentCount大于0，则VkRenderingInfo::pColorAttachments 中每一个其imageView不为VK_NULL_HANDLE的元素的VkImageView必须以VkFormat对应绑定的graphics pipeline的VkPipelineRenderingCreateInfo::pColorAttachmentFormats指明的format创建，或者是对应元素为VK_FORMAT_UNDEFINED创建
                                                                （2）如果VkRenderingInfo::pDepthAttachment->imageView不为VK_NULL_HANDLE，且创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::depthAttachmentFormat和创建VkRenderingInfo::pDepthAttachment->imageView的VkFormat不同，则该format必须为VK_FORMAT_UNDEFINED
                                                                （3）如果VkRenderingInfo::pStencilAttachment->imageView不为VK_NULL_HANDLE，且创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::stencilAttachmentFormat和创建VkRenderingInfo::pStencilAttachment->imageView的VkFormat不同，则该format必须为VK_FORMAT_UNDEFINED
        91.如果没有shader object绑定到任何graphics stage，且当前的render pass instance以vkCmdBeginRendering开始且VkRenderingInfo::colorAttachmentCount为1，且一个color attachment的 resolve mode为VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID，则VkRenderingInfo::pColorAttachments中每个resolveImageView不为VK_NULL_HANDLE的元素其对应image必须以和创建当前绑定的pipeline 相同的VkExternalFormatANDROID::externalFormat创建
        92.如果有一个shader object绑定到任何graphics stage，且当前的render pass 包含一个使用VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID resolve mode的color attachment，则（1）vkCmdSetColorBlendEnableEXT必须在该命令前设置blend enable为VK_FALSE
                                                                                                                                                                                 （2）则vkCmdSetRasterizationSamplesEXT必须在该命令前设置rasterizationSamples为VK_SAMPLE_COUNT_1_BIT
                                                                                                                                                                                 （3）则vkCmdSetFragmentShadingRateKHR必须在该命令前设置pFragmentSize->width为1，pFragmentSize->height为1
        93.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT动态state开启创建， 则vkCmdSetColorWriteEnableEXT 必须在该命令之前设置，且设置的attachmentCount必须大于等于创建当前绑定的pipeline的VkPipelineColorBlendStateCreateInfo::attachmentCount
                                        （2）以VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT动态state开启创建， 则vkCmdSetDiscardRectangleEXT 必须在该命令之前为每个VkPipelineDiscardRectangleStateCreateInfoEXT::discardRectangleCount指明的discard rectangle 设置
                                        （3）以VK_DYNAMIC_STATE_DISCARD_RECTANGLE_ENABLE_EXT动态state开启创建， 则vkCmdSetDiscardRectangleEnableEXT 必须在该命令之前设置
                                        （4）以VK_DYNAMIC_STATE_DISCARD_RECTANGLE_MODE_EXT动态state开启创建， 则vkCmdSetDiscardRectangleModeEXT 必须在该命令之前设置
        94.如果有一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                        （1）如果colorWriteEnable特性在device上开启，则vkCmdSetColorWriteEnableEXT 必须在该命令之前设置，且设置的attachmentCount必须大于等于当前render pass instance的color attachment的数量
                                        （2）如果VK_EXT_discard_rectangles拓展开启，且最近的vkCmdSetDiscardRectangleEnableEXT设置discardRectangleEnable为VK_TRUE， 则vkCmdSetDiscardRectangleEXT 必须在该命令之前设置
                                        （3）如果VK_EXT_discard_rectangles拓展开启， 则vkCmdSetDiscardRectangleEnableEXT 必须在该命令之前设置
                                        （4）如果VK_EXT_discard_rectangles拓展开启， 则最近的vkCmdSetDiscardRectangleEnableEXT设置discardRectangleEnable为VK_TRUE，则vkCmdSetDiscardRectangleModeEXT 必须在该命令之前设置
        95.如果当前的render pass instance以vkCmdBeginRendering开始，则（1）如果VkRenderingFragmentShadingRateAttachmentInfoKHR::imageView不为VK_NULL_HANDLE，则当前绑定的graphics pipeline必须以VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR创建
                                                                      （2）如果VkRenderingFragmentDensityMapAttachmentInfoEXT::imageView不为VK_NULL_HANDLE，则当前绑定的graphics pipeline必须以VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT创建
                                                                      （3）且含VkRenderingInfo::colorAttachmentCount大于0，如果当前的绑定的pipeline以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，则VkRenderingInfo::pColorAttachments中每个imageView不为VK_NULL_HANDLE的元素的imageView，必须以当前pipeline的VkAttachmentSampleCountInfoAMD 或者 VkAttachmentSampleCountInfoNV中的pColorAttachmentSamples中对应元素的sample count进行创建
                                                                      （4）如果当前的绑定的pipeline以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且VkRenderingInfo::pDepthAttachment中的imageView不为VK_NULL_HANDLE，则当前pipeline的VkAttachmentSampleCountInfoAMD 或者 VkAttachmentSampleCountInfoNV中的depthStencilAttachmentSamples必须等于创建VkRenderingInfo::pDepthAttachment->imageView的sample count
                                                                      （5）如果当前的绑定的pipeline以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且VkRenderingInfo::pStencilAttachment中的imageView不为VK_NULL_HANDLE，则当前pipeline的VkAttachmentSampleCountInfoAMD 或者 VkAttachmentSampleCountInfoNV中的depthStencilAttachmentSamples必须等于创建VkRenderingInfo::pStencilAttachment->imageView的sample count
                                                                      （6）且含VkRenderingInfo::colorAttachmentCount大于0，如果当前的绑定的pipeline不以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且multisampledRenderToSingleSampled特性没有开启，则VkRenderingInfo::pColorAttachments中每个imageView不为VK_NULL_HANDLE的元素的imageView，其创建的sample count必须等于当前绑定的graphics pipeline的rasterizationSamples
                                                                      （7）如果当前的绑定的pipeline不以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且VkRenderingInfo::pDepthAttachment中的imageView不为VK_NULL_HANDLE，且multisampledRenderToSingleSampled特性没有开启，则当前pipeline的rasterizationSamples 必须等于创建VkRenderingInfo::pDepthAttachment->imageView的sample count
                                                                      （8）如果当前的绑定的pipeline不以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且VkRenderingInfo::pStencilAttachment中的imageView不为VK_NULL_HANDLE，且multisampledRenderToSingleSampled特性没有开启，则当前pipeline的rasterizationSamples 必须等于创建VkRenderingInfo::pStencilAttachment->imageView的sample count
                                                                      （9）当前绑定的pipeline必须VkGraphicsPipelineCreateInfo::renderPass为VK_NULL_HANDLE创建
                                                                      （10）如果绑定的pipeline的fragment shader静态写入一个color attachment，且color write mask不为0，启用了color writes，且该附件对应的VkRenderingInfo::pColorAttachments->imageView 不为VK_NULL_HANDLE，则对应的创建pipeline的VkPipelineRenderingCreateInfo::pColorAttachmentFormats中的元素不能为VK_FORMAT_UNDEFINED
                                                                      （11）如果绑定的pipeline启用了depth test，启用了depth writes，且VkRenderingInfo::pDepthAttachment->imageView 不为VK_NULL_HANDLE，则创建pipeline的VkPipelineRenderingCreateInfo::depthAttachmentFormat不能为VK_FORMAT_UNDEFINED
                                                                      （12）如果绑定的pipeline启用了stencil test，且VkRenderingInfo::pStencilAttachment->imageView 不为VK_NULL_HANDLE，则创建pipeline的VkPipelineRenderingCreateInfo::stencilAttachmentFormat不能为VK_FORMAT_UNDEFINED
        96.如果该命令在以vkCmdBeginRendering开始的render pass instance中调用，且VkRenderingInfo的pNext中包含一个multisampledRenderToSingleSampledEnable设为VK_TRUE的VkMultisampledRenderToSingleSampledInfoEXT，则当前绑定的graphics pipeline的rasterizationSamples必须等于VkMultisampledRenderToSingleSampledInfoEXT::rasterizationSamples
        97.如果primitivesGeneratedQueryWithRasterizerDiscard特性未开启，且VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query激活，则不能启用rasterization discard
        98.如果primitivesGeneratedQueryWithNonZeroStreams特性未开启，且VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query激活，则 绑定的graphics pipeline不能以VkPipelineRasterizationStateStreamCreateInfoEXT::rasterizationStream为非零值创建
        98.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_TESSELLATION_DOMAIN_ORIGIN_EXT动态state开启创建，则vkCmdSetTessellationDomainOriginEXT必须在该命令之前设置
                                        （2）以VK_DYNAMIC_STATE_DEPTH_CLAMP_ENABLE_EXT动态state开启创建，则vkCmdSetDepthClampEnableEXT必须在该命令之前设置
                                        （3）以VK_DYNAMIC_STATE_POLYGON_MODE_EXT动态state开启创建，则vkCmdSetPolygonModeEXT必须在该命令之前设置
                                        （4）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，则vkCmdSetRasterizationSamplesEXT必须在该命令之前设置
                                        （5）以VK_DYNAMIC_STATE_SAMPLE_MASK_EXT动态state开启创建，则vkCmdSetSampleMaskEXT必须在该命令之前设置
                                        （6）以VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT动态state开启创建，则vkCmdSetAlphaToCoverageEnableEXT必须在该命令之前设置
                                        （7）以VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT动态state开启创建，则最近的vkCmdSetAlphaToCoverageEnableEXT设置alphaToCoverageEnable为VK_TRUE，则Fragment Output Interface中 Index 0的Location 0必须有一个含alpha Component的变量
                                        （8）以VK_DYNAMIC_STATE_ALPHA_TO_ONE_ENABLE_EXT动态state开启创建，则vkCmdSetAlphaToOneEnableEXT必须在该命令之前设置
                                        （9）以VK_DYNAMIC_STATE_LOGIC_OP_ENABLE_EXT动态state开启创建，则vkCmdSetLogicOpEnableEXT必须在该命令之前设置
                                        （10）以VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态state开启创建，则vkCmdSetColorBlendEnableEXT必须在该命令之前设置
                                        （11）以VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT动态state开启创建，则vkCmdSetColorBlendEquationEXT必须在该命令之前设置
                                        （12）以VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT动态state开启创建，则vkCmdSetColorWriteMaskEXT必须在该命令之前设置

        99.如果一个shader object绑定到VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT stage，则vkCmdSetTessellationDomainOriginEXT必须在该命令之前设置
        100.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                                        （1）如果depthClamp特性启用，则vkCmdSetDepthClampEnableEXT必须在该命令之前设置
                                                        （2）则vkCmdSetPolygonModeEXT必须在该命令之前设置
                                                        （3）则vkCmdSetRasterizationSamplesEXT必须在该命令之前设置
                                                        （4）则vkCmdSetSampleMaskEXT必须在该命令之前设置
                                                        （5）则vkCmdSetAlphaToCoverageEnableEXT必须在该命令之前设置
                                                        （6）如果alphaToOne特性启用，则vkCmdSetAlphaToOneEnableEXT必须在该命令之前设置

        101.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetAlphaToCoverageEnableEXT设置alphaToCoverageEnable为VK_TRUE，则Fragment Output Interface中 Index 0的Location 0必须有一个含alpha Component的变量
        102.如果一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                            （1）如果logicOp特性开启 ,vkCmdSetLogicOpEnableEXT必须在该命令之前设置
                                            （2）如果绑定了color attachments，则vkCmdSetColorBlendEnableEXT必须在该命令之前设置
                                            （3）如果最近的vkCmdSetColorBlendEnableEXT设置任何附件在pColorBlendEnables中的值为VK_TRUE ，则vkCmdSetColorBlendEquationEXT必须在该命令之前设置
                                            （4）如果绑定了color attachments，则vkCmdSetColorWriteMaskEXT必须在该命令之前设置

        103.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT动态state开启创建，则vkCmdSetRasterizationStreamEXT必须在该命令之前设置
                                         （2）以VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT动态state开启创建，则vkCmdSetConservativeRasterizationModeEXT必须在该命令之前设置
                                         （3）以VK_DYNAMIC_STATE_EXTRA_PRIMITIVE_OVERESTIMATION_SIZE_EXT动态state开启创建，则vkCmdSetExtraPrimitiveOverestimationSizeEXT必须在该命令之前设置
                                         （4）以VK_DYNAMIC_STATE_DEPTH_CLIP_ENABLE_EXT动态state开启创建，则vkCmdSetDepthClipEnableEXT必须在该命令之前设置
                                         （5）以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT动态state开启创建，则vkCmdSetSampleLocationsEnableEXT必须在该命令之前设置
                                         （6）以VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT动态state开启创建，则vkCmdSetColorBlendAdvancedEXT必须在该命令之前设置
                                         （7）以VK_DYNAMIC_STATE_PROVOKING_VERTEX_MODE_EXT动态state开启创建，则vkCmdSetProvokingVertexModeEXT必须在该命令之前设置
                                         （8）以VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT动态state开启创建，则vkCmdSetLineRasterizationModeEXT必须在该命令之前设置
                                         （9）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT动态state开启创建，则vkCmdSetLineStippleEnableEXT必须在该命令之前设置
                                         （10）以VK_DYNAMIC_STATE_LINE_STIPPLE_KHR动态state开启创建，则vkCmdSetLineStippleKHR必须在该命令之前设置
                                         （11）以VK_DYNAMIC_STATE_DEPTH_CLIP_NEGATIVE_ONE_TO_ONE_EXT动态state开启创建，则vkCmdSetDepthClipNegativeOneToOneEXT必须在该命令之前设置
                                         （12）以VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_ENABLE_NV动态state开启创建，则vkCmdSetViewportWScalingEnableNV必须在该命令之前设置
                                         （13）以VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV动态state开启创建，则vkCmdSetViewportSwizzleNV必须在该命令之前设置
                                         （14）以VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV动态state开启创建，则vkCmdSetCoverageToColorEnableNV必须在该命令之前设置
                                         （15）以VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_LOCATION_NV动态state开启创建，则vkCmdSetCoverageToColorLocationNV必须在该命令之前设置
                                         （16）以VK_DYNAMIC_STATE_COVERAGE_MODULATION_MODE_NV动态state开启创建，则vkCmdSetCoverageModulationModeNV必须在该命令之前设置
                                         （17）以VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV动态state开启创建，则vkCmdSetCoverageModulationTableEnableNV必须在该命令之前设置
                                         （18）以VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_NV动态state开启创建，则vkCmdSetCoverageModulationTableNV必须在该命令之前设置
                                         （19）以VK_DYNAMIC_STATE_SHADING_RATE_IMAGE_ENABLE_NV动态state开启创建，则vkCmdSetShadingRateImageEnableNV必须在该命令之前设置
                                         （20）以VK_DYNAMIC_STATE_REPRESENTATIVE_FRAGMENT_TEST_ENABLE_NV动态state开启创建，则vkCmdSetRepresentativeFragmentTestEnableNV必须在该命令之前设置
                                         （21）以VK_DYNAMIC_STATE_COVERAGE_REDUCTION_MODE_NV动态state开启创建，则vkCmdSetCoverageReductionModeNV必须在该命令之前设置

        104.如果一个shader object绑定到VK_SHADER_STAGE_GEOMETRY_BIT stage，且如果geometryStreams 特性开启，则vkCmdSetRasterizationStreamEXT必须在该命令之前设置
        105.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                （1）如果VK_EXT_conservative_rasterization 拓展开启，vkCmdSetConservativeRasterizationModeEXT必须在该命令之前设置
                                （2）如果VK_EXT_conservative_rasterization 拓展开启，且最近的vkCmdSetConservativeRasterizationModeEXT设置conservativeRasterizationMode为VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT，则vkCmdSetExtraPrimitiveOverestimationSizeEXT必须在该命令之前设置
                                （3）如果VK_EXT_sample_locations 拓展开启，则vkCmdSetSampleLocationsEnableEXT必须在该命令之前设置
        106.如果一个shader object绑定到任何graphics stage，且depthClipEnable 特性开启，则vkCmdSetDepthClipEnableEXT必须在该命令之前设置
        107.如果如果一个shader object绑定到任何VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且如果VK_EXT_blend_operation_advanced 拓展开启，则vkCmdSetColorBlendEquationEXT 和 vkCmdSetColorBlendAdvancedEXT中至少一个必须在该命令之前设置
        108.如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，如果VK_EXT_provoking_vertex拓展开启， 则vkCmdSetProvokingVertexModeEXT必须在该命令之前设置
        109.如果VK_KHR_line_rasterization 或者 VK_EXT_line_rasterization拓展开启，则（1）如果一个shader object绑定到任意一个graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetPolygonModeEXT设置polygonMode 为VK_POLYGON_MODE_LINE ，则vkCmdSetLineRasterizationModeEXT必须在该命令之前设置
                                                                                    （2）如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetPrimitiveTopology设置primitiveTopology 为任何line topology ，则vkCmdSetLineRasterizationModeEXT必须在该命令之前设置
                                                                                    （3）如果一个输出为line primitive的shader object绑定到VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或 VK_SHADER_STAGE_GEOMETRY_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则vkCmdSetLineRasterizationModeEXT必须在该命令之前设置
                                                                                    （4）如果一个shader object绑定到任意一个graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetPolygonModeEXT设置polygonMode 为VK_POLYGON_MODE_LINE ，则vkCmdSetLineStippleEnableEXT必须在该命令之前设置
                                                                                    （5）如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetPrimitiveTopology设置primitiveTopology 为任何line topology ，则vkCmdSetLineStippleEnableEXT必须在该命令之前设置
                                                                                    （6）如果一个输出为line primitive的shader object绑定到VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或 VK_SHADER_STAGE_GEOMETRY_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则vkCmdSetLineStippleEnableEXT必须在该命令之前设置
                                                                                    （7）如果一个shader object绑定到任意一个graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetLineStippleEnableEXT设置stippledLineEnable 为VK_TRUE ，则vkCmdSetLineStippleEXT必须在该命令之前设置
        110.如果一个shader object绑定到任何graphics stage，（1）如果depthClipControl 特性开启，则vkCmdSetDepthClipNegativeOneToOneEXT必须在该命令之前设置
                                                           （2）VK_NV_clip_space_w_scaling 拓展开启，则vkCmdSetViewportWScalingEnableNV必须在该命令之前设置
                                                           （3）VK_NV_viewport_swizzle 拓展开启，则vkCmdSetViewportSwizzleNV必须在该命令之前设置
        111.如果如果一个shader object绑定到任何VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                            （1）如果VK_NV_fragment_coverage_to_color 拓展开启，则vkCmdSetCoverageToColorEnableNV 必须在该命令之前设置
                            （2）如果VK_NV_fragment_coverage_to_color 拓展开启，且最近的vkCmdSetCoverageToColorEnableNV 设置coverageToColorEnable 为VK_TRUE，则vkCmdSetCoverageToColorLocationNV 必须在该命令之前设置
                            （3）如果pipelineFragmentShadingRate 特性开启，则vkCmdSetFragmentShadingRateKHR 必须在该命令之前设置
        112.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                    （1）如果VK_NV_framebuffer_mixed_samples 拓展开启，则vkCmdSetCoverageModulationModeNV 必须在该命令之前设置
                                    （2）如果VK_NV_framebuffer_mixed_samples 拓展开启，且最近的vkCmdSetCoverageModulationModeNV设置coverageModulationMode为任何除VK_COVERAGE_MODULATION_MODE_NONE_NV之外的值，则vkCmdSetCoverageModulationTableEnableNV 必须在该命令之前设置
                                    （3）如果VK_NV_framebuffer_mixed_samples 拓展开启，最近的vkCmdSetCoverageModulationTableEnableNV设置coverageModulationTableEnable为VK_TRUE，则vkCmdSetCoverageModulationTableNV 必须在该命令之前设置
                                    （4）如果shadingRateImage 特性开启，则vkCmdSetShadingRateImageEnableNV 必须在该命令之前设置
                                    （5）如果representativeFragmentTest 特性开启，则vkCmdSetRepresentativeFragmentTestEnableNV 必须在该命令之前设置
                                    （6）如果coverageReductionMode 特性开启，则vkCmdSetCoverageReductionModeNV 必须在该命令之前设置
        113.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态state开启创建，且最近的vkCmdSetColorBlendEnableEXT设置任何附件在pColorBlendEnables中的值为VK_TRUE 则subpas中这些附件对应的image view的format features中必须包含VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT
                                         （2）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，且当前subpass不使用任何color和/或者 depth/stencil attachments，则最后的vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples必须符合zero￾attachment subpass的规则
                                         （3）以VK_DYNAMIC_STATE_SAMPLE_MASK_EXT不以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT 动态state开启创建，则最后调用的vkCmdSetSampleMaskEXT中设置的samples参数必须大于等于创建该pipeline的VkPipelineMultisampleStateCreateInfo::rasterizationSamples
                                         （4）以VK_DYNAMIC_STATE_SAMPLE_MASK_EXT和 VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT 动态state开启创建，则最后调用的vkCmdSetSampleMaskEXT中设置的samples参数必须大于等于最后的vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples
                                         （5）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，且VK_AMD_mixed_attachment_samples和VK_NV_framebuffer_mixed_samples拓展都没有开启，则最后的vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples必须等于subpass中color和/或者 depth/stencil attachments使用的相同
                                         （6）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，或者一个shader object绑定到任意graphics stage，且当前的subpass包含一个multisampledRenderToSingleSampledEnable 为VK_TRUE的VkMultisampledRenderToSingleSampledInfoEXT，则最后的vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples必须等于该VkMultisampledRenderToSingleSampledInfoEXT中的对应成员
                                         （7）以VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态state开启创建，则vkCmdSetColorBlendEnableEXT 必须在该命令之前设置，且vkCmdSetColorBlendEnableEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定值
                                         （8）以VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT动态state开启创建，则vkCmdSetColorBlendEquationEXT 必须在该命令之前设置，且vkCmdSetColorBlendEquationEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定blend equations
                                         （9）以VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT动态state开启创建，则vkCmdSetColorWriteMaskEXT 必须在该命令之前设置，且vkCmdSetColorWriteMaskEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定color write mask
                                         （10）以VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT动态state开启创建，则vkCmdSetColorBlendAdvancedEXT 必须在该命令之前设置，且vkCmdSetColorBlendAdvancedEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活blend的color attachments指定advanced blend equations
                                         （11）以VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT和VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态state开启创建，且最后的vkCmdSetColorBlendEnableEXT和vkCmdSetColorBlendAdvancedEXT设置启用了advanced blending，则当前subpass中激活的color attachments的数量不能超过advancedBlendMaxColorAttachments
                                         （12）以VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT动态state开启创建，且如果primitivesGeneratedQueryWithNonZeroStreams特性未开启且VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query已经激活，则最后的vkCmdSetRasterizationStreamEXT必须设置rasterizationStream为0
                                         （13）以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT但不以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，则最后的vkCmdSetSampleLocationsEXT设置的pSampleLocationsInfo->sampleLocationsPerPixel必须等于创建pipeline的VkPipelineMultisampleStateCreateInfo::rasterizationSamples
                                         （14）以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT和VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，则最后的vkCmdSetSampleLocationsEXT设置的pSampleLocationsInfo->sampleLocationsPerPixel必须等于最后vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples
                                         （15）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT但不以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT动态state开启创建，且绑定的pipeline的VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable为VK_TRUE 或者以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT动态state开启，则sampleLocationsInfo.sampleLocationsPerPixel 必须等于最后vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples
                                         （16）以VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV动态state开启创建，且最后的vkCmdSetCoverageToColorEnableNV设置coverageToColorEnable为VK_TRUE，则当前subpass必须有color attachment，且该attachment的format必须为VK_FORMAT_R8_UINT, VK_FORMAT_R8_SINT, VK_FORMAT_R16_UINT, VK_FORMAT_R16_SINT, VK_FORMAT_R32_UINT, 或者 VK_FORMAT_R32_SINT，且该attachment的location 有最后的vkCmdSetCoverageToColorLocationNV设置的coverageToColorLocation决定
                                         （17）以VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV和VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT 动态state开启创建，且如果VK_NV_coverage_reduction_mode 拓展开启，则当前的 coverageReductionMode，rasterizationSamples 以及color 以及 depth/stencil attachments（如果subpass有）的sample count必须是有效的返回值vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV的值的组合
                                         （18）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT但不以VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV 动态state开启创建，则绑定的graphics pipeline的VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount 必须大于等于最后vkCmdSetViewportWithCount设置的viewportCount
                                         （19）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT和VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV 动态state开启创建，则最后vkCmdSetViewportSwizzleNV设置的viewportCount 必须大于等于最后vkCmdSetViewportWithCount设置的viewportCount
                                         （20）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT或者 VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT 动态state开启创建，如果当前的stippledLineEnable为VK_TRUE，且当前的lineRasterizationMode为VK_LINE_RASTERIZATION_MODE_RECTANGULAR_KHR，则stippledRectangularLines 特性必须开启
                                         （21）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT或者 VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT 动态state开启创建，如果当前的stippledLineEnable为VK_TRUE，且当前的lineRasterizationMode为VK_LINE_RASTERIZATION_MODE_BRESENHAM_KHR，则stippledBresenhamLines 特性必须开启
                                         （22）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT或者 VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT 动态state开启创建，如果当前的stippledLineEnable为VK_TRUE，且当前的lineRasterizationMode为VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_KHR，则stippledSmoothLines 特性必须开启
                                         （23）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT或者 VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT 动态state开启创建，如果当前的stippledLineEnable为VK_TRUE，且当前的lineRasterizationMode为VK_LINE_RASTERIZATION_MODE_DEFAULT_KHR，则stippledRectangularLines 特性必须开启且VkPhysicalDeviceLimits::strictLines 必须为VK_TRUE
                                         （24）以VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT 动态state开启创建，且conservativePointAndLineRasterization不支持，最后的 pre-rasterization shader stage输出的有效图元拓扑为点或者线，则最后vkCmdSetConservativeRasterizationModeEXT设置的conservativeRasterizationMode 必须为VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT
                                         （25）以VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT 动态state开启创建，则vkCmdSetAttachmentFeedbackLoopEnableEXT 必须在该命令之前调用
        114.如果一个shader object绑定到 VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                                                                            （1）则vkCmdSetColorBlendEnableEXT 必须在该命令之前设置，且vkCmdSetColorBlendEnableEXT指定的firstAttachment开始的attachmentCount的值必须为当前subpass所有激活的color attachments指定
                                                                                            （2）则vkCmdSetColorBlendEquationEXT 必须在该命令之前设置，且vkCmdSetColorBlendEquationEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定blend equations
                                                                                            （3）则vkCmdSetColorWriteMaskEXT 必须在该命令之前设置，且vkCmdSetColorWriteMaskEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定color write mask
                                                                                            （4）如果VK_NV_fragment_coverage_to_color拓展开启， 最后的vkCmdSetCoverageToColorEnableNV设置coverageToColorEnable为VK_TRUE，则当前subpass必须有color attachment，且该attachment的format必须为VK_FORMAT_R8_UINT, VK_FORMAT_R8_SINT, VK_FORMAT_R16_UINT, VK_FORMAT_R16_SINT, VK_FORMAT_R32_UINT, 或者 VK_FORMAT_R32_SINT，且该attachment的location 有最后的vkCmdSetCoverageToColorLocationNV设置的coverageToColorLocation决定
        115.如果一个shader object绑定到 VK_SHADER_STAGE_FRAGMENT_BIT stage，（1）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT动态state开启创建，且最近的vkCmdSetSampleLocationsEnableEXT设置sampleLocationsEnable为VK_TRUE，且该subpass含有depth/stencil attachment，则该附件必须以VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT创建
                                                                            （2）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT和VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT 动态state开启创建，且最近的vkCmdSetSampleLocationsEnableEXT设置sampleLocationsEnable为VK_TRUE，则 最后vkCmdSetSampleLocationsEXT设置的sampleLocationsInfo.sampleLocationGridSize.width以及height 必须等于被调用vkGetPhysicalDeviceMultisamplePropertiesEXT传入rasterizationSamples返回的VkMultisamplePropertiesEXT::sampleLocationGridSize.width以及height一一对应均匀整除
                                                                            （3）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT 动态state开启创建，且最近的vkCmdSetSampleLocationsEnableEXT设置sampleLocationsEnable为VK_TRUE，则fragment shader代码中不能静态使用扩展指令InterpolateAtSample
                                                                            （4）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT但不以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT 动态state开启创建，且绑定的pipeline的VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable为VK_TRUE 或者以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT动态state开启，则 最后vkCmdSetRasterizationSamplesEXT设置的sampleLocationsInfo.sampleLocationGridSize.width以及height 必须等于被调用vkGetPhysicalDeviceMultisamplePropertiesEXT传入和vkCmdSetRasterizationSamplesEXT设置的相同rasterizationSamples的samples返回的VkMultisamplePropertiesEXT::sampleLocationGridSize.width以及height一一对应均匀整除
        116.如果一个shader object绑定到任何graphics stage，（1）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV 动态state开启创建，且最近的vkCmdSetCoverageModulationTableEnableNV设置coverageModulationTableEnable为VK_TRUE，则最近的vkCmdSetCoverageModulationTableNV 设置的coverageModulationTableCount 必须等于当前rasterizationSamples除以当前subppas的color samples
                                                           （2）如果VK_NV_viewport_swizzle 拓展开启，则最后vkCmdSetViewportSwizzleNV设置的viewportCount 必须大于等于最后vkCmdSetViewportWithCount设置的viewportCount
        117.如果VK_NV_framebuffer_mixed_samples 拓展开启，且如果在绑定的graphics pipeline中当前subpass有一个depth/stencil attachment以及dep test, stencil test, 或depth bounds test 启用，则当前rasterizationSamples 必须等于depth/stencil attachment的sample count
        118.如果VK_NV_framebuffer_mixed_samples 拓展开启，且如果最后的vkCmdSetRasterizationSamplesEXT设置的当前subpass的任何color attachments的rasterizationSamples 都大于 color samples，则sampleShadingEnable 必须为VK_FALSE
        119.如果当前绑定的graphics pipeline以VkGraphicsPipelineCreateInfo::pStages中的元素的VkPipelineShaderStageCreateInfo::stage设置为VK_SHADER_STAGE_VERTEX_BIT, VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT, VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或者 VK_SHADER_STAGE_GEOMETRY_BIT创建，则Mesh Shader Queries 不能激活
        120.如果dynamic state继承自VkCommandBufferInheritanceViewportScissorInfoNV，则这些动态state的设置必须在该命令之前设置
        121.如果没有绑定graphics pipeline，则（1）vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_VERTEX_BIT
                                             （2）如果tessellationShader 特性开启，vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT，VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT
                                             （3）如果geometryShader 特性开启，vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_GEOMETRY_BIT
                                             （4）vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_FRAGMENT_BIT
                                             （5）如果taskShader 特性开启，vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_TASK_BIT_EXT
                                             （6）如果meshShader 特性开启，vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_MESH_BIT_EXT
                                             （8）如果至少taskShader 和 meshShader一个特性开启，VK_SHADER_STAGE_VERTEX_BIT 或者VK_SHADER_STAGE_MESH_BIT_EXT stages中的一个必须含有有效的VkShaderEXT绑定，另外一个则不含有VkShaderEXT绑定
                                             （9）如果taskShader 和 meshShader特性同时开启，且一个有效的VkShaderEXT 绑定到VK_SHADER_STAGE_MESH_BIT_EXT stage，且该VkShaderEXT不以VK_SHADER_CREATE_NO_TASK_SHADER_BIT_EXT 创建，则一个有效的VkShaderEXT必须绑定到VK_SHADER_STAGE_TASK_BIT_EXT stage
                                             （10）如果taskShader 和 meshShader特性同时开启，且一个有效的VkShaderEXT 绑定到VK_SHADER_STAGE_MESH_BIT_EXT stage，且该VkShaderEXT以VK_SHADER_CREATE_NO_TASK_SHADER_BIT_EXT 创建，则不能有VkShaderEXT绑定到VK_SHADER_STAGE_TASK_BIT_EXT stage
                                             （11）如果一个有效的VkShaderEXT 绑定到VK_SHADER_STAGE_VERTEX_BIT stage，则不能有VkShaderEXT绑定到VK_SHADER_STAGE_TASK_BIT_EXT stage或者VK_SHADER_STAGE_MESH_BIT_EXT stage中的一个
        122.如果任何绑定的graphics shader以VK_SHADER_CREATE_LINK_STAGE_BIT_EXT 创建，（1）所有在相同vkCreateShadersEXT中以VK_SHADER_CREATE_LINK_STAGE_BIT_EXT创建的shaders必须也要绑定
                                                                                     （2）任何相同vkCreateShadersEXT中不以VK_SHADER_CREATE_LINK_STAGE_BIT_EXT创建的shaders不能有任何VkShaderEXT绑定
        123.所有绑定的graphics shader objects 必须以相同或者相同定义的push constant ranges创建
        124.所有绑定的graphics shader objects 必须以相同或者相同定义的descriptor set layouts的数组创建
        125.如果当前的render pass instance以vkCmdBeginRendering开始，且VkRenderingInfo::colorAttachmentCount为1，且有一个resolve mode为 VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID 的color attachment，且绑定了fragment shader，则DepthReplacing 和 StencilRefReplacingEXT execution modes 不能声明
        126.如果一个shader object绑定到 VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则 （1）如果attachmentFeedbackLoopDynamicState 特性开启，则 vkCmdSetAttachmentFeedbackLoopEnableEXT 必须在该命令之前调用
        127.如果包含一个fragment shader stage的绑定的graphics pipeline，（1）且该pipeline以VkPipelineDynamicStateCreateInfo::pDynamicStates中设置有VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE创建，且该fragment shader声明了EarlyFragmentTests execution mode且使用了OpDepthAttachmentReadEXT，则最后vkCmdSetDepthWriteEnable 设置的 depthWriteEnable 必须为VK_FALSE
                                                                        （2）且该pipeline以VkPipelineDynamicStateCreateInfo::pDynamicStates中设置有VK_DYNAMIC_STATE_STENCIL_WRITE_MASK创建，且该fragment shader声明了EarlyFragmentTests execution mode且使用了OpStencilAttachmentReadEXT，则最后vkCmdSetStencilWriteMask 设置的 writeMask 必须为0
        128.如果一个shader object绑定到任何graphics stage 或者绑定的graphics pipeline 以VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT 动态state开启创建，且任何color attachment的format为VK_FORMAT_E5B9G9R9_UFLOAT_PACK32，则vkCmdSetColorWriteMaskEXT设置的pColorWriteMasks参数的对应元素必须包含VK_COLOR_COMPONENT_R_BIT, VK_COLOR_COMPONENT_G_BIT, 和 VK_COLOR_COMPONENT_B_BIT，或者都不包含
        129.如果任何附件开启了blending，且该附件的source 或者 destination blend factors使用第二个颜色输入，则该命令执行的Fragment Execution Model静态使用的任何输出output attachment的Location的最大值必须小于maxFragmentDualSrcAttachments
        130.如果当前的render pass instance以vkCmdBeginRendering开始，（1）如果没有任何shader object绑定到任何graphics stage，则vkCmdSetRenderingAttachmentLocationsKHR 设置的VkRenderingAttachmentLocationInfoKHR::pColorAttachmentLocations中的每个元素必须匹配设置在当前绑定的graphics pipeline中的对应元素
                                                                     （2）如果没有任何shader object绑定到任何graphics stage，绑定的graphics pipeline中的input attchment 索引中映射的附件必须匹配在当前render pass instance的VkRenderingInputAttachmentIndexInfoKHR中设置的
        131.如果当前的render pass instance以vkCmdBeginRendering开始且以VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT标志开始，则绑定的graphics pipeline必须以VK_PIPELINE_CREATE_2_ENABLE_LEGACY_DITHERING_BIT_EXT创建
        132.如果绑定的graphics pipeline以VK_PIPELINE_CREATE_2_ENABLE_LEGACY_DITHERING_BIT_EXT创建，则当前的render pass 必须以vkCmdBeginRendering开始且以VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT标志开始
        133.如果commandBuffer是protected command buffer且protectedNoFault不支持，（1）则任何绑定到pipeline bind point的VkPipeline写入的resource资源不能是unprotected resource
                                                                                 （2）则任何绑定到pipeline bind point的VkPipeline的除了framebuffer-space 以及 compute stages之外的pipeline stage不能写入任何resource
        134.如果该命令使用的任何绑定到pipeline bind point的VkPipeline的shader stages使用RayQueryKHR capability，则commandBuffer不能是一个protected command buffer
        135.所有在vertex shader entry point 的 interface通过声明的vertex input variables访问的vertex input bindings必须是有效的buffer绑定或者为VK_NULL_HANDLE绑定
        136.如果nullDescriptor 特性未开启，则所有在vertex shader entry point 的 interface通过声明的vertex input variables访问的vertex input bindings不能为VK_NULL_HANDLE绑定
        137.如果robustBufferAccess 特性未开启，且pipeline的创建不对vertexInputs以VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT开启创建，则对于指定的vertex buffer binding，任何获取的顶点属性数据必须包含在对应的vertex buffer binding中，参见Vertex Input Description p2586
        138.如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage或者绑定的graphics pipeline以VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY动态state开启创建，则vkCmdSetPrimitiveTopology必须在该命令前设置
        140.如果绑定的graphics pipeline以VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY动态state开启创建，且dynamicPrimitiveTopologyUnrestricted为VK_FALSE，则vkCmdSetPrimitiveTopology设置的primitiveTopology 必须和pipeline创建的VkPipelineInputAssemblyStateCreateInfo::topology相同
        141.如果绑定的graphics pipeline以VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT但不以VK_DYNAMIC_STATE_VERTEX_INPUT_EXT 动态state开启创建，则vkCmdBindVertexBuffers2EXT必须在该命令前设置，且pStrides参数不能为NULL
        142.如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage或者绑定的graphics pipeline以VK_DYNAMIC_STATE_VERTEX_INPUT_EXT动态state开启创建，则
                                            （1）vkCmdSetVertexInputEXT必须在该命令前设置
                                            （2）所有以Input storage class修饰的Vertex Execution Model OpEntryPoint中的变量其Location必须包含在VkVertexInputAttributeDescription2EXT::location指定的location中
                                            （3）如果满足legacyVertexAttributes未开启或者Vertex Execution Model OpEntryPoint中给定对应Location的Input variable的 SPIR-V Type为64-bit的中的一个，则Vertex Execution Model OpEntryPoint中对应Location的所有Input variable的numeric type必须和VkVertexInputAttributeDescription2EXT::format的相同
                                            （4）如果VkVertexInputAttributeDescription2EXT::format含有64-bit 分量，Vertex Execution Model OpEntryPoint中对应Location的所有Input variable的scalar width必须是64-bit的
                                            （5）如果Vertex Execution Model OpEntryPoint中对应Location的Input variable的scalar width是64-bit的，则对应VkVertexInputAttributeDescription2EXT::format必须含有64-bit 分量
                                            （6）如果VkVertexInputAttributeDescription2EXT::format含有64-bit 分量，则Vertex Execution Model OpEntryPoint中对应Location的所有Input variable不能使用该format未呈现的分量
        143.如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage且最近的vkCmdSetPrimitiveTopology设置primitiveTopology为VK_PRIMITIVE_TOPOLOGY_PATCH_LIST，或者绑定的graphics pipeline以VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT动态state开启创建，则vkCmdSetPatchControlPointsEXT必须在该命令前设置
        144.如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage或者绑定的graphics pipeline以VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE动态state开启创建，则vkCmdSetPrimitiveRestartEnable必须在该命令前设置
        145.如果primitiveTopologyListRestart特性未开启，且topology 为VK_PRIMITIVE_TOPOLOGY_POINT_LIST, VK_PRIMITIVE_TOPOLOGY_LINE_LIST, VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST, VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY, 或者 VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY，
                    且有一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage或者绑定的graphics pipeline以VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE动态state开启创建，则vkCmdSetPrimitiveRestartEnable必须设置为VK_FALSE
        146.绑定的graphics pipeline不能以VkGraphicsPipelineCreateInfo::pStages中元素的VkPipelineShaderStageCreateInfo::stage设置为VK_SHADER_STAGE_TASK_BIT_EXT 或者 VK_SHADER_STAGE_MESH_BIT_EXT创建
        147.不能有shader object绑定到VK_SHADER_STAGE_TASK_BIT_EXT或者 VK_SHADER_STAGE_MESH_BIT_EXT中的一个stage
        148.如果绑定的graphics pipeline 以VkGraphicsPipelineCreateInfo::pVertexInputState->pNext中包含一个VkPipelineVertexInputDivisorStateCreateInfoKHR创建，且VkPipelineVertexInputDivisorStateCreateInfoKHR::pVertexBindingDivisors任何元素为除数为1外的值，且VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR::supportsNonZeroFirstInstance 为VK_FALSE，则firstInstance必须为0
        149.如果shader objects用于绘制或者绑定的graphics pipeline以VK_DYNAMIC_STATE_VERTEX_INPUT_EXT动态state开启创建，且vkCmdSetVertexInputEXT设置的pVertexBindingDescriptions中设置该动态state的任何元素有为除数为1外的值，且VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR::supportsNonZeroFirstInstance 为VK_FALSE，则firstInstance必须为0
        150.multiDraw 特性必须开启
        151.drawCount必须小于 VkPhysicalDeviceMultiDrawPropertiesEXT::maxMultiDrawCount
        152.如果drawCount大于0，则pVertexInfo必须为有效的包含一个或多个VkMultiDrawInfoEXT的数组指针
        153.如果drawCount大于1，则stride必须为4的倍数，且必须大于或者等于sizeof(VkMultiDrawInfoEXT)


        */



        VkMultiDrawIndexedInfoEXT multiDrawIndexedInfoEXT{};//该结构体中的 firstIndex, indexCount, 以及 vertexOffset等价于VkDrawIndexedIndirectCommand结构体中的firstIndex, indexCount, 以及 vertexOffset。
		multiDrawIndexedInfoEXT.firstIndex = 0;//要绘制的第一个顶点索引
		multiDrawIndexedInfoEXT.indexCount = 6;//要绘制的顶点索引数量
		multiDrawIndexedInfoEXT.vertexOffset = 0;//是多重绘制中在索引到顶点缓冲区之前添加到顶点索引的偏移值。
        int32_t vertexOffset = 0;
		//记录一组state不会变化的顺序索引绘制命令   记录drawCount个绘制，每次绘制从VkMultiDrawIndexedInfoEXT的firstIndex开始绘制indexCount个顶点，图元组装依据vkCmdDrawIndexed的规则，每次绘制instanceCount个实例
		vkCmdDrawMultiIndexedEXT(commandBuffer, 1/*drawCount,要绘制的VkMultiDrawIndexedInfoEXT的数量，可以为0.*/, &multiDrawIndexedInfoEXT/*pIndexInfo，一组VkMultiDrawIndexedInfoEXT数组指针，指明绘制的顶点索引信息*/, 
            1/*instanceCount，每次绘制要绘制的instances的数量.*/, 0/*firstInstance，每次绘制的第一个instance的ID*/,
            sizeof(VkMultiDrawIndexedInfoEXT)/*stride，为pIndexInfo中连续元素之间的字节步长.*/, &vertexOffset/*pVertexOffset，为NULL 或者是添加到计算索引到顶点缓冲区的索引之前的值的数组指针，如果指定，则在pIndexInfo中的VkMultiDrawIndexedInfoEXT::offset会被忽略*/);
        /*
        
         vkCmdDrawMultiIndexedEXT有效用法:
        1.如果一个VkSampler以其magFilter或者minFilter等于VK_FILTER_LINEAR创建，则（1）如果reductionMode为VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE，如果用于采样一个VkImageView作为该命令的结果的compareEnable为VK_FALSE，则该image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT
                                                                                 （2）如果reductionMode为VK_SAMPLER_REDUCTION_MODE_MIN 或者VK_SAMPLER_REDUCTION_MODE_MAX之一 用于采样一个VkImageView作为该命令的结果，则该image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT
        2.如果一个VkSampler以其mipmapMode 等于VK_SAMPLER_MIPMAP_MODE_LINEAR创建，则（1）如果reductionMode为VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE，如果用于采样一个VkImageView作为该命令的结果的compareEnable为VK_FALSE，则该image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT
                                                                                 （2）如果reductionMode为VK_SAMPLER_REDUCTION_MODE_MIN 或者VK_SAMPLER_REDUCTION_MODE_MAX之一 用于采样一个VkImageView作为该命令的结果，则该image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT
        3.如果一个VkSampler以其unnormalizedCoordinates等于VK_TRUE用于采样一个VkImageView作为该命令的结果创建，则（1）该image view的levelCount以及layerCount必须为1
                                                                                                                （2）该image view的viewType必须为VK_IMAGE_VIEW_TYPE_1D 或者 VK_IMAGE_VIEW_TYPE_2D
        4.如果一个VkImageView的采样带depth comparison操作，则image view的format features必须包含VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT
        5.如果一个VkImageView使用atomic operations作为该命令的结果进行访问，则image view的format features必须包含VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT
        6.如果一个VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER类型的 descriptor使用atomic operations作为该命令的结果进行访问，则storage texel buffer的format features必须包含VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT
        7.如果一个以VK_FILTER_CUBIC_EXT进行采样的VkImageView作为该命令的结果，则image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT
        8.如果VK_EXT_filter_cubic拓展没有开启，且有任何一个以VK_FILTER_CUBIC_EXT进行采样的VkImageView作为该命令的结果，则其VkImageViewType不能为VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, 或者 VK_IMAGE_VIEW_TYPE_CUBE_ARRAY
        9.任何一个以VK_FILTER_CUBIC_EXT进行采样的作为该命令的结果的VkImageView，其VkImageViewType和format 必须支持cubic filtering，参见vkGetPhysicalDeviceImageFormatProperties2返回的VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic
        10.任何一个以VK_FILTER_CUBIC_EXT进行采样且reduction mode为VK_SAMPLER_REDUCTION_MODE_MIN 或者 VK_SAMPLER_REDUCTION_MODE_MAX之一的作为该命令的结果的VkImageView，其VkImageViewType和format 必须支持带minmax filtering的cubic filtering，参见vkGetPhysicalDeviceImageFormatProperties2返回的VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax
        11.如果cubicRangeClamp特性没有开启，则有任何一个以VK_FILTER_CUBIC_EXT进行采样VkImageView的作为该命令的结果，VkSamplerReductionModeCreateInfo::reductionMode不能为VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM
        12.任何一个以VkSamplerReductionModeCreateInfo::reductionMode为VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM进行采样的作为该命令的结果的VkImageView必须以VK_FILTER_CUBIC_EXT进行采样
        13.如果selectableCubicWeights特性没有开启，则有任何一个以VK_FILTER_CUBIC_EXT进行采样VkImageView的作为该命令的结果，VkSamplerCubicWeightsCreateInfoQCOM::cubicWeights必须为VK_CUBIC_FILTER_WEIGHTS_CATMULL_ROM_QCOM
        14.任何一个以VkImageCreateInfo::flags含VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV创建的采样作为该命令结果的VkImage必须以VkSamplerAddressMode为VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE 进行采样
        15.对于任何作为storage image写入的VkImageView，且其OpTypeImage的format未知，则该image view的 format features必须包含VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT
        16.对于任何作为storage image读取的VkImageView，且其OpTypeImage的format未知，则该image view的 format features必须包含VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT
        17.对于任何作为storage storage texel buffer写入的VkBufferView，且其OpTypeImage的format未知，则该buffer view的 buffer features必须包含VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT
        18.对于任何作为storage storage texel buffer读取的VkBufferView，且其OpTypeImage的format未知，则该buffer view的 buffer features必须包含VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT
        19.对于每个在绑定的shader中静态使用的set n，一个descriptor set必须被绑定到相同pipeline bind point的set n处，该set n必须和创建当前VkPipeline的VkPipelineLayout或者和创建当前VkShaderEXT的VkDescriptorSetLayout 数组的set n处的布局兼容，参见Pipeline Layout Compatibility p1280
        20.对于每个在绑定的shader中静态使用的push constant，一个push constant值必须被绑定到相同pipeline bind point的对应处，该push constant必须和创建当前VkPipeline的VkPipelineLayout或者和创建当前VkShaderEXT的VkDescriptorSetLayout 数组中的对应处的布局兼容，参见Pipeline Layout Compatibility p1280
        21.如果maintenance4特性没有开启，则对于每个在绑定的shader中静态使用的push constant，一个push constant值必须被设置到相同pipeline bind point的对应处，该push constant必须和创建当前VkPipeline的VkPipelineLayout或者和创建当前VkShaderEXT的VkDescriptorSetLayout 数组中的对应处的布局兼容，参见Pipeline Layout Compatibility p1280
        22.每一个通过vkCmdBindDescriptorSets绑定的descriptor set的descriptors,如果是被不以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建的，且已经绑定到该命令使用的pipeline bind point的VkPipeline静态使用的，则这些descriptors必须是有效的，参见 descriptor validity p1328
        23.如果通过vkCmdBindDescriptorSets指定绑定到pipeline bind point的VkPipeline要使用的descriptors，则绑定的VkPipeline不能以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建
        24.在vkCmdSetDescriptorBufferOffsetsEXT中指定绑定的descriptor buffers的descriptors，则（1）如果绑定到pipeline bind point的该命令会使用的VkPipeline以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建，且这些descriptors是动态使用的，则这些descriptors必须是有效的
                                                                                              （2）如果绑定到pipeline bind point的对应stage的该命令会使用的VkShaderEXT，且这些descriptors是动态使用的，则这些descriptors必须是有效的
        25.在vkCmdSetDescriptorBufferOffsetsEXT中指定的descriptors在绑定到pipeline bind point的VkPipeline中使用，则VkPipeline必须以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建
        26.如果一个descriptor在以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建的VkPipeline中动态使用，则descriptor memory必须是驻留内存
        27.如果一个descriptor在以其VkDescriptorSetLayout以VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建的VkShaderEXT中动态使用，则descriptor memory必须是驻留内存
        28.如果shaderObject 特性没有开启，一个有效的pipeline必须绑定到这个命令使用的绑定到pipeline bind point上
        29.如果一个pipeline绑定到该命令使用的pipeline bind point上，则不能有任何动态state 设置命令设置任何该VkPipeline 中没有指定的动态 state
        30.如果一个VkPipeline绑定到该命令使用的pipeline bind point上 或者任何一个会访问一个使用unnormalized coordinates的VkSampler的 VkShaderEXT绑定到该命令使用的pipeline bind point上的pipeline的对应stage，则
                                                                                    （1）在任何shader stage中，VkSampler不能用来采样任何类型为VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY 或者 VK_IMAGE_VIEW_TYPE_CUBE_ARRAY的VkImageView
                                                                                    （2）在任何shader stage中，该VkSampler不能和任何带有名字中带有ImplicitLod，Dref 或者 Proj 的SPIR-V OpImageSample* 或者 OpImageSparseSample*指令一起使用
                                                                                    （3）在任何shader stage中，该VkSampler不能和任何包含 LOD bias或者offset 值 的SPIR-V OpImageSample* or OpImageSparseSample*指令一起使用
        31.如果shaderObject开启，一个有效的pipeline必须绑定到该命令使用的pipeline bind point上或者一个有效的shader objects以及VK_NULL_HANDLE的组合必须绑定到该命令使用的pipeline bind point每一个支持的shader stage上
        32.如何绑定到该命令使用的pipeline bind point上的VkPipeline的任何stage会访问一个uniform buffer，且该stage对uniformBuffers不以启用VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT或者VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT 创建，且robustBufferAccess特性未开启，则该stage就不能访问绑定到相同pipeline bind point的descriptor set指定的buffer范围外的值
        33.如果robustBufferAccess特性未开启，且任何会访问uniform buffer的绑定到该命令使用的pipeline bind point上对应shader stage的VkShaderEXT，则其不能访问绑定到相同pipeline bind point的descriptor set指定的buffer范围外的值
        34.如何绑定到该命令使用的pipeline bind point上的VkPipeline的任何stage会访问一个storage buffer，且该stage对storageBuffers不以启用VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT或者VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT 创建，且robustBufferAccess特性未开启，则该stage就不能访问绑定到相同pipeline bind point的descriptor set指定的buffer范围外的值
        35.如果robustBufferAccess特性未开启，且任何会访问storage buffer的绑定到该命令使用的pipeline bind point上对应shader stage的VkShaderEXT，则其不能访问绑定到相同pipeline bind point的descriptor set指定的buffer范围外的值
        36.如果commandBuffer 是一个unprotected command buffer，且protectedNoFault 未支持，则任何绑定的shaders访问的资源不能是一个protected resource
        37.如果一个绑定的shader访问一个VkSampler 或者 VkImageView ，且启用了sampler Y′C BCR conversion，则只能使用OpImageSample* 或者 OpImageSparseSample*指令，不能使用ConstOffset 以及 Offset操作符
        38.如果一个VkImageView作为该命令的结果进行访问，则（1）image view 的viewType 必须匹配Instruction/Sampler/Image View Validation p1481中描述的OpTypeImage的Dim操作符
                                                          （2）image view 的foamrt的numeric type 必须匹配OpTypeImage的Sampled Type操作符
        39.如果一个VkImageView以一个不是VK_FORMAT_A8_UNORM_KHR的format创建且通过OpImageWrite作为该命令的结果进行访问，则该命令的Texel 操作符的Type必须至少包含和 image view的 format含有的components的个数相同的components个数
        40.如果一个VkImageView以VK_FORMAT_A8_UNORM_KHR的format创建且通过OpImageWrite作为该命令的结果进行访问，则该命令的Texel 操作符的Type必须包含4个components
        41.如果一个VkBufferView通过OpImageWrite作为该命令的结果进行访问，则该命令的Texel 操作符的Type必须至少包含和 buffer view的 format含有的components的个数相同的components个数
        42.如果一个带64-bit component的VkFormat的VkImageView作为该命令的结果进行访问，则该命令的OpTypeImage操作符的SampledType的宽度必须为64
        43.如果一个带少于64-bit component的VkFormat的VkImageView作为该命令的结果进行访问，则该命令的OpTypeImage操作符的SampledType的宽度必须为32
        44.如果一个带64-bit component的VkFormat的VkBufferView作为该命令的结果进行访问，则该命令的OpTypeImage操作符的SampledType的宽度必须为64位
        45.如果一个带少于64-bit component的VkFormat的VkBufferView作为该命令的结果进行访问，则该命令的OpTypeImage操作符的SampledType的宽度必须为32
        46.如果sparseImageInt64Atomics 特性未开启，则以VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT创建的VkImage对象不能被SampledType宽度为64位的OpTypeImage的atomic instructions访问
        47.如果sparseImageInt64Atomics 特性未开启，则以VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT创建的VkBuffer对象不能被SampledType宽度为64位的OpTypeImage的atomic instructions访问
        48.如果OpImageWeightedSampleQCOM用来采样一个作为该命令的结果的VkImageView，则该image view的format features必须包含VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM
        49.如果OpImageWeightedSampleQCOM用来采样一个作为该命令的结果的sample weight image的VkImageView，则该image view的format features必须包含VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM
        50.如果OpImageBoxFilterQCOM用来采样一个作为该命令的结果的VkImageView，则该image view的format features必须包含VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM
        51.如果OpImageBlockMatchSSDQCOM，或者 OpImageBlockMatchSADQCOM用来读取一个作为该命令的结果的VkImageView，则（1）该image view的format features必须包含VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM
                                                                                                                   （2）如果是读取的reference image，指定的reference coordinates不能在integer texel coordinate validation 时候失败
        52.如果OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchWindowSSDQCOM, OpImageBlockMatchWindowSADQCOM, OpImageBlockMatchGatherSSDQCOM,
                                                    OpImageBlockMatchGatherSADQCOM, OpImageBlockMatchSSDQCOM, 或者 OpImageBlockMatchSADQCOM用来采样一个作为该命令的结果的VkImageView，则该VkSampler必须以VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM创建
        53.如果任何除了OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchWindowSSDQCOM, OpImageBlockMatchWindowSADQCOM, OpImageBlockMatchGatherSSDQCOM, OpImageBlockMatchGatherSADQCOM, OpImageBlockMatchSSDQCOM, 或者 OpImageBlockMatchSADQCOM之外的指令使用VkSampler进行采样作为该命令的结果，则该sampler不能以VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM 创建
        54.如果OpImageBlockMatchWindow*QCOM or OpImageBlockMatchGather*QCOM指令用来读取VkImageView作为该命令的结果，则（1）VkImageView的format features必须包含VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM
                                                                                                                      （2）VkImageView的format必须只含有一个component
        55.如果OpImageBlockMatchWindow*QCOM or OpImageBlockMatchGather*QCOM指令用来读取一个引用的image作为该命令的结果，则指定的 reference coordinates不能在integer texel coordinate validation 时候失败
        56.任何该命令执行的shader invocation必须已经终止
        57.如果有一个类型位为VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM, VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, 或者 VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT中任意一个的descriptor作为该命令的结果进行访问，则该descriptor所指的image subresource的layout必须和该descriptor被写入时的layout相同。
        58.当前的 render pass  必须和绑定到VK_PIPELINE_BIND_POINT_GRAPHICS上的VkPipeline 创建时候的VkGraphicsPipelineCreateInfo中指定的renderPass兼容
        59.当前的 render pass  的subpass index必须和绑定到VK_PIPELINE_BIND_POINT_GRAPHICS上的VkPipeline 创建时候的VkGraphicsPipelineCreateInfo中指定的subpass相同
        60.如果任何shader静态访问一个input attachment，则有效的descriptor必须通过VkDescriptorSet被绑定到该pipeline中
        61.如果任何该pipeline执行shader以SubpassData的Dim操作符访问一个OpTypeImage变量，则该变量必须被一个对应当前subpass的input attachment的InputAttachmentIndex修饰
        62.在subpass中访问的Input attachment views必须以和该subpass相同定义的VkFormat创建，且必须以一个和当前绑定的VkFramebuffer的该附件引用的subpass的pInputAttachments[InputAttachmentIndex]附件兼容的VkImageView创建，参见Fragment Input Attachment Compatibility p1408
        63.在动态render pass中访问以VkRenderingInputAttachmentIndexInfoKHR的InputAttachmentIndex，或者VkRenderingInputAttachmentIndexInfoKHR:pDepthInputAttachmentIndex 或者 VkRenderingInputAttachmentIndexInfoKHR:pStencilInputAttachmentIndex为NULL情况下不指定InputAttachmentIndex的引用的Input attachment views，必须以和VkRenderingInfo中对应color, depth, 或者 stencil attachment兼容的VkImageView创建
        64.如果VkRenderingInputAttachmentIndexInfoKHR::pDepthInputAttachmentIndex 以及 VkRenderingInputAttachmentIndexInfoKHR::pStencilInputAttachmentIndex不为NULL，则在动态render pass中通过shader object访问Input attachment views必须指明InputAttachmentIndex
        65.如果在动态render pass中通过shader object访问Input attachment views指明了InputAttachmentIndex，则InputAttachmentIndex必须匹配VkRenderingInputAttachmentIndexInfoKHR中的index
        66.当前render pass所用的附件对应的image subresource底层内存的写入只能作为该命令的一个附件写入
        67.如果一个color attachment在之前的该subpass的命令中以load, store, 或者 resolve operations进行了写入，则其layout不为VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT，且有当前绑定的pipeline设有VK_PIPELINE_CREATE_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT，或者
                                        最后的vkCmdSetAttachmentFeedbackLoopEnableEXT调用包含VK_IMAGE_ASPECT_COLOR_BIT以及 没有绑定的pipeline 或者绑定的pipeline以VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT创建，则该附件只能以附件进行访问的，这两种情况中之一
        68.如果一个depth attachment在之前的该subpass的命令中以load, store, 或者 resolve operations进行了写入，则其layout不为VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT，且有当前绑定的pipeline设有VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT，或者
                                        最后的vkCmdSetAttachmentFeedbackLoopEnableEXT调用包含VK_IMAGE_ASPECT_DEPTH_BIT以及 没有绑定的pipeline 或者绑定的pipeline以VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT创建，则该附件只能以附件进行访问的，这两种情况中之一
        69.如果一个stencil attachment在之前的该subpass的命令中以load, store, 或者 resolve operations进行了写入，则其layout不为VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT，且有当前绑定的pipeline设有VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT，或者
                                        最后的vkCmdSetAttachmentFeedbackLoopEnableEXT调用包含VK_IMAGE_ASPECT_STENCIL_BIT以及 没有绑定的pipeline 或者绑定的pipeline以VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT创建，则该附件只能以附件进行访问的，这两种情况中之一
        70.如果一个attachment在之前的该subpass的命令中以load, store, 或者 resolve operations进行了写入,则该附件就不能再以除作为一个附件，storage image或者sampled image被该命令访问
        71.如果在之前的命令的subpass中以用作附件外的方式访问访问了一个当权subpass的附件所对的image subresource，则该命令就不能再将该image subresource用作附件进行写入
        72.如果当前render pass使用一个depth/stencil attachment，则（1）如果depth aspect的layout为read-only的layout，则不能启用depth writes
                                                                  （2）如果stencil aspect的layout为read-only的layout，front 以及 back writeMask不为0，且stencil 测试开启，则所有stencil 操作必须为VK_STENCIL_OP_KEEP
        73.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_VIEWPORT动态state开启创建，则vkCmdSetViewport必须在该命令之前设置
                                        （2）以VK_DYNAMIC_STATE_SCISSOR动态state开启创建，则vkCmdSetScissor必须在该命令之前设置
                                        （3）以VK_DYNAMIC_STATE_LINE_WIDTH动态state开启创建，则vkCmdSetLineWidth必须在该命令之前设置
                                        （4）以VK_DYNAMIC_STATE_DEPTH_BIAS动态state开启创建，则vkCmdSetDepthBias或者vkCmdSetDepthBias2EXT 必须在该命令之前设置
                                        （5）以VK_DYNAMIC_STATE_BLEND_CONSTANTS动态state开启创建，则vkCmdSetBlendConstants 必须在该命令之前设置
                                        （6）以VK_DYNAMIC_STATE_DEPTH_BOUNDS动态state开启创建，且如果当前depthBoundsTestEnable为VK_TRUE， 则vkCmdSetDepthBounds 必须在该命令之前设置
                                        （7）以VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK动态state开启创建，且如果当前stencilTestEnable为VK_TRUE， 则vkCmdSetStencilCompareMask 必须在该命令之前设置
                                        （8）以VK_DYNAMIC_STATE_STENCIL_WRITE_MASK动态state开启创建，且如果当前stencilTestEnable为VK_TRUE， 则vkCmdSetStencilWriteMask 必须在该命令之前设置
                                        （9）以VK_DYNAMIC_STATE_STENCIL_REFERENCE动态state开启创建，且如果当前stencilTestEnable为VK_TRUE， 则vkCmdSetStencilReference 必须在该命令之前设置
                                        （10）以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT动态state开启创建， 则vkCmdSetSampleLocationsEXT 必须在该命令之前设置
                                        （11）以VK_DYNAMIC_STATE_CULL_MODE动态state开启创建， 则vkCmdSetCullMode 必须在该命令之前设置
                                        （12）以VK_DYNAMIC_STATE_FRONT_FACE动态state开启创建， 则vkCmdSetFrontFace 必须在该命令之前设置
                                        （13）以VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE动态state开启创建， 则vkCmdSetDepthTestEnable 必须在该命令之前设置
                                        （14）以VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE动态state开启创建， 则vkCmdSetDepthWriteEnable 必须在该命令之前设置
                                        （15）以VK_DYNAMIC_STATE_DEPTH_COMPARE_OP动态state开启创建， 则vkCmdSetDepthCompareOp 必须在该命令之前设置
                                        （16）以VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE动态state开启创建， 则vkCmdSetDepthBoundsTestEnable 必须在该命令之前设置
                                        （17）以VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE动态state开启创建， 则vkCmdSetStencilTestEnable 必须在该命令之前设置
                                        （18）以VK_DYNAMIC_STATE_STENCIL_OP动态state开启创建， 则vkCmdSetStencilOp 必须在该命令之前设置
                                        （19）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT但不以VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT 动态state开启创建， 则vkCmdSetViewportWithCount 必须在该命令之前设置，且vkCmdSetViewportWithCount设置的viewportCount必须匹配pipeline的VkPipelineViewportStateCreateInfo::scissorCount
                                        （20）以VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT但不以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT 动态state开启创建， 则vkCmdSetScissorWithCount 必须在该命令之前设置，且vkCmdSetScissorWithCount设置的scissorCount必须匹配pipeline的VkPipelineViewportStateCreateInfo::viewportCount
                                        （21）以VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT和VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT 动态state同时开启创建， 则vkCmdSetViewportWithCount以及vkCmdSetScissorWithCount 必须在该命令之前设置，且vkCmdSetViewportWithCount设置的viewportCount必须匹配vkCmdSetScissorWithCount设置的scissorCount
                                        （22）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT但不以VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV 动态state开启创建， 则绑定的pipeline必须以VkPipelineViewportWScalingStateCreateInfoNV::viewportCount 大于等于最近vkCmdSetViewportWithCount设置的viewportCount创建
                                        （23）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT和VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV 动态state开启创建， 则最近调用的vkCmdSetViewportWScalingNV设置的viewportCount 必须大于等于最近vkCmdSetViewportWithCount设置的viewportCount
                                        （24）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT但不以VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV 动态state开启创建， 则绑定的pipeline必须以VkPipelineViewportShadingRateImageStateCreateInfoNV::viewportCount 大于等于最近vkCmdSetViewportWithCount设置的viewportCount创建
                                        （25）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT和VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV 动态state开启创建， 则最近调用的vkCmdSetViewportShadingRatePaletteNV设置的viewportCount 必须大于等于最近vkCmdSetViewportWithCount设置的viewportCount
                                        （26）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT动态state开启且VkPipelineViewportStateCreateInfo的pNext中含有一个VkPipelineViewportSwizzleStateCreateInfoNV 创建， 则绑定的pipeline必须以VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount 大于等于最近vkCmdSetViewportWithCount设置的viewportCount创建
                                        （27）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT动态state开启且VkPipelineViewportStateCreateInfo的pNext中含有一个VkPipelineViewportExclusiveScissorStateCreateInfoNV 创建， 则绑定的pipeline必须以VkPipelineViewportExclusiveScissorStateCreateInfoNV::exclusiveScissorCount 大于等于最近vkCmdSetViewportWithCount设置的viewportCount创建
                                        （28）以VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_ENABLE_NV动态state开启创建， 则vkCmdSetExclusiveScissorEnableNV 必须在该命令之前设置
                                        （29）以VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV动态state开启创建， 则vkCmdSetExclusiveScissorNV 必须在该命令之前设置
                                        （30）以VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE动态state开启创建， 则vkCmdSetRasterizerDiscardEnable 必须在该命令之前设置
                                        （31）以VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE动态state开启创建， 则vkCmdSetDepthBiasEnable 必须在该命令之前设置
                                        （32）以VK_DYNAMIC_STATE_LOGIC_OP_EXT动态state开启创建， 则vkCmdSetLogicOpEXT 必须在该命令之前设置且参数logicOp必须是一个有效的VkLogicOp值
        74.如果一个shader object绑定到任何graphics stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                        （1）如果最靠近当前命令的vkCmdSetPolygonModeEXT设置polygonMode为VK_POLYGON_MODE_LINE或者是任何line topology，则vkCmdSetLineWidth必须在该命令之前设置
                                        （2）如果最靠近当前命令的vkCmdSetDepthBiasEnable设置depthBiasEnable为VK_TRUE，则vkCmdSetDepthBias 或者 vkCmdSetDepthBias2EXT必须在该命令之前设置
                                        （3）如果最靠近当前命令的vkCmdSetDepthBoundsTestEnable设置depthBoundsTestEnable为VK_TRUE，则vkCmdSetDepthBounds必须在该命令之前设置
                                        （4）如果最靠近当前命令的vkCmdSetStencilTestEnable设置stencilTestEnable为VK_TRUE，则vkCmdSetStencilCompareMask必须在该命令之前设置
                                        （5）如果最靠近当前命令的vkCmdSetStencilTestEnable设置stencilTestEnable为VK_TRUE，则vkCmdSetStencilWriteMask必须在该命令之前设置
                                        （6）如果最靠近当前命令的vkCmdSetStencilTestEnable设置stencilTestEnable为VK_TRUE，则vkCmdSetStencilReference必须在该命令之前设置
                                        （7）如果最靠近当前命令的vkCmdSetSampleLocationsEnableEXT设置sampleLocationsEnable为VK_TRUE，则vkCmdSetSampleLocationsEXT必须在该命令之前设置
                                        （8）则vkCmdSetCullMode必须在该命令之前设置
                                        （9）则vkCmdSetFrontFace必须在该命令之前设置
                                        （10）则vkCmdSetDepthTestEnable 必须在该命令之前设置
                                        （11）则vkCmdSetDepthWriteEnable 必须在该命令之前设置
                                        （12）如果最靠近当前命令的vkCmdSetDepthTestEnable设置depthTestEnable为VK_TRUE，则vkCmdSetDepthCompareOp 必须在该命令之前设置
                                        （13）则vkCmdSetDepthBoundsTestEnable 必须在该命令之前设置
                                        （14）则vkCmdSetStencilTestEnable 必须在该命令之前设置
                                        （15）如果最靠近当前命令的vkCmdSetStencilTestEnable设置stencilTestEnable为VK_TRUE，则vkCmdSetStencilOp 必须在该命令之前设置
                                        （16）
                                        （17）如果shadingRateImage特性开启，则vkCmdSetCoarseSampleOrderNV 必须在该命令之前设置
                                        （18）如果shadingRateImage特性开启，且最靠近当前命令的vkCmdSetShadingRateImageEnableNV设置shadingRateImageEnable为VK_TRUE，则vkCmdSetViewportShadingRatePaletteNV 必须在该命令之前设置
                                        （19）如果shadingRateImage特性开启，且最靠近当前命令的vkCmdSetShadingRateImageEnableNV设置shadingRateImageEnable为VK_TRUE，则最近的vkCmdSetViewportShadingRatePaletteNV设置的viewportCount 必须大于等于vkCmdSetViewportWithCount设置的viewportCount
                                        （20）则vkCmdSetDepthBiasEnable必须在该命令之前设置
        75.如果一个输出line primitives的shader object绑定到VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或者 VK_SHADER_STAGE_GEOMETRY_BIT，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则vkCmdSetLineWidth必须在该命令之前设置
        76.如果一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最靠近当前命令的vkCmdSetColorBlendEnableEXT设置pColorBlendEnables任何元素为VK_TRUE，且
                            最靠近当前命令的vkCmdSetColorBlendEquationEXT设置pColorBlendEquations相同元素的VkColorBlendEquationEXT的VkBlendFactor成员为VK_BLEND_FACTOR_CONSTANT_COLOR, VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR, VK_BLEND_FACTOR_CONSTANT_ALPHA, 或者 VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA，则vkCmdSetBlendConstants必须在该命令之前设置
        77.如果该命令记录在开启了multiview的render pass instance中，则最大的instance 索引必须小于等于VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex
        78.如果绑定的graphics pipeline以VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable设置为VK_TRUE创建且当前的subpass含有一个 depth/stencil attachment，则该attachment必须以VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT创建
        >>78.5  .如果一个shader object绑定到任何graphics stage，则（1）vkCmdSetViewportWithCount 和vkCmdSetScissorWithCount 必须同时在该命令之前设置，且vkCmdSetViewportWithCount设置的viewportCount必须匹配vkCmdSetScissorWithCount设置的scissorCount
                                                                  （2）则vkCmdSetRasterizerDiscardEnable 必须在该命令之前设置
        79.如果VK_NV_clip_space_w_scaling拓展开启，且shader object绑定到任何graphics stage，且最近的vkCmdSetViewportWScalingEnableNV设置viewportWScalingEnable为VK_TRUE，则（1）vkCmdSetViewportWScalingNV必须在该命令前设置
                                                                                                                                                                           （2）最近vkCmdSetViewportWScalingNV设置的viewportCount必须大于等于vkCmdSetViewportWithCount设置的viewportCount
        80.如果exclusiveScissor 特性开启，且shader object绑定到任何graphics stage，，则（1）vkCmdSetExclusiveScissorEnableNV必须在该命令前设置
                                                                                       （2）最近的vkCmdSetExclusiveScissorEnableNV调用设置的pExclusiveScissorEnables中的任何元素为VK_TRUE,则vkCmdSetExclusiveScissorNV必须在该命令前设置
        81.如果一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最靠近当前命令的vkCmdSetLogicOpEnableEXT设置logicOpEnable任何元素为VK_TRUE，则vkCmdSetLogicOpEXT 必须在该命令之前设置且参数logicOp必须是一个有效的VkLogicOp值
        82.如果primitiveFragmentShadingRateWithMultipleViewports限制不支持，则（1）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT动态state开启创建，且任何该pipeline的shader stage会写入PrimitiveShadingRateKHR built-in修饰的变量，则vkCmdSetViewportWithCount 必须在该命令之前设置且参数viewportCount必须是1
                                                                              （2）任何绑定的graphics pipeline的shader stage会写入PrimitiveShadingRateKHR built-in修饰的变量，则vkCmdSetViewportWithCount 必须在该命令之前设置且参数viewportCount必须是1
        83.如果graphics pipeline中未开启rasterization，则对subpass中的每个color attachment，如果其对应的image view 的format features不包含VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT，则pColorBlendState中其对应pAttachments中元素的blendEnable必须为VK_FALSE
        84.如果一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则对于render pass中的每个color attachment，如果其对应的image view 的format features不包含VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT， 则最近的vkCmdSetColorBlendEnableEXT设置的pColorBlendEnables中该附件的对应元素必须为VK_FALSE
        85.如果graphics pipeline中未开启rasterization，有VK_AMD_mixed_attachment_samples拓展未开启，VK_NV_framebuffer_mixed_samples拓展未开启，multisampledRenderToSingleSampled特性未开启，则当前绑定的pipeline的rasterizationSamples必须和当前subpass的color 以及/或者 depth/stencil attachments的相同
        86.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且有VK_AMD_mixed_attachment_samples拓展未开启，VK_NV_framebuffer_mixed_samples拓展未开启，multisampledRenderToSingleSampled特性未开启，则最近vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples必须和当前subpass的color 以及/或者 depth/stencil attachments的相同
        87.如果一个shader object绑定到任何graphics stage，则当前的render pass instance必须以vkCmdBeginRendering开始
        88.如果当前的render pass instance以vkCmdBeginRendering开始，（1）如果pDepthAttachment的imageView不为VK_NULL_HANDLE，且pDepthAttachment的layout不为VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL，则该命令不能写入任何值到depth attachment
                                                                    （2）如果pStencilAttachment的imageView不为VK_NULL_HANDLE，且pStencilAttachment的layout不为VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL，则该命令不能写入任何值到stencil attachment
                                                                    （3）如果pDepthAttachment的imageView不为VK_NULL_HANDLE，且pDepthAttachment的layout为VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL，则该命令不能写入任何值到depth attachment
                                                                    （4）如果pStencilAttachment的imageView不为VK_NULL_HANDLE，且pStencilAttachment的layout为VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL，则该命令不能写入任何值到stencil attachment
                                                                    （5）如果pDepthAttachment的imageView不为VK_NULL_HANDLE，且pDepthAttachment的layout为VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL，则该命令不能写入任何值到depth attachment
                                                                    （6）如果pStencilAttachment的imageView不为VK_NULL_HANDLE，且pStencilAttachment的layout为VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL，则该命令不能写入任何值到stencil attachment
                                                                    （7）则当前绑定的graphics pipeline必须以含VkPipelineRenderingCreateInfo::viewMask等于VkRenderingInfo::viewMask创建
                                                                    （8）如果带有VkRenderingInfo::colorAttachmentCount为1，则没有shader object绑定到任何graphics stage，且一个color attachment的 resolve mode为VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID，则VkRenderingInfo::pColorAttachments中每个resolveImageView不为VK_NULL_HANDLE的元素其对应image必须以和创建当前绑定的pipeline 相同的VkExternalFormatANDROID::externalFormat创建
                                                                    （9）如果没有shader object绑定到任何graphics stage，如果绑定的graphics pipeline以一个非零值VkExternalFormatANDROID::externalFormat创建且启用VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态设置，则vkCmdSetColorBlendEnableEXT必须在该命令前设置blend enable为VK_FALSE
                                                                    （10）如果没有shader object绑定到任何graphics stage，如果绑定的graphics pipeline以一个非零值VkExternalFormatANDROID::externalFormat创建且启用VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态设置，则vkCmdSetRasterizationSamplesEXT必须在该命令前设置rasterizationSamples为VK_SAMPLE_COUNT_1_BIT
                                                                    （11）如果没有shader object绑定到任何graphics stage，如果绑定的graphics pipeline以一个非零值VkExternalFormatANDROID::externalFormat创建且启用VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR动态设置，则vkCmdSetFragmentShadingRateKHR必须在该命令前设置pFragmentSize->width为1，pFragmentSize->height为1
        89.如果dynamicRenderingUnusedAttachments特性未开启，且当前的render pass instance以vkCmdBeginRendering开始，则
                                                                （1）当前绑定的graphics pipeline必须以含VkPipelineRenderingCreateInfo::colorAttachmentCount等于VkRenderingInfo::colorAttachmentCount创建
                                                                （2）如果VkRenderingInfo::colorAttachmentCount大于0，则VkRenderingInfo::pColorAttachments 中每一个其imageView不为VK_NULL_HANDLE的元素的VkImageView必须以VkFormat对应绑定的graphics pipeline的VkPipelineRenderingCreateInfo::pColorAttachmentFormats指明的format创建
                                                                （3）如果VkRenderingInfo::colorAttachmentCount大于0，则VkRenderingInfo::pColorAttachments 中每一个其imageView为VK_NULL_HANDLE的元素对应绑定的graphics pipeline的VkPipelineRenderingCreateInfo::pColorAttachmentFormats指明的format必须为VK_FORMAT_UNDEFINED
                                                                （4）如果VkRenderingInfo::pDepthAttachment->imageView为VK_NULL_HANDLE，则创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::depthAttachmentFormat必须为VK_FORMAT_UNDEFINED
                                                                （5）如果VkRenderingInfo::pDepthAttachment->imageView不为VK_NULL_HANDLE，则创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::depthAttachmentFormat必须和创建VkRenderingInfo::pDepthAttachment->imageView的VkFormat相同
                                                                （6）如果VkRenderingInfo::pStencilAttachment->imageView为VK_NULL_HANDLE，则创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::stencilAttachmentFormat必须为VK_FORMAT_UNDEFINED
                                                                （7）如果VkRenderingInfo::pStencilAttachment->imageView不为VK_NULL_HANDLE，则创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::stencilAttachmentFormat必须和创建VkRenderingInfo::pStencilAttachment->imageView的VkFormat相同
        90.如果dynamicRenderingUnusedAttachments特性开启，且当前的render pass instance以vkCmdBeginRendering开始，则
                                                                （1）如果VkRenderingInfo::colorAttachmentCount大于0，则VkRenderingInfo::pColorAttachments 中每一个其imageView不为VK_NULL_HANDLE的元素的VkImageView必须以VkFormat对应绑定的graphics pipeline的VkPipelineRenderingCreateInfo::pColorAttachmentFormats指明的format创建，或者是对应元素为VK_FORMAT_UNDEFINED创建
                                                                （2）如果VkRenderingInfo::pDepthAttachment->imageView不为VK_NULL_HANDLE，且创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::depthAttachmentFormat和创建VkRenderingInfo::pDepthAttachment->imageView的VkFormat不同，则该format必须为VK_FORMAT_UNDEFINED
                                                                （3）如果VkRenderingInfo::pStencilAttachment->imageView不为VK_NULL_HANDLE，且创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::stencilAttachmentFormat和创建VkRenderingInfo::pStencilAttachment->imageView的VkFormat不同，则该format必须为VK_FORMAT_UNDEFINED
        91.如果没有shader object绑定到任何graphics stage，且当前的render pass instance以vkCmdBeginRendering开始且VkRenderingInfo::colorAttachmentCount为1，且一个color attachment的 resolve mode为VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID，则VkRenderingInfo::pColorAttachments中每个resolveImageView不为VK_NULL_HANDLE的元素其对应image必须以和创建当前绑定的pipeline 相同的VkExternalFormatANDROID::externalFormat创建
        92.如果有一个shader object绑定到任何graphics stage，且当前的render pass 包含一个使用VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID resolve mode的color attachment，则（1）vkCmdSetColorBlendEnableEXT必须在该命令前设置blend enable为VK_FALSE
                                                                                                                                                                                 （2）则vkCmdSetRasterizationSamplesEXT必须在该命令前设置rasterizationSamples为VK_SAMPLE_COUNT_1_BIT
                                                                                                                                                                                 （3）则vkCmdSetFragmentShadingRateKHR必须在该命令前设置pFragmentSize->width为1，pFragmentSize->height为1
        93.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT动态state开启创建， 则vkCmdSetColorWriteEnableEXT 必须在该命令之前设置，且设置的attachmentCount必须大于等于创建当前绑定的pipeline的VkPipelineColorBlendStateCreateInfo::attachmentCount
                                        （2）以VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT动态state开启创建， 则vkCmdSetDiscardRectangleEXT 必须在该命令之前为每个VkPipelineDiscardRectangleStateCreateInfoEXT::discardRectangleCount指明的discard rectangle 设置
                                        （3）以VK_DYNAMIC_STATE_DISCARD_RECTANGLE_ENABLE_EXT动态state开启创建， 则vkCmdSetDiscardRectangleEnableEXT 必须在该命令之前设置
                                        （4）以VK_DYNAMIC_STATE_DISCARD_RECTANGLE_MODE_EXT动态state开启创建， 则vkCmdSetDiscardRectangleModeEXT 必须在该命令之前设置
        94.如果有一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                        （1）如果colorWriteEnable特性在device上开启，则vkCmdSetColorWriteEnableEXT 必须在该命令之前设置，且设置的attachmentCount必须大于等于当前render pass instance的color attachment的数量
                                        （2）如果VK_EXT_discard_rectangles拓展开启，且最近的vkCmdSetDiscardRectangleEnableEXT设置discardRectangleEnable为VK_TRUE， 则vkCmdSetDiscardRectangleEXT 必须在该命令之前设置
                                        （3）如果VK_EXT_discard_rectangles拓展开启， 则vkCmdSetDiscardRectangleEnableEXT 必须在该命令之前设置
                                        （4）如果VK_EXT_discard_rectangles拓展开启， 则最近的vkCmdSetDiscardRectangleEnableEXT设置discardRectangleEnable为VK_TRUE，则vkCmdSetDiscardRectangleModeEXT 必须在该命令之前设置
        95.如果当前的render pass instance以vkCmdBeginRendering开始，则（1）如果VkRenderingFragmentShadingRateAttachmentInfoKHR::imageView不为VK_NULL_HANDLE，则当前绑定的graphics pipeline必须以VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR创建
                                                                      （2）如果VkRenderingFragmentDensityMapAttachmentInfoEXT::imageView不为VK_NULL_HANDLE，则当前绑定的graphics pipeline必须以VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT创建
                                                                      （3）且含VkRenderingInfo::colorAttachmentCount大于0，如果当前的绑定的pipeline以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，则VkRenderingInfo::pColorAttachments中每个imageView不为VK_NULL_HANDLE的元素的imageView，必须以当前pipeline的VkAttachmentSampleCountInfoAMD 或者 VkAttachmentSampleCountInfoNV中的pColorAttachmentSamples中对应元素的sample count进行创建
                                                                      （4）如果当前的绑定的pipeline以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且VkRenderingInfo::pDepthAttachment中的imageView不为VK_NULL_HANDLE，则当前pipeline的VkAttachmentSampleCountInfoAMD 或者 VkAttachmentSampleCountInfoNV中的depthStencilAttachmentSamples必须等于创建VkRenderingInfo::pDepthAttachment->imageView的sample count
                                                                      （5）如果当前的绑定的pipeline以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且VkRenderingInfo::pStencilAttachment中的imageView不为VK_NULL_HANDLE，则当前pipeline的VkAttachmentSampleCountInfoAMD 或者 VkAttachmentSampleCountInfoNV中的depthStencilAttachmentSamples必须等于创建VkRenderingInfo::pStencilAttachment->imageView的sample count
                                                                      （6）且含VkRenderingInfo::colorAttachmentCount大于0，如果当前的绑定的pipeline不以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且multisampledRenderToSingleSampled特性没有开启，则VkRenderingInfo::pColorAttachments中每个imageView不为VK_NULL_HANDLE的元素的imageView，其创建的sample count必须等于当前绑定的graphics pipeline的rasterizationSamples
                                                                      （7）如果当前的绑定的pipeline不以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且VkRenderingInfo::pDepthAttachment中的imageView不为VK_NULL_HANDLE，且multisampledRenderToSingleSampled特性没有开启，则当前pipeline的rasterizationSamples 必须等于创建VkRenderingInfo::pDepthAttachment->imageView的sample count
                                                                      （8）如果当前的绑定的pipeline不以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且VkRenderingInfo::pStencilAttachment中的imageView不为VK_NULL_HANDLE，且multisampledRenderToSingleSampled特性没有开启，则当前pipeline的rasterizationSamples 必须等于创建VkRenderingInfo::pStencilAttachment->imageView的sample count
                                                                      （9）当前绑定的pipeline必须VkGraphicsPipelineCreateInfo::renderPass为VK_NULL_HANDLE创建
                                                                      （10）如果绑定的pipeline的fragment shader静态写入一个color attachment，且color write mask不为0，启用了color writes，且该附件对应的VkRenderingInfo::pColorAttachments->imageView 不为VK_NULL_HANDLE，则对应的创建pipeline的VkPipelineRenderingCreateInfo::pColorAttachmentFormats中的元素不能为VK_FORMAT_UNDEFINED
                                                                      （11）如果绑定的pipeline启用了depth test，启用了depth writes，且VkRenderingInfo::pDepthAttachment->imageView 不为VK_NULL_HANDLE，则创建pipeline的VkPipelineRenderingCreateInfo::depthAttachmentFormat不能为VK_FORMAT_UNDEFINED
                                                                      （12）如果绑定的pipeline启用了stencil test，且VkRenderingInfo::pStencilAttachment->imageView 不为VK_NULL_HANDLE，则创建pipeline的VkPipelineRenderingCreateInfo::stencilAttachmentFormat不能为VK_FORMAT_UNDEFINED
        96.如果该命令在以vkCmdBeginRendering开始的render pass instance中调用，且VkRenderingInfo的pNext中包含一个multisampledRenderToSingleSampledEnable设为VK_TRUE的VkMultisampledRenderToSingleSampledInfoEXT，则当前绑定的graphics pipeline的rasterizationSamples必须等于VkMultisampledRenderToSingleSampledInfoEXT::rasterizationSamples
        97.如果primitivesGeneratedQueryWithRasterizerDiscard特性未开启，且VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query激活，则不能启用rasterization discard
        98.如果primitivesGeneratedQueryWithNonZeroStreams特性未开启，且VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query激活，则 绑定的graphics pipeline不能以VkPipelineRasterizationStateStreamCreateInfoEXT::rasterizationStream为非零值创建
        98.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_TESSELLATION_DOMAIN_ORIGIN_EXT动态state开启创建，则vkCmdSetTessellationDomainOriginEXT必须在该命令之前设置
                                        （2）以VK_DYNAMIC_STATE_DEPTH_CLAMP_ENABLE_EXT动态state开启创建，则vkCmdSetDepthClampEnableEXT必须在该命令之前设置
                                        （3）以VK_DYNAMIC_STATE_POLYGON_MODE_EXT动态state开启创建，则vkCmdSetPolygonModeEXT必须在该命令之前设置
                                        （4）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，则vkCmdSetRasterizationSamplesEXT必须在该命令之前设置
                                        （5）以VK_DYNAMIC_STATE_SAMPLE_MASK_EXT动态state开启创建，则vkCmdSetSampleMaskEXT必须在该命令之前设置
                                        （6）以VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT动态state开启创建，则vkCmdSetAlphaToCoverageEnableEXT必须在该命令之前设置
                                        （7）以VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT动态state开启创建，则最近的vkCmdSetAlphaToCoverageEnableEXT设置alphaToCoverageEnable为VK_TRUE，则Fragment Output Interface中 Index 0的Location 0必须有一个含alpha Component的变量
                                        （8）以VK_DYNAMIC_STATE_ALPHA_TO_ONE_ENABLE_EXT动态state开启创建，则vkCmdSetAlphaToOneEnableEXT必须在该命令之前设置
                                        （9）以VK_DYNAMIC_STATE_LOGIC_OP_ENABLE_EXT动态state开启创建，则vkCmdSetLogicOpEnableEXT必须在该命令之前设置
                                        （10）以VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态state开启创建，则vkCmdSetColorBlendEnableEXT必须在该命令之前设置
                                        （11）以VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT动态state开启创建，则vkCmdSetColorBlendEquationEXT必须在该命令之前设置
                                        （12）以VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT动态state开启创建，则vkCmdSetColorWriteMaskEXT必须在该命令之前设置
        
        99.如果一个shader object绑定到VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT stage，则vkCmdSetTessellationDomainOriginEXT必须在该命令之前设置
        100.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                                        （1）如果depthClamp特性启用，则vkCmdSetDepthClampEnableEXT必须在该命令之前设置
                                                        （2）则vkCmdSetPolygonModeEXT必须在该命令之前设置
                                                        （3）则vkCmdSetRasterizationSamplesEXT必须在该命令之前设置
                                                        （4）则vkCmdSetSampleMaskEXT必须在该命令之前设置
                                                        （5）则vkCmdSetAlphaToCoverageEnableEXT必须在该命令之前设置
                                                        （6）如果alphaToOne特性启用，则vkCmdSetAlphaToOneEnableEXT必须在该命令之前设置
        
        101.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetAlphaToCoverageEnableEXT设置alphaToCoverageEnable为VK_TRUE，则Fragment Output Interface中 Index 0的Location 0必须有一个含alpha Component的变量
        102.如果一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                            （1）如果logicOp特性开启 ,vkCmdSetLogicOpEnableEXT必须在该命令之前设置
                                            （2）如果绑定了color attachments，则vkCmdSetColorBlendEnableEXT必须在该命令之前设置
                                            （3）如果最近的vkCmdSetColorBlendEnableEXT设置任何附件在pColorBlendEnables中的值为VK_TRUE ，则vkCmdSetColorBlendEquationEXT必须在该命令之前设置
                                            （4）如果绑定了color attachments，则vkCmdSetColorWriteMaskEXT必须在该命令之前设置
        
        103.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT动态state开启创建，则vkCmdSetRasterizationStreamEXT必须在该命令之前设置
                                         （2）以VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT动态state开启创建，则vkCmdSetConservativeRasterizationModeEXT必须在该命令之前设置
                                         （3）以VK_DYNAMIC_STATE_EXTRA_PRIMITIVE_OVERESTIMATION_SIZE_EXT动态state开启创建，则vkCmdSetExtraPrimitiveOverestimationSizeEXT必须在该命令之前设置
                                         （4）以VK_DYNAMIC_STATE_DEPTH_CLIP_ENABLE_EXT动态state开启创建，则vkCmdSetDepthClipEnableEXT必须在该命令之前设置
                                         （5）以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT动态state开启创建，则vkCmdSetSampleLocationsEnableEXT必须在该命令之前设置
                                         （6）以VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT动态state开启创建，则vkCmdSetColorBlendAdvancedEXT必须在该命令之前设置
                                         （7）以VK_DYNAMIC_STATE_PROVOKING_VERTEX_MODE_EXT动态state开启创建，则vkCmdSetProvokingVertexModeEXT必须在该命令之前设置
                                         （8）以VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT动态state开启创建，则vkCmdSetLineRasterizationModeEXT必须在该命令之前设置
                                         （9）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT动态state开启创建，则vkCmdSetLineStippleEnableEXT必须在该命令之前设置
                                         （10）以VK_DYNAMIC_STATE_LINE_STIPPLE_KHR动态state开启创建，则vkCmdSetLineStippleKHR必须在该命令之前设置
                                         （11）以VK_DYNAMIC_STATE_DEPTH_CLIP_NEGATIVE_ONE_TO_ONE_EXT动态state开启创建，则vkCmdSetDepthClipNegativeOneToOneEXT必须在该命令之前设置
                                         （12）以VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_ENABLE_NV动态state开启创建，则vkCmdSetViewportWScalingEnableNV必须在该命令之前设置
                                         （13）以VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV动态state开启创建，则vkCmdSetViewportSwizzleNV必须在该命令之前设置
                                         （14）以VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV动态state开启创建，则vkCmdSetCoverageToColorEnableNV必须在该命令之前设置
                                         （15）以VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_LOCATION_NV动态state开启创建，则vkCmdSetCoverageToColorLocationNV必须在该命令之前设置
                                         （16）以VK_DYNAMIC_STATE_COVERAGE_MODULATION_MODE_NV动态state开启创建，则vkCmdSetCoverageModulationModeNV必须在该命令之前设置
                                         （17）以VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV动态state开启创建，则vkCmdSetCoverageModulationTableEnableNV必须在该命令之前设置
                                         （18）以VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_NV动态state开启创建，则vkCmdSetCoverageModulationTableNV必须在该命令之前设置
                                         （19）以VK_DYNAMIC_STATE_SHADING_RATE_IMAGE_ENABLE_NV动态state开启创建，则vkCmdSetShadingRateImageEnableNV必须在该命令之前设置
                                         （20）以VK_DYNAMIC_STATE_REPRESENTATIVE_FRAGMENT_TEST_ENABLE_NV动态state开启创建，则vkCmdSetRepresentativeFragmentTestEnableNV必须在该命令之前设置
                                         （21）以VK_DYNAMIC_STATE_COVERAGE_REDUCTION_MODE_NV动态state开启创建，则vkCmdSetCoverageReductionModeNV必须在该命令之前设置
        
        104.如果一个shader object绑定到VK_SHADER_STAGE_GEOMETRY_BIT stage，且如果geometryStreams 特性开启，则vkCmdSetRasterizationStreamEXT必须在该命令之前设置
        105.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                （1）如果VK_EXT_conservative_rasterization 拓展开启，vkCmdSetConservativeRasterizationModeEXT必须在该命令之前设置
                                （2）如果VK_EXT_conservative_rasterization 拓展开启，且最近的vkCmdSetConservativeRasterizationModeEXT设置conservativeRasterizationMode为VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT，则vkCmdSetExtraPrimitiveOverestimationSizeEXT必须在该命令之前设置
                                （3）如果VK_EXT_sample_locations 拓展开启，则vkCmdSetSampleLocationsEnableEXT必须在该命令之前设置
        106.如果一个shader object绑定到任何graphics stage，且depthClipEnable 特性开启，则vkCmdSetDepthClipEnableEXT必须在该命令之前设置
        107.如果如果一个shader object绑定到任何VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且如果VK_EXT_blend_operation_advanced 拓展开启，则vkCmdSetColorBlendEquationEXT 和 vkCmdSetColorBlendAdvancedEXT中至少一个必须在该命令之前设置
        108.如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，如果VK_EXT_provoking_vertex拓展开启， 则vkCmdSetProvokingVertexModeEXT必须在该命令之前设置
        109.如果VK_KHR_line_rasterization 或者 VK_EXT_line_rasterization拓展开启，则（1）如果一个shader object绑定到任意一个graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetPolygonModeEXT设置polygonMode 为VK_POLYGON_MODE_LINE ，则vkCmdSetLineRasterizationModeEXT必须在该命令之前设置
                                                                                    （2）如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetPrimitiveTopology设置primitiveTopology 为任何line topology ，则vkCmdSetLineRasterizationModeEXT必须在该命令之前设置
                                                                                    （3）如果一个输出为line primitive的shader object绑定到VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或 VK_SHADER_STAGE_GEOMETRY_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则vkCmdSetLineRasterizationModeEXT必须在该命令之前设置
                                                                                    （4）如果一个shader object绑定到任意一个graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetPolygonModeEXT设置polygonMode 为VK_POLYGON_MODE_LINE ，则vkCmdSetLineStippleEnableEXT必须在该命令之前设置
                                                                                    （5）如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetPrimitiveTopology设置primitiveTopology 为任何line topology ，则vkCmdSetLineStippleEnableEXT必须在该命令之前设置
                                                                                    （6）如果一个输出为line primitive的shader object绑定到VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或 VK_SHADER_STAGE_GEOMETRY_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则vkCmdSetLineStippleEnableEXT必须在该命令之前设置
                                                                                    （7）如果一个shader object绑定到任意一个graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetLineStippleEnableEXT设置stippledLineEnable 为VK_TRUE ，则vkCmdSetLineStippleEXT必须在该命令之前设置
        110.如果一个shader object绑定到任何graphics stage，（1）如果depthClipControl 特性开启，则vkCmdSetDepthClipNegativeOneToOneEXT必须在该命令之前设置
                                                           （2）VK_NV_clip_space_w_scaling 拓展开启，则vkCmdSetViewportWScalingEnableNV必须在该命令之前设置
                                                           （3）VK_NV_viewport_swizzle 拓展开启，则vkCmdSetViewportSwizzleNV必须在该命令之前设置
        111.如果如果一个shader object绑定到任何VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                            （1）如果VK_NV_fragment_coverage_to_color 拓展开启，则vkCmdSetCoverageToColorEnableNV 必须在该命令之前设置
                            （2）如果VK_NV_fragment_coverage_to_color 拓展开启，且最近的vkCmdSetCoverageToColorEnableNV 设置coverageToColorEnable 为VK_TRUE，则vkCmdSetCoverageToColorLocationNV 必须在该命令之前设置
                            （3）如果pipelineFragmentShadingRate 特性开启，则vkCmdSetFragmentShadingRateKHR 必须在该命令之前设置
        112.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                    （1）如果VK_NV_framebuffer_mixed_samples 拓展开启，则vkCmdSetCoverageModulationModeNV 必须在该命令之前设置
                                    （2）如果VK_NV_framebuffer_mixed_samples 拓展开启，且最近的vkCmdSetCoverageModulationModeNV设置coverageModulationMode为任何除VK_COVERAGE_MODULATION_MODE_NONE_NV之外的值，则vkCmdSetCoverageModulationTableEnableNV 必须在该命令之前设置
                                    （3）如果VK_NV_framebuffer_mixed_samples 拓展开启，最近的vkCmdSetCoverageModulationTableEnableNV设置coverageModulationTableEnable为VK_TRUE，则vkCmdSetCoverageModulationTableNV 必须在该命令之前设置
                                    （4）如果shadingRateImage 特性开启，则vkCmdSetShadingRateImageEnableNV 必须在该命令之前设置
                                    （5）如果representativeFragmentTest 特性开启，则vkCmdSetRepresentativeFragmentTestEnableNV 必须在该命令之前设置
                                    （6）如果coverageReductionMode 特性开启，则vkCmdSetCoverageReductionModeNV 必须在该命令之前设置
        113.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态state开启创建，且最近的vkCmdSetColorBlendEnableEXT设置任何附件在pColorBlendEnables中的值为VK_TRUE 则subpas中这些附件对应的image view的format features中必须包含VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT
                                         （2）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，且当前subpass不使用任何color和/或者 depth/stencil attachments，则最后的vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples必须符合zero￾attachment subpass的规则
                                         （3）以VK_DYNAMIC_STATE_SAMPLE_MASK_EXT不以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT 动态state开启创建，则最后调用的vkCmdSetSampleMaskEXT中设置的samples参数必须大于等于创建该pipeline的VkPipelineMultisampleStateCreateInfo::rasterizationSamples
                                         （4）以VK_DYNAMIC_STATE_SAMPLE_MASK_EXT和 VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT 动态state开启创建，则最后调用的vkCmdSetSampleMaskEXT中设置的samples参数必须大于等于最后的vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples
                                         （5）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，且VK_AMD_mixed_attachment_samples和VK_NV_framebuffer_mixed_samples拓展都没有开启，则最后的vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples必须等于subpass中color和/或者 depth/stencil attachments使用的相同
                                         （6）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，或者一个shader object绑定到任意graphics stage，且当前的subpass包含一个multisampledRenderToSingleSampledEnable 为VK_TRUE的VkMultisampledRenderToSingleSampledInfoEXT，则最后的vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples必须等于该VkMultisampledRenderToSingleSampledInfoEXT中的对应成员
                                         （7）以VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态state开启创建，则vkCmdSetColorBlendEnableEXT 必须在该命令之前设置，且vkCmdSetColorBlendEnableEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定值
                                         （8）以VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT动态state开启创建，则vkCmdSetColorBlendEquationEXT 必须在该命令之前设置，且vkCmdSetColorBlendEquationEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定blend equations
                                         （9）以VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT动态state开启创建，则vkCmdSetColorWriteMaskEXT 必须在该命令之前设置，且vkCmdSetColorWriteMaskEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定color write mask
                                         （10）以VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT动态state开启创建，则vkCmdSetColorBlendAdvancedEXT 必须在该命令之前设置，且vkCmdSetColorBlendAdvancedEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活blend的color attachments指定advanced blend equations
                                         （11）以VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT和VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态state开启创建，且最后的vkCmdSetColorBlendEnableEXT和vkCmdSetColorBlendAdvancedEXT设置启用了advanced blending，则当前subpass中激活的color attachments的数量不能超过advancedBlendMaxColorAttachments
                                         （12）以VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT动态state开启创建，且如果primitivesGeneratedQueryWithNonZeroStreams特性未开启且VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query已经激活，则最后的vkCmdSetRasterizationStreamEXT必须设置rasterizationStream为0
                                         （13）以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT但不以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，则最后的vkCmdSetSampleLocationsEXT设置的pSampleLocationsInfo->sampleLocationsPerPixel必须等于创建pipeline的VkPipelineMultisampleStateCreateInfo::rasterizationSamples
                                         （14）以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT和VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，则最后的vkCmdSetSampleLocationsEXT设置的pSampleLocationsInfo->sampleLocationsPerPixel必须等于最后vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples
                                         （15）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT但不以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT动态state开启创建，且绑定的pipeline的VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable为VK_TRUE 或者以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT动态state开启，则sampleLocationsInfo.sampleLocationsPerPixel 必须等于最后vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples
                                         （16）以VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV动态state开启创建，且最后的vkCmdSetCoverageToColorEnableNV设置coverageToColorEnable为VK_TRUE，则当前subpass必须有color attachment，且该attachment的format必须为VK_FORMAT_R8_UINT, VK_FORMAT_R8_SINT, VK_FORMAT_R16_UINT, VK_FORMAT_R16_SINT, VK_FORMAT_R32_UINT, 或者 VK_FORMAT_R32_SINT，且该attachment的location 有最后的vkCmdSetCoverageToColorLocationNV设置的coverageToColorLocation决定
                                         （17）以VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV和VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT 动态state开启创建，且如果VK_NV_coverage_reduction_mode 拓展开启，则当前的 coverageReductionMode，rasterizationSamples 以及color 以及 depth/stencil attachments（如果subpass有）的sample count必须是有效的返回值vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV的值的组合
                                         （18）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT但不以VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV 动态state开启创建，则绑定的graphics pipeline的VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount 必须大于等于最后vkCmdSetViewportWithCount设置的viewportCount
                                         （19）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT和VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV 动态state开启创建，则最后vkCmdSetViewportSwizzleNV设置的viewportCount 必须大于等于最后vkCmdSetViewportWithCount设置的viewportCount
                                         （20）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT或者 VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT 动态state开启创建，如果当前的stippledLineEnable为VK_TRUE，且当前的lineRasterizationMode为VK_LINE_RASTERIZATION_MODE_RECTANGULAR_KHR，则stippledRectangularLines 特性必须开启
                                         （21）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT或者 VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT 动态state开启创建，如果当前的stippledLineEnable为VK_TRUE，且当前的lineRasterizationMode为VK_LINE_RASTERIZATION_MODE_BRESENHAM_KHR，则stippledBresenhamLines 特性必须开启
                                         （22）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT或者 VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT 动态state开启创建，如果当前的stippledLineEnable为VK_TRUE，且当前的lineRasterizationMode为VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_KHR，则stippledSmoothLines 特性必须开启
                                         （23）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT或者 VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT 动态state开启创建，如果当前的stippledLineEnable为VK_TRUE，且当前的lineRasterizationMode为VK_LINE_RASTERIZATION_MODE_DEFAULT_KHR，则stippledRectangularLines 特性必须开启且VkPhysicalDeviceLimits::strictLines 必须为VK_TRUE
                                         （24）以VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT 动态state开启创建，且conservativePointAndLineRasterization不支持，最后的 pre-rasterization shader stage输出的有效图元拓扑为点或者线，则最后vkCmdSetConservativeRasterizationModeEXT设置的conservativeRasterizationMode 必须为VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT
                                         （25）以VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT 动态state开启创建，则vkCmdSetAttachmentFeedbackLoopEnableEXT 必须在该命令之前调用
        114.如果一个shader object绑定到 VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                                                                            （1）则vkCmdSetColorBlendEnableEXT 必须在该命令之前设置，且vkCmdSetColorBlendEnableEXT指定的firstAttachment开始的attachmentCount的值必须为当前subpass所有激活的color attachments指定
                                                                                            （2）则vkCmdSetColorBlendEquationEXT 必须在该命令之前设置，且vkCmdSetColorBlendEquationEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定blend equations
                                                                                            （3）则vkCmdSetColorWriteMaskEXT 必须在该命令之前设置，且vkCmdSetColorWriteMaskEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定color write mask
                                                                                            （4）如果VK_NV_fragment_coverage_to_color拓展开启， 最后的vkCmdSetCoverageToColorEnableNV设置coverageToColorEnable为VK_TRUE，则当前subpass必须有color attachment，且该attachment的format必须为VK_FORMAT_R8_UINT, VK_FORMAT_R8_SINT, VK_FORMAT_R16_UINT, VK_FORMAT_R16_SINT, VK_FORMAT_R32_UINT, 或者 VK_FORMAT_R32_SINT，且该attachment的location 有最后的vkCmdSetCoverageToColorLocationNV设置的coverageToColorLocation决定
        115.如果一个shader object绑定到 VK_SHADER_STAGE_FRAGMENT_BIT stage，（1）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT动态state开启创建，且最近的vkCmdSetSampleLocationsEnableEXT设置sampleLocationsEnable为VK_TRUE，且该subpass含有depth/stencil attachment，则该附件必须以VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT创建
                                                                            （2）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT和VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT 动态state开启创建，且最近的vkCmdSetSampleLocationsEnableEXT设置sampleLocationsEnable为VK_TRUE，则 最后vkCmdSetSampleLocationsEXT设置的sampleLocationsInfo.sampleLocationGridSize.width以及height 必须等于被调用vkGetPhysicalDeviceMultisamplePropertiesEXT传入rasterizationSamples返回的VkMultisamplePropertiesEXT::sampleLocationGridSize.width以及height一一对应均匀整除
                                                                            （3）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT 动态state开启创建，且最近的vkCmdSetSampleLocationsEnableEXT设置sampleLocationsEnable为VK_TRUE，则fragment shader代码中不能静态使用扩展指令InterpolateAtSample
                                                                            （4）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT但不以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT 动态state开启创建，且绑定的pipeline的VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable为VK_TRUE 或者以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT动态state开启，则 最后vkCmdSetRasterizationSamplesEXT设置的sampleLocationsInfo.sampleLocationGridSize.width以及height 必须等于被调用vkGetPhysicalDeviceMultisamplePropertiesEXT传入和vkCmdSetRasterizationSamplesEXT设置的相同rasterizationSamples的samples返回的VkMultisamplePropertiesEXT::sampleLocationGridSize.width以及height一一对应均匀整除
        116.如果一个shader object绑定到任何graphics stage，（1）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV 动态state开启创建，且最近的vkCmdSetCoverageModulationTableEnableNV设置coverageModulationTableEnable为VK_TRUE，则最近的vkCmdSetCoverageModulationTableNV 设置的coverageModulationTableCount 必须等于当前rasterizationSamples除以当前subppas的color samples
                                                           （2）如果VK_NV_viewport_swizzle 拓展开启，则最后vkCmdSetViewportSwizzleNV设置的viewportCount 必须大于等于最后vkCmdSetViewportWithCount设置的viewportCount
        117.如果VK_NV_framebuffer_mixed_samples 拓展开启，且如果在绑定的graphics pipeline中当前subpass有一个depth/stencil attachment以及dep test, stencil test, 或depth bounds test 启用，则当前rasterizationSamples 必须等于depth/stencil attachment的sample count
        118.如果VK_NV_framebuffer_mixed_samples 拓展开启，且如果最后的vkCmdSetRasterizationSamplesEXT设置的当前subpass的任何color attachments的rasterizationSamples 都大于 color samples，则sampleShadingEnable 必须为VK_FALSE
        119.如果当前绑定的graphics pipeline以VkGraphicsPipelineCreateInfo::pStages中的元素的VkPipelineShaderStageCreateInfo::stage设置为VK_SHADER_STAGE_VERTEX_BIT, VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT, VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或者 VK_SHADER_STAGE_GEOMETRY_BIT创建，则Mesh Shader Queries 不能激活
        120.如果dynamic state继承自VkCommandBufferInheritanceViewportScissorInfoNV，则这些动态state的设置必须在该命令之前设置
        121.如果没有绑定graphics pipeline，则（1）vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_VERTEX_BIT
                                             （2）如果tessellationShader 特性开启，vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT，VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT
                                             （3）如果geometryShader 特性开启，vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_GEOMETRY_BIT
                                             （4）vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_FRAGMENT_BIT
                                             （5）如果taskShader 特性开启，vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_TASK_BIT_EXT
                                             （6）如果meshShader 特性开启，vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_MESH_BIT_EXT
                                             （8）如果至少taskShader 和 meshShader一个特性开启，VK_SHADER_STAGE_VERTEX_BIT 或者VK_SHADER_STAGE_MESH_BIT_EXT stages中的一个必须含有有效的VkShaderEXT绑定，另外一个则不含有VkShaderEXT绑定
                                             （9）如果taskShader 和 meshShader特性同时开启，且一个有效的VkShaderEXT 绑定到VK_SHADER_STAGE_MESH_BIT_EXT stage，且该VkShaderEXT不以VK_SHADER_CREATE_NO_TASK_SHADER_BIT_EXT 创建，则一个有效的VkShaderEXT必须绑定到VK_SHADER_STAGE_TASK_BIT_EXT stage
                                             （10）如果taskShader 和 meshShader特性同时开启，且一个有效的VkShaderEXT 绑定到VK_SHADER_STAGE_MESH_BIT_EXT stage，且该VkShaderEXT以VK_SHADER_CREATE_NO_TASK_SHADER_BIT_EXT 创建，则不能有VkShaderEXT绑定到VK_SHADER_STAGE_TASK_BIT_EXT stage
                                             （11）如果一个有效的VkShaderEXT 绑定到VK_SHADER_STAGE_VERTEX_BIT stage，则不能有VkShaderEXT绑定到VK_SHADER_STAGE_TASK_BIT_EXT stage或者VK_SHADER_STAGE_MESH_BIT_EXT stage中的一个
        122.如果任何绑定的graphics shader以VK_SHADER_CREATE_LINK_STAGE_BIT_EXT 创建，（1）所有在相同vkCreateShadersEXT中以VK_SHADER_CREATE_LINK_STAGE_BIT_EXT创建的shaders必须也要绑定
                                                                                     （2）任何相同vkCreateShadersEXT中不以VK_SHADER_CREATE_LINK_STAGE_BIT_EXT创建的shaders不能有任何VkShaderEXT绑定
        123.所有绑定的graphics shader objects 必须以相同或者相同定义的push constant ranges创建
        124.所有绑定的graphics shader objects 必须以相同或者相同定义的descriptor set layouts的数组创建
        125.如果当前的render pass instance以vkCmdBeginRendering开始，且VkRenderingInfo::colorAttachmentCount为1，且有一个resolve mode为 VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID 的color attachment，且绑定了fragment shader，则DepthReplacing 和 StencilRefReplacingEXT execution modes 不能声明
        126.如果一个shader object绑定到 VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则 （1）如果attachmentFeedbackLoopDynamicState 特性开启，则 vkCmdSetAttachmentFeedbackLoopEnableEXT 必须在该命令之前调用
        127.如果包含一个fragment shader stage的绑定的graphics pipeline，（1）且该pipeline以VkPipelineDynamicStateCreateInfo::pDynamicStates中设置有VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE创建，且该fragment shader声明了EarlyFragmentTests execution mode且使用了OpDepthAttachmentReadEXT，则最后vkCmdSetDepthWriteEnable 设置的 depthWriteEnable 必须为VK_FALSE
                                                                        （2）且该pipeline以VkPipelineDynamicStateCreateInfo::pDynamicStates中设置有VK_DYNAMIC_STATE_STENCIL_WRITE_MASK创建，且该fragment shader声明了EarlyFragmentTests execution mode且使用了OpStencilAttachmentReadEXT，则最后vkCmdSetStencilWriteMask 设置的 writeMask 必须为0
        128.如果一个shader object绑定到任何graphics stage 或者绑定的graphics pipeline 以VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT 动态state开启创建，且任何color attachment的format为VK_FORMAT_E5B9G9R9_UFLOAT_PACK32，则vkCmdSetColorWriteMaskEXT设置的pColorWriteMasks参数的对应元素必须包含VK_COLOR_COMPONENT_R_BIT, VK_COLOR_COMPONENT_G_BIT, 和 VK_COLOR_COMPONENT_B_BIT，或者都不包含
        129.如果任何附件开启了blending，且该附件的source 或者 destination blend factors使用第二个颜色输入，则该命令执行的Fragment Execution Model静态使用的任何输出output attachment的Location的最大值必须小于maxFragmentDualSrcAttachments
        130.如果当前的render pass instance以vkCmdBeginRendering开始，（1）如果没有任何shader object绑定到任何graphics stage，则vkCmdSetRenderingAttachmentLocationsKHR 设置的VkRenderingAttachmentLocationInfoKHR::pColorAttachmentLocations中的每个元素必须匹配设置在当前绑定的graphics pipeline中的对应元素
                                                                     （2）如果没有任何shader object绑定到任何graphics stage，绑定的graphics pipeline中的input attchment 索引中映射的附件必须匹配在当前render pass instance的VkRenderingInputAttachmentIndexInfoKHR中设置的
        131.如果当前的render pass instance以vkCmdBeginRendering开始且以VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT标志开始，则绑定的graphics pipeline必须以VK_PIPELINE_CREATE_2_ENABLE_LEGACY_DITHERING_BIT_EXT创建
        132.如果绑定的graphics pipeline以VK_PIPELINE_CREATE_2_ENABLE_LEGACY_DITHERING_BIT_EXT创建，则当前的render pass 必须以vkCmdBeginRendering开始且以VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT标志开始
        133.如果commandBuffer是protected command buffer且protectedNoFault不支持，（1）则任何绑定到pipeline bind point的VkPipeline写入的resource资源不能是unprotected resource
                                                                                 （2）则任何绑定到pipeline bind point的VkPipeline的除了framebuffer-space 以及 compute stages之外的pipeline stage不能写入任何resource
        134.如果该命令使用的任何绑定到pipeline bind point的VkPipeline的shader stages使用RayQueryKHR capability，则commandBuffer不能是一个protected command buffer
        135.所有在vertex shader entry point 的 interface通过声明的vertex input variables访问的vertex input bindings必须是有效的buffer绑定或者为VK_NULL_HANDLE绑定
        136.如果nullDescriptor 特性未开启，则所有在vertex shader entry point 的 interface通过声明的vertex input variables访问的vertex input bindings不能为VK_NULL_HANDLE绑定
        137.如果robustBufferAccess 特性未开启，且pipeline的创建不对vertexInputs以VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT开启创建，则对于指定的vertex buffer binding，任何获取的顶点属性数据必须包含在对应的vertex buffer binding中，参见Vertex Input Description p2586
        138.如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage或者绑定的graphics pipeline以VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY动态state开启创建，则vkCmdSetPrimitiveTopology必须在该命令前设置
        140.如果绑定的graphics pipeline以VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY动态state开启创建，且dynamicPrimitiveTopologyUnrestricted为VK_FALSE，则vkCmdSetPrimitiveTopology设置的primitiveTopology 必须和pipeline创建的VkPipelineInputAssemblyStateCreateInfo::topology相同
        141.如果绑定的graphics pipeline以VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT但不以VK_DYNAMIC_STATE_VERTEX_INPUT_EXT 动态state开启创建，则vkCmdBindVertexBuffers2EXT必须在该命令前设置，且pStrides参数不能为NULL
        142.如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage或者绑定的graphics pipeline以VK_DYNAMIC_STATE_VERTEX_INPUT_EXT动态state开启创建，则
                                            （1）vkCmdSetVertexInputEXT必须在该命令前设置
                                            （2）所有以Input storage class修饰的Vertex Execution Model OpEntryPoint中的变量其Location必须包含在VkVertexInputAttributeDescription2EXT::location指定的location中
                                            （3）如果满足legacyVertexAttributes未开启或者Vertex Execution Model OpEntryPoint中给定对应Location的Input variable的 SPIR-V Type为64-bit的中的一个，则Vertex Execution Model OpEntryPoint中对应Location的所有Input variable的numeric type必须和VkVertexInputAttributeDescription2EXT::format的相同
                                            （4）如果VkVertexInputAttributeDescription2EXT::format含有64-bit 分量，Vertex Execution Model OpEntryPoint中对应Location的所有Input variable的scalar width必须是64-bit的
                                            （5）如果Vertex Execution Model OpEntryPoint中对应Location的Input variable的scalar width是64-bit的，则对应VkVertexInputAttributeDescription2EXT::format必须含有64-bit 分量
                                            （6）如果VkVertexInputAttributeDescription2EXT::format含有64-bit 分量，则Vertex Execution Model OpEntryPoint中对应Location的所有Input variable不能使用该format未呈现的分量
        143.如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage且最近的vkCmdSetPrimitiveTopology设置primitiveTopology为VK_PRIMITIVE_TOPOLOGY_PATCH_LIST，或者绑定的graphics pipeline以VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT动态state开启创建，则vkCmdSetPatchControlPointsEXT必须在该命令前设置
        144.如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage或者绑定的graphics pipeline以VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE动态state开启创建，则vkCmdSetPrimitiveRestartEnable必须在该命令前设置
        145.如果primitiveTopologyListRestart特性未开启，且topology 为VK_PRIMITIVE_TOPOLOGY_POINT_LIST, VK_PRIMITIVE_TOPOLOGY_LINE_LIST, VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST, VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY, 或者 VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY，
                    且有一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage或者绑定的graphics pipeline以VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE动态state开启创建，则vkCmdSetPrimitiveRestartEnable必须设置为VK_FALSE
        146.绑定的graphics pipeline不能以VkGraphicsPipelineCreateInfo::pStages中元素的VkPipelineShaderStageCreateInfo::stage设置为VK_SHADER_STAGE_TASK_BIT_EXT 或者 VK_SHADER_STAGE_MESH_BIT_EXT创建
        147.不能有shader object绑定到VK_SHADER_STAGE_TASK_BIT_EXT或者 VK_SHADER_STAGE_MESH_BIT_EXT中的一个stage
        148.如果maintenance6 未开启，一个有效的index buffer必须被绑定
        149.如果robustBufferAccess2 未开启，则(indexSize × (firstIndex + indexCount) + offset)  必须小于等于绑定的index buffer的大小，其中indexSize 取决于indexType，index buffer, indexType, offset 都通过vkCmdBindIndexBuffer指定
        150.如果绑定的graphics pipeline 以VkGraphicsPipelineCreateInfo::pVertexInputState->pNext中包含一个VkPipelineVertexInputDivisorStateCreateInfoKHR创建，且VkPipelineVertexInputDivisorStateCreateInfoKHR::pVertexBindingDivisors任何元素为除数为1外的值，且VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR::supportsNonZeroFirstInstance 为VK_FALSE，则firstInstance必须为0
        151.如果shader objects用于绘制或者绑定的graphics pipeline以VK_DYNAMIC_STATE_VERTEX_INPUT_EXT动态state开启创建，且vkCmdSetVertexInputEXT设置的pVertexBindingDescriptions中设置该动态state的任何元素有为除数为1外的值，且VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR::supportsNonZeroFirstInstance 为VK_FALSE，则firstInstance必须为0
        152.如果robustBufferAccess2 未开启，则(indexSize × (firstIndex + indexCount) + offset)  必须小于等于绑定的index buffer的大小，其中indexSize 取决于indexType，index buffer, indexType, offset 都通过vkCmdBindIndexBuffer或者vkCmdBindIndexBuffer2KHR 指定，如果使用vkCmdBindIndexBuffer2KHR绑定index buffer，则vkCmdBindIndexBuffer2KHR::size指定index buffer的大小
		153.multiDraw 特性必须开启
        154.drawCount必须小于 VkPhysicalDeviceMultiDrawPropertiesEXT::maxMultiDrawCount
        155.如果drawCount大于0，则pVertexInfo必须为有效的包含一个或多个VkMultiDrawIndexedInfoEXT的数组指针
        156.如果drawCount大于1，则stride必须为4的倍数，且必须大于或者等于sizeof(VkMultiDrawIndexedInfoEXT)
        
        */


        VkDrawIndirectCommand drawIndirectCommand{};//该结构体中的参数类似于 vkCmdDraw 中设置的参数 
		drawIndirectCommand.firstVertex = 0;//要绘制的第一个顶点
        drawIndirectCommand.vertexCount = 3;//要绘制的顶点数
		drawIndirectCommand.firstInstance = 0;//要绘制的第一个实例的ID
		drawIndirectCommand.instanceCount = 1;//要绘制的实例的数量
        /*
        VkDrawIndirectCommand有效用法:
        1.如果绑定的graphics pipeline 以VkGraphicsPipelineCreateInfo::pVertexInputState->pNext中包含一个VkPipelineVertexInputDivisorStateCreateInfoKHR创建，且VkPipelineVertexInputDivisorStateCreateInfoKHR::pVertexBindingDivisors任何元素为除数为1外的值，且VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR::supportsNonZeroFirstInstance 为VK_FALSE，则firstInstance必须为0
        2.如果shader objects用于绘制或者绑定的graphics pipeline以VK_DYNAMIC_STATE_VERTEX_INPUT_EXT动态state开启创建，且vkCmdSetVertexInputEXT设置的pVertexBindingDescriptions中设置该动态state的任何元素有为除数为1外的值，且VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR::supportsNonZeroFirstInstance 为VK_FALSE，则firstInstance必须为0
        3.对于指定的vertex buffer binding，任何获取的顶点属性数据必须包含在对应的vertex buffer binding中，参见Vertex Input Description p2586
		4.如果drawIndirectFirstInstance 特性未开启，则firstInstance必须为0
        */

		// 记录一个非索引绘制的间接绘制命令   该命令类似于vkCmdDraw,只是参数从buffer中读取而不是直接指定   drawCount指明要绘制的数量，stride指明参数之间的字节步长，buffer指明参数的buffer，offset指明参数的起始字节偏移量。buffer中的参数以VkMultiDrawIndirectInfoEXT结构体的形式连续存储。
        vkCmdDrawIndirect(commandBuffer, VkBuffer{/*假设这是一个有效的VkBuffer*/ }/*buffer,是包含绘制参数的VkBuffer.*/,
            0/*offset,是buffer中参数开始的起始字节偏移量.*/, 1/*drawCount，是执行的绘制数量，可以为0.*/, 3/*stride，是buffer中连续绘制参数组之间的字节步长*/);
        /*
        
         vkCmdDrawIndirect有效用法:
        1.如果一个VkSampler以其magFilter或者minFilter等于VK_FILTER_LINEAR创建，则（1）如果reductionMode为VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE，如果用于采样一个VkImageView作为该命令的结果的compareEnable为VK_FALSE，则该image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT
                                                                                 （2）如果reductionMode为VK_SAMPLER_REDUCTION_MODE_MIN 或者VK_SAMPLER_REDUCTION_MODE_MAX之一 用于采样一个VkImageView作为该命令的结果，则该image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT
        2.如果一个VkSampler以其mipmapMode 等于VK_SAMPLER_MIPMAP_MODE_LINEAR创建，则（1）如果reductionMode为VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE，如果用于采样一个VkImageView作为该命令的结果的compareEnable为VK_FALSE，则该image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT
                                                                                 （2）如果reductionMode为VK_SAMPLER_REDUCTION_MODE_MIN 或者VK_SAMPLER_REDUCTION_MODE_MAX之一 用于采样一个VkImageView作为该命令的结果，则该image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT
        3.如果一个VkSampler以其unnormalizedCoordinates等于VK_TRUE用于采样一个VkImageView作为该命令的结果创建，则（1）该image view的levelCount以及layerCount必须为1
                                                                                                                （2）该image view的viewType必须为VK_IMAGE_VIEW_TYPE_1D 或者 VK_IMAGE_VIEW_TYPE_2D
        4.如果一个VkImageView的采样带depth comparison操作，则image view的format features必须包含VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT
        5.如果一个VkImageView使用atomic operations作为该命令的结果进行访问，则image view的format features必须包含VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT
        6.如果一个VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER类型的 descriptor使用atomic operations作为该命令的结果进行访问，则storage texel buffer的format features必须包含VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT
        7.如果一个以VK_FILTER_CUBIC_EXT进行采样的VkImageView作为该命令的结果，则image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT
        8.如果VK_EXT_filter_cubic拓展没有开启，且有任何一个以VK_FILTER_CUBIC_EXT进行采样的VkImageView作为该命令的结果，则其VkImageViewType不能为VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, 或者 VK_IMAGE_VIEW_TYPE_CUBE_ARRAY
        9.任何一个以VK_FILTER_CUBIC_EXT进行采样的作为该命令的结果的VkImageView，其VkImageViewType和format 必须支持cubic filtering，参见vkGetPhysicalDeviceImageFormatProperties2返回的VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic
        10.任何一个以VK_FILTER_CUBIC_EXT进行采样且reduction mode为VK_SAMPLER_REDUCTION_MODE_MIN 或者 VK_SAMPLER_REDUCTION_MODE_MAX之一的作为该命令的结果的VkImageView，其VkImageViewType和format 必须支持带minmax filtering的cubic filtering，参见vkGetPhysicalDeviceImageFormatProperties2返回的VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax
        11.如果cubicRangeClamp特性没有开启，则有任何一个以VK_FILTER_CUBIC_EXT进行采样VkImageView的作为该命令的结果，VkSamplerReductionModeCreateInfo::reductionMode不能为VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM
        12.任何一个以VkSamplerReductionModeCreateInfo::reductionMode为VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM进行采样的作为该命令的结果的VkImageView必须以VK_FILTER_CUBIC_EXT进行采样
        13.如果selectableCubicWeights特性没有开启，则有任何一个以VK_FILTER_CUBIC_EXT进行采样VkImageView的作为该命令的结果，VkSamplerCubicWeightsCreateInfoQCOM::cubicWeights必须为VK_CUBIC_FILTER_WEIGHTS_CATMULL_ROM_QCOM
        14.任何一个以VkImageCreateInfo::flags含VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV创建的采样作为该命令结果的VkImage必须以VkSamplerAddressMode为VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE 进行采样
        15.对于任何作为storage image写入的VkImageView，且其OpTypeImage的format未知，则该image view的 format features必须包含VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT
        16.对于任何作为storage image读取的VkImageView，且其OpTypeImage的format未知，则该image view的 format features必须包含VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT
        17.对于任何作为storage storage texel buffer写入的VkBufferView，且其OpTypeImage的format未知，则该buffer view的 buffer features必须包含VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT
        18.对于任何作为storage storage texel buffer读取的VkBufferView，且其OpTypeImage的format未知，则该buffer view的 buffer features必须包含VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT
        19.对于每个在绑定的shader中静态使用的set n，一个descriptor set必须被绑定到相同pipeline bind point的set n处，该set n必须和创建当前VkPipeline的VkPipelineLayout或者和创建当前VkShaderEXT的VkDescriptorSetLayout 数组的set n处的布局兼容，参见Pipeline Layout Compatibility p1280
        20.对于每个在绑定的shader中静态使用的push constant，一个push constant值必须被绑定到相同pipeline bind point的对应处，该push constant必须和创建当前VkPipeline的VkPipelineLayout或者和创建当前VkShaderEXT的VkDescriptorSetLayout 数组中的对应处的布局兼容，参见Pipeline Layout Compatibility p1280
        21.如果maintenance4特性没有开启，则对于每个在绑定的shader中静态使用的push constant，一个push constant值必须被设置到相同pipeline bind point的对应处，该push constant必须和创建当前VkPipeline的VkPipelineLayout或者和创建当前VkShaderEXT的VkDescriptorSetLayout 数组中的对应处的布局兼容，参见Pipeline Layout Compatibility p1280
        22.每一个通过vkCmdBindDescriptorSets绑定的descriptor set的descriptors,如果是被不以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建的，且已经绑定到该命令使用的pipeline bind point的VkPipeline静态使用的，则这些descriptors必须是有效的，参见 descriptor validity p1328
        23.如果通过vkCmdBindDescriptorSets指定绑定到pipeline bind point的VkPipeline要使用的descriptors，则绑定的VkPipeline不能以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建
        24.在vkCmdSetDescriptorBufferOffsetsEXT中指定绑定的descriptor buffers的descriptors，则（1）如果绑定到pipeline bind point的该命令会使用的VkPipeline以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建，且这些descriptors是动态使用的，则这些descriptors必须是有效的
                                                                                              （2）如果绑定到pipeline bind point的对应stage的该命令会使用的VkShaderEXT，且这些descriptors是动态使用的，则这些descriptors必须是有效的
        25.在vkCmdSetDescriptorBufferOffsetsEXT中指定的descriptors在绑定到pipeline bind point的VkPipeline中使用，则VkPipeline必须以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建
        26.如果一个descriptor在以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建的VkPipeline中动态使用，则descriptor memory必须是驻留内存
        27.如果一个descriptor在以其VkDescriptorSetLayout以VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建的VkShaderEXT中动态使用，则descriptor memory必须是驻留内存
        28.如果shaderObject 特性没有开启，一个有效的pipeline必须绑定到这个命令使用的绑定到pipeline bind point上
        29.如果一个pipeline绑定到该命令使用的pipeline bind point上，则不能有任何动态state 设置命令设置任何该VkPipeline 中没有指定的动态 state
        30.如果一个VkPipeline绑定到该命令使用的pipeline bind point上 或者任何一个会访问一个使用unnormalized coordinates的VkSampler的 VkShaderEXT绑定到该命令使用的pipeline bind point上的pipeline的对应stage，则
                                                                                    （1）在任何shader stage中，VkSampler不能用来采样任何类型为VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY 或者 VK_IMAGE_VIEW_TYPE_CUBE_ARRAY的VkImageView
                                                                                    （2）在任何shader stage中，该VkSampler不能和任何带有名字中带有ImplicitLod，Dref 或者 Proj 的SPIR-V OpImageSample* 或者 OpImageSparseSample*指令一起使用
                                                                                    （3）在任何shader stage中，该VkSampler不能和任何包含 LOD bias或者offset 值 的SPIR-V OpImageSample* or OpImageSparseSample*指令一起使用
        31.如果shaderObject开启，一个有效的pipeline必须绑定到该命令使用的pipeline bind point上或者一个有效的shader objects以及VK_NULL_HANDLE的组合必须绑定到该命令使用的pipeline bind point每一个支持的shader stage上
        32.如何绑定到该命令使用的pipeline bind point上的VkPipeline的任何stage会访问一个uniform buffer，且该stage对uniformBuffers不以启用VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT或者VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT 创建，且robustBufferAccess特性未开启，则该stage就不能访问绑定到相同pipeline bind point的descriptor set指定的buffer范围外的值
        33.如果robustBufferAccess特性未开启，且任何会访问uniform buffer的绑定到该命令使用的pipeline bind point上对应shader stage的VkShaderEXT，则其不能访问绑定到相同pipeline bind point的descriptor set指定的buffer范围外的值
        34.如何绑定到该命令使用的pipeline bind point上的VkPipeline的任何stage会访问一个storage buffer，且该stage对storageBuffers不以启用VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT或者VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT 创建，且robustBufferAccess特性未开启，则该stage就不能访问绑定到相同pipeline bind point的descriptor set指定的buffer范围外的值
        35.如果robustBufferAccess特性未开启，且任何会访问storage buffer的绑定到该命令使用的pipeline bind point上对应shader stage的VkShaderEXT，则其不能访问绑定到相同pipeline bind point的descriptor set指定的buffer范围外的值
        36.如果commandBuffer 是一个unprotected command buffer，且protectedNoFault 未支持，则任何绑定的shaders访问的资源不能是一个protected resource
        37.如果一个绑定的shader访问一个VkSampler 或者 VkImageView ，且启用了sampler Y′C BCR conversion，则只能使用OpImageSample* 或者 OpImageSparseSample*指令，不能使用ConstOffset 以及 Offset操作符
        38.如果一个VkImageView作为该命令的结果进行访问，则（1）image view 的viewType 必须匹配Instruction/Sampler/Image View Validation p1481中描述的OpTypeImage的Dim操作符
                                                          （2）image view 的foamrt的numeric type 必须匹配OpTypeImage的Sampled Type操作符
        39.如果一个VkImageView以一个不是VK_FORMAT_A8_UNORM_KHR的format创建且通过OpImageWrite作为该命令的结果进行访问，则该命令的Texel 操作符的Type必须至少包含和 image view的 format含有的components的个数相同的components个数
        40.如果一个VkImageView以VK_FORMAT_A8_UNORM_KHR的format创建且通过OpImageWrite作为该命令的结果进行访问，则该命令的Texel 操作符的Type必须包含4个components
        41.如果一个VkBufferView通过OpImageWrite作为该命令的结果进行访问，则该命令的Texel 操作符的Type必须至少包含和 buffer view的 format含有的components的个数相同的components个数
        42.如果一个带64-bit component的VkFormat的VkImageView作为该命令的结果进行访问，则该命令的OpTypeImage操作符的SampledType的宽度必须为64
        43.如果一个带少于64-bit component的VkFormat的VkImageView作为该命令的结果进行访问，则该命令的OpTypeImage操作符的SampledType的宽度必须为32
        44.如果一个带64-bit component的VkFormat的VkBufferView作为该命令的结果进行访问，则该命令的OpTypeImage操作符的SampledType的宽度必须为64位
        45.如果一个带少于64-bit component的VkFormat的VkBufferView作为该命令的结果进行访问，则该命令的OpTypeImage操作符的SampledType的宽度必须为32
        46.如果sparseImageInt64Atomics 特性未开启，则以VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT创建的VkImage对象不能被SampledType宽度为64位的OpTypeImage的atomic instructions访问
        47.如果sparseImageInt64Atomics 特性未开启，则以VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT创建的VkBuffer对象不能被SampledType宽度为64位的OpTypeImage的atomic instructions访问
        48.如果OpImageWeightedSampleQCOM用来采样一个作为该命令的结果的VkImageView，则该image view的format features必须包含VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM
        49.如果OpImageWeightedSampleQCOM用来采样一个作为该命令的结果的sample weight image的VkImageView，则该image view的format features必须包含VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM
        50.如果OpImageBoxFilterQCOM用来采样一个作为该命令的结果的VkImageView，则该image view的format features必须包含VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM
        51.如果OpImageBlockMatchSSDQCOM，或者 OpImageBlockMatchSADQCOM用来读取一个作为该命令的结果的VkImageView，则（1）该image view的format features必须包含VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM
                                                                                                                   （2）如果是读取的reference image，指定的reference coordinates不能在integer texel coordinate validation 时候失败
        52.如果OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchWindowSSDQCOM, OpImageBlockMatchWindowSADQCOM, OpImageBlockMatchGatherSSDQCOM,
                                                    OpImageBlockMatchGatherSADQCOM, OpImageBlockMatchSSDQCOM, 或者 OpImageBlockMatchSADQCOM用来采样一个作为该命令的结果的VkImageView，则该VkSampler必须以VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM创建
        53.如果任何除了OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchWindowSSDQCOM, OpImageBlockMatchWindowSADQCOM, OpImageBlockMatchGatherSSDQCOM, OpImageBlockMatchGatherSADQCOM, OpImageBlockMatchSSDQCOM, 或者 OpImageBlockMatchSADQCOM之外的指令使用VkSampler进行采样作为该命令的结果，则该sampler不能以VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM 创建
        54.如果OpImageBlockMatchWindow*QCOM or OpImageBlockMatchGather*QCOM指令用来读取VkImageView作为该命令的结果，则（1）VkImageView的format features必须包含VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM
                                                                                                                      （2）VkImageView的format必须只含有一个component
        55.如果OpImageBlockMatchWindow*QCOM or OpImageBlockMatchGather*QCOM指令用来读取一个引用的image作为该命令的结果，则指定的 reference coordinates不能在integer texel coordinate validation 时候失败
        56.任何该命令执行的shader invocation必须已经终止
        57.如果有一个类型位为VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM, VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, 或者 VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT中任意一个的descriptor作为该命令的结果进行访问，则该descriptor所指的image subresource的layout必须和该descriptor被写入时的layout相同。
        58.当前的 render pass  必须和绑定到VK_PIPELINE_BIND_POINT_GRAPHICS上的VkPipeline 创建时候的VkGraphicsPipelineCreateInfo中指定的renderPass兼容
        59.当前的 render pass  的subpass index必须和绑定到VK_PIPELINE_BIND_POINT_GRAPHICS上的VkPipeline 创建时候的VkGraphicsPipelineCreateInfo中指定的subpass相同
        60.如果任何shader静态访问一个input attachment，则有效的descriptor必须通过VkDescriptorSet被绑定到该pipeline中
        61.如果任何该pipeline执行shader以SubpassData的Dim操作符访问一个OpTypeImage变量，则该变量必须被一个对应当前subpass的input attachment的InputAttachmentIndex修饰
        62.在subpass中访问的Input attachment views必须以和该subpass相同定义的VkFormat创建，且必须以一个和当前绑定的VkFramebuffer的该附件引用的subpass的pInputAttachments[InputAttachmentIndex]附件兼容的VkImageView创建，参见Fragment Input Attachment Compatibility p1408
        63.在动态render pass中访问以VkRenderingInputAttachmentIndexInfoKHR的InputAttachmentIndex，或者VkRenderingInputAttachmentIndexInfoKHR:pDepthInputAttachmentIndex 或者 VkRenderingInputAttachmentIndexInfoKHR:pStencilInputAttachmentIndex为NULL情况下不指定InputAttachmentIndex的引用的Input attachment views，必须以和VkRenderingInfo中对应color, depth, 或者 stencil attachment兼容的VkImageView创建
        64.如果VkRenderingInputAttachmentIndexInfoKHR::pDepthInputAttachmentIndex 以及 VkRenderingInputAttachmentIndexInfoKHR::pStencilInputAttachmentIndex不为NULL，则在动态render pass中通过shader object访问Input attachment views必须指明InputAttachmentIndex
        65.如果在动态render pass中通过shader object访问Input attachment views指明了InputAttachmentIndex，则InputAttachmentIndex必须匹配VkRenderingInputAttachmentIndexInfoKHR中的index
        66.当前render pass所用的附件对应的image subresource底层内存的写入只能作为该命令的一个附件写入
        67.如果一个color attachment在之前的该subpass的命令中以load, store, 或者 resolve operations进行了写入，则其layout不为VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT，且有当前绑定的pipeline设有VK_PIPELINE_CREATE_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT，或者
                                        最后的vkCmdSetAttachmentFeedbackLoopEnableEXT调用包含VK_IMAGE_ASPECT_COLOR_BIT以及 没有绑定的pipeline 或者绑定的pipeline以VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT创建，则该附件只能以附件进行访问的，这两种情况中之一
        68.如果一个depth attachment在之前的该subpass的命令中以load, store, 或者 resolve operations进行了写入，则其layout不为VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT，且有当前绑定的pipeline设有VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT，或者
                                        最后的vkCmdSetAttachmentFeedbackLoopEnableEXT调用包含VK_IMAGE_ASPECT_DEPTH_BIT以及 没有绑定的pipeline 或者绑定的pipeline以VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT创建，则该附件只能以附件进行访问的，这两种情况中之一
        69.如果一个stencil attachment在之前的该subpass的命令中以load, store, 或者 resolve operations进行了写入，则其layout不为VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT，且有当前绑定的pipeline设有VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT，或者
                                        最后的vkCmdSetAttachmentFeedbackLoopEnableEXT调用包含VK_IMAGE_ASPECT_STENCIL_BIT以及 没有绑定的pipeline 或者绑定的pipeline以VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT创建，则该附件只能以附件进行访问的，这两种情况中之一
        70.如果一个attachment在之前的该subpass的命令中以load, store, 或者 resolve operations进行了写入,则该附件就不能再以除作为一个附件，storage image或者sampled image被该命令访问
        71.如果在之前的命令的subpass中以用作附件外的方式访问访问了一个当权subpass的附件所对的image subresource，则该命令就不能再将该image subresource用作附件进行写入
        72.如果当前render pass使用一个depth/stencil attachment，则（1）如果depth aspect的layout为read-only的layout，则不能启用depth writes
                                                                  （2）如果stencil aspect的layout为read-only的layout，front 以及 back writeMask不为0，且stencil 测试开启，则所有stencil 操作必须为VK_STENCIL_OP_KEEP
        73.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_VIEWPORT动态state开启创建，则vkCmdSetViewport必须在该命令之前设置
                                        （2）以VK_DYNAMIC_STATE_SCISSOR动态state开启创建，则vkCmdSetScissor必须在该命令之前设置
                                        （3）以VK_DYNAMIC_STATE_LINE_WIDTH动态state开启创建，则vkCmdSetLineWidth必须在该命令之前设置
                                        （4）以VK_DYNAMIC_STATE_DEPTH_BIAS动态state开启创建，则vkCmdSetDepthBias或者vkCmdSetDepthBias2EXT 必须在该命令之前设置
                                        （5）以VK_DYNAMIC_STATE_BLEND_CONSTANTS动态state开启创建，则vkCmdSetBlendConstants 必须在该命令之前设置
                                        （6）以VK_DYNAMIC_STATE_DEPTH_BOUNDS动态state开启创建，且如果当前depthBoundsTestEnable为VK_TRUE， 则vkCmdSetDepthBounds 必须在该命令之前设置
                                        （7）以VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK动态state开启创建，且如果当前stencilTestEnable为VK_TRUE， 则vkCmdSetStencilCompareMask 必须在该命令之前设置
                                        （8）以VK_DYNAMIC_STATE_STENCIL_WRITE_MASK动态state开启创建，且如果当前stencilTestEnable为VK_TRUE， 则vkCmdSetStencilWriteMask 必须在该命令之前设置
                                        （9）以VK_DYNAMIC_STATE_STENCIL_REFERENCE动态state开启创建，且如果当前stencilTestEnable为VK_TRUE， 则vkCmdSetStencilReference 必须在该命令之前设置
                                        （10）以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT动态state开启创建， 则vkCmdSetSampleLocationsEXT 必须在该命令之前设置
                                        （11）以VK_DYNAMIC_STATE_CULL_MODE动态state开启创建， 则vkCmdSetCullMode 必须在该命令之前设置
                                        （12）以VK_DYNAMIC_STATE_FRONT_FACE动态state开启创建， 则vkCmdSetFrontFace 必须在该命令之前设置
                                        （13）以VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE动态state开启创建， 则vkCmdSetDepthTestEnable 必须在该命令之前设置
                                        （14）以VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE动态state开启创建， 则vkCmdSetDepthWriteEnable 必须在该命令之前设置
                                        （15）以VK_DYNAMIC_STATE_DEPTH_COMPARE_OP动态state开启创建， 则vkCmdSetDepthCompareOp 必须在该命令之前设置
                                        （16）以VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE动态state开启创建， 则vkCmdSetDepthBoundsTestEnable 必须在该命令之前设置
                                        （17）以VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE动态state开启创建， 则vkCmdSetStencilTestEnable 必须在该命令之前设置
                                        （18）以VK_DYNAMIC_STATE_STENCIL_OP动态state开启创建， 则vkCmdSetStencilOp 必须在该命令之前设置
                                        （19）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT但不以VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT 动态state开启创建， 则vkCmdSetViewportWithCount 必须在该命令之前设置，且vkCmdSetViewportWithCount设置的viewportCount必须匹配pipeline的VkPipelineViewportStateCreateInfo::scissorCount
                                        （20）以VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT但不以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT 动态state开启创建， 则vkCmdSetScissorWithCount 必须在该命令之前设置，且vkCmdSetScissorWithCount设置的scissorCount必须匹配pipeline的VkPipelineViewportStateCreateInfo::viewportCount
                                        （21）以VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT和VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT 动态state同时开启创建， 则vkCmdSetViewportWithCount以及vkCmdSetScissorWithCount 必须在该命令之前设置，且vkCmdSetViewportWithCount设置的viewportCount必须匹配vkCmdSetScissorWithCount设置的scissorCount
                                        （22）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT但不以VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV 动态state开启创建， 则绑定的pipeline必须以VkPipelineViewportWScalingStateCreateInfoNV::viewportCount 大于等于最近vkCmdSetViewportWithCount设置的viewportCount创建
                                        （23）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT和VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV 动态state开启创建， 则最近调用的vkCmdSetViewportWScalingNV设置的viewportCount 必须大于等于最近vkCmdSetViewportWithCount设置的viewportCount
                                        （24）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT但不以VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV 动态state开启创建， 则绑定的pipeline必须以VkPipelineViewportShadingRateImageStateCreateInfoNV::viewportCount 大于等于最近vkCmdSetViewportWithCount设置的viewportCount创建
                                        （25）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT和VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV 动态state开启创建， 则最近调用的vkCmdSetViewportShadingRatePaletteNV设置的viewportCount 必须大于等于最近vkCmdSetViewportWithCount设置的viewportCount
                                        （26）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT动态state开启且VkPipelineViewportStateCreateInfo的pNext中含有一个VkPipelineViewportSwizzleStateCreateInfoNV 创建， 则绑定的pipeline必须以VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount 大于等于最近vkCmdSetViewportWithCount设置的viewportCount创建
                                        （27）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT动态state开启且VkPipelineViewportStateCreateInfo的pNext中含有一个VkPipelineViewportExclusiveScissorStateCreateInfoNV 创建， 则绑定的pipeline必须以VkPipelineViewportExclusiveScissorStateCreateInfoNV::exclusiveScissorCount 大于等于最近vkCmdSetViewportWithCount设置的viewportCount创建
                                        （28）以VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_ENABLE_NV动态state开启创建， 则vkCmdSetExclusiveScissorEnableNV 必须在该命令之前设置
                                        （29）以VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV动态state开启创建， 则vkCmdSetExclusiveScissorNV 必须在该命令之前设置
                                        （30）以VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE动态state开启创建， 则vkCmdSetRasterizerDiscardEnable 必须在该命令之前设置
                                        （31）以VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE动态state开启创建， 则vkCmdSetDepthBiasEnable 必须在该命令之前设置
                                        （32）以VK_DYNAMIC_STATE_LOGIC_OP_EXT动态state开启创建， 则vkCmdSetLogicOpEXT 必须在该命令之前设置且参数logicOp必须是一个有效的VkLogicOp值
        74.如果一个shader object绑定到任何graphics stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                        （1）如果最靠近当前命令的vkCmdSetPolygonModeEXT设置polygonMode为VK_POLYGON_MODE_LINE或者是任何line topology，则vkCmdSetLineWidth必须在该命令之前设置
                                        （2）如果最靠近当前命令的vkCmdSetDepthBiasEnable设置depthBiasEnable为VK_TRUE，则vkCmdSetDepthBias 或者 vkCmdSetDepthBias2EXT必须在该命令之前设置
                                        （3）如果最靠近当前命令的vkCmdSetDepthBoundsTestEnable设置depthBoundsTestEnable为VK_TRUE，则vkCmdSetDepthBounds必须在该命令之前设置
                                        （4）如果最靠近当前命令的vkCmdSetStencilTestEnable设置stencilTestEnable为VK_TRUE，则vkCmdSetStencilCompareMask必须在该命令之前设置
                                        （5）如果最靠近当前命令的vkCmdSetStencilTestEnable设置stencilTestEnable为VK_TRUE，则vkCmdSetStencilWriteMask必须在该命令之前设置
                                        （6）如果最靠近当前命令的vkCmdSetStencilTestEnable设置stencilTestEnable为VK_TRUE，则vkCmdSetStencilReference必须在该命令之前设置
                                        （7）如果最靠近当前命令的vkCmdSetSampleLocationsEnableEXT设置sampleLocationsEnable为VK_TRUE，则vkCmdSetSampleLocationsEXT必须在该命令之前设置
                                        （8）则vkCmdSetCullMode必须在该命令之前设置
                                        （9）则vkCmdSetFrontFace必须在该命令之前设置
                                        （10）则vkCmdSetDepthTestEnable 必须在该命令之前设置
                                        （11）则vkCmdSetDepthWriteEnable 必须在该命令之前设置
                                        （12）如果最靠近当前命令的vkCmdSetDepthTestEnable设置depthTestEnable为VK_TRUE，则vkCmdSetDepthCompareOp 必须在该命令之前设置
                                        （13）则vkCmdSetDepthBoundsTestEnable 必须在该命令之前设置
                                        （14）则vkCmdSetStencilTestEnable 必须在该命令之前设置
                                        （15）如果最靠近当前命令的vkCmdSetStencilTestEnable设置stencilTestEnable为VK_TRUE，则vkCmdSetStencilOp 必须在该命令之前设置
                                        （16）
                                        （17）如果shadingRateImage特性开启，则vkCmdSetCoarseSampleOrderNV 必须在该命令之前设置
                                        （18）如果shadingRateImage特性开启，且最靠近当前命令的vkCmdSetShadingRateImageEnableNV设置shadingRateImageEnable为VK_TRUE，则vkCmdSetViewportShadingRatePaletteNV 必须在该命令之前设置
                                        （19）如果shadingRateImage特性开启，且最靠近当前命令的vkCmdSetShadingRateImageEnableNV设置shadingRateImageEnable为VK_TRUE，则最近的vkCmdSetViewportShadingRatePaletteNV设置的viewportCount 必须大于等于vkCmdSetViewportWithCount设置的viewportCount
                                        （20）则vkCmdSetDepthBiasEnable必须在该命令之前设置
        75.如果一个输出line primitives的shader object绑定到VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或者 VK_SHADER_STAGE_GEOMETRY_BIT，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则vkCmdSetLineWidth必须在该命令之前设置
        76.如果一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最靠近当前命令的vkCmdSetColorBlendEnableEXT设置pColorBlendEnables任何元素为VK_TRUE，且
                            最靠近当前命令的vkCmdSetColorBlendEquationEXT设置pColorBlendEquations相同元素的VkColorBlendEquationEXT的VkBlendFactor成员为VK_BLEND_FACTOR_CONSTANT_COLOR, VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR, VK_BLEND_FACTOR_CONSTANT_ALPHA, 或者 VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA，则vkCmdSetBlendConstants必须在该命令之前设置
        77.如果该命令记录在开启了multiview的render pass instance中，则最大的instance 索引必须小于等于VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex
        78.如果绑定的graphics pipeline以VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable设置为VK_TRUE创建且当前的subpass含有一个 depth/stencil attachment，则该attachment必须以VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT创建
        >>78.5  .如果一个shader object绑定到任何graphics stage，则（1）vkCmdSetViewportWithCount 和vkCmdSetScissorWithCount 必须同时在该命令之前设置，且vkCmdSetViewportWithCount设置的viewportCount必须匹配vkCmdSetScissorWithCount设置的scissorCount
                                                                  （2）则vkCmdSetRasterizerDiscardEnable 必须在该命令之前设置
        79.如果VK_NV_clip_space_w_scaling拓展开启，且shader object绑定到任何graphics stage，且最近的vkCmdSetViewportWScalingEnableNV设置viewportWScalingEnable为VK_TRUE，则（1）vkCmdSetViewportWScalingNV必须在该命令前设置
                                                                                                                                                                           （2）最近vkCmdSetViewportWScalingNV设置的viewportCount必须大于等于vkCmdSetViewportWithCount设置的viewportCount
        80.如果exclusiveScissor 特性开启，且shader object绑定到任何graphics stage，，则（1）vkCmdSetExclusiveScissorEnableNV必须在该命令前设置
                                                                                       （2）最近的vkCmdSetExclusiveScissorEnableNV调用设置的pExclusiveScissorEnables中的任何元素为VK_TRUE,则vkCmdSetExclusiveScissorNV必须在该命令前设置
        81.如果一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最靠近当前命令的vkCmdSetLogicOpEnableEXT设置logicOpEnable任何元素为VK_TRUE，则vkCmdSetLogicOpEXT 必须在该命令之前设置且参数logicOp必须是一个有效的VkLogicOp值
        82.如果primitiveFragmentShadingRateWithMultipleViewports限制不支持，则（1）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT动态state开启创建，且任何该pipeline的shader stage会写入PrimitiveShadingRateKHR built-in修饰的变量，则vkCmdSetViewportWithCount 必须在该命令之前设置且参数viewportCount必须是1
                                                                              （2）任何绑定的graphics pipeline的shader stage会写入PrimitiveShadingRateKHR built-in修饰的变量，则vkCmdSetViewportWithCount 必须在该命令之前设置且参数viewportCount必须是1
        83.如果graphics pipeline中未开启rasterization，则对subpass中的每个color attachment，如果其对应的image view 的format features不包含VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT，则pColorBlendState中其对应pAttachments中元素的blendEnable必须为VK_FALSE
        84.如果一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则对于render pass中的每个color attachment，如果其对应的image view 的format features不包含VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT， 则最近的vkCmdSetColorBlendEnableEXT设置的pColorBlendEnables中该附件的对应元素必须为VK_FALSE
        85.如果graphics pipeline中未开启rasterization，有VK_AMD_mixed_attachment_samples拓展未开启，VK_NV_framebuffer_mixed_samples拓展未开启，multisampledRenderToSingleSampled特性未开启，则当前绑定的pipeline的rasterizationSamples必须和当前subpass的color 以及/或者 depth/stencil attachments的相同
        86.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且有VK_AMD_mixed_attachment_samples拓展未开启，VK_NV_framebuffer_mixed_samples拓展未开启，multisampledRenderToSingleSampled特性未开启，则最近vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples必须和当前subpass的color 以及/或者 depth/stencil attachments的相同
        87.如果一个shader object绑定到任何graphics stage，则当前的render pass instance必须以vkCmdBeginRendering开始
        88.如果当前的render pass instance以vkCmdBeginRendering开始，（1）如果pDepthAttachment的imageView不为VK_NULL_HANDLE，且pDepthAttachment的layout不为VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL，则该命令不能写入任何值到depth attachment
                                                                    （2）如果pStencilAttachment的imageView不为VK_NULL_HANDLE，且pStencilAttachment的layout不为VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL，则该命令不能写入任何值到stencil attachment
                                                                    （3）如果pDepthAttachment的imageView不为VK_NULL_HANDLE，且pDepthAttachment的layout为VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL，则该命令不能写入任何值到depth attachment
                                                                    （4）如果pStencilAttachment的imageView不为VK_NULL_HANDLE，且pStencilAttachment的layout为VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL，则该命令不能写入任何值到stencil attachment
                                                                    （5）如果pDepthAttachment的imageView不为VK_NULL_HANDLE，且pDepthAttachment的layout为VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL，则该命令不能写入任何值到depth attachment
                                                                    （6）如果pStencilAttachment的imageView不为VK_NULL_HANDLE，且pStencilAttachment的layout为VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL，则该命令不能写入任何值到stencil attachment
                                                                    （7）则当前绑定的graphics pipeline必须以含VkPipelineRenderingCreateInfo::viewMask等于VkRenderingInfo::viewMask创建
                                                                    （8）如果带有VkRenderingInfo::colorAttachmentCount为1，则没有shader object绑定到任何graphics stage，且一个color attachment的 resolve mode为VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID，则VkRenderingInfo::pColorAttachments中每个resolveImageView不为VK_NULL_HANDLE的元素其对应image必须以和创建当前绑定的pipeline 相同的VkExternalFormatANDROID::externalFormat创建
                                                                    （9）如果没有shader object绑定到任何graphics stage，如果绑定的graphics pipeline以一个非零值VkExternalFormatANDROID::externalFormat创建且启用VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态设置，则vkCmdSetColorBlendEnableEXT必须在该命令前设置blend enable为VK_FALSE
                                                                    （10）如果没有shader object绑定到任何graphics stage，如果绑定的graphics pipeline以一个非零值VkExternalFormatANDROID::externalFormat创建且启用VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态设置，则vkCmdSetRasterizationSamplesEXT必须在该命令前设置rasterizationSamples为VK_SAMPLE_COUNT_1_BIT
                                                                    （11）如果没有shader object绑定到任何graphics stage，如果绑定的graphics pipeline以一个非零值VkExternalFormatANDROID::externalFormat创建且启用VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR动态设置，则vkCmdSetFragmentShadingRateKHR必须在该命令前设置pFragmentSize->width为1，pFragmentSize->height为1
        89.如果dynamicRenderingUnusedAttachments特性未开启，且当前的render pass instance以vkCmdBeginRendering开始，则
                                                                （1）当前绑定的graphics pipeline必须以含VkPipelineRenderingCreateInfo::colorAttachmentCount等于VkRenderingInfo::colorAttachmentCount创建
                                                                （2）如果VkRenderingInfo::colorAttachmentCount大于0，则VkRenderingInfo::pColorAttachments 中每一个其imageView不为VK_NULL_HANDLE的元素的VkImageView必须以VkFormat对应绑定的graphics pipeline的VkPipelineRenderingCreateInfo::pColorAttachmentFormats指明的format创建
                                                                （3）如果VkRenderingInfo::colorAttachmentCount大于0，则VkRenderingInfo::pColorAttachments 中每一个其imageView为VK_NULL_HANDLE的元素对应绑定的graphics pipeline的VkPipelineRenderingCreateInfo::pColorAttachmentFormats指明的format必须为VK_FORMAT_UNDEFINED
                                                                （4）如果VkRenderingInfo::pDepthAttachment->imageView为VK_NULL_HANDLE，则创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::depthAttachmentFormat必须为VK_FORMAT_UNDEFINED
                                                                （5）如果VkRenderingInfo::pDepthAttachment->imageView不为VK_NULL_HANDLE，则创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::depthAttachmentFormat必须和创建VkRenderingInfo::pDepthAttachment->imageView的VkFormat相同
                                                                （6）如果VkRenderingInfo::pStencilAttachment->imageView为VK_NULL_HANDLE，则创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::stencilAttachmentFormat必须为VK_FORMAT_UNDEFINED
                                                                （7）如果VkRenderingInfo::pStencilAttachment->imageView不为VK_NULL_HANDLE，则创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::stencilAttachmentFormat必须和创建VkRenderingInfo::pStencilAttachment->imageView的VkFormat相同
        90.如果dynamicRenderingUnusedAttachments特性开启，且当前的render pass instance以vkCmdBeginRendering开始，则
                                                                （1）如果VkRenderingInfo::colorAttachmentCount大于0，则VkRenderingInfo::pColorAttachments 中每一个其imageView不为VK_NULL_HANDLE的元素的VkImageView必须以VkFormat对应绑定的graphics pipeline的VkPipelineRenderingCreateInfo::pColorAttachmentFormats指明的format创建，或者是对应元素为VK_FORMAT_UNDEFINED创建
                                                                （2）如果VkRenderingInfo::pDepthAttachment->imageView不为VK_NULL_HANDLE，且创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::depthAttachmentFormat和创建VkRenderingInfo::pDepthAttachment->imageView的VkFormat不同，则该format必须为VK_FORMAT_UNDEFINED
                                                                （3）如果VkRenderingInfo::pStencilAttachment->imageView不为VK_NULL_HANDLE，且创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::stencilAttachmentFormat和创建VkRenderingInfo::pStencilAttachment->imageView的VkFormat不同，则该format必须为VK_FORMAT_UNDEFINED
        91.如果没有shader object绑定到任何graphics stage，且当前的render pass instance以vkCmdBeginRendering开始且VkRenderingInfo::colorAttachmentCount为1，且一个color attachment的 resolve mode为VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID，则VkRenderingInfo::pColorAttachments中每个resolveImageView不为VK_NULL_HANDLE的元素其对应image必须以和创建当前绑定的pipeline 相同的VkExternalFormatANDROID::externalFormat创建
        92.如果有一个shader object绑定到任何graphics stage，且当前的render pass 包含一个使用VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID resolve mode的color attachment，则（1）vkCmdSetColorBlendEnableEXT必须在该命令前设置blend enable为VK_FALSE
                                                                                                                                                                                 （2）则vkCmdSetRasterizationSamplesEXT必须在该命令前设置rasterizationSamples为VK_SAMPLE_COUNT_1_BIT
                                                                                                                                                                                 （3）则vkCmdSetFragmentShadingRateKHR必须在该命令前设置pFragmentSize->width为1，pFragmentSize->height为1
        93.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT动态state开启创建， 则vkCmdSetColorWriteEnableEXT 必须在该命令之前设置，且设置的attachmentCount必须大于等于创建当前绑定的pipeline的VkPipelineColorBlendStateCreateInfo::attachmentCount
                                        （2）以VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT动态state开启创建， 则vkCmdSetDiscardRectangleEXT 必须在该命令之前为每个VkPipelineDiscardRectangleStateCreateInfoEXT::discardRectangleCount指明的discard rectangle 设置
                                        （3）以VK_DYNAMIC_STATE_DISCARD_RECTANGLE_ENABLE_EXT动态state开启创建， 则vkCmdSetDiscardRectangleEnableEXT 必须在该命令之前设置
                                        （4）以VK_DYNAMIC_STATE_DISCARD_RECTANGLE_MODE_EXT动态state开启创建， 则vkCmdSetDiscardRectangleModeEXT 必须在该命令之前设置
        94.如果有一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                        （1）如果colorWriteEnable特性在device上开启，则vkCmdSetColorWriteEnableEXT 必须在该命令之前设置，且设置的attachmentCount必须大于等于当前render pass instance的color attachment的数量
                                        （2）如果VK_EXT_discard_rectangles拓展开启，且最近的vkCmdSetDiscardRectangleEnableEXT设置discardRectangleEnable为VK_TRUE， 则vkCmdSetDiscardRectangleEXT 必须在该命令之前设置
                                        （3）如果VK_EXT_discard_rectangles拓展开启， 则vkCmdSetDiscardRectangleEnableEXT 必须在该命令之前设置
                                        （4）如果VK_EXT_discard_rectangles拓展开启， 则最近的vkCmdSetDiscardRectangleEnableEXT设置discardRectangleEnable为VK_TRUE，则vkCmdSetDiscardRectangleModeEXT 必须在该命令之前设置
        95.如果当前的render pass instance以vkCmdBeginRendering开始，则（1）如果VkRenderingFragmentShadingRateAttachmentInfoKHR::imageView不为VK_NULL_HANDLE，则当前绑定的graphics pipeline必须以VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR创建
                                                                      （2）如果VkRenderingFragmentDensityMapAttachmentInfoEXT::imageView不为VK_NULL_HANDLE，则当前绑定的graphics pipeline必须以VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT创建
                                                                      （3）且含VkRenderingInfo::colorAttachmentCount大于0，如果当前的绑定的pipeline以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，则VkRenderingInfo::pColorAttachments中每个imageView不为VK_NULL_HANDLE的元素的imageView，必须以当前pipeline的VkAttachmentSampleCountInfoAMD 或者 VkAttachmentSampleCountInfoNV中的pColorAttachmentSamples中对应元素的sample count进行创建
                                                                      （4）如果当前的绑定的pipeline以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且VkRenderingInfo::pDepthAttachment中的imageView不为VK_NULL_HANDLE，则当前pipeline的VkAttachmentSampleCountInfoAMD 或者 VkAttachmentSampleCountInfoNV中的depthStencilAttachmentSamples必须等于创建VkRenderingInfo::pDepthAttachment->imageView的sample count
                                                                      （5）如果当前的绑定的pipeline以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且VkRenderingInfo::pStencilAttachment中的imageView不为VK_NULL_HANDLE，则当前pipeline的VkAttachmentSampleCountInfoAMD 或者 VkAttachmentSampleCountInfoNV中的depthStencilAttachmentSamples必须等于创建VkRenderingInfo::pStencilAttachment->imageView的sample count
                                                                      （6）且含VkRenderingInfo::colorAttachmentCount大于0，如果当前的绑定的pipeline不以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且multisampledRenderToSingleSampled特性没有开启，则VkRenderingInfo::pColorAttachments中每个imageView不为VK_NULL_HANDLE的元素的imageView，其创建的sample count必须等于当前绑定的graphics pipeline的rasterizationSamples
                                                                      （7）如果当前的绑定的pipeline不以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且VkRenderingInfo::pDepthAttachment中的imageView不为VK_NULL_HANDLE，且multisampledRenderToSingleSampled特性没有开启，则当前pipeline的rasterizationSamples 必须等于创建VkRenderingInfo::pDepthAttachment->imageView的sample count
                                                                      （8）如果当前的绑定的pipeline不以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且VkRenderingInfo::pStencilAttachment中的imageView不为VK_NULL_HANDLE，且multisampledRenderToSingleSampled特性没有开启，则当前pipeline的rasterizationSamples 必须等于创建VkRenderingInfo::pStencilAttachment->imageView的sample count
                                                                      （9）当前绑定的pipeline必须VkGraphicsPipelineCreateInfo::renderPass为VK_NULL_HANDLE创建
                                                                      （10）如果绑定的pipeline的fragment shader静态写入一个color attachment，且color write mask不为0，启用了color writes，且该附件对应的VkRenderingInfo::pColorAttachments->imageView 不为VK_NULL_HANDLE，则对应的创建pipeline的VkPipelineRenderingCreateInfo::pColorAttachmentFormats中的元素不能为VK_FORMAT_UNDEFINED
                                                                      （11）如果绑定的pipeline启用了depth test，启用了depth writes，且VkRenderingInfo::pDepthAttachment->imageView 不为VK_NULL_HANDLE，则创建pipeline的VkPipelineRenderingCreateInfo::depthAttachmentFormat不能为VK_FORMAT_UNDEFINED
                                                                      （12）如果绑定的pipeline启用了stencil test，且VkRenderingInfo::pStencilAttachment->imageView 不为VK_NULL_HANDLE，则创建pipeline的VkPipelineRenderingCreateInfo::stencilAttachmentFormat不能为VK_FORMAT_UNDEFINED
        96.如果该命令在以vkCmdBeginRendering开始的render pass instance中调用，且VkRenderingInfo的pNext中包含一个multisampledRenderToSingleSampledEnable设为VK_TRUE的VkMultisampledRenderToSingleSampledInfoEXT，则当前绑定的graphics pipeline的rasterizationSamples必须等于VkMultisampledRenderToSingleSampledInfoEXT::rasterizationSamples
        97.如果primitivesGeneratedQueryWithRasterizerDiscard特性未开启，且VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query激活，则不能启用rasterization discard
        98.如果primitivesGeneratedQueryWithNonZeroStreams特性未开启，且VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query激活，则 绑定的graphics pipeline不能以VkPipelineRasterizationStateStreamCreateInfoEXT::rasterizationStream为非零值创建
        98.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_TESSELLATION_DOMAIN_ORIGIN_EXT动态state开启创建，则vkCmdSetTessellationDomainOriginEXT必须在该命令之前设置
                                        （2）以VK_DYNAMIC_STATE_DEPTH_CLAMP_ENABLE_EXT动态state开启创建，则vkCmdSetDepthClampEnableEXT必须在该命令之前设置
                                        （3）以VK_DYNAMIC_STATE_POLYGON_MODE_EXT动态state开启创建，则vkCmdSetPolygonModeEXT必须在该命令之前设置
                                        （4）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，则vkCmdSetRasterizationSamplesEXT必须在该命令之前设置
                                        （5）以VK_DYNAMIC_STATE_SAMPLE_MASK_EXT动态state开启创建，则vkCmdSetSampleMaskEXT必须在该命令之前设置
                                        （6）以VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT动态state开启创建，则vkCmdSetAlphaToCoverageEnableEXT必须在该命令之前设置
                                        （7）以VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT动态state开启创建，则最近的vkCmdSetAlphaToCoverageEnableEXT设置alphaToCoverageEnable为VK_TRUE，则Fragment Output Interface中 Index 0的Location 0必须有一个含alpha Component的变量
                                        （8）以VK_DYNAMIC_STATE_ALPHA_TO_ONE_ENABLE_EXT动态state开启创建，则vkCmdSetAlphaToOneEnableEXT必须在该命令之前设置
                                        （9）以VK_DYNAMIC_STATE_LOGIC_OP_ENABLE_EXT动态state开启创建，则vkCmdSetLogicOpEnableEXT必须在该命令之前设置
                                        （10）以VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态state开启创建，则vkCmdSetColorBlendEnableEXT必须在该命令之前设置
                                        （11）以VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT动态state开启创建，则vkCmdSetColorBlendEquationEXT必须在该命令之前设置
                                        （12）以VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT动态state开启创建，则vkCmdSetColorWriteMaskEXT必须在该命令之前设置
        
        99.如果一个shader object绑定到VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT stage，则vkCmdSetTessellationDomainOriginEXT必须在该命令之前设置
        100.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                                        （1）如果depthClamp特性启用，则vkCmdSetDepthClampEnableEXT必须在该命令之前设置
                                                        （2）则vkCmdSetPolygonModeEXT必须在该命令之前设置
                                                        （3）则vkCmdSetRasterizationSamplesEXT必须在该命令之前设置
                                                        （4）则vkCmdSetSampleMaskEXT必须在该命令之前设置
                                                        （5）则vkCmdSetAlphaToCoverageEnableEXT必须在该命令之前设置
                                                        （6）如果alphaToOne特性启用，则vkCmdSetAlphaToOneEnableEXT必须在该命令之前设置
        
        101.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetAlphaToCoverageEnableEXT设置alphaToCoverageEnable为VK_TRUE，则Fragment Output Interface中 Index 0的Location 0必须有一个含alpha Component的变量
        102.如果一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                            （1）如果logicOp特性开启 ,vkCmdSetLogicOpEnableEXT必须在该命令之前设置
                                            （2）如果绑定了color attachments，则vkCmdSetColorBlendEnableEXT必须在该命令之前设置
                                            （3）如果最近的vkCmdSetColorBlendEnableEXT设置任何附件在pColorBlendEnables中的值为VK_TRUE ，则vkCmdSetColorBlendEquationEXT必须在该命令之前设置
                                            （4）如果绑定了color attachments，则vkCmdSetColorWriteMaskEXT必须在该命令之前设置
        
        103.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT动态state开启创建，则vkCmdSetRasterizationStreamEXT必须在该命令之前设置
                                         （2）以VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT动态state开启创建，则vkCmdSetConservativeRasterizationModeEXT必须在该命令之前设置
                                         （3）以VK_DYNAMIC_STATE_EXTRA_PRIMITIVE_OVERESTIMATION_SIZE_EXT动态state开启创建，则vkCmdSetExtraPrimitiveOverestimationSizeEXT必须在该命令之前设置
                                         （4）以VK_DYNAMIC_STATE_DEPTH_CLIP_ENABLE_EXT动态state开启创建，则vkCmdSetDepthClipEnableEXT必须在该命令之前设置
                                         （5）以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT动态state开启创建，则vkCmdSetSampleLocationsEnableEXT必须在该命令之前设置
                                         （6）以VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT动态state开启创建，则vkCmdSetColorBlendAdvancedEXT必须在该命令之前设置
                                         （7）以VK_DYNAMIC_STATE_PROVOKING_VERTEX_MODE_EXT动态state开启创建，则vkCmdSetProvokingVertexModeEXT必须在该命令之前设置
                                         （8）以VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT动态state开启创建，则vkCmdSetLineRasterizationModeEXT必须在该命令之前设置
                                         （9）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT动态state开启创建，则vkCmdSetLineStippleEnableEXT必须在该命令之前设置
                                         （10）以VK_DYNAMIC_STATE_LINE_STIPPLE_KHR动态state开启创建，则vkCmdSetLineStippleKHR必须在该命令之前设置
                                         （11）以VK_DYNAMIC_STATE_DEPTH_CLIP_NEGATIVE_ONE_TO_ONE_EXT动态state开启创建，则vkCmdSetDepthClipNegativeOneToOneEXT必须在该命令之前设置
                                         （12）以VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_ENABLE_NV动态state开启创建，则vkCmdSetViewportWScalingEnableNV必须在该命令之前设置
                                         （13）以VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV动态state开启创建，则vkCmdSetViewportSwizzleNV必须在该命令之前设置
                                         （14）以VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV动态state开启创建，则vkCmdSetCoverageToColorEnableNV必须在该命令之前设置
                                         （15）以VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_LOCATION_NV动态state开启创建，则vkCmdSetCoverageToColorLocationNV必须在该命令之前设置
                                         （16）以VK_DYNAMIC_STATE_COVERAGE_MODULATION_MODE_NV动态state开启创建，则vkCmdSetCoverageModulationModeNV必须在该命令之前设置
                                         （17）以VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV动态state开启创建，则vkCmdSetCoverageModulationTableEnableNV必须在该命令之前设置
                                         （18）以VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_NV动态state开启创建，则vkCmdSetCoverageModulationTableNV必须在该命令之前设置
                                         （19）以VK_DYNAMIC_STATE_SHADING_RATE_IMAGE_ENABLE_NV动态state开启创建，则vkCmdSetShadingRateImageEnableNV必须在该命令之前设置
                                         （20）以VK_DYNAMIC_STATE_REPRESENTATIVE_FRAGMENT_TEST_ENABLE_NV动态state开启创建，则vkCmdSetRepresentativeFragmentTestEnableNV必须在该命令之前设置
                                         （21）以VK_DYNAMIC_STATE_COVERAGE_REDUCTION_MODE_NV动态state开启创建，则vkCmdSetCoverageReductionModeNV必须在该命令之前设置
        
        104.如果一个shader object绑定到VK_SHADER_STAGE_GEOMETRY_BIT stage，且如果geometryStreams 特性开启，则vkCmdSetRasterizationStreamEXT必须在该命令之前设置
        105.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                （1）如果VK_EXT_conservative_rasterization 拓展开启，vkCmdSetConservativeRasterizationModeEXT必须在该命令之前设置
                                （2）如果VK_EXT_conservative_rasterization 拓展开启，且最近的vkCmdSetConservativeRasterizationModeEXT设置conservativeRasterizationMode为VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT，则vkCmdSetExtraPrimitiveOverestimationSizeEXT必须在该命令之前设置
                                （3）如果VK_EXT_sample_locations 拓展开启，则vkCmdSetSampleLocationsEnableEXT必须在该命令之前设置
        106.如果一个shader object绑定到任何graphics stage，且depthClipEnable 特性开启，则vkCmdSetDepthClipEnableEXT必须在该命令之前设置
        107.如果如果一个shader object绑定到任何VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且如果VK_EXT_blend_operation_advanced 拓展开启，则vkCmdSetColorBlendEquationEXT 和 vkCmdSetColorBlendAdvancedEXT中至少一个必须在该命令之前设置
        108.如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，如果VK_EXT_provoking_vertex拓展开启， 则vkCmdSetProvokingVertexModeEXT必须在该命令之前设置
        109.如果VK_KHR_line_rasterization 或者 VK_EXT_line_rasterization拓展开启，则（1）如果一个shader object绑定到任意一个graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetPolygonModeEXT设置polygonMode 为VK_POLYGON_MODE_LINE ，则vkCmdSetLineRasterizationModeEXT必须在该命令之前设置
                                                                                    （2）如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetPrimitiveTopology设置primitiveTopology 为任何line topology ，则vkCmdSetLineRasterizationModeEXT必须在该命令之前设置
                                                                                    （3）如果一个输出为line primitive的shader object绑定到VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或 VK_SHADER_STAGE_GEOMETRY_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则vkCmdSetLineRasterizationModeEXT必须在该命令之前设置
                                                                                    （4）如果一个shader object绑定到任意一个graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetPolygonModeEXT设置polygonMode 为VK_POLYGON_MODE_LINE ，则vkCmdSetLineStippleEnableEXT必须在该命令之前设置
                                                                                    （5）如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetPrimitiveTopology设置primitiveTopology 为任何line topology ，则vkCmdSetLineStippleEnableEXT必须在该命令之前设置
                                                                                    （6）如果一个输出为line primitive的shader object绑定到VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或 VK_SHADER_STAGE_GEOMETRY_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则vkCmdSetLineStippleEnableEXT必须在该命令之前设置
                                                                                    （7）如果一个shader object绑定到任意一个graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetLineStippleEnableEXT设置stippledLineEnable 为VK_TRUE ，则vkCmdSetLineStippleEXT必须在该命令之前设置
        110.如果一个shader object绑定到任何graphics stage，（1）如果depthClipControl 特性开启，则vkCmdSetDepthClipNegativeOneToOneEXT必须在该命令之前设置
                                                           （2）VK_NV_clip_space_w_scaling 拓展开启，则vkCmdSetViewportWScalingEnableNV必须在该命令之前设置
                                                           （3）VK_NV_viewport_swizzle 拓展开启，则vkCmdSetViewportSwizzleNV必须在该命令之前设置
        111.如果如果一个shader object绑定到任何VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                            （1）如果VK_NV_fragment_coverage_to_color 拓展开启，则vkCmdSetCoverageToColorEnableNV 必须在该命令之前设置
                            （2）如果VK_NV_fragment_coverage_to_color 拓展开启，且最近的vkCmdSetCoverageToColorEnableNV 设置coverageToColorEnable 为VK_TRUE，则vkCmdSetCoverageToColorLocationNV 必须在该命令之前设置
                            （3）如果pipelineFragmentShadingRate 特性开启，则vkCmdSetFragmentShadingRateKHR 必须在该命令之前设置
        112.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                    （1）如果VK_NV_framebuffer_mixed_samples 拓展开启，则vkCmdSetCoverageModulationModeNV 必须在该命令之前设置
                                    （2）如果VK_NV_framebuffer_mixed_samples 拓展开启，且最近的vkCmdSetCoverageModulationModeNV设置coverageModulationMode为任何除VK_COVERAGE_MODULATION_MODE_NONE_NV之外的值，则vkCmdSetCoverageModulationTableEnableNV 必须在该命令之前设置
                                    （3）如果VK_NV_framebuffer_mixed_samples 拓展开启，最近的vkCmdSetCoverageModulationTableEnableNV设置coverageModulationTableEnable为VK_TRUE，则vkCmdSetCoverageModulationTableNV 必须在该命令之前设置
                                    （4）如果shadingRateImage 特性开启，则vkCmdSetShadingRateImageEnableNV 必须在该命令之前设置
                                    （5）如果representativeFragmentTest 特性开启，则vkCmdSetRepresentativeFragmentTestEnableNV 必须在该命令之前设置
                                    （6）如果coverageReductionMode 特性开启，则vkCmdSetCoverageReductionModeNV 必须在该命令之前设置
        113.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态state开启创建，且最近的vkCmdSetColorBlendEnableEXT设置任何附件在pColorBlendEnables中的值为VK_TRUE 则subpas中这些附件对应的image view的format features中必须包含VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT
                                         （2）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，且当前subpass不使用任何color和/或者 depth/stencil attachments，则最后的vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples必须符合zero￾attachment subpass的规则
                                         （3）以VK_DYNAMIC_STATE_SAMPLE_MASK_EXT不以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT 动态state开启创建，则最后调用的vkCmdSetSampleMaskEXT中设置的samples参数必须大于等于创建该pipeline的VkPipelineMultisampleStateCreateInfo::rasterizationSamples
                                         （4）以VK_DYNAMIC_STATE_SAMPLE_MASK_EXT和 VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT 动态state开启创建，则最后调用的vkCmdSetSampleMaskEXT中设置的samples参数必须大于等于最后的vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples
                                         （5）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，且VK_AMD_mixed_attachment_samples和VK_NV_framebuffer_mixed_samples拓展都没有开启，则最后的vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples必须等于subpass中color和/或者 depth/stencil attachments使用的相同
                                         （6）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，或者一个shader object绑定到任意graphics stage，且当前的subpass包含一个multisampledRenderToSingleSampledEnable 为VK_TRUE的VkMultisampledRenderToSingleSampledInfoEXT，则最后的vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples必须等于该VkMultisampledRenderToSingleSampledInfoEXT中的对应成员
                                         （7）以VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态state开启创建，则vkCmdSetColorBlendEnableEXT 必须在该命令之前设置，且vkCmdSetColorBlendEnableEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定值
                                         （8）以VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT动态state开启创建，则vkCmdSetColorBlendEquationEXT 必须在该命令之前设置，且vkCmdSetColorBlendEquationEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定blend equations
                                         （9）以VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT动态state开启创建，则vkCmdSetColorWriteMaskEXT 必须在该命令之前设置，且vkCmdSetColorWriteMaskEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定color write mask
                                         （10）以VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT动态state开启创建，则vkCmdSetColorBlendAdvancedEXT 必须在该命令之前设置，且vkCmdSetColorBlendAdvancedEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活blend的color attachments指定advanced blend equations
                                         （11）以VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT和VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态state开启创建，且最后的vkCmdSetColorBlendEnableEXT和vkCmdSetColorBlendAdvancedEXT设置启用了advanced blending，则当前subpass中激活的color attachments的数量不能超过advancedBlendMaxColorAttachments
                                         （12）以VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT动态state开启创建，且如果primitivesGeneratedQueryWithNonZeroStreams特性未开启且VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query已经激活，则最后的vkCmdSetRasterizationStreamEXT必须设置rasterizationStream为0
                                         （13）以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT但不以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，则最后的vkCmdSetSampleLocationsEXT设置的pSampleLocationsInfo->sampleLocationsPerPixel必须等于创建pipeline的VkPipelineMultisampleStateCreateInfo::rasterizationSamples
                                         （14）以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT和VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，则最后的vkCmdSetSampleLocationsEXT设置的pSampleLocationsInfo->sampleLocationsPerPixel必须等于最后vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples
                                         （15）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT但不以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT动态state开启创建，且绑定的pipeline的VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable为VK_TRUE 或者以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT动态state开启，则sampleLocationsInfo.sampleLocationsPerPixel 必须等于最后vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples
                                         （16）以VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV动态state开启创建，且最后的vkCmdSetCoverageToColorEnableNV设置coverageToColorEnable为VK_TRUE，则当前subpass必须有color attachment，且该attachment的format必须为VK_FORMAT_R8_UINT, VK_FORMAT_R8_SINT, VK_FORMAT_R16_UINT, VK_FORMAT_R16_SINT, VK_FORMAT_R32_UINT, 或者 VK_FORMAT_R32_SINT，且该attachment的location 有最后的vkCmdSetCoverageToColorLocationNV设置的coverageToColorLocation决定
                                         （17）以VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV和VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT 动态state开启创建，且如果VK_NV_coverage_reduction_mode 拓展开启，则当前的 coverageReductionMode，rasterizationSamples 以及color 以及 depth/stencil attachments（如果subpass有）的sample count必须是有效的返回值vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV的值的组合
                                         （18）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT但不以VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV 动态state开启创建，则绑定的graphics pipeline的VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount 必须大于等于最后vkCmdSetViewportWithCount设置的viewportCount
                                         （19）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT和VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV 动态state开启创建，则最后vkCmdSetViewportSwizzleNV设置的viewportCount 必须大于等于最后vkCmdSetViewportWithCount设置的viewportCount
                                         （20）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT或者 VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT 动态state开启创建，如果当前的stippledLineEnable为VK_TRUE，且当前的lineRasterizationMode为VK_LINE_RASTERIZATION_MODE_RECTANGULAR_KHR，则stippledRectangularLines 特性必须开启
                                         （21）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT或者 VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT 动态state开启创建，如果当前的stippledLineEnable为VK_TRUE，且当前的lineRasterizationMode为VK_LINE_RASTERIZATION_MODE_BRESENHAM_KHR，则stippledBresenhamLines 特性必须开启
                                         （22）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT或者 VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT 动态state开启创建，如果当前的stippledLineEnable为VK_TRUE，且当前的lineRasterizationMode为VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_KHR，则stippledSmoothLines 特性必须开启
                                         （23）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT或者 VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT 动态state开启创建，如果当前的stippledLineEnable为VK_TRUE，且当前的lineRasterizationMode为VK_LINE_RASTERIZATION_MODE_DEFAULT_KHR，则stippledRectangularLines 特性必须开启且VkPhysicalDeviceLimits::strictLines 必须为VK_TRUE
                                         （24）以VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT 动态state开启创建，且conservativePointAndLineRasterization不支持，最后的 pre-rasterization shader stage输出的有效图元拓扑为点或者线，则最后vkCmdSetConservativeRasterizationModeEXT设置的conservativeRasterizationMode 必须为VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT
                                         （25）以VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT 动态state开启创建，则vkCmdSetAttachmentFeedbackLoopEnableEXT 必须在该命令之前调用
        114.如果一个shader object绑定到 VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                                                                            （1）则vkCmdSetColorBlendEnableEXT 必须在该命令之前设置，且vkCmdSetColorBlendEnableEXT指定的firstAttachment开始的attachmentCount的值必须为当前subpass所有激活的color attachments指定
                                                                                            （2）则vkCmdSetColorBlendEquationEXT 必须在该命令之前设置，且vkCmdSetColorBlendEquationEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定blend equations
                                                                                            （3）则vkCmdSetColorWriteMaskEXT 必须在该命令之前设置，且vkCmdSetColorWriteMaskEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定color write mask
                                                                                            （4）如果VK_NV_fragment_coverage_to_color拓展开启， 最后的vkCmdSetCoverageToColorEnableNV设置coverageToColorEnable为VK_TRUE，则当前subpass必须有color attachment，且该attachment的format必须为VK_FORMAT_R8_UINT, VK_FORMAT_R8_SINT, VK_FORMAT_R16_UINT, VK_FORMAT_R16_SINT, VK_FORMAT_R32_UINT, 或者 VK_FORMAT_R32_SINT，且该attachment的location 有最后的vkCmdSetCoverageToColorLocationNV设置的coverageToColorLocation决定
        115.如果一个shader object绑定到 VK_SHADER_STAGE_FRAGMENT_BIT stage，（1）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT动态state开启创建，且最近的vkCmdSetSampleLocationsEnableEXT设置sampleLocationsEnable为VK_TRUE，且该subpass含有depth/stencil attachment，则该附件必须以VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT创建
                                                                            （2）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT和VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT 动态state开启创建，且最近的vkCmdSetSampleLocationsEnableEXT设置sampleLocationsEnable为VK_TRUE，则 最后vkCmdSetSampleLocationsEXT设置的sampleLocationsInfo.sampleLocationGridSize.width以及height 必须等于被调用vkGetPhysicalDeviceMultisamplePropertiesEXT传入rasterizationSamples返回的VkMultisamplePropertiesEXT::sampleLocationGridSize.width以及height一一对应均匀整除
                                                                            （3）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT 动态state开启创建，且最近的vkCmdSetSampleLocationsEnableEXT设置sampleLocationsEnable为VK_TRUE，则fragment shader代码中不能静态使用扩展指令InterpolateAtSample
                                                                            （4）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT但不以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT 动态state开启创建，且绑定的pipeline的VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable为VK_TRUE 或者以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT动态state开启，则 最后vkCmdSetRasterizationSamplesEXT设置的sampleLocationsInfo.sampleLocationGridSize.width以及height 必须等于被调用vkGetPhysicalDeviceMultisamplePropertiesEXT传入和vkCmdSetRasterizationSamplesEXT设置的相同rasterizationSamples的samples返回的VkMultisamplePropertiesEXT::sampleLocationGridSize.width以及height一一对应均匀整除
        116.如果一个shader object绑定到任何graphics stage，（1）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV 动态state开启创建，且最近的vkCmdSetCoverageModulationTableEnableNV设置coverageModulationTableEnable为VK_TRUE，则最近的vkCmdSetCoverageModulationTableNV 设置的coverageModulationTableCount 必须等于当前rasterizationSamples除以当前subppas的color samples
                                                           （2）如果VK_NV_viewport_swizzle 拓展开启，则最后vkCmdSetViewportSwizzleNV设置的viewportCount 必须大于等于最后vkCmdSetViewportWithCount设置的viewportCount
        117.如果VK_NV_framebuffer_mixed_samples 拓展开启，且如果在绑定的graphics pipeline中当前subpass有一个depth/stencil attachment以及dep test, stencil test, 或depth bounds test 启用，则当前rasterizationSamples 必须等于depth/stencil attachment的sample count
        118.如果VK_NV_framebuffer_mixed_samples 拓展开启，且如果最后的vkCmdSetRasterizationSamplesEXT设置的当前subpass的任何color attachments的rasterizationSamples 都大于 color samples，则sampleShadingEnable 必须为VK_FALSE
        119.如果当前绑定的graphics pipeline以VkGraphicsPipelineCreateInfo::pStages中的元素的VkPipelineShaderStageCreateInfo::stage设置为VK_SHADER_STAGE_VERTEX_BIT, VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT, VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或者 VK_SHADER_STAGE_GEOMETRY_BIT创建，则Mesh Shader Queries 不能激活
        120.如果dynamic state继承自VkCommandBufferInheritanceViewportScissorInfoNV，则这些动态state的设置必须在该命令之前设置
        121.如果没有绑定graphics pipeline，则（1）vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_VERTEX_BIT
                                             （2）如果tessellationShader 特性开启，vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT，VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT
                                             （3）如果geometryShader 特性开启，vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_GEOMETRY_BIT
                                             （4）vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_FRAGMENT_BIT
                                             （5）如果taskShader 特性开启，vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_TASK_BIT_EXT
                                             （6）如果meshShader 特性开启，vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_MESH_BIT_EXT
                                             （8）如果至少taskShader 和 meshShader一个特性开启，VK_SHADER_STAGE_VERTEX_BIT 或者VK_SHADER_STAGE_MESH_BIT_EXT stages中的一个必须含有有效的VkShaderEXT绑定，另外一个则不含有VkShaderEXT绑定
                                             （9）如果taskShader 和 meshShader特性同时开启，且一个有效的VkShaderEXT 绑定到VK_SHADER_STAGE_MESH_BIT_EXT stage，且该VkShaderEXT不以VK_SHADER_CREATE_NO_TASK_SHADER_BIT_EXT 创建，则一个有效的VkShaderEXT必须绑定到VK_SHADER_STAGE_TASK_BIT_EXT stage
                                             （10）如果taskShader 和 meshShader特性同时开启，且一个有效的VkShaderEXT 绑定到VK_SHADER_STAGE_MESH_BIT_EXT stage，且该VkShaderEXT以VK_SHADER_CREATE_NO_TASK_SHADER_BIT_EXT 创建，则不能有VkShaderEXT绑定到VK_SHADER_STAGE_TASK_BIT_EXT stage
                                             （11）如果一个有效的VkShaderEXT 绑定到VK_SHADER_STAGE_VERTEX_BIT stage，则不能有VkShaderEXT绑定到VK_SHADER_STAGE_TASK_BIT_EXT stage或者VK_SHADER_STAGE_MESH_BIT_EXT stage中的一个
        122.如果任何绑定的graphics shader以VK_SHADER_CREATE_LINK_STAGE_BIT_EXT 创建，（1）所有在相同vkCreateShadersEXT中以VK_SHADER_CREATE_LINK_STAGE_BIT_EXT创建的shaders必须也要绑定
                                                                                     （2）任何相同vkCreateShadersEXT中不以VK_SHADER_CREATE_LINK_STAGE_BIT_EXT创建的shaders不能有任何VkShaderEXT绑定
        123.所有绑定的graphics shader objects 必须以相同或者相同定义的push constant ranges创建
        124.所有绑定的graphics shader objects 必须以相同或者相同定义的descriptor set layouts的数组创建
        125.如果当前的render pass instance以vkCmdBeginRendering开始，且VkRenderingInfo::colorAttachmentCount为1，且有一个resolve mode为 VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID 的color attachment，且绑定了fragment shader，则DepthReplacing 和 StencilRefReplacingEXT execution modes 不能声明
        126.如果一个shader object绑定到 VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则 （1）如果attachmentFeedbackLoopDynamicState 特性开启，则 vkCmdSetAttachmentFeedbackLoopEnableEXT 必须在该命令之前调用
        127.如果包含一个fragment shader stage的绑定的graphics pipeline，（1）且该pipeline以VkPipelineDynamicStateCreateInfo::pDynamicStates中设置有VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE创建，且该fragment shader声明了EarlyFragmentTests execution mode且使用了OpDepthAttachmentReadEXT，则最后vkCmdSetDepthWriteEnable 设置的 depthWriteEnable 必须为VK_FALSE
                                                                        （2）且该pipeline以VkPipelineDynamicStateCreateInfo::pDynamicStates中设置有VK_DYNAMIC_STATE_STENCIL_WRITE_MASK创建，且该fragment shader声明了EarlyFragmentTests execution mode且使用了OpStencilAttachmentReadEXT，则最后vkCmdSetStencilWriteMask 设置的 writeMask 必须为0
        128.如果一个shader object绑定到任何graphics stage 或者绑定的graphics pipeline 以VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT 动态state开启创建，且任何color attachment的format为VK_FORMAT_E5B9G9R9_UFLOAT_PACK32，则vkCmdSetColorWriteMaskEXT设置的pColorWriteMasks参数的对应元素必须包含VK_COLOR_COMPONENT_R_BIT, VK_COLOR_COMPONENT_G_BIT, 和 VK_COLOR_COMPONENT_B_BIT，或者都不包含
        129.如果任何附件开启了blending，且该附件的source 或者 destination blend factors使用第二个颜色输入，则该命令执行的Fragment Execution Model静态使用的任何输出output attachment的Location的最大值必须小于maxFragmentDualSrcAttachments
        130.如果当前的render pass instance以vkCmdBeginRendering开始，（1）如果没有任何shader object绑定到任何graphics stage，则vkCmdSetRenderingAttachmentLocationsKHR 设置的VkRenderingAttachmentLocationInfoKHR::pColorAttachmentLocations中的每个元素必须匹配设置在当前绑定的graphics pipeline中的对应元素
                                                                     （2）如果没有任何shader object绑定到任何graphics stage，绑定的graphics pipeline中的input attchment 索引中映射的附件必须匹配在当前render pass instance的VkRenderingInputAttachmentIndexInfoKHR中设置的
        131.如果当前的render pass instance以vkCmdBeginRendering开始且以VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT标志开始，则绑定的graphics pipeline必须以VK_PIPELINE_CREATE_2_ENABLE_LEGACY_DITHERING_BIT_EXT创建
        132.如果绑定的graphics pipeline以VK_PIPELINE_CREATE_2_ENABLE_LEGACY_DITHERING_BIT_EXT创建，则当前的render pass 必须以vkCmdBeginRendering开始且以VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT标志开始
        135.所有在vertex shader entry point 的 interface通过声明的vertex input variables访问的vertex input bindings必须是有效的buffer绑定或者为VK_NULL_HANDLE绑定
        136.如果nullDescriptor 特性未开启，则所有在vertex shader entry point 的 interface通过声明的vertex input variables访问的vertex input bindings不能为VK_NULL_HANDLE绑定
        137.如果robustBufferAccess 特性未开启，且pipeline的创建不对vertexInputs以VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT开启创建，则对于指定的vertex buffer binding，任何获取的顶点属性数据必须包含在对应的vertex buffer binding中，参见Vertex Input Description p2586
        138.如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage或者绑定的graphics pipeline以VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY动态state开启创建，则vkCmdSetPrimitiveTopology必须在该命令前设置
        140.如果绑定的graphics pipeline以VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY动态state开启创建，且dynamicPrimitiveTopologyUnrestricted为VK_FALSE，则vkCmdSetPrimitiveTopology设置的primitiveTopology 必须和pipeline创建的VkPipelineInputAssemblyStateCreateInfo::topology相同
        141.如果绑定的graphics pipeline以VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT但不以VK_DYNAMIC_STATE_VERTEX_INPUT_EXT 动态state开启创建，则vkCmdBindVertexBuffers2EXT必须在该命令前设置，且pStrides参数不能为NULL
        142.如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage或者绑定的graphics pipeline以VK_DYNAMIC_STATE_VERTEX_INPUT_EXT动态state开启创建，则
                                            （1）vkCmdSetVertexInputEXT必须在该命令前设置
                                            （2）所有以Input storage class修饰的Vertex Execution Model OpEntryPoint中的变量其Location必须包含在VkVertexInputAttributeDescription2EXT::location指定的location中
                                            （3）如果满足legacyVertexAttributes未开启或者Vertex Execution Model OpEntryPoint中给定对应Location的Input variable的 SPIR-V Type为64-bit的中的一个，则Vertex Execution Model OpEntryPoint中对应Location的所有Input variable的numeric type必须和VkVertexInputAttributeDescription2EXT::format的相同
                                            （4）如果VkVertexInputAttributeDescription2EXT::format含有64-bit 分量，Vertex Execution Model OpEntryPoint中对应Location的所有Input variable的scalar width必须是64-bit的
                                            （5）如果Vertex Execution Model OpEntryPoint中对应Location的Input variable的scalar width是64-bit的，则对应VkVertexInputAttributeDescription2EXT::format必须含有64-bit 分量
                                            （6）如果VkVertexInputAttributeDescription2EXT::format含有64-bit 分量，则Vertex Execution Model OpEntryPoint中对应Location的所有Input variable不能使用该format未呈现的分量
        143.如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage且最近的vkCmdSetPrimitiveTopology设置primitiveTopology为VK_PRIMITIVE_TOPOLOGY_PATCH_LIST，或者绑定的graphics pipeline以VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT动态state开启创建，则vkCmdSetPatchControlPointsEXT必须在该命令前设置
        144.如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage或者绑定的graphics pipeline以VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE动态state开启创建，则vkCmdSetPrimitiveRestartEnable必须在该命令前设置
        145.如果primitiveTopologyListRestart特性未开启，且topology 为VK_PRIMITIVE_TOPOLOGY_POINT_LIST, VK_PRIMITIVE_TOPOLOGY_LINE_LIST, VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST, VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY, 或者 VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY，
                    且有一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage或者绑定的graphics pipeline以VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE动态state开启创建，则vkCmdSetPrimitiveRestartEnable必须设置为VK_FALSE
        146.绑定的graphics pipeline不能以VkGraphicsPipelineCreateInfo::pStages中元素的VkPipelineShaderStageCreateInfo::stage设置为VK_SHADER_STAGE_TASK_BIT_EXT 或者 VK_SHADER_STAGE_MESH_BIT_EXT创建
        147.不能有shader object绑定到VK_SHADER_STAGE_TASK_BIT_EXT或者 VK_SHADER_STAGE_MESH_BIT_EXT中的一个stage
        148.如果绑定的graphics pipeline 以VkGraphicsPipelineCreateInfo::pVertexInputState->pNext中包含一个VkPipelineVertexInputDivisorStateCreateInfoKHR创建，且VkPipelineVertexInputDivisorStateCreateInfoKHR::pVertexBindingDivisors任何元素为除数为1外的值，且VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR::supportsNonZeroFirstInstance 为VK_FALSE，则firstInstance必须为0
        149.如果shader objects用于绘制或者绑定的graphics pipeline以VK_DYNAMIC_STATE_VERTEX_INPUT_EXT动态state开启创建，且vkCmdSetVertexInputEXT设置的pVertexBindingDescriptions中设置该动态state的任何元素有为除数为1外的值，且VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR::supportsNonZeroFirstInstance 为VK_FALSE，则firstInstance必须为0
        150.multiDraw 特性必须开启
        151.drawCount必须小于 VkPhysicalDeviceMultiDrawPropertiesEXT::maxMultiDrawCount
        152.如果drawCount大于0，则pVertexInfo必须为有效的包含一个或多个VkMultiDrawInfoEXT的数组指针
        153.如果drawCount大于1，则stride必须为4的倍数，且必须大于或者等于sizeof(VkMultiDrawInfoEXT)
        154.如果buffer为non-sparse的，则该buffer必须绑定到完整的连续的单独的VkDeviceMemory上
        155.buffer必须以VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT 创建
        156.offset必须是4的倍数
        157.commandBuffer不能为一个protected command buffer
        158.如果multiDrawIndirect 特性未开启，则drawCount必须为0或1
        159.drawCount必须小于等于VkPhysicalDeviceLimits::maxDrawIndirectCount
        160.如果drawCount大于1，则stride必须为4的倍数，且必须大于或者等于sizeof(VkDrawIndirectCommand)
        161.如果drawCount为1，则(offset + sizeof(VkDrawIndirectCommand))必须小于等于buffer的大小
        162.如果drawCount大于1，则(offset + stride × (drawCount - 1) + sizeof(VkDrawIndirectCommand))必须小于等于buffer的大小
        */


        //记录非索引的从buffer中指定绘制次数的绘制  等效于vkCmdDrawIndirectCountKHR或者vkCmdDrawIndirectCountAMD   ，该命令类似于 vkCmdDrawIndirect,其中绘制次数会从countBuffer中获取，绘制参数以VkDrawIndirectCommand组织
        vkCmdDrawIndirectCount(commandBuffer, VkBuffer{/*假设只是一个有效的VkBuffer*/ }/*buffer ,包含绘制参数的buffer.*/, 0/*offset,为buffer中绘制参数开始的起始字节偏移量.*/,
                VkBuffer{/*假设只是一个有效的VkBuffer*/ }/*countBuffer，是包含绘制计数的buffer.*/, 0/*• countBufferOffset，为countBuffer中绘制计数参数开始的起始字节偏移量.*/,
                1/*maxDrawCount，是要执行的最大的绘制的次数.实际上绘制的次数为maxDrawCount以及countBuffer中记录的绘制次数的最小值.*/, 3/*stride，是buffer中连续绘制设置组之间的字节步长.*/);
        /*
        
         vkCmdDrawIndirectCount有效用法:
        1.如果一个VkSampler以其magFilter或者minFilter等于VK_FILTER_LINEAR创建，则（1）如果reductionMode为VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE，如果用于采样一个VkImageView作为该命令的结果的compareEnable为VK_FALSE，则该image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT
                                                                                 （2）如果reductionMode为VK_SAMPLER_REDUCTION_MODE_MIN 或者VK_SAMPLER_REDUCTION_MODE_MAX之一 用于采样一个VkImageView作为该命令的结果，则该image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT
        2.如果一个VkSampler以其mipmapMode 等于VK_SAMPLER_MIPMAP_MODE_LINEAR创建，则（1）如果reductionMode为VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE，如果用于采样一个VkImageView作为该命令的结果的compareEnable为VK_FALSE，则该image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT
                                                                                 （2）如果reductionMode为VK_SAMPLER_REDUCTION_MODE_MIN 或者VK_SAMPLER_REDUCTION_MODE_MAX之一 用于采样一个VkImageView作为该命令的结果，则该image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT
        3.如果一个VkSampler以其unnormalizedCoordinates等于VK_TRUE用于采样一个VkImageView作为该命令的结果创建，则（1）该image view的levelCount以及layerCount必须为1
                                                                                                                （2）该image view的viewType必须为VK_IMAGE_VIEW_TYPE_1D 或者 VK_IMAGE_VIEW_TYPE_2D
        4.如果一个VkImageView的采样带depth comparison操作，则image view的format features必须包含VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT
        5.如果一个VkImageView使用atomic operations作为该命令的结果进行访问，则image view的format features必须包含VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT
        6.如果一个VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER类型的 descriptor使用atomic operations作为该命令的结果进行访问，则storage texel buffer的format features必须包含VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT
        7.如果一个以VK_FILTER_CUBIC_EXT进行采样的VkImageView作为该命令的结果，则image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT
        8.如果VK_EXT_filter_cubic拓展没有开启，且有任何一个以VK_FILTER_CUBIC_EXT进行采样的VkImageView作为该命令的结果，则其VkImageViewType不能为VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, 或者 VK_IMAGE_VIEW_TYPE_CUBE_ARRAY
        9.任何一个以VK_FILTER_CUBIC_EXT进行采样的作为该命令的结果的VkImageView，其VkImageViewType和format 必须支持cubic filtering，参见vkGetPhysicalDeviceImageFormatProperties2返回的VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic
        10.任何一个以VK_FILTER_CUBIC_EXT进行采样且reduction mode为VK_SAMPLER_REDUCTION_MODE_MIN 或者 VK_SAMPLER_REDUCTION_MODE_MAX之一的作为该命令的结果的VkImageView，其VkImageViewType和format 必须支持带minmax filtering的cubic filtering，参见vkGetPhysicalDeviceImageFormatProperties2返回的VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax
        11.如果cubicRangeClamp特性没有开启，则有任何一个以VK_FILTER_CUBIC_EXT进行采样VkImageView的作为该命令的结果，VkSamplerReductionModeCreateInfo::reductionMode不能为VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM
        12.任何一个以VkSamplerReductionModeCreateInfo::reductionMode为VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM进行采样的作为该命令的结果的VkImageView必须以VK_FILTER_CUBIC_EXT进行采样
        13.如果selectableCubicWeights特性没有开启，则有任何一个以VK_FILTER_CUBIC_EXT进行采样VkImageView的作为该命令的结果，VkSamplerCubicWeightsCreateInfoQCOM::cubicWeights必须为VK_CUBIC_FILTER_WEIGHTS_CATMULL_ROM_QCOM
        14.任何一个以VkImageCreateInfo::flags含VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV创建的采样作为该命令结果的VkImage必须以VkSamplerAddressMode为VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE 进行采样
        15.对于任何作为storage image写入的VkImageView，且其OpTypeImage的format未知，则该image view的 format features必须包含VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT
        16.对于任何作为storage image读取的VkImageView，且其OpTypeImage的format未知，则该image view的 format features必须包含VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT
        17.对于任何作为storage storage texel buffer写入的VkBufferView，且其OpTypeImage的format未知，则该buffer view的 buffer features必须包含VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT
        18.对于任何作为storage storage texel buffer读取的VkBufferView，且其OpTypeImage的format未知，则该buffer view的 buffer features必须包含VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT
        19.对于每个在绑定的shader中静态使用的set n，一个descriptor set必须被绑定到相同pipeline bind point的set n处，该set n必须和创建当前VkPipeline的VkPipelineLayout或者和创建当前VkShaderEXT的VkDescriptorSetLayout 数组的set n处的布局兼容，参见Pipeline Layout Compatibility p1280
        20.对于每个在绑定的shader中静态使用的push constant，一个push constant值必须被绑定到相同pipeline bind point的对应处，该push constant必须和创建当前VkPipeline的VkPipelineLayout或者和创建当前VkShaderEXT的VkDescriptorSetLayout 数组中的对应处的布局兼容，参见Pipeline Layout Compatibility p1280
        21.如果maintenance4特性没有开启，则对于每个在绑定的shader中静态使用的push constant，一个push constant值必须被设置到相同pipeline bind point的对应处，该push constant必须和创建当前VkPipeline的VkPipelineLayout或者和创建当前VkShaderEXT的VkDescriptorSetLayout 数组中的对应处的布局兼容，参见Pipeline Layout Compatibility p1280
        22.每一个通过vkCmdBindDescriptorSets绑定的descriptor set的descriptors,如果是被不以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建的，且已经绑定到该命令使用的pipeline bind point的VkPipeline静态使用的，则这些descriptors必须是有效的，参见 descriptor validity p1328
        23.如果通过vkCmdBindDescriptorSets指定绑定到pipeline bind point的VkPipeline要使用的descriptors，则绑定的VkPipeline不能以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建
        24.在vkCmdSetDescriptorBufferOffsetsEXT中指定绑定的descriptor buffers的descriptors，则（1）如果绑定到pipeline bind point的该命令会使用的VkPipeline以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建，且这些descriptors是动态使用的，则这些descriptors必须是有效的
                                                                                              （2）如果绑定到pipeline bind point的对应stage的该命令会使用的VkShaderEXT，且这些descriptors是动态使用的，则这些descriptors必须是有效的
        25.在vkCmdSetDescriptorBufferOffsetsEXT中指定的descriptors在绑定到pipeline bind point的VkPipeline中使用，则VkPipeline必须以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建
        26.如果一个descriptor在以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建的VkPipeline中动态使用，则descriptor memory必须是驻留内存
        27.如果一个descriptor在以其VkDescriptorSetLayout以VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建的VkShaderEXT中动态使用，则descriptor memory必须是驻留内存
        28.如果shaderObject 特性没有开启，一个有效的pipeline必须绑定到这个命令使用的绑定到pipeline bind point上
        29.如果一个pipeline绑定到该命令使用的pipeline bind point上，则不能有任何动态state 设置命令设置任何该VkPipeline 中没有指定的动态 state
        30.如果一个VkPipeline绑定到该命令使用的pipeline bind point上 或者任何一个会访问一个使用unnormalized coordinates的VkSampler的 VkShaderEXT绑定到该命令使用的pipeline bind point上的pipeline的对应stage，则
                                                                                    （1）在任何shader stage中，VkSampler不能用来采样任何类型为VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY 或者 VK_IMAGE_VIEW_TYPE_CUBE_ARRAY的VkImageView
                                                                                    （2）在任何shader stage中，该VkSampler不能和任何带有名字中带有ImplicitLod，Dref 或者 Proj 的SPIR-V OpImageSample* 或者 OpImageSparseSample*指令一起使用
                                                                                    （3）在任何shader stage中，该VkSampler不能和任何包含 LOD bias或者offset 值 的SPIR-V OpImageSample* or OpImageSparseSample*指令一起使用
        31.如果shaderObject开启，一个有效的pipeline必须绑定到该命令使用的pipeline bind point上或者一个有效的shader objects以及VK_NULL_HANDLE的组合必须绑定到该命令使用的pipeline bind point每一个支持的shader stage上
        32.如何绑定到该命令使用的pipeline bind point上的VkPipeline的任何stage会访问一个uniform buffer，且该stage对uniformBuffers不以启用VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT或者VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT 创建，且robustBufferAccess特性未开启，则该stage就不能访问绑定到相同pipeline bind point的descriptor set指定的buffer范围外的值
        33.如果robustBufferAccess特性未开启，且任何会访问uniform buffer的绑定到该命令使用的pipeline bind point上对应shader stage的VkShaderEXT，则其不能访问绑定到相同pipeline bind point的descriptor set指定的buffer范围外的值
        34.如何绑定到该命令使用的pipeline bind point上的VkPipeline的任何stage会访问一个storage buffer，且该stage对storageBuffers不以启用VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT或者VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT 创建，且robustBufferAccess特性未开启，则该stage就不能访问绑定到相同pipeline bind point的descriptor set指定的buffer范围外的值
        35.如果robustBufferAccess特性未开启，且任何会访问storage buffer的绑定到该命令使用的pipeline bind point上对应shader stage的VkShaderEXT，则其不能访问绑定到相同pipeline bind point的descriptor set指定的buffer范围外的值
        36.如果commandBuffer 是一个unprotected command buffer，且protectedNoFault 未支持，则任何绑定的shaders访问的资源不能是一个protected resource
        37.如果一个绑定的shader访问一个VkSampler 或者 VkImageView ，且启用了sampler Y′C BCR conversion，则只能使用OpImageSample* 或者 OpImageSparseSample*指令，不能使用ConstOffset 以及 Offset操作符
        38.如果一个VkImageView作为该命令的结果进行访问，则（1）image view 的viewType 必须匹配Instruction/Sampler/Image View Validation p1481中描述的OpTypeImage的Dim操作符
                                                          （2）image view 的foamrt的numeric type 必须匹配OpTypeImage的Sampled Type操作符
        39.如果一个VkImageView以一个不是VK_FORMAT_A8_UNORM_KHR的format创建且通过OpImageWrite作为该命令的结果进行访问，则该命令的Texel 操作符的Type必须至少包含和 image view的 format含有的components的个数相同的components个数
        40.如果一个VkImageView以VK_FORMAT_A8_UNORM_KHR的format创建且通过OpImageWrite作为该命令的结果进行访问，则该命令的Texel 操作符的Type必须包含4个components
        41.如果一个VkBufferView通过OpImageWrite作为该命令的结果进行访问，则该命令的Texel 操作符的Type必须至少包含和 buffer view的 format含有的components的个数相同的components个数
        42.如果一个带64-bit component的VkFormat的VkImageView作为该命令的结果进行访问，则该命令的OpTypeImage操作符的SampledType的宽度必须为64
        43.如果一个带少于64-bit component的VkFormat的VkImageView作为该命令的结果进行访问，则该命令的OpTypeImage操作符的SampledType的宽度必须为32
        44.如果一个带64-bit component的VkFormat的VkBufferView作为该命令的结果进行访问，则该命令的OpTypeImage操作符的SampledType的宽度必须为64位
        45.如果一个带少于64-bit component的VkFormat的VkBufferView作为该命令的结果进行访问，则该命令的OpTypeImage操作符的SampledType的宽度必须为32
        46.如果sparseImageInt64Atomics 特性未开启，则以VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT创建的VkImage对象不能被SampledType宽度为64位的OpTypeImage的atomic instructions访问
        47.如果sparseImageInt64Atomics 特性未开启，则以VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT创建的VkBuffer对象不能被SampledType宽度为64位的OpTypeImage的atomic instructions访问
        48.如果OpImageWeightedSampleQCOM用来采样一个作为该命令的结果的VkImageView，则该image view的format features必须包含VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM
        49.如果OpImageWeightedSampleQCOM用来采样一个作为该命令的结果的sample weight image的VkImageView，则该image view的format features必须包含VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM
        50.如果OpImageBoxFilterQCOM用来采样一个作为该命令的结果的VkImageView，则该image view的format features必须包含VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM
        51.如果OpImageBlockMatchSSDQCOM，或者 OpImageBlockMatchSADQCOM用来读取一个作为该命令的结果的VkImageView，则（1）该image view的format features必须包含VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM
                                                                                                                   （2）如果是读取的reference image，指定的reference coordinates不能在integer texel coordinate validation 时候失败
        52.如果OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchWindowSSDQCOM, OpImageBlockMatchWindowSADQCOM, OpImageBlockMatchGatherSSDQCOM,
                                                    OpImageBlockMatchGatherSADQCOM, OpImageBlockMatchSSDQCOM, 或者 OpImageBlockMatchSADQCOM用来采样一个作为该命令的结果的VkImageView，则该VkSampler必须以VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM创建
        53.如果任何除了OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchWindowSSDQCOM, OpImageBlockMatchWindowSADQCOM, OpImageBlockMatchGatherSSDQCOM, OpImageBlockMatchGatherSADQCOM, OpImageBlockMatchSSDQCOM, 或者 OpImageBlockMatchSADQCOM之外的指令使用VkSampler进行采样作为该命令的结果，则该sampler不能以VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM 创建
        54.如果OpImageBlockMatchWindow*QCOM or OpImageBlockMatchGather*QCOM指令用来读取VkImageView作为该命令的结果，则（1）VkImageView的format features必须包含VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM
                                                                                                                      （2）VkImageView的format必须只含有一个component
        55.如果OpImageBlockMatchWindow*QCOM or OpImageBlockMatchGather*QCOM指令用来读取一个引用的image作为该命令的结果，则指定的 reference coordinates不能在integer texel coordinate validation 时候失败
        56.任何该命令执行的shader invocation必须已经终止
        57.如果有一个类型位为VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM, VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, 或者 VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT中任意一个的descriptor作为该命令的结果进行访问，则该descriptor所指的image subresource的layout必须和该descriptor被写入时的layout相同。
        58.当前的 render pass  必须和绑定到VK_PIPELINE_BIND_POINT_GRAPHICS上的VkPipeline 创建时候的VkGraphicsPipelineCreateInfo中指定的renderPass兼容
        59.当前的 render pass  的subpass index必须和绑定到VK_PIPELINE_BIND_POINT_GRAPHICS上的VkPipeline 创建时候的VkGraphicsPipelineCreateInfo中指定的subpass相同
        60.如果任何shader静态访问一个input attachment，则有效的descriptor必须通过VkDescriptorSet被绑定到该pipeline中
        61.如果任何该pipeline执行shader以SubpassData的Dim操作符访问一个OpTypeImage变量，则该变量必须被一个对应当前subpass的input attachment的InputAttachmentIndex修饰
        62.在subpass中访问的Input attachment views必须以和该subpass相同定义的VkFormat创建，且必须以一个和当前绑定的VkFramebuffer的该附件引用的subpass的pInputAttachments[InputAttachmentIndex]附件兼容的VkImageView创建，参见Fragment Input Attachment Compatibility p1408
        63.在动态render pass中访问以VkRenderingInputAttachmentIndexInfoKHR的InputAttachmentIndex，或者VkRenderingInputAttachmentIndexInfoKHR:pDepthInputAttachmentIndex 或者 VkRenderingInputAttachmentIndexInfoKHR:pStencilInputAttachmentIndex为NULL情况下不指定InputAttachmentIndex的引用的Input attachment views，必须以和VkRenderingInfo中对应color, depth, 或者 stencil attachment兼容的VkImageView创建
        64.如果VkRenderingInputAttachmentIndexInfoKHR::pDepthInputAttachmentIndex 以及 VkRenderingInputAttachmentIndexInfoKHR::pStencilInputAttachmentIndex不为NULL，则在动态render pass中通过shader object访问Input attachment views必须指明InputAttachmentIndex
        65.如果在动态render pass中通过shader object访问Input attachment views指明了InputAttachmentIndex，则InputAttachmentIndex必须匹配VkRenderingInputAttachmentIndexInfoKHR中的index
        66.当前render pass所用的附件对应的image subresource底层内存的写入只能作为该命令的一个附件写入
        67.如果一个color attachment在之前的该subpass的命令中以load, store, 或者 resolve operations进行了写入，则其layout不为VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT，且有当前绑定的pipeline设有VK_PIPELINE_CREATE_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT，或者
                                        最后的vkCmdSetAttachmentFeedbackLoopEnableEXT调用包含VK_IMAGE_ASPECT_COLOR_BIT以及 没有绑定的pipeline 或者绑定的pipeline以VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT创建，则该附件只能以附件进行访问的，这两种情况中之一
        68.如果一个depth attachment在之前的该subpass的命令中以load, store, 或者 resolve operations进行了写入，则其layout不为VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT，且有当前绑定的pipeline设有VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT，或者
                                        最后的vkCmdSetAttachmentFeedbackLoopEnableEXT调用包含VK_IMAGE_ASPECT_DEPTH_BIT以及 没有绑定的pipeline 或者绑定的pipeline以VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT创建，则该附件只能以附件进行访问的，这两种情况中之一
        69.如果一个stencil attachment在之前的该subpass的命令中以load, store, 或者 resolve operations进行了写入，则其layout不为VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT，且有当前绑定的pipeline设有VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT，或者
                                        最后的vkCmdSetAttachmentFeedbackLoopEnableEXT调用包含VK_IMAGE_ASPECT_STENCIL_BIT以及 没有绑定的pipeline 或者绑定的pipeline以VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT创建，则该附件只能以附件进行访问的，这两种情况中之一
        70.如果一个attachment在之前的该subpass的命令中以load, store, 或者 resolve operations进行了写入,则该附件就不能再以除作为一个附件，storage image或者sampled image被该命令访问
        71.如果在之前的命令的subpass中以用作附件外的方式访问访问了一个当权subpass的附件所对的image subresource，则该命令就不能再将该image subresource用作附件进行写入
        72.如果当前render pass使用一个depth/stencil attachment，则（1）如果depth aspect的layout为read-only的layout，则不能启用depth writes
                                                                  （2）如果stencil aspect的layout为read-only的layout，front 以及 back writeMask不为0，且stencil 测试开启，则所有stencil 操作必须为VK_STENCIL_OP_KEEP
        73.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_VIEWPORT动态state开启创建，则vkCmdSetViewport必须在该命令之前设置
                                        （2）以VK_DYNAMIC_STATE_SCISSOR动态state开启创建，则vkCmdSetScissor必须在该命令之前设置
                                        （3）以VK_DYNAMIC_STATE_LINE_WIDTH动态state开启创建，则vkCmdSetLineWidth必须在该命令之前设置
                                        （4）以VK_DYNAMIC_STATE_DEPTH_BIAS动态state开启创建，则vkCmdSetDepthBias或者vkCmdSetDepthBias2EXT 必须在该命令之前设置
                                        （5）以VK_DYNAMIC_STATE_BLEND_CONSTANTS动态state开启创建，则vkCmdSetBlendConstants 必须在该命令之前设置
                                        （6）以VK_DYNAMIC_STATE_DEPTH_BOUNDS动态state开启创建，且如果当前depthBoundsTestEnable为VK_TRUE， 则vkCmdSetDepthBounds 必须在该命令之前设置
                                        （7）以VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK动态state开启创建，且如果当前stencilTestEnable为VK_TRUE， 则vkCmdSetStencilCompareMask 必须在该命令之前设置
                                        （8）以VK_DYNAMIC_STATE_STENCIL_WRITE_MASK动态state开启创建，且如果当前stencilTestEnable为VK_TRUE， 则vkCmdSetStencilWriteMask 必须在该命令之前设置
                                        （9）以VK_DYNAMIC_STATE_STENCIL_REFERENCE动态state开启创建，且如果当前stencilTestEnable为VK_TRUE， 则vkCmdSetStencilReference 必须在该命令之前设置
                                        （10）以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT动态state开启创建， 则vkCmdSetSampleLocationsEXT 必须在该命令之前设置
                                        （11）以VK_DYNAMIC_STATE_CULL_MODE动态state开启创建， 则vkCmdSetCullMode 必须在该命令之前设置
                                        （12）以VK_DYNAMIC_STATE_FRONT_FACE动态state开启创建， 则vkCmdSetFrontFace 必须在该命令之前设置
                                        （13）以VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE动态state开启创建， 则vkCmdSetDepthTestEnable 必须在该命令之前设置
                                        （14）以VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE动态state开启创建， 则vkCmdSetDepthWriteEnable 必须在该命令之前设置
                                        （15）以VK_DYNAMIC_STATE_DEPTH_COMPARE_OP动态state开启创建， 则vkCmdSetDepthCompareOp 必须在该命令之前设置
                                        （16）以VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE动态state开启创建， 则vkCmdSetDepthBoundsTestEnable 必须在该命令之前设置
                                        （17）以VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE动态state开启创建， 则vkCmdSetStencilTestEnable 必须在该命令之前设置
                                        （18）以VK_DYNAMIC_STATE_STENCIL_OP动态state开启创建， 则vkCmdSetStencilOp 必须在该命令之前设置
                                        （19）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT但不以VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT 动态state开启创建， 则vkCmdSetViewportWithCount 必须在该命令之前设置，且vkCmdSetViewportWithCount设置的viewportCount必须匹配pipeline的VkPipelineViewportStateCreateInfo::scissorCount
                                        （20）以VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT但不以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT 动态state开启创建， 则vkCmdSetScissorWithCount 必须在该命令之前设置，且vkCmdSetScissorWithCount设置的scissorCount必须匹配pipeline的VkPipelineViewportStateCreateInfo::viewportCount
                                        （21）以VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT和VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT 动态state同时开启创建， 则vkCmdSetViewportWithCount以及vkCmdSetScissorWithCount 必须在该命令之前设置，且vkCmdSetViewportWithCount设置的viewportCount必须匹配vkCmdSetScissorWithCount设置的scissorCount
                                        （22）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT但不以VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV 动态state开启创建， 则绑定的pipeline必须以VkPipelineViewportWScalingStateCreateInfoNV::viewportCount 大于等于最近vkCmdSetViewportWithCount设置的viewportCount创建
                                        （23）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT和VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV 动态state开启创建， 则最近调用的vkCmdSetViewportWScalingNV设置的viewportCount 必须大于等于最近vkCmdSetViewportWithCount设置的viewportCount
                                        （24）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT但不以VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV 动态state开启创建， 则绑定的pipeline必须以VkPipelineViewportShadingRateImageStateCreateInfoNV::viewportCount 大于等于最近vkCmdSetViewportWithCount设置的viewportCount创建
                                        （25）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT和VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV 动态state开启创建， 则最近调用的vkCmdSetViewportShadingRatePaletteNV设置的viewportCount 必须大于等于最近vkCmdSetViewportWithCount设置的viewportCount
                                        （26）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT动态state开启且VkPipelineViewportStateCreateInfo的pNext中含有一个VkPipelineViewportSwizzleStateCreateInfoNV 创建， 则绑定的pipeline必须以VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount 大于等于最近vkCmdSetViewportWithCount设置的viewportCount创建
                                        （27）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT动态state开启且VkPipelineViewportStateCreateInfo的pNext中含有一个VkPipelineViewportExclusiveScissorStateCreateInfoNV 创建， 则绑定的pipeline必须以VkPipelineViewportExclusiveScissorStateCreateInfoNV::exclusiveScissorCount 大于等于最近vkCmdSetViewportWithCount设置的viewportCount创建
                                        （28）以VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_ENABLE_NV动态state开启创建， 则vkCmdSetExclusiveScissorEnableNV 必须在该命令之前设置
                                        （29）以VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV动态state开启创建， 则vkCmdSetExclusiveScissorNV 必须在该命令之前设置
                                        （30）以VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE动态state开启创建， 则vkCmdSetRasterizerDiscardEnable 必须在该命令之前设置
                                        （31）以VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE动态state开启创建， 则vkCmdSetDepthBiasEnable 必须在该命令之前设置
                                        （32）以VK_DYNAMIC_STATE_LOGIC_OP_EXT动态state开启创建， 则vkCmdSetLogicOpEXT 必须在该命令之前设置且参数logicOp必须是一个有效的VkLogicOp值
        74.如果一个shader object绑定到任何graphics stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                        （1）如果最靠近当前命令的vkCmdSetPolygonModeEXT设置polygonMode为VK_POLYGON_MODE_LINE或者是任何line topology，则vkCmdSetLineWidth必须在该命令之前设置
                                        （2）如果最靠近当前命令的vkCmdSetDepthBiasEnable设置depthBiasEnable为VK_TRUE，则vkCmdSetDepthBias 或者 vkCmdSetDepthBias2EXT必须在该命令之前设置
                                        （3）如果最靠近当前命令的vkCmdSetDepthBoundsTestEnable设置depthBoundsTestEnable为VK_TRUE，则vkCmdSetDepthBounds必须在该命令之前设置
                                        （4）如果最靠近当前命令的vkCmdSetStencilTestEnable设置stencilTestEnable为VK_TRUE，则vkCmdSetStencilCompareMask必须在该命令之前设置
                                        （5）如果最靠近当前命令的vkCmdSetStencilTestEnable设置stencilTestEnable为VK_TRUE，则vkCmdSetStencilWriteMask必须在该命令之前设置
                                        （6）如果最靠近当前命令的vkCmdSetStencilTestEnable设置stencilTestEnable为VK_TRUE，则vkCmdSetStencilReference必须在该命令之前设置
                                        （7）如果最靠近当前命令的vkCmdSetSampleLocationsEnableEXT设置sampleLocationsEnable为VK_TRUE，则vkCmdSetSampleLocationsEXT必须在该命令之前设置
                                        （8）则vkCmdSetCullMode必须在该命令之前设置
                                        （9）则vkCmdSetFrontFace必须在该命令之前设置
                                        （10）则vkCmdSetDepthTestEnable 必须在该命令之前设置
                                        （11）则vkCmdSetDepthWriteEnable 必须在该命令之前设置
                                        （12）如果最靠近当前命令的vkCmdSetDepthTestEnable设置depthTestEnable为VK_TRUE，则vkCmdSetDepthCompareOp 必须在该命令之前设置
                                        （13）则vkCmdSetDepthBoundsTestEnable 必须在该命令之前设置
                                        （14）则vkCmdSetStencilTestEnable 必须在该命令之前设置
                                        （15）如果最靠近当前命令的vkCmdSetStencilTestEnable设置stencilTestEnable为VK_TRUE，则vkCmdSetStencilOp 必须在该命令之前设置
                                        （16）
                                        （17）如果shadingRateImage特性开启，则vkCmdSetCoarseSampleOrderNV 必须在该命令之前设置
                                        （18）如果shadingRateImage特性开启，且最靠近当前命令的vkCmdSetShadingRateImageEnableNV设置shadingRateImageEnable为VK_TRUE，则vkCmdSetViewportShadingRatePaletteNV 必须在该命令之前设置
                                        （19）如果shadingRateImage特性开启，且最靠近当前命令的vkCmdSetShadingRateImageEnableNV设置shadingRateImageEnable为VK_TRUE，则最近的vkCmdSetViewportShadingRatePaletteNV设置的viewportCount 必须大于等于vkCmdSetViewportWithCount设置的viewportCount
                                        （20）则vkCmdSetDepthBiasEnable必须在该命令之前设置
        75.如果一个输出line primitives的shader object绑定到VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或者 VK_SHADER_STAGE_GEOMETRY_BIT，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则vkCmdSetLineWidth必须在该命令之前设置
        76.如果一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最靠近当前命令的vkCmdSetColorBlendEnableEXT设置pColorBlendEnables任何元素为VK_TRUE，且
                            最靠近当前命令的vkCmdSetColorBlendEquationEXT设置pColorBlendEquations相同元素的VkColorBlendEquationEXT的VkBlendFactor成员为VK_BLEND_FACTOR_CONSTANT_COLOR, VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR, VK_BLEND_FACTOR_CONSTANT_ALPHA, 或者 VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA，则vkCmdSetBlendConstants必须在该命令之前设置
        77.如果该命令记录在开启了multiview的render pass instance中，则最大的instance 索引必须小于等于VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex
        78.如果绑定的graphics pipeline以VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable设置为VK_TRUE创建且当前的subpass含有一个 depth/stencil attachment，则该attachment必须以VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT创建
        >>78.5  .如果一个shader object绑定到任何graphics stage，则（1）vkCmdSetViewportWithCount 和vkCmdSetScissorWithCount 必须同时在该命令之前设置，且vkCmdSetViewportWithCount设置的viewportCount必须匹配vkCmdSetScissorWithCount设置的scissorCount
                                                                  （2）则vkCmdSetRasterizerDiscardEnable 必须在该命令之前设置
        79.如果VK_NV_clip_space_w_scaling拓展开启，且shader object绑定到任何graphics stage，且最近的vkCmdSetViewportWScalingEnableNV设置viewportWScalingEnable为VK_TRUE，则（1）vkCmdSetViewportWScalingNV必须在该命令前设置
                                                                                                                                                                           （2）最近vkCmdSetViewportWScalingNV设置的viewportCount必须大于等于vkCmdSetViewportWithCount设置的viewportCount
        80.如果exclusiveScissor 特性开启，且shader object绑定到任何graphics stage，，则（1）vkCmdSetExclusiveScissorEnableNV必须在该命令前设置
                                                                                       （2）最近的vkCmdSetExclusiveScissorEnableNV调用设置的pExclusiveScissorEnables中的任何元素为VK_TRUE,则vkCmdSetExclusiveScissorNV必须在该命令前设置
        81.如果一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最靠近当前命令的vkCmdSetLogicOpEnableEXT设置logicOpEnable任何元素为VK_TRUE，则vkCmdSetLogicOpEXT 必须在该命令之前设置且参数logicOp必须是一个有效的VkLogicOp值
        82.如果primitiveFragmentShadingRateWithMultipleViewports限制不支持，则（1）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT动态state开启创建，且任何该pipeline的shader stage会写入PrimitiveShadingRateKHR built-in修饰的变量，则vkCmdSetViewportWithCount 必须在该命令之前设置且参数viewportCount必须是1
                                                                              （2）任何绑定的graphics pipeline的shader stage会写入PrimitiveShadingRateKHR built-in修饰的变量，则vkCmdSetViewportWithCount 必须在该命令之前设置且参数viewportCount必须是1
        83.如果graphics pipeline中未开启rasterization，则对subpass中的每个color attachment，如果其对应的image view 的format features不包含VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT，则pColorBlendState中其对应pAttachments中元素的blendEnable必须为VK_FALSE
        84.如果一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则对于render pass中的每个color attachment，如果其对应的image view 的format features不包含VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT， 则最近的vkCmdSetColorBlendEnableEXT设置的pColorBlendEnables中该附件的对应元素必须为VK_FALSE
        85.如果graphics pipeline中未开启rasterization，有VK_AMD_mixed_attachment_samples拓展未开启，VK_NV_framebuffer_mixed_samples拓展未开启，multisampledRenderToSingleSampled特性未开启，则当前绑定的pipeline的rasterizationSamples必须和当前subpass的color 以及/或者 depth/stencil attachments的相同
        86.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且有VK_AMD_mixed_attachment_samples拓展未开启，VK_NV_framebuffer_mixed_samples拓展未开启，multisampledRenderToSingleSampled特性未开启，则最近vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples必须和当前subpass的color 以及/或者 depth/stencil attachments的相同
        87.如果一个shader object绑定到任何graphics stage，则当前的render pass instance必须以vkCmdBeginRendering开始
        88.如果当前的render pass instance以vkCmdBeginRendering开始，（1）如果pDepthAttachment的imageView不为VK_NULL_HANDLE，且pDepthAttachment的layout不为VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL，则该命令不能写入任何值到depth attachment
                                                                    （2）如果pStencilAttachment的imageView不为VK_NULL_HANDLE，且pStencilAttachment的layout不为VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL，则该命令不能写入任何值到stencil attachment
                                                                    （3）如果pDepthAttachment的imageView不为VK_NULL_HANDLE，且pDepthAttachment的layout为VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL，则该命令不能写入任何值到depth attachment
                                                                    （4）如果pStencilAttachment的imageView不为VK_NULL_HANDLE，且pStencilAttachment的layout为VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL，则该命令不能写入任何值到stencil attachment
                                                                    （5）如果pDepthAttachment的imageView不为VK_NULL_HANDLE，且pDepthAttachment的layout为VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL，则该命令不能写入任何值到depth attachment
                                                                    （6）如果pStencilAttachment的imageView不为VK_NULL_HANDLE，且pStencilAttachment的layout为VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL，则该命令不能写入任何值到stencil attachment
                                                                    （7）则当前绑定的graphics pipeline必须以含VkPipelineRenderingCreateInfo::viewMask等于VkRenderingInfo::viewMask创建
                                                                    （8）如果带有VkRenderingInfo::colorAttachmentCount为1，则没有shader object绑定到任何graphics stage，且一个color attachment的 resolve mode为VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID，则VkRenderingInfo::pColorAttachments中每个resolveImageView不为VK_NULL_HANDLE的元素其对应image必须以和创建当前绑定的pipeline 相同的VkExternalFormatANDROID::externalFormat创建
                                                                    （9）如果没有shader object绑定到任何graphics stage，如果绑定的graphics pipeline以一个非零值VkExternalFormatANDROID::externalFormat创建且启用VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态设置，则vkCmdSetColorBlendEnableEXT必须在该命令前设置blend enable为VK_FALSE
                                                                    （10）如果没有shader object绑定到任何graphics stage，如果绑定的graphics pipeline以一个非零值VkExternalFormatANDROID::externalFormat创建且启用VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态设置，则vkCmdSetRasterizationSamplesEXT必须在该命令前设置rasterizationSamples为VK_SAMPLE_COUNT_1_BIT
                                                                    （11）如果没有shader object绑定到任何graphics stage，如果绑定的graphics pipeline以一个非零值VkExternalFormatANDROID::externalFormat创建且启用VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR动态设置，则vkCmdSetFragmentShadingRateKHR必须在该命令前设置pFragmentSize->width为1，pFragmentSize->height为1
        89.如果dynamicRenderingUnusedAttachments特性未开启，且当前的render pass instance以vkCmdBeginRendering开始，则
                                                                （1）当前绑定的graphics pipeline必须以含VkPipelineRenderingCreateInfo::colorAttachmentCount等于VkRenderingInfo::colorAttachmentCount创建
                                                                （2）如果VkRenderingInfo::colorAttachmentCount大于0，则VkRenderingInfo::pColorAttachments 中每一个其imageView不为VK_NULL_HANDLE的元素的VkImageView必须以VkFormat对应绑定的graphics pipeline的VkPipelineRenderingCreateInfo::pColorAttachmentFormats指明的format创建
                                                                （3）如果VkRenderingInfo::colorAttachmentCount大于0，则VkRenderingInfo::pColorAttachments 中每一个其imageView为VK_NULL_HANDLE的元素对应绑定的graphics pipeline的VkPipelineRenderingCreateInfo::pColorAttachmentFormats指明的format必须为VK_FORMAT_UNDEFINED
                                                                （4）如果VkRenderingInfo::pDepthAttachment->imageView为VK_NULL_HANDLE，则创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::depthAttachmentFormat必须为VK_FORMAT_UNDEFINED
                                                                （5）如果VkRenderingInfo::pDepthAttachment->imageView不为VK_NULL_HANDLE，则创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::depthAttachmentFormat必须和创建VkRenderingInfo::pDepthAttachment->imageView的VkFormat相同
                                                                （6）如果VkRenderingInfo::pStencilAttachment->imageView为VK_NULL_HANDLE，则创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::stencilAttachmentFormat必须为VK_FORMAT_UNDEFINED
                                                                （7）如果VkRenderingInfo::pStencilAttachment->imageView不为VK_NULL_HANDLE，则创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::stencilAttachmentFormat必须和创建VkRenderingInfo::pStencilAttachment->imageView的VkFormat相同
        90.如果dynamicRenderingUnusedAttachments特性开启，且当前的render pass instance以vkCmdBeginRendering开始，则
                                                                （1）如果VkRenderingInfo::colorAttachmentCount大于0，则VkRenderingInfo::pColorAttachments 中每一个其imageView不为VK_NULL_HANDLE的元素的VkImageView必须以VkFormat对应绑定的graphics pipeline的VkPipelineRenderingCreateInfo::pColorAttachmentFormats指明的format创建，或者是对应元素为VK_FORMAT_UNDEFINED创建
                                                                （2）如果VkRenderingInfo::pDepthAttachment->imageView不为VK_NULL_HANDLE，且创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::depthAttachmentFormat和创建VkRenderingInfo::pDepthAttachment->imageView的VkFormat不同，则该format必须为VK_FORMAT_UNDEFINED
                                                                （3）如果VkRenderingInfo::pStencilAttachment->imageView不为VK_NULL_HANDLE，且创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::stencilAttachmentFormat和创建VkRenderingInfo::pStencilAttachment->imageView的VkFormat不同，则该format必须为VK_FORMAT_UNDEFINED
        91.如果没有shader object绑定到任何graphics stage，且当前的render pass instance以vkCmdBeginRendering开始且VkRenderingInfo::colorAttachmentCount为1，且一个color attachment的 resolve mode为VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID，则VkRenderingInfo::pColorAttachments中每个resolveImageView不为VK_NULL_HANDLE的元素其对应image必须以和创建当前绑定的pipeline 相同的VkExternalFormatANDROID::externalFormat创建
        92.如果有一个shader object绑定到任何graphics stage，且当前的render pass 包含一个使用VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID resolve mode的color attachment，则（1）vkCmdSetColorBlendEnableEXT必须在该命令前设置blend enable为VK_FALSE
                                                                                                                                                                                 （2）则vkCmdSetRasterizationSamplesEXT必须在该命令前设置rasterizationSamples为VK_SAMPLE_COUNT_1_BIT
                                                                                                                                                                                 （3）则vkCmdSetFragmentShadingRateKHR必须在该命令前设置pFragmentSize->width为1，pFragmentSize->height为1
        93.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT动态state开启创建， 则vkCmdSetColorWriteEnableEXT 必须在该命令之前设置，且设置的attachmentCount必须大于等于创建当前绑定的pipeline的VkPipelineColorBlendStateCreateInfo::attachmentCount
                                        （2）以VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT动态state开启创建， 则vkCmdSetDiscardRectangleEXT 必须在该命令之前为每个VkPipelineDiscardRectangleStateCreateInfoEXT::discardRectangleCount指明的discard rectangle 设置
                                        （3）以VK_DYNAMIC_STATE_DISCARD_RECTANGLE_ENABLE_EXT动态state开启创建， 则vkCmdSetDiscardRectangleEnableEXT 必须在该命令之前设置
                                        （4）以VK_DYNAMIC_STATE_DISCARD_RECTANGLE_MODE_EXT动态state开启创建， 则vkCmdSetDiscardRectangleModeEXT 必须在该命令之前设置
        94.如果有一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                        （1）如果colorWriteEnable特性在device上开启，则vkCmdSetColorWriteEnableEXT 必须在该命令之前设置，且设置的attachmentCount必须大于等于当前render pass instance的color attachment的数量
                                        （2）如果VK_EXT_discard_rectangles拓展开启，且最近的vkCmdSetDiscardRectangleEnableEXT设置discardRectangleEnable为VK_TRUE， 则vkCmdSetDiscardRectangleEXT 必须在该命令之前设置
                                        （3）如果VK_EXT_discard_rectangles拓展开启， 则vkCmdSetDiscardRectangleEnableEXT 必须在该命令之前设置
                                        （4）如果VK_EXT_discard_rectangles拓展开启， 则最近的vkCmdSetDiscardRectangleEnableEXT设置discardRectangleEnable为VK_TRUE，则vkCmdSetDiscardRectangleModeEXT 必须在该命令之前设置
        95.如果当前的render pass instance以vkCmdBeginRendering开始，则（1）如果VkRenderingFragmentShadingRateAttachmentInfoKHR::imageView不为VK_NULL_HANDLE，则当前绑定的graphics pipeline必须以VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR创建
                                                                      （2）如果VkRenderingFragmentDensityMapAttachmentInfoEXT::imageView不为VK_NULL_HANDLE，则当前绑定的graphics pipeline必须以VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT创建
                                                                      （3）且含VkRenderingInfo::colorAttachmentCount大于0，如果当前的绑定的pipeline以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，则VkRenderingInfo::pColorAttachments中每个imageView不为VK_NULL_HANDLE的元素的imageView，必须以当前pipeline的VkAttachmentSampleCountInfoAMD 或者 VkAttachmentSampleCountInfoNV中的pColorAttachmentSamples中对应元素的sample count进行创建
                                                                      （4）如果当前的绑定的pipeline以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且VkRenderingInfo::pDepthAttachment中的imageView不为VK_NULL_HANDLE，则当前pipeline的VkAttachmentSampleCountInfoAMD 或者 VkAttachmentSampleCountInfoNV中的depthStencilAttachmentSamples必须等于创建VkRenderingInfo::pDepthAttachment->imageView的sample count
                                                                      （5）如果当前的绑定的pipeline以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且VkRenderingInfo::pStencilAttachment中的imageView不为VK_NULL_HANDLE，则当前pipeline的VkAttachmentSampleCountInfoAMD 或者 VkAttachmentSampleCountInfoNV中的depthStencilAttachmentSamples必须等于创建VkRenderingInfo::pStencilAttachment->imageView的sample count
                                                                      （6）且含VkRenderingInfo::colorAttachmentCount大于0，如果当前的绑定的pipeline不以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且multisampledRenderToSingleSampled特性没有开启，则VkRenderingInfo::pColorAttachments中每个imageView不为VK_NULL_HANDLE的元素的imageView，其创建的sample count必须等于当前绑定的graphics pipeline的rasterizationSamples
                                                                      （7）如果当前的绑定的pipeline不以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且VkRenderingInfo::pDepthAttachment中的imageView不为VK_NULL_HANDLE，且multisampledRenderToSingleSampled特性没有开启，则当前pipeline的rasterizationSamples 必须等于创建VkRenderingInfo::pDepthAttachment->imageView的sample count
                                                                      （8）如果当前的绑定的pipeline不以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且VkRenderingInfo::pStencilAttachment中的imageView不为VK_NULL_HANDLE，且multisampledRenderToSingleSampled特性没有开启，则当前pipeline的rasterizationSamples 必须等于创建VkRenderingInfo::pStencilAttachment->imageView的sample count
                                                                      （9）当前绑定的pipeline必须VkGraphicsPipelineCreateInfo::renderPass为VK_NULL_HANDLE创建
                                                                      （10）如果绑定的pipeline的fragment shader静态写入一个color attachment，且color write mask不为0，启用了color writes，且该附件对应的VkRenderingInfo::pColorAttachments->imageView 不为VK_NULL_HANDLE，则对应的创建pipeline的VkPipelineRenderingCreateInfo::pColorAttachmentFormats中的元素不能为VK_FORMAT_UNDEFINED
                                                                      （11）如果绑定的pipeline启用了depth test，启用了depth writes，且VkRenderingInfo::pDepthAttachment->imageView 不为VK_NULL_HANDLE，则创建pipeline的VkPipelineRenderingCreateInfo::depthAttachmentFormat不能为VK_FORMAT_UNDEFINED
                                                                      （12）如果绑定的pipeline启用了stencil test，且VkRenderingInfo::pStencilAttachment->imageView 不为VK_NULL_HANDLE，则创建pipeline的VkPipelineRenderingCreateInfo::stencilAttachmentFormat不能为VK_FORMAT_UNDEFINED
        96.如果该命令在以vkCmdBeginRendering开始的render pass instance中调用，且VkRenderingInfo的pNext中包含一个multisampledRenderToSingleSampledEnable设为VK_TRUE的VkMultisampledRenderToSingleSampledInfoEXT，则当前绑定的graphics pipeline的rasterizationSamples必须等于VkMultisampledRenderToSingleSampledInfoEXT::rasterizationSamples
        97.如果primitivesGeneratedQueryWithRasterizerDiscard特性未开启，且VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query激活，则不能启用rasterization discard
        98.如果primitivesGeneratedQueryWithNonZeroStreams特性未开启，且VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query激活，则 绑定的graphics pipeline不能以VkPipelineRasterizationStateStreamCreateInfoEXT::rasterizationStream为非零值创建
        98.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_TESSELLATION_DOMAIN_ORIGIN_EXT动态state开启创建，则vkCmdSetTessellationDomainOriginEXT必须在该命令之前设置
                                        （2）以VK_DYNAMIC_STATE_DEPTH_CLAMP_ENABLE_EXT动态state开启创建，则vkCmdSetDepthClampEnableEXT必须在该命令之前设置
                                        （3）以VK_DYNAMIC_STATE_POLYGON_MODE_EXT动态state开启创建，则vkCmdSetPolygonModeEXT必须在该命令之前设置
                                        （4）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，则vkCmdSetRasterizationSamplesEXT必须在该命令之前设置
                                        （5）以VK_DYNAMIC_STATE_SAMPLE_MASK_EXT动态state开启创建，则vkCmdSetSampleMaskEXT必须在该命令之前设置
                                        （6）以VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT动态state开启创建，则vkCmdSetAlphaToCoverageEnableEXT必须在该命令之前设置
                                        （7）以VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT动态state开启创建，则最近的vkCmdSetAlphaToCoverageEnableEXT设置alphaToCoverageEnable为VK_TRUE，则Fragment Output Interface中 Index 0的Location 0必须有一个含alpha Component的变量
                                        （8）以VK_DYNAMIC_STATE_ALPHA_TO_ONE_ENABLE_EXT动态state开启创建，则vkCmdSetAlphaToOneEnableEXT必须在该命令之前设置
                                        （9）以VK_DYNAMIC_STATE_LOGIC_OP_ENABLE_EXT动态state开启创建，则vkCmdSetLogicOpEnableEXT必须在该命令之前设置
                                        （10）以VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态state开启创建，则vkCmdSetColorBlendEnableEXT必须在该命令之前设置
                                        （11）以VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT动态state开启创建，则vkCmdSetColorBlendEquationEXT必须在该命令之前设置
                                        （12）以VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT动态state开启创建，则vkCmdSetColorWriteMaskEXT必须在该命令之前设置
        
        99.如果一个shader object绑定到VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT stage，则vkCmdSetTessellationDomainOriginEXT必须在该命令之前设置
        100.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                                        （1）如果depthClamp特性启用，则vkCmdSetDepthClampEnableEXT必须在该命令之前设置
                                                        （2）则vkCmdSetPolygonModeEXT必须在该命令之前设置
                                                        （3）则vkCmdSetRasterizationSamplesEXT必须在该命令之前设置
                                                        （4）则vkCmdSetSampleMaskEXT必须在该命令之前设置
                                                        （5）则vkCmdSetAlphaToCoverageEnableEXT必须在该命令之前设置
                                                        （6）如果alphaToOne特性启用，则vkCmdSetAlphaToOneEnableEXT必须在该命令之前设置
        
        101.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetAlphaToCoverageEnableEXT设置alphaToCoverageEnable为VK_TRUE，则Fragment Output Interface中 Index 0的Location 0必须有一个含alpha Component的变量
        102.如果一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                            （1）如果logicOp特性开启 ,vkCmdSetLogicOpEnableEXT必须在该命令之前设置
                                            （2）如果绑定了color attachments，则vkCmdSetColorBlendEnableEXT必须在该命令之前设置
                                            （3）如果最近的vkCmdSetColorBlendEnableEXT设置任何附件在pColorBlendEnables中的值为VK_TRUE ，则vkCmdSetColorBlendEquationEXT必须在该命令之前设置
                                            （4）如果绑定了color attachments，则vkCmdSetColorWriteMaskEXT必须在该命令之前设置
        
        103.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT动态state开启创建，则vkCmdSetRasterizationStreamEXT必须在该命令之前设置
                                         （2）以VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT动态state开启创建，则vkCmdSetConservativeRasterizationModeEXT必须在该命令之前设置
                                         （3）以VK_DYNAMIC_STATE_EXTRA_PRIMITIVE_OVERESTIMATION_SIZE_EXT动态state开启创建，则vkCmdSetExtraPrimitiveOverestimationSizeEXT必须在该命令之前设置
                                         （4）以VK_DYNAMIC_STATE_DEPTH_CLIP_ENABLE_EXT动态state开启创建，则vkCmdSetDepthClipEnableEXT必须在该命令之前设置
                                         （5）以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT动态state开启创建，则vkCmdSetSampleLocationsEnableEXT必须在该命令之前设置
                                         （6）以VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT动态state开启创建，则vkCmdSetColorBlendAdvancedEXT必须在该命令之前设置
                                         （7）以VK_DYNAMIC_STATE_PROVOKING_VERTEX_MODE_EXT动态state开启创建，则vkCmdSetProvokingVertexModeEXT必须在该命令之前设置
                                         （8）以VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT动态state开启创建，则vkCmdSetLineRasterizationModeEXT必须在该命令之前设置
                                         （9）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT动态state开启创建，则vkCmdSetLineStippleEnableEXT必须在该命令之前设置
                                         （10）以VK_DYNAMIC_STATE_LINE_STIPPLE_KHR动态state开启创建，则vkCmdSetLineStippleKHR必须在该命令之前设置
                                         （11）以VK_DYNAMIC_STATE_DEPTH_CLIP_NEGATIVE_ONE_TO_ONE_EXT动态state开启创建，则vkCmdSetDepthClipNegativeOneToOneEXT必须在该命令之前设置
                                         （12）以VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_ENABLE_NV动态state开启创建，则vkCmdSetViewportWScalingEnableNV必须在该命令之前设置
                                         （13）以VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV动态state开启创建，则vkCmdSetViewportSwizzleNV必须在该命令之前设置
                                         （14）以VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV动态state开启创建，则vkCmdSetCoverageToColorEnableNV必须在该命令之前设置
                                         （15）以VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_LOCATION_NV动态state开启创建，则vkCmdSetCoverageToColorLocationNV必须在该命令之前设置
                                         （16）以VK_DYNAMIC_STATE_COVERAGE_MODULATION_MODE_NV动态state开启创建，则vkCmdSetCoverageModulationModeNV必须在该命令之前设置
                                         （17）以VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV动态state开启创建，则vkCmdSetCoverageModulationTableEnableNV必须在该命令之前设置
                                         （18）以VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_NV动态state开启创建，则vkCmdSetCoverageModulationTableNV必须在该命令之前设置
                                         （19）以VK_DYNAMIC_STATE_SHADING_RATE_IMAGE_ENABLE_NV动态state开启创建，则vkCmdSetShadingRateImageEnableNV必须在该命令之前设置
                                         （20）以VK_DYNAMIC_STATE_REPRESENTATIVE_FRAGMENT_TEST_ENABLE_NV动态state开启创建，则vkCmdSetRepresentativeFragmentTestEnableNV必须在该命令之前设置
                                         （21）以VK_DYNAMIC_STATE_COVERAGE_REDUCTION_MODE_NV动态state开启创建，则vkCmdSetCoverageReductionModeNV必须在该命令之前设置
        
        104.如果一个shader object绑定到VK_SHADER_STAGE_GEOMETRY_BIT stage，且如果geometryStreams 特性开启，则vkCmdSetRasterizationStreamEXT必须在该命令之前设置
        105.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                （1）如果VK_EXT_conservative_rasterization 拓展开启，vkCmdSetConservativeRasterizationModeEXT必须在该命令之前设置
                                （2）如果VK_EXT_conservative_rasterization 拓展开启，且最近的vkCmdSetConservativeRasterizationModeEXT设置conservativeRasterizationMode为VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT，则vkCmdSetExtraPrimitiveOverestimationSizeEXT必须在该命令之前设置
                                （3）如果VK_EXT_sample_locations 拓展开启，则vkCmdSetSampleLocationsEnableEXT必须在该命令之前设置
        106.如果一个shader object绑定到任何graphics stage，且depthClipEnable 特性开启，则vkCmdSetDepthClipEnableEXT必须在该命令之前设置
        107.如果如果一个shader object绑定到任何VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且如果VK_EXT_blend_operation_advanced 拓展开启，则vkCmdSetColorBlendEquationEXT 和 vkCmdSetColorBlendAdvancedEXT中至少一个必须在该命令之前设置
        108.如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，如果VK_EXT_provoking_vertex拓展开启， 则vkCmdSetProvokingVertexModeEXT必须在该命令之前设置
        109.如果VK_KHR_line_rasterization 或者 VK_EXT_line_rasterization拓展开启，则（1）如果一个shader object绑定到任意一个graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetPolygonModeEXT设置polygonMode 为VK_POLYGON_MODE_LINE ，则vkCmdSetLineRasterizationModeEXT必须在该命令之前设置
                                                                                    （2）如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetPrimitiveTopology设置primitiveTopology 为任何line topology ，则vkCmdSetLineRasterizationModeEXT必须在该命令之前设置
                                                                                    （3）如果一个输出为line primitive的shader object绑定到VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或 VK_SHADER_STAGE_GEOMETRY_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则vkCmdSetLineRasterizationModeEXT必须在该命令之前设置
                                                                                    （4）如果一个shader object绑定到任意一个graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetPolygonModeEXT设置polygonMode 为VK_POLYGON_MODE_LINE ，则vkCmdSetLineStippleEnableEXT必须在该命令之前设置
                                                                                    （5）如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetPrimitiveTopology设置primitiveTopology 为任何line topology ，则vkCmdSetLineStippleEnableEXT必须在该命令之前设置
                                                                                    （6）如果一个输出为line primitive的shader object绑定到VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或 VK_SHADER_STAGE_GEOMETRY_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则vkCmdSetLineStippleEnableEXT必须在该命令之前设置
                                                                                    （7）如果一个shader object绑定到任意一个graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetLineStippleEnableEXT设置stippledLineEnable 为VK_TRUE ，则vkCmdSetLineStippleEXT必须在该命令之前设置
        110.如果一个shader object绑定到任何graphics stage，（1）如果depthClipControl 特性开启，则vkCmdSetDepthClipNegativeOneToOneEXT必须在该命令之前设置
                                                           （2）VK_NV_clip_space_w_scaling 拓展开启，则vkCmdSetViewportWScalingEnableNV必须在该命令之前设置
                                                           （3）VK_NV_viewport_swizzle 拓展开启，则vkCmdSetViewportSwizzleNV必须在该命令之前设置
        111.如果如果一个shader object绑定到任何VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                            （1）如果VK_NV_fragment_coverage_to_color 拓展开启，则vkCmdSetCoverageToColorEnableNV 必须在该命令之前设置
                            （2）如果VK_NV_fragment_coverage_to_color 拓展开启，且最近的vkCmdSetCoverageToColorEnableNV 设置coverageToColorEnable 为VK_TRUE，则vkCmdSetCoverageToColorLocationNV 必须在该命令之前设置
                            （3）如果pipelineFragmentShadingRate 特性开启，则vkCmdSetFragmentShadingRateKHR 必须在该命令之前设置
        112.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                    （1）如果VK_NV_framebuffer_mixed_samples 拓展开启，则vkCmdSetCoverageModulationModeNV 必须在该命令之前设置
                                    （2）如果VK_NV_framebuffer_mixed_samples 拓展开启，且最近的vkCmdSetCoverageModulationModeNV设置coverageModulationMode为任何除VK_COVERAGE_MODULATION_MODE_NONE_NV之外的值，则vkCmdSetCoverageModulationTableEnableNV 必须在该命令之前设置
                                    （3）如果VK_NV_framebuffer_mixed_samples 拓展开启，最近的vkCmdSetCoverageModulationTableEnableNV设置coverageModulationTableEnable为VK_TRUE，则vkCmdSetCoverageModulationTableNV 必须在该命令之前设置
                                    （4）如果shadingRateImage 特性开启，则vkCmdSetShadingRateImageEnableNV 必须在该命令之前设置
                                    （5）如果representativeFragmentTest 特性开启，则vkCmdSetRepresentativeFragmentTestEnableNV 必须在该命令之前设置
                                    （6）如果coverageReductionMode 特性开启，则vkCmdSetCoverageReductionModeNV 必须在该命令之前设置
        113.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态state开启创建，且最近的vkCmdSetColorBlendEnableEXT设置任何附件在pColorBlendEnables中的值为VK_TRUE 则subpas中这些附件对应的image view的format features中必须包含VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT
                                         （2）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，且当前subpass不使用任何color和/或者 depth/stencil attachments，则最后的vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples必须符合zero￾attachment subpass的规则
                                         （3）以VK_DYNAMIC_STATE_SAMPLE_MASK_EXT不以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT 动态state开启创建，则最后调用的vkCmdSetSampleMaskEXT中设置的samples参数必须大于等于创建该pipeline的VkPipelineMultisampleStateCreateInfo::rasterizationSamples
                                         （4）以VK_DYNAMIC_STATE_SAMPLE_MASK_EXT和 VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT 动态state开启创建，则最后调用的vkCmdSetSampleMaskEXT中设置的samples参数必须大于等于最后的vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples
                                         （5）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，且VK_AMD_mixed_attachment_samples和VK_NV_framebuffer_mixed_samples拓展都没有开启，则最后的vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples必须等于subpass中color和/或者 depth/stencil attachments使用的相同
                                         （6）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，或者一个shader object绑定到任意graphics stage，且当前的subpass包含一个multisampledRenderToSingleSampledEnable 为VK_TRUE的VkMultisampledRenderToSingleSampledInfoEXT，则最后的vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples必须等于该VkMultisampledRenderToSingleSampledInfoEXT中的对应成员
                                         （7）以VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态state开启创建，则vkCmdSetColorBlendEnableEXT 必须在该命令之前设置，且vkCmdSetColorBlendEnableEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定值
                                         （8）以VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT动态state开启创建，则vkCmdSetColorBlendEquationEXT 必须在该命令之前设置，且vkCmdSetColorBlendEquationEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定blend equations
                                         （9）以VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT动态state开启创建，则vkCmdSetColorWriteMaskEXT 必须在该命令之前设置，且vkCmdSetColorWriteMaskEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定color write mask
                                         （10）以VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT动态state开启创建，则vkCmdSetColorBlendAdvancedEXT 必须在该命令之前设置，且vkCmdSetColorBlendAdvancedEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活blend的color attachments指定advanced blend equations
                                         （11）以VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT和VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态state开启创建，且最后的vkCmdSetColorBlendEnableEXT和vkCmdSetColorBlendAdvancedEXT设置启用了advanced blending，则当前subpass中激活的color attachments的数量不能超过advancedBlendMaxColorAttachments
                                         （12）以VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT动态state开启创建，且如果primitivesGeneratedQueryWithNonZeroStreams特性未开启且VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query已经激活，则最后的vkCmdSetRasterizationStreamEXT必须设置rasterizationStream为0
                                         （13）以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT但不以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，则最后的vkCmdSetSampleLocationsEXT设置的pSampleLocationsInfo->sampleLocationsPerPixel必须等于创建pipeline的VkPipelineMultisampleStateCreateInfo::rasterizationSamples
                                         （14）以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT和VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，则最后的vkCmdSetSampleLocationsEXT设置的pSampleLocationsInfo->sampleLocationsPerPixel必须等于最后vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples
                                         （15）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT但不以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT动态state开启创建，且绑定的pipeline的VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable为VK_TRUE 或者以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT动态state开启，则sampleLocationsInfo.sampleLocationsPerPixel 必须等于最后vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples
                                         （16）以VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV动态state开启创建，且最后的vkCmdSetCoverageToColorEnableNV设置coverageToColorEnable为VK_TRUE，则当前subpass必须有color attachment，且该attachment的format必须为VK_FORMAT_R8_UINT, VK_FORMAT_R8_SINT, VK_FORMAT_R16_UINT, VK_FORMAT_R16_SINT, VK_FORMAT_R32_UINT, 或者 VK_FORMAT_R32_SINT，且该attachment的location 有最后的vkCmdSetCoverageToColorLocationNV设置的coverageToColorLocation决定
                                         （17）以VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV和VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT 动态state开启创建，且如果VK_NV_coverage_reduction_mode 拓展开启，则当前的 coverageReductionMode，rasterizationSamples 以及color 以及 depth/stencil attachments（如果subpass有）的sample count必须是有效的返回值vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV的值的组合
                                         （18）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT但不以VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV 动态state开启创建，则绑定的graphics pipeline的VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount 必须大于等于最后vkCmdSetViewportWithCount设置的viewportCount
                                         （19）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT和VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV 动态state开启创建，则最后vkCmdSetViewportSwizzleNV设置的viewportCount 必须大于等于最后vkCmdSetViewportWithCount设置的viewportCount
                                         （20）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT或者 VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT 动态state开启创建，如果当前的stippledLineEnable为VK_TRUE，且当前的lineRasterizationMode为VK_LINE_RASTERIZATION_MODE_RECTANGULAR_KHR，则stippledRectangularLines 特性必须开启
                                         （21）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT或者 VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT 动态state开启创建，如果当前的stippledLineEnable为VK_TRUE，且当前的lineRasterizationMode为VK_LINE_RASTERIZATION_MODE_BRESENHAM_KHR，则stippledBresenhamLines 特性必须开启
                                         （22）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT或者 VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT 动态state开启创建，如果当前的stippledLineEnable为VK_TRUE，且当前的lineRasterizationMode为VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_KHR，则stippledSmoothLines 特性必须开启
                                         （23）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT或者 VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT 动态state开启创建，如果当前的stippledLineEnable为VK_TRUE，且当前的lineRasterizationMode为VK_LINE_RASTERIZATION_MODE_DEFAULT_KHR，则stippledRectangularLines 特性必须开启且VkPhysicalDeviceLimits::strictLines 必须为VK_TRUE
                                         （24）以VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT 动态state开启创建，且conservativePointAndLineRasterization不支持，最后的 pre-rasterization shader stage输出的有效图元拓扑为点或者线，则最后vkCmdSetConservativeRasterizationModeEXT设置的conservativeRasterizationMode 必须为VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT
                                         （25）以VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT 动态state开启创建，则vkCmdSetAttachmentFeedbackLoopEnableEXT 必须在该命令之前调用
        114.如果一个shader object绑定到 VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                                                                            （1）则vkCmdSetColorBlendEnableEXT 必须在该命令之前设置，且vkCmdSetColorBlendEnableEXT指定的firstAttachment开始的attachmentCount的值必须为当前subpass所有激活的color attachments指定
                                                                                            （2）则vkCmdSetColorBlendEquationEXT 必须在该命令之前设置，且vkCmdSetColorBlendEquationEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定blend equations
                                                                                            （3）则vkCmdSetColorWriteMaskEXT 必须在该命令之前设置，且vkCmdSetColorWriteMaskEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定color write mask
                                                                                            （4）如果VK_NV_fragment_coverage_to_color拓展开启， 最后的vkCmdSetCoverageToColorEnableNV设置coverageToColorEnable为VK_TRUE，则当前subpass必须有color attachment，且该attachment的format必须为VK_FORMAT_R8_UINT, VK_FORMAT_R8_SINT, VK_FORMAT_R16_UINT, VK_FORMAT_R16_SINT, VK_FORMAT_R32_UINT, 或者 VK_FORMAT_R32_SINT，且该attachment的location 有最后的vkCmdSetCoverageToColorLocationNV设置的coverageToColorLocation决定
        115.如果一个shader object绑定到 VK_SHADER_STAGE_FRAGMENT_BIT stage，（1）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT动态state开启创建，且最近的vkCmdSetSampleLocationsEnableEXT设置sampleLocationsEnable为VK_TRUE，且该subpass含有depth/stencil attachment，则该附件必须以VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT创建
                                                                            （2）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT和VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT 动态state开启创建，且最近的vkCmdSetSampleLocationsEnableEXT设置sampleLocationsEnable为VK_TRUE，则 最后vkCmdSetSampleLocationsEXT设置的sampleLocationsInfo.sampleLocationGridSize.width以及height 必须等于被调用vkGetPhysicalDeviceMultisamplePropertiesEXT传入rasterizationSamples返回的VkMultisamplePropertiesEXT::sampleLocationGridSize.width以及height一一对应均匀整除
                                                                            （3）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT 动态state开启创建，且最近的vkCmdSetSampleLocationsEnableEXT设置sampleLocationsEnable为VK_TRUE，则fragment shader代码中不能静态使用扩展指令InterpolateAtSample
                                                                            （4）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT但不以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT 动态state开启创建，且绑定的pipeline的VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable为VK_TRUE 或者以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT动态state开启，则 最后vkCmdSetRasterizationSamplesEXT设置的sampleLocationsInfo.sampleLocationGridSize.width以及height 必须等于被调用vkGetPhysicalDeviceMultisamplePropertiesEXT传入和vkCmdSetRasterizationSamplesEXT设置的相同rasterizationSamples的samples返回的VkMultisamplePropertiesEXT::sampleLocationGridSize.width以及height一一对应均匀整除
        116.如果一个shader object绑定到任何graphics stage，（1）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV 动态state开启创建，且最近的vkCmdSetCoverageModulationTableEnableNV设置coverageModulationTableEnable为VK_TRUE，则最近的vkCmdSetCoverageModulationTableNV 设置的coverageModulationTableCount 必须等于当前rasterizationSamples除以当前subppas的color samples
                                                           （2）如果VK_NV_viewport_swizzle 拓展开启，则最后vkCmdSetViewportSwizzleNV设置的viewportCount 必须大于等于最后vkCmdSetViewportWithCount设置的viewportCount
        117.如果VK_NV_framebuffer_mixed_samples 拓展开启，且如果在绑定的graphics pipeline中当前subpass有一个depth/stencil attachment以及dep test, stencil test, 或depth bounds test 启用，则当前rasterizationSamples 必须等于depth/stencil attachment的sample count
        118.如果VK_NV_framebuffer_mixed_samples 拓展开启，且如果最后的vkCmdSetRasterizationSamplesEXT设置的当前subpass的任何color attachments的rasterizationSamples 都大于 color samples，则sampleShadingEnable 必须为VK_FALSE
        119.如果当前绑定的graphics pipeline以VkGraphicsPipelineCreateInfo::pStages中的元素的VkPipelineShaderStageCreateInfo::stage设置为VK_SHADER_STAGE_VERTEX_BIT, VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT, VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或者 VK_SHADER_STAGE_GEOMETRY_BIT创建，则Mesh Shader Queries 不能激活
        120.如果dynamic state继承自VkCommandBufferInheritanceViewportScissorInfoNV，则这些动态state的设置必须在该命令之前设置
        121.如果没有绑定graphics pipeline，则（1）vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_VERTEX_BIT
                                             （2）如果tessellationShader 特性开启，vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT，VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT
                                             （3）如果geometryShader 特性开启，vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_GEOMETRY_BIT
                                             （4）vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_FRAGMENT_BIT
                                             （5）如果taskShader 特性开启，vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_TASK_BIT_EXT
                                             （6）如果meshShader 特性开启，vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_MESH_BIT_EXT
                                             （8）如果至少taskShader 和 meshShader一个特性开启，VK_SHADER_STAGE_VERTEX_BIT 或者VK_SHADER_STAGE_MESH_BIT_EXT stages中的一个必须含有有效的VkShaderEXT绑定，另外一个则不含有VkShaderEXT绑定
                                             （9）如果taskShader 和 meshShader特性同时开启，且一个有效的VkShaderEXT 绑定到VK_SHADER_STAGE_MESH_BIT_EXT stage，且该VkShaderEXT不以VK_SHADER_CREATE_NO_TASK_SHADER_BIT_EXT 创建，则一个有效的VkShaderEXT必须绑定到VK_SHADER_STAGE_TASK_BIT_EXT stage
                                             （10）如果taskShader 和 meshShader特性同时开启，且一个有效的VkShaderEXT 绑定到VK_SHADER_STAGE_MESH_BIT_EXT stage，且该VkShaderEXT以VK_SHADER_CREATE_NO_TASK_SHADER_BIT_EXT 创建，则不能有VkShaderEXT绑定到VK_SHADER_STAGE_TASK_BIT_EXT stage
                                             （11）如果一个有效的VkShaderEXT 绑定到VK_SHADER_STAGE_VERTEX_BIT stage，则不能有VkShaderEXT绑定到VK_SHADER_STAGE_TASK_BIT_EXT stage或者VK_SHADER_STAGE_MESH_BIT_EXT stage中的一个
        122.如果任何绑定的graphics shader以VK_SHADER_CREATE_LINK_STAGE_BIT_EXT 创建，（1）所有在相同vkCreateShadersEXT中以VK_SHADER_CREATE_LINK_STAGE_BIT_EXT创建的shaders必须也要绑定
                                                                                     （2）任何相同vkCreateShadersEXT中不以VK_SHADER_CREATE_LINK_STAGE_BIT_EXT创建的shaders不能有任何VkShaderEXT绑定
        123.所有绑定的graphics shader objects 必须以相同或者相同定义的push constant ranges创建
        124.所有绑定的graphics shader objects 必须以相同或者相同定义的descriptor set layouts的数组创建
        125.如果当前的render pass instance以vkCmdBeginRendering开始，且VkRenderingInfo::colorAttachmentCount为1，且有一个resolve mode为 VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID 的color attachment，且绑定了fragment shader，则DepthReplacing 和 StencilRefReplacingEXT execution modes 不能声明
        126.如果一个shader object绑定到 VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则 （1）如果attachmentFeedbackLoopDynamicState 特性开启，则 vkCmdSetAttachmentFeedbackLoopEnableEXT 必须在该命令之前调用
        127.如果包含一个fragment shader stage的绑定的graphics pipeline，（1）且该pipeline以VkPipelineDynamicStateCreateInfo::pDynamicStates中设置有VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE创建，且该fragment shader声明了EarlyFragmentTests execution mode且使用了OpDepthAttachmentReadEXT，则最后vkCmdSetDepthWriteEnable 设置的 depthWriteEnable 必须为VK_FALSE
                                                                        （2）且该pipeline以VkPipelineDynamicStateCreateInfo::pDynamicStates中设置有VK_DYNAMIC_STATE_STENCIL_WRITE_MASK创建，且该fragment shader声明了EarlyFragmentTests execution mode且使用了OpStencilAttachmentReadEXT，则最后vkCmdSetStencilWriteMask 设置的 writeMask 必须为0
        128.如果一个shader object绑定到任何graphics stage 或者绑定的graphics pipeline 以VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT 动态state开启创建，且任何color attachment的format为VK_FORMAT_E5B9G9R9_UFLOAT_PACK32，则vkCmdSetColorWriteMaskEXT设置的pColorWriteMasks参数的对应元素必须包含VK_COLOR_COMPONENT_R_BIT, VK_COLOR_COMPONENT_G_BIT, 和 VK_COLOR_COMPONENT_B_BIT，或者都不包含
        129.如果任何附件开启了blending，且该附件的source 或者 destination blend factors使用第二个颜色输入，则该命令执行的Fragment Execution Model静态使用的任何输出output attachment的Location的最大值必须小于maxFragmentDualSrcAttachments
        130.如果当前的render pass instance以vkCmdBeginRendering开始，（1）如果没有任何shader object绑定到任何graphics stage，则vkCmdSetRenderingAttachmentLocationsKHR 设置的VkRenderingAttachmentLocationInfoKHR::pColorAttachmentLocations中的每个元素必须匹配设置在当前绑定的graphics pipeline中的对应元素
                                                                     （2）如果没有任何shader object绑定到任何graphics stage，绑定的graphics pipeline中的input attchment 索引中映射的附件必须匹配在当前render pass instance的VkRenderingInputAttachmentIndexInfoKHR中设置的
        131.如果当前的render pass instance以vkCmdBeginRendering开始且以VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT标志开始，则绑定的graphics pipeline必须以VK_PIPELINE_CREATE_2_ENABLE_LEGACY_DITHERING_BIT_EXT创建
        132.如果绑定的graphics pipeline以VK_PIPELINE_CREATE_2_ENABLE_LEGACY_DITHERING_BIT_EXT创建，则当前的render pass 必须以vkCmdBeginRendering开始且以VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT标志开始
        135.所有在vertex shader entry point 的 interface通过声明的vertex input variables访问的vertex input bindings必须是有效的buffer绑定或者为VK_NULL_HANDLE绑定
        136.如果nullDescriptor 特性未开启，则所有在vertex shader entry point 的 interface通过声明的vertex input variables访问的vertex input bindings不能为VK_NULL_HANDLE绑定
        137.如果robustBufferAccess 特性未开启，且pipeline的创建不对vertexInputs以VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT开启创建，则对于指定的vertex buffer binding，任何获取的顶点属性数据必须包含在对应的vertex buffer binding中，参见Vertex Input Description p2586
        138.如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage或者绑定的graphics pipeline以VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY动态state开启创建，则vkCmdSetPrimitiveTopology必须在该命令前设置
        140.如果绑定的graphics pipeline以VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY动态state开启创建，且dynamicPrimitiveTopologyUnrestricted为VK_FALSE，则vkCmdSetPrimitiveTopology设置的primitiveTopology 必须和pipeline创建的VkPipelineInputAssemblyStateCreateInfo::topology相同
        141.如果绑定的graphics pipeline以VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT但不以VK_DYNAMIC_STATE_VERTEX_INPUT_EXT 动态state开启创建，则vkCmdBindVertexBuffers2EXT必须在该命令前设置，且pStrides参数不能为NULL
        142.如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage或者绑定的graphics pipeline以VK_DYNAMIC_STATE_VERTEX_INPUT_EXT动态state开启创建，则
                                            （1）vkCmdSetVertexInputEXT必须在该命令前设置
                                            （2）所有以Input storage class修饰的Vertex Execution Model OpEntryPoint中的变量其Location必须包含在VkVertexInputAttributeDescription2EXT::location指定的location中
                                            （3）如果满足legacyVertexAttributes未开启或者Vertex Execution Model OpEntryPoint中给定对应Location的Input variable的 SPIR-V Type为64-bit的中的一个，则Vertex Execution Model OpEntryPoint中对应Location的所有Input variable的numeric type必须和VkVertexInputAttributeDescription2EXT::format的相同
                                            （4）如果VkVertexInputAttributeDescription2EXT::format含有64-bit 分量，Vertex Execution Model OpEntryPoint中对应Location的所有Input variable的scalar width必须是64-bit的
                                            （5）如果Vertex Execution Model OpEntryPoint中对应Location的Input variable的scalar width是64-bit的，则对应VkVertexInputAttributeDescription2EXT::format必须含有64-bit 分量
                                            （6）如果VkVertexInputAttributeDescription2EXT::format含有64-bit 分量，则Vertex Execution Model OpEntryPoint中对应Location的所有Input variable不能使用该format未呈现的分量
        143.如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage且最近的vkCmdSetPrimitiveTopology设置primitiveTopology为VK_PRIMITIVE_TOPOLOGY_PATCH_LIST，或者绑定的graphics pipeline以VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT动态state开启创建，则vkCmdSetPatchControlPointsEXT必须在该命令前设置
        144.如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage或者绑定的graphics pipeline以VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE动态state开启创建，则vkCmdSetPrimitiveRestartEnable必须在该命令前设置
        145.如果primitiveTopologyListRestart特性未开启，且topology 为VK_PRIMITIVE_TOPOLOGY_POINT_LIST, VK_PRIMITIVE_TOPOLOGY_LINE_LIST, VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST, VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY, 或者 VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY，
                    且有一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage或者绑定的graphics pipeline以VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE动态state开启创建，则vkCmdSetPrimitiveRestartEnable必须设置为VK_FALSE
        146.绑定的graphics pipeline不能以VkGraphicsPipelineCreateInfo::pStages中元素的VkPipelineShaderStageCreateInfo::stage设置为VK_SHADER_STAGE_TASK_BIT_EXT 或者 VK_SHADER_STAGE_MESH_BIT_EXT创建
        147.不能有shader object绑定到VK_SHADER_STAGE_TASK_BIT_EXT或者 VK_SHADER_STAGE_MESH_BIT_EXT中的一个stage
        148.如果buffer为non-sparse的，则该buffer必须绑定到完整的连续的单独的VkDeviceMemory上
        149.buffer必须以VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT 创建
        150.offset必须是4的倍数
        151.commandBuffer不能为一个protected command buffer
        152.如果countBuffer为non-sparse的，则该buffer必须绑定到完整的连续的单独的VkDeviceMemory上
        153.countBuffer必须以VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT 创建
        154.countBufferOffset必须是4的倍数
        155.存储在countBuffer中的绘制次数值必须小于等于VkPhysicalDeviceLimits::maxDrawIndirectCount
        156.(countBufferOffset + sizeof(uint32_t))必须小于等于countBuffer的大小
        157.如果drawIndirectCount 没有启用则该命令就不能使用
        158.stride必须为4的倍数，且必须大于或者等于sizeof(VkDrawIndirectCommand)
        159.如果maxDrawCount大于1，则(stride × (maxDrawCount - 1) + offset + sizeof(VkDrawIndirectCommand))必须小于等于buffer的大小
        160.如果存储在countBuffer中的绘制次数值为1，则(offset + sizeof(VkDrawIndirectCommand))必须小于或者等于buffer的大小
        161.如果存储在countBuffer中的绘制次数值大于1，则(stride × (drawCount - 1) + offset + sizeof(VkDrawIndirectCommand))必须小于等于buffer的大小
        
        */



        VkDrawIndexedIndirectCommand drawIndexedIndirectCommand{};
        drawIndexedIndirectCommand.firstIndex = 0;//index buffer中基础索引
        drawIndexedIndirectCommand.indexCount = 3;//要绘制的顶点数
        drawIndexedIndirectCommand.firstInstance = 0;//要绘制的第一个instance的ID
        drawIndexedIndirectCommand.instanceCount = 1;//要绘制的instances的数量
        drawIndexedIndirectCommand.vertexOffset = 0;//是在索引到index buffer之间添加到顶点索引的一个值
        /*
        VkDrawIndexedIndirectCommand有效用法:
        1.如果绑定的graphics pipeline 以VkGraphicsPipelineCreateInfo::pVertexInputState->pNext中包含一个VkPipelineVertexInputDivisorStateCreateInfoKHR创建，且VkPipelineVertexInputDivisorStateCreateInfoKHR::pVertexBindingDivisors任何元素为除数为1外的值，且VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR::supportsNonZeroFirstInstance 为VK_FALSE，则firstInstance必须为0
        2.如果shader objects用于绘制或者绑定的graphics pipeline以VK_DYNAMIC_STATE_VERTEX_INPUT_EXT动态state开启创建，且vkCmdSetVertexInputEXT设置的pVertexBindingDescriptions中设置该动态state的任何元素有为除数为1外的值，且VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR::supportsNonZeroFirstInstance 为VK_FALSE，则firstInstance必须为0
        3.如果robustBufferAccess2 未开启，则(indexSize × (firstIndex + indexCount) + offset) 必须小于等于绑定的index buffer的大小，其中indexSize 基于indexType，且index buffer, indexType, 以及 offset由vkCmdBindIndexBuffer 或者 vkCmdBindIndexBuffer2KHR指定，如果使用vkCmdBindIndexBuffer2KHR来绑定index buffer，则绑定的index buffer的大小为vkCmdBindIndexBuffer2KHR::size
        4.对于指定的vertex buffer binding，任何获取的顶点属性数据必须包含在对应的vertex buffer binding中，参见Vertex Input Description p2586
        5.如果drawIndirectFirstInstance 特性未开启，则firstInstance必须为0
        */


        //记录索引的间接绘制命令   类似于 vkCmdDrawIndexed，但是绘制参数从buffer中读取，绘制参数在buffer中以VkDrawIndexedIndirectCommand组织，如果 drawCount小于等于1，则stride会被忽略
        vkCmdDrawIndexedIndirect(commandBuffer, VkBuffer{/*假设只是一个有效的VkBuffer*/ }/*buffer ,包含绘制参数的buffer.*/, 0/*offset,为buffer中绘制参数开始的起始字节偏移量.*/, 
                    1/*drawCount,要绘制的次数，可以为0.*/, 3/*stride，是buffer中连续绘制设置组之间的字节步长.*/);
        /*

         vkCmdDrawIndexedIndirect有效用法:
        1.如果一个VkSampler以其magFilter或者minFilter等于VK_FILTER_LINEAR创建，则（1）如果reductionMode为VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE，如果用于采样一个VkImageView作为该命令的结果的compareEnable为VK_FALSE，则该image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT
                                                                                 （2）如果reductionMode为VK_SAMPLER_REDUCTION_MODE_MIN 或者VK_SAMPLER_REDUCTION_MODE_MAX之一 用于采样一个VkImageView作为该命令的结果，则该image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT
        2.如果一个VkSampler以其mipmapMode 等于VK_SAMPLER_MIPMAP_MODE_LINEAR创建，则（1）如果reductionMode为VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE，如果用于采样一个VkImageView作为该命令的结果的compareEnable为VK_FALSE，则该image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT
                                                                                 （2）如果reductionMode为VK_SAMPLER_REDUCTION_MODE_MIN 或者VK_SAMPLER_REDUCTION_MODE_MAX之一 用于采样一个VkImageView作为该命令的结果，则该image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT
        3.如果一个VkSampler以其unnormalizedCoordinates等于VK_TRUE用于采样一个VkImageView作为该命令的结果创建，则（1）该image view的levelCount以及layerCount必须为1
                                                                                                                （2）该image view的viewType必须为VK_IMAGE_VIEW_TYPE_1D 或者 VK_IMAGE_VIEW_TYPE_2D
        4.如果一个VkImageView的采样带depth comparison操作，则image view的format features必须包含VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT
        5.如果一个VkImageView使用atomic operations作为该命令的结果进行访问，则image view的format features必须包含VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT
        6.如果一个VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER类型的 descriptor使用atomic operations作为该命令的结果进行访问，则storage texel buffer的format features必须包含VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT
        7.如果一个以VK_FILTER_CUBIC_EXT进行采样的VkImageView作为该命令的结果，则image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT
        8.如果VK_EXT_filter_cubic拓展没有开启，且有任何一个以VK_FILTER_CUBIC_EXT进行采样的VkImageView作为该命令的结果，则其VkImageViewType不能为VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, 或者 VK_IMAGE_VIEW_TYPE_CUBE_ARRAY
        9.任何一个以VK_FILTER_CUBIC_EXT进行采样的作为该命令的结果的VkImageView，其VkImageViewType和format 必须支持cubic filtering，参见vkGetPhysicalDeviceImageFormatProperties2返回的VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic
        10.任何一个以VK_FILTER_CUBIC_EXT进行采样且reduction mode为VK_SAMPLER_REDUCTION_MODE_MIN 或者 VK_SAMPLER_REDUCTION_MODE_MAX之一的作为该命令的结果的VkImageView，其VkImageViewType和format 必须支持带minmax filtering的cubic filtering，参见vkGetPhysicalDeviceImageFormatProperties2返回的VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax
        11.如果cubicRangeClamp特性没有开启，则有任何一个以VK_FILTER_CUBIC_EXT进行采样VkImageView的作为该命令的结果，VkSamplerReductionModeCreateInfo::reductionMode不能为VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM
        12.任何一个以VkSamplerReductionModeCreateInfo::reductionMode为VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM进行采样的作为该命令的结果的VkImageView必须以VK_FILTER_CUBIC_EXT进行采样
        13.如果selectableCubicWeights特性没有开启，则有任何一个以VK_FILTER_CUBIC_EXT进行采样VkImageView的作为该命令的结果，VkSamplerCubicWeightsCreateInfoQCOM::cubicWeights必须为VK_CUBIC_FILTER_WEIGHTS_CATMULL_ROM_QCOM
        14.任何一个以VkImageCreateInfo::flags含VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV创建的采样作为该命令结果的VkImage必须以VkSamplerAddressMode为VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE 进行采样
        15.对于任何作为storage image写入的VkImageView，且其OpTypeImage的format未知，则该image view的 format features必须包含VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT
        16.对于任何作为storage image读取的VkImageView，且其OpTypeImage的format未知，则该image view的 format features必须包含VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT
        17.对于任何作为storage storage texel buffer写入的VkBufferView，且其OpTypeImage的format未知，则该buffer view的 buffer features必须包含VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT
        18.对于任何作为storage storage texel buffer读取的VkBufferView，且其OpTypeImage的format未知，则该buffer view的 buffer features必须包含VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT
        19.对于每个在绑定的shader中静态使用的set n，一个descriptor set必须被绑定到相同pipeline bind point的set n处，该set n必须和创建当前VkPipeline的VkPipelineLayout或者和创建当前VkShaderEXT的VkDescriptorSetLayout 数组的set n处的布局兼容，参见Pipeline Layout Compatibility p1280
        20.对于每个在绑定的shader中静态使用的push constant，一个push constant值必须被绑定到相同pipeline bind point的对应处，该push constant必须和创建当前VkPipeline的VkPipelineLayout或者和创建当前VkShaderEXT的VkDescriptorSetLayout 数组中的对应处的布局兼容，参见Pipeline Layout Compatibility p1280
        21.如果maintenance4特性没有开启，则对于每个在绑定的shader中静态使用的push constant，一个push constant值必须被设置到相同pipeline bind point的对应处，该push constant必须和创建当前VkPipeline的VkPipelineLayout或者和创建当前VkShaderEXT的VkDescriptorSetLayout 数组中的对应处的布局兼容，参见Pipeline Layout Compatibility p1280
        22.每一个通过vkCmdBindDescriptorSets绑定的descriptor set的descriptors,如果是被不以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建的，且已经绑定到该命令使用的pipeline bind point的VkPipeline静态使用的，则这些descriptors必须是有效的，参见 descriptor validity p1328
        23.如果通过vkCmdBindDescriptorSets指定绑定到pipeline bind point的VkPipeline要使用的descriptors，则绑定的VkPipeline不能以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建
        24.在vkCmdSetDescriptorBufferOffsetsEXT中指定绑定的descriptor buffers的descriptors，则（1）如果绑定到pipeline bind point的该命令会使用的VkPipeline以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建，且这些descriptors是动态使用的，则这些descriptors必须是有效的
                                                                                              （2）如果绑定到pipeline bind point的对应stage的该命令会使用的VkShaderEXT，且这些descriptors是动态使用的，则这些descriptors必须是有效的
        25.在vkCmdSetDescriptorBufferOffsetsEXT中指定的descriptors在绑定到pipeline bind point的VkPipeline中使用，则VkPipeline必须以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建
        26.如果一个descriptor在以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建的VkPipeline中动态使用，则descriptor memory必须是驻留内存
        27.如果一个descriptor在以其VkDescriptorSetLayout以VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建的VkShaderEXT中动态使用，则descriptor memory必须是驻留内存
        28.如果shaderObject 特性没有开启，一个有效的pipeline必须绑定到这个命令使用的绑定到pipeline bind point上
        29.如果一个pipeline绑定到该命令使用的pipeline bind point上，则不能有任何动态state 设置命令设置任何该VkPipeline 中没有指定的动态 state
        30.如果一个VkPipeline绑定到该命令使用的pipeline bind point上 或者任何一个会访问一个使用unnormalized coordinates的VkSampler的 VkShaderEXT绑定到该命令使用的pipeline bind point上的pipeline的对应stage，则
                                                                                    （1）在任何shader stage中，VkSampler不能用来采样任何类型为VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY 或者 VK_IMAGE_VIEW_TYPE_CUBE_ARRAY的VkImageView
                                                                                    （2）在任何shader stage中，该VkSampler不能和任何带有名字中带有ImplicitLod，Dref 或者 Proj 的SPIR-V OpImageSample* 或者 OpImageSparseSample*指令一起使用
                                                                                    （3）在任何shader stage中，该VkSampler不能和任何包含 LOD bias或者offset 值 的SPIR-V OpImageSample* or OpImageSparseSample*指令一起使用
        31.如果shaderObject开启，一个有效的pipeline必须绑定到该命令使用的pipeline bind point上或者一个有效的shader objects以及VK_NULL_HANDLE的组合必须绑定到该命令使用的pipeline bind point每一个支持的shader stage上
        32.如何绑定到该命令使用的pipeline bind point上的VkPipeline的任何stage会访问一个uniform buffer，且该stage对uniformBuffers不以启用VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT或者VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT 创建，且robustBufferAccess特性未开启，则该stage就不能访问绑定到相同pipeline bind point的descriptor set指定的buffer范围外的值
        33.如果robustBufferAccess特性未开启，且任何会访问uniform buffer的绑定到该命令使用的pipeline bind point上对应shader stage的VkShaderEXT，则其不能访问绑定到相同pipeline bind point的descriptor set指定的buffer范围外的值
        34.如何绑定到该命令使用的pipeline bind point上的VkPipeline的任何stage会访问一个storage buffer，且该stage对storageBuffers不以启用VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT或者VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT 创建，且robustBufferAccess特性未开启，则该stage就不能访问绑定到相同pipeline bind point的descriptor set指定的buffer范围外的值
        35.如果robustBufferAccess特性未开启，且任何会访问storage buffer的绑定到该命令使用的pipeline bind point上对应shader stage的VkShaderEXT，则其不能访问绑定到相同pipeline bind point的descriptor set指定的buffer范围外的值
        36.如果commandBuffer 是一个unprotected command buffer，且protectedNoFault 未支持，则任何绑定的shaders访问的资源不能是一个protected resource
        37.如果一个绑定的shader访问一个VkSampler 或者 VkImageView ，且启用了sampler Y′C BCR conversion，则只能使用OpImageSample* 或者 OpImageSparseSample*指令，不能使用ConstOffset 以及 Offset操作符
        38.如果一个VkImageView作为该命令的结果进行访问，则（1）image view 的viewType 必须匹配Instruction/Sampler/Image View Validation p1481中描述的OpTypeImage的Dim操作符
                                                          （2）image view 的foamrt的numeric type 必须匹配OpTypeImage的Sampled Type操作符
        39.如果一个VkImageView以一个不是VK_FORMAT_A8_UNORM_KHR的format创建且通过OpImageWrite作为该命令的结果进行访问，则该命令的Texel 操作符的Type必须至少包含和 image view的 format含有的components的个数相同的components个数
        40.如果一个VkImageView以VK_FORMAT_A8_UNORM_KHR的format创建且通过OpImageWrite作为该命令的结果进行访问，则该命令的Texel 操作符的Type必须包含4个components
        41.如果一个VkBufferView通过OpImageWrite作为该命令的结果进行访问，则该命令的Texel 操作符的Type必须至少包含和 buffer view的 format含有的components的个数相同的components个数
        42.如果一个带64-bit component的VkFormat的VkImageView作为该命令的结果进行访问，则该命令的OpTypeImage操作符的SampledType的宽度必须为64
        43.如果一个带少于64-bit component的VkFormat的VkImageView作为该命令的结果进行访问，则该命令的OpTypeImage操作符的SampledType的宽度必须为32
        44.如果一个带64-bit component的VkFormat的VkBufferView作为该命令的结果进行访问，则该命令的OpTypeImage操作符的SampledType的宽度必须为64位
        45.如果一个带少于64-bit component的VkFormat的VkBufferView作为该命令的结果进行访问，则该命令的OpTypeImage操作符的SampledType的宽度必须为32
        46.如果sparseImageInt64Atomics 特性未开启，则以VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT创建的VkImage对象不能被SampledType宽度为64位的OpTypeImage的atomic instructions访问
        47.如果sparseImageInt64Atomics 特性未开启，则以VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT创建的VkBuffer对象不能被SampledType宽度为64位的OpTypeImage的atomic instructions访问
        48.如果OpImageWeightedSampleQCOM用来采样一个作为该命令的结果的VkImageView，则该image view的format features必须包含VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM
        49.如果OpImageWeightedSampleQCOM用来采样一个作为该命令的结果的sample weight image的VkImageView，则该image view的format features必须包含VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM
        50.如果OpImageBoxFilterQCOM用来采样一个作为该命令的结果的VkImageView，则该image view的format features必须包含VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM
        51.如果OpImageBlockMatchSSDQCOM，或者 OpImageBlockMatchSADQCOM用来读取一个作为该命令的结果的VkImageView，则（1）该image view的format features必须包含VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM
                                                                                                                   （2）如果是读取的reference image，指定的reference coordinates不能在integer texel coordinate validation 时候失败
        52.如果OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchWindowSSDQCOM, OpImageBlockMatchWindowSADQCOM, OpImageBlockMatchGatherSSDQCOM,
                                                    OpImageBlockMatchGatherSADQCOM, OpImageBlockMatchSSDQCOM, 或者 OpImageBlockMatchSADQCOM用来采样一个作为该命令的结果的VkImageView，则该VkSampler必须以VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM创建
        53.如果任何除了OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchWindowSSDQCOM, OpImageBlockMatchWindowSADQCOM, OpImageBlockMatchGatherSSDQCOM, OpImageBlockMatchGatherSADQCOM, OpImageBlockMatchSSDQCOM, 或者 OpImageBlockMatchSADQCOM之外的指令使用VkSampler进行采样作为该命令的结果，则该sampler不能以VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM 创建
        54.如果OpImageBlockMatchWindow*QCOM or OpImageBlockMatchGather*QCOM指令用来读取VkImageView作为该命令的结果，则（1）VkImageView的format features必须包含VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM
                                                                                                                      （2）VkImageView的format必须只含有一个component
        55.如果OpImageBlockMatchWindow*QCOM or OpImageBlockMatchGather*QCOM指令用来读取一个引用的image作为该命令的结果，则指定的 reference coordinates不能在integer texel coordinate validation 时候失败
        56.任何该命令执行的shader invocation必须已经终止
        57.如果有一个类型位为VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM, VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, 或者 VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT中任意一个的descriptor作为该命令的结果进行访问，则该descriptor所指的image subresource的layout必须和该descriptor被写入时的layout相同。
        58.当前的 render pass  必须和绑定到VK_PIPELINE_BIND_POINT_GRAPHICS上的VkPipeline 创建时候的VkGraphicsPipelineCreateInfo中指定的renderPass兼容
        59.当前的 render pass  的subpass index必须和绑定到VK_PIPELINE_BIND_POINT_GRAPHICS上的VkPipeline 创建时候的VkGraphicsPipelineCreateInfo中指定的subpass相同
        60.如果任何shader静态访问一个input attachment，则有效的descriptor必须通过VkDescriptorSet被绑定到该pipeline中
        61.如果任何该pipeline执行shader以SubpassData的Dim操作符访问一个OpTypeImage变量，则该变量必须被一个对应当前subpass的input attachment的InputAttachmentIndex修饰
        62.在subpass中访问的Input attachment views必须以和该subpass相同定义的VkFormat创建，且必须以一个和当前绑定的VkFramebuffer的该附件引用的subpass的pInputAttachments[InputAttachmentIndex]附件兼容的VkImageView创建，参见Fragment Input Attachment Compatibility p1408
        63.在动态render pass中访问以VkRenderingInputAttachmentIndexInfoKHR的InputAttachmentIndex，或者VkRenderingInputAttachmentIndexInfoKHR:pDepthInputAttachmentIndex 或者 VkRenderingInputAttachmentIndexInfoKHR:pStencilInputAttachmentIndex为NULL情况下不指定InputAttachmentIndex的引用的Input attachment views，必须以和VkRenderingInfo中对应color, depth, 或者 stencil attachment兼容的VkImageView创建
        64.如果VkRenderingInputAttachmentIndexInfoKHR::pDepthInputAttachmentIndex 以及 VkRenderingInputAttachmentIndexInfoKHR::pStencilInputAttachmentIndex不为NULL，则在动态render pass中通过shader object访问Input attachment views必须指明InputAttachmentIndex
        65.如果在动态render pass中通过shader object访问Input attachment views指明了InputAttachmentIndex，则InputAttachmentIndex必须匹配VkRenderingInputAttachmentIndexInfoKHR中的index
        66.当前render pass所用的附件对应的image subresource底层内存的写入只能作为该命令的一个附件写入
        67.如果一个color attachment在之前的该subpass的命令中以load, store, 或者 resolve operations进行了写入，则其layout不为VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT，且有当前绑定的pipeline设有VK_PIPELINE_CREATE_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT，或者
                                        最后的vkCmdSetAttachmentFeedbackLoopEnableEXT调用包含VK_IMAGE_ASPECT_COLOR_BIT以及 没有绑定的pipeline 或者绑定的pipeline以VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT创建，则该附件只能以附件进行访问的，这两种情况中之一
        68.如果一个depth attachment在之前的该subpass的命令中以load, store, 或者 resolve operations进行了写入，则其layout不为VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT，且有当前绑定的pipeline设有VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT，或者
                                        最后的vkCmdSetAttachmentFeedbackLoopEnableEXT调用包含VK_IMAGE_ASPECT_DEPTH_BIT以及 没有绑定的pipeline 或者绑定的pipeline以VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT创建，则该附件只能以附件进行访问的，这两种情况中之一
        69.如果一个stencil attachment在之前的该subpass的命令中以load, store, 或者 resolve operations进行了写入，则其layout不为VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT，且有当前绑定的pipeline设有VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT，或者
                                        最后的vkCmdSetAttachmentFeedbackLoopEnableEXT调用包含VK_IMAGE_ASPECT_STENCIL_BIT以及 没有绑定的pipeline 或者绑定的pipeline以VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT创建，则该附件只能以附件进行访问的，这两种情况中之一
        70.如果一个attachment在之前的该subpass的命令中以load, store, 或者 resolve operations进行了写入,则该附件就不能再以除作为一个附件，storage image或者sampled image被该命令访问
        71.如果在之前的命令的subpass中以用作附件外的方式访问访问了一个当权subpass的附件所对的image subresource，则该命令就不能再将该image subresource用作附件进行写入
        72.如果当前render pass使用一个depth/stencil attachment，则（1）如果depth aspect的layout为read-only的layout，则不能启用depth writes
                                                                  （2）如果stencil aspect的layout为read-only的layout，front 以及 back writeMask不为0，且stencil 测试开启，则所有stencil 操作必须为VK_STENCIL_OP_KEEP
        73.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_VIEWPORT动态state开启创建，则vkCmdSetViewport必须在该命令之前设置
                                        （2）以VK_DYNAMIC_STATE_SCISSOR动态state开启创建，则vkCmdSetScissor必须在该命令之前设置
                                        （3）以VK_DYNAMIC_STATE_LINE_WIDTH动态state开启创建，则vkCmdSetLineWidth必须在该命令之前设置
                                        （4）以VK_DYNAMIC_STATE_DEPTH_BIAS动态state开启创建，则vkCmdSetDepthBias或者vkCmdSetDepthBias2EXT 必须在该命令之前设置
                                        （5）以VK_DYNAMIC_STATE_BLEND_CONSTANTS动态state开启创建，则vkCmdSetBlendConstants 必须在该命令之前设置
                                        （6）以VK_DYNAMIC_STATE_DEPTH_BOUNDS动态state开启创建，且如果当前depthBoundsTestEnable为VK_TRUE， 则vkCmdSetDepthBounds 必须在该命令之前设置
                                        （7）以VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK动态state开启创建，且如果当前stencilTestEnable为VK_TRUE， 则vkCmdSetStencilCompareMask 必须在该命令之前设置
                                        （8）以VK_DYNAMIC_STATE_STENCIL_WRITE_MASK动态state开启创建，且如果当前stencilTestEnable为VK_TRUE， 则vkCmdSetStencilWriteMask 必须在该命令之前设置
                                        （9）以VK_DYNAMIC_STATE_STENCIL_REFERENCE动态state开启创建，且如果当前stencilTestEnable为VK_TRUE， 则vkCmdSetStencilReference 必须在该命令之前设置
                                        （10）以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT动态state开启创建， 则vkCmdSetSampleLocationsEXT 必须在该命令之前设置
                                        （11）以VK_DYNAMIC_STATE_CULL_MODE动态state开启创建， 则vkCmdSetCullMode 必须在该命令之前设置
                                        （12）以VK_DYNAMIC_STATE_FRONT_FACE动态state开启创建， 则vkCmdSetFrontFace 必须在该命令之前设置
                                        （13）以VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE动态state开启创建， 则vkCmdSetDepthTestEnable 必须在该命令之前设置
                                        （14）以VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE动态state开启创建， 则vkCmdSetDepthWriteEnable 必须在该命令之前设置
                                        （15）以VK_DYNAMIC_STATE_DEPTH_COMPARE_OP动态state开启创建， 则vkCmdSetDepthCompareOp 必须在该命令之前设置
                                        （16）以VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE动态state开启创建， 则vkCmdSetDepthBoundsTestEnable 必须在该命令之前设置
                                        （17）以VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE动态state开启创建， 则vkCmdSetStencilTestEnable 必须在该命令之前设置
                                        （18）以VK_DYNAMIC_STATE_STENCIL_OP动态state开启创建， 则vkCmdSetStencilOp 必须在该命令之前设置
                                        （19）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT但不以VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT 动态state开启创建， 则vkCmdSetViewportWithCount 必须在该命令之前设置，且vkCmdSetViewportWithCount设置的viewportCount必须匹配pipeline的VkPipelineViewportStateCreateInfo::scissorCount
                                        （20）以VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT但不以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT 动态state开启创建， 则vkCmdSetScissorWithCount 必须在该命令之前设置，且vkCmdSetScissorWithCount设置的scissorCount必须匹配pipeline的VkPipelineViewportStateCreateInfo::viewportCount
                                        （21）以VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT和VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT 动态state同时开启创建， 则vkCmdSetViewportWithCount以及vkCmdSetScissorWithCount 必须在该命令之前设置，且vkCmdSetViewportWithCount设置的viewportCount必须匹配vkCmdSetScissorWithCount设置的scissorCount
                                        （22）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT但不以VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV 动态state开启创建， 则绑定的pipeline必须以VkPipelineViewportWScalingStateCreateInfoNV::viewportCount 大于等于最近vkCmdSetViewportWithCount设置的viewportCount创建
                                        （23）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT和VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV 动态state开启创建， 则最近调用的vkCmdSetViewportWScalingNV设置的viewportCount 必须大于等于最近vkCmdSetViewportWithCount设置的viewportCount
                                        （24）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT但不以VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV 动态state开启创建， 则绑定的pipeline必须以VkPipelineViewportShadingRateImageStateCreateInfoNV::viewportCount 大于等于最近vkCmdSetViewportWithCount设置的viewportCount创建
                                        （25）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT和VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV 动态state开启创建， 则最近调用的vkCmdSetViewportShadingRatePaletteNV设置的viewportCount 必须大于等于最近vkCmdSetViewportWithCount设置的viewportCount
                                        （26）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT动态state开启且VkPipelineViewportStateCreateInfo的pNext中含有一个VkPipelineViewportSwizzleStateCreateInfoNV 创建， 则绑定的pipeline必须以VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount 大于等于最近vkCmdSetViewportWithCount设置的viewportCount创建
                                        （27）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT动态state开启且VkPipelineViewportStateCreateInfo的pNext中含有一个VkPipelineViewportExclusiveScissorStateCreateInfoNV 创建， 则绑定的pipeline必须以VkPipelineViewportExclusiveScissorStateCreateInfoNV::exclusiveScissorCount 大于等于最近vkCmdSetViewportWithCount设置的viewportCount创建
                                        （28）以VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_ENABLE_NV动态state开启创建， 则vkCmdSetExclusiveScissorEnableNV 必须在该命令之前设置
                                        （29）以VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV动态state开启创建， 则vkCmdSetExclusiveScissorNV 必须在该命令之前设置
                                        （30）以VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE动态state开启创建， 则vkCmdSetRasterizerDiscardEnable 必须在该命令之前设置
                                        （31）以VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE动态state开启创建， 则vkCmdSetDepthBiasEnable 必须在该命令之前设置
                                        （32）以VK_DYNAMIC_STATE_LOGIC_OP_EXT动态state开启创建， 则vkCmdSetLogicOpEXT 必须在该命令之前设置且参数logicOp必须是一个有效的VkLogicOp值
        74.如果一个shader object绑定到任何graphics stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                        （1）如果最靠近当前命令的vkCmdSetPolygonModeEXT设置polygonMode为VK_POLYGON_MODE_LINE或者是任何line topology，则vkCmdSetLineWidth必须在该命令之前设置
                                        （2）如果最靠近当前命令的vkCmdSetDepthBiasEnable设置depthBiasEnable为VK_TRUE，则vkCmdSetDepthBias 或者 vkCmdSetDepthBias2EXT必须在该命令之前设置
                                        （3）如果最靠近当前命令的vkCmdSetDepthBoundsTestEnable设置depthBoundsTestEnable为VK_TRUE，则vkCmdSetDepthBounds必须在该命令之前设置
                                        （4）如果最靠近当前命令的vkCmdSetStencilTestEnable设置stencilTestEnable为VK_TRUE，则vkCmdSetStencilCompareMask必须在该命令之前设置
                                        （5）如果最靠近当前命令的vkCmdSetStencilTestEnable设置stencilTestEnable为VK_TRUE，则vkCmdSetStencilWriteMask必须在该命令之前设置
                                        （6）如果最靠近当前命令的vkCmdSetStencilTestEnable设置stencilTestEnable为VK_TRUE，则vkCmdSetStencilReference必须在该命令之前设置
                                        （7）如果最靠近当前命令的vkCmdSetSampleLocationsEnableEXT设置sampleLocationsEnable为VK_TRUE，则vkCmdSetSampleLocationsEXT必须在该命令之前设置
                                        （8）则vkCmdSetCullMode必须在该命令之前设置
                                        （9）则vkCmdSetFrontFace必须在该命令之前设置
                                        （10）则vkCmdSetDepthTestEnable 必须在该命令之前设置
                                        （11）则vkCmdSetDepthWriteEnable 必须在该命令之前设置
                                        （12）如果最靠近当前命令的vkCmdSetDepthTestEnable设置depthTestEnable为VK_TRUE，则vkCmdSetDepthCompareOp 必须在该命令之前设置
                                        （13）则vkCmdSetDepthBoundsTestEnable 必须在该命令之前设置
                                        （14）则vkCmdSetStencilTestEnable 必须在该命令之前设置
                                        （15）如果最靠近当前命令的vkCmdSetStencilTestEnable设置stencilTestEnable为VK_TRUE，则vkCmdSetStencilOp 必须在该命令之前设置
                                        （16）
                                        （17）如果shadingRateImage特性开启，则vkCmdSetCoarseSampleOrderNV 必须在该命令之前设置
                                        （18）如果shadingRateImage特性开启，且最靠近当前命令的vkCmdSetShadingRateImageEnableNV设置shadingRateImageEnable为VK_TRUE，则vkCmdSetViewportShadingRatePaletteNV 必须在该命令之前设置
                                        （19）如果shadingRateImage特性开启，且最靠近当前命令的vkCmdSetShadingRateImageEnableNV设置shadingRateImageEnable为VK_TRUE，则最近的vkCmdSetViewportShadingRatePaletteNV设置的viewportCount 必须大于等于vkCmdSetViewportWithCount设置的viewportCount
                                        （20）则vkCmdSetDepthBiasEnable必须在该命令之前设置
        75.如果一个输出line primitives的shader object绑定到VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或者 VK_SHADER_STAGE_GEOMETRY_BIT，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则vkCmdSetLineWidth必须在该命令之前设置
        76.如果一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最靠近当前命令的vkCmdSetColorBlendEnableEXT设置pColorBlendEnables任何元素为VK_TRUE，且
                            最靠近当前命令的vkCmdSetColorBlendEquationEXT设置pColorBlendEquations相同元素的VkColorBlendEquationEXT的VkBlendFactor成员为VK_BLEND_FACTOR_CONSTANT_COLOR, VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR, VK_BLEND_FACTOR_CONSTANT_ALPHA, 或者 VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA，则vkCmdSetBlendConstants必须在该命令之前设置
        77.如果该命令记录在开启了multiview的render pass instance中，则最大的instance 索引必须小于等于VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex
        78.如果绑定的graphics pipeline以VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable设置为VK_TRUE创建且当前的subpass含有一个 depth/stencil attachment，则该attachment必须以VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT创建
        >>78.5  .如果一个shader object绑定到任何graphics stage，则（1）vkCmdSetViewportWithCount 和vkCmdSetScissorWithCount 必须同时在该命令之前设置，且vkCmdSetViewportWithCount设置的viewportCount必须匹配vkCmdSetScissorWithCount设置的scissorCount
                                                                  （2）则vkCmdSetRasterizerDiscardEnable 必须在该命令之前设置
        79.如果VK_NV_clip_space_w_scaling拓展开启，且shader object绑定到任何graphics stage，且最近的vkCmdSetViewportWScalingEnableNV设置viewportWScalingEnable为VK_TRUE，则（1）vkCmdSetViewportWScalingNV必须在该命令前设置
                                                                                                                                                                           （2）最近vkCmdSetViewportWScalingNV设置的viewportCount必须大于等于vkCmdSetViewportWithCount设置的viewportCount
        80.如果exclusiveScissor 特性开启，且shader object绑定到任何graphics stage，，则（1）vkCmdSetExclusiveScissorEnableNV必须在该命令前设置
                                                                                       （2）最近的vkCmdSetExclusiveScissorEnableNV调用设置的pExclusiveScissorEnables中的任何元素为VK_TRUE,则vkCmdSetExclusiveScissorNV必须在该命令前设置
        81.如果一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最靠近当前命令的vkCmdSetLogicOpEnableEXT设置logicOpEnable任何元素为VK_TRUE，则vkCmdSetLogicOpEXT 必须在该命令之前设置且参数logicOp必须是一个有效的VkLogicOp值
        82.如果primitiveFragmentShadingRateWithMultipleViewports限制不支持，则（1）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT动态state开启创建，且任何该pipeline的shader stage会写入PrimitiveShadingRateKHR built-in修饰的变量，则vkCmdSetViewportWithCount 必须在该命令之前设置且参数viewportCount必须是1
                                                                              （2）任何绑定的graphics pipeline的shader stage会写入PrimitiveShadingRateKHR built-in修饰的变量，则vkCmdSetViewportWithCount 必须在该命令之前设置且参数viewportCount必须是1
        83.如果graphics pipeline中未开启rasterization，则对subpass中的每个color attachment，如果其对应的image view 的format features不包含VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT，则pColorBlendState中其对应pAttachments中元素的blendEnable必须为VK_FALSE
        84.如果一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则对于render pass中的每个color attachment，如果其对应的image view 的format features不包含VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT， 则最近的vkCmdSetColorBlendEnableEXT设置的pColorBlendEnables中该附件的对应元素必须为VK_FALSE
        85.如果graphics pipeline中未开启rasterization，有VK_AMD_mixed_attachment_samples拓展未开启，VK_NV_framebuffer_mixed_samples拓展未开启，multisampledRenderToSingleSampled特性未开启，则当前绑定的pipeline的rasterizationSamples必须和当前subpass的color 以及/或者 depth/stencil attachments的相同
        86.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且有VK_AMD_mixed_attachment_samples拓展未开启，VK_NV_framebuffer_mixed_samples拓展未开启，multisampledRenderToSingleSampled特性未开启，则最近vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples必须和当前subpass的color 以及/或者 depth/stencil attachments的相同
        87.如果一个shader object绑定到任何graphics stage，则当前的render pass instance必须以vkCmdBeginRendering开始
        88.如果当前的render pass instance以vkCmdBeginRendering开始，（1）如果pDepthAttachment的imageView不为VK_NULL_HANDLE，且pDepthAttachment的layout不为VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL，则该命令不能写入任何值到depth attachment
                                                                    （2）如果pStencilAttachment的imageView不为VK_NULL_HANDLE，且pStencilAttachment的layout不为VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL，则该命令不能写入任何值到stencil attachment
                                                                    （3）如果pDepthAttachment的imageView不为VK_NULL_HANDLE，且pDepthAttachment的layout为VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL，则该命令不能写入任何值到depth attachment
                                                                    （4）如果pStencilAttachment的imageView不为VK_NULL_HANDLE，且pStencilAttachment的layout为VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL，则该命令不能写入任何值到stencil attachment
                                                                    （5）如果pDepthAttachment的imageView不为VK_NULL_HANDLE，且pDepthAttachment的layout为VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL，则该命令不能写入任何值到depth attachment
                                                                    （6）如果pStencilAttachment的imageView不为VK_NULL_HANDLE，且pStencilAttachment的layout为VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL，则该命令不能写入任何值到stencil attachment
                                                                    （7）则当前绑定的graphics pipeline必须以含VkPipelineRenderingCreateInfo::viewMask等于VkRenderingInfo::viewMask创建
                                                                    （8）如果带有VkRenderingInfo::colorAttachmentCount为1，则没有shader object绑定到任何graphics stage，且一个color attachment的 resolve mode为VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID，则VkRenderingInfo::pColorAttachments中每个resolveImageView不为VK_NULL_HANDLE的元素其对应image必须以和创建当前绑定的pipeline 相同的VkExternalFormatANDROID::externalFormat创建
                                                                    （9）如果没有shader object绑定到任何graphics stage，如果绑定的graphics pipeline以一个非零值VkExternalFormatANDROID::externalFormat创建且启用VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态设置，则vkCmdSetColorBlendEnableEXT必须在该命令前设置blend enable为VK_FALSE
                                                                    （10）如果没有shader object绑定到任何graphics stage，如果绑定的graphics pipeline以一个非零值VkExternalFormatANDROID::externalFormat创建且启用VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态设置，则vkCmdSetRasterizationSamplesEXT必须在该命令前设置rasterizationSamples为VK_SAMPLE_COUNT_1_BIT
                                                                    （11）如果没有shader object绑定到任何graphics stage，如果绑定的graphics pipeline以一个非零值VkExternalFormatANDROID::externalFormat创建且启用VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR动态设置，则vkCmdSetFragmentShadingRateKHR必须在该命令前设置pFragmentSize->width为1，pFragmentSize->height为1
        89.如果dynamicRenderingUnusedAttachments特性未开启，且当前的render pass instance以vkCmdBeginRendering开始，则
                                                                （1）当前绑定的graphics pipeline必须以含VkPipelineRenderingCreateInfo::colorAttachmentCount等于VkRenderingInfo::colorAttachmentCount创建
                                                                （2）如果VkRenderingInfo::colorAttachmentCount大于0，则VkRenderingInfo::pColorAttachments 中每一个其imageView不为VK_NULL_HANDLE的元素的VkImageView必须以VkFormat对应绑定的graphics pipeline的VkPipelineRenderingCreateInfo::pColorAttachmentFormats指明的format创建
                                                                （3）如果VkRenderingInfo::colorAttachmentCount大于0，则VkRenderingInfo::pColorAttachments 中每一个其imageView为VK_NULL_HANDLE的元素对应绑定的graphics pipeline的VkPipelineRenderingCreateInfo::pColorAttachmentFormats指明的format必须为VK_FORMAT_UNDEFINED
                                                                （4）如果VkRenderingInfo::pDepthAttachment->imageView为VK_NULL_HANDLE，则创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::depthAttachmentFormat必须为VK_FORMAT_UNDEFINED
                                                                （5）如果VkRenderingInfo::pDepthAttachment->imageView不为VK_NULL_HANDLE，则创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::depthAttachmentFormat必须和创建VkRenderingInfo::pDepthAttachment->imageView的VkFormat相同
                                                                （6）如果VkRenderingInfo::pStencilAttachment->imageView为VK_NULL_HANDLE，则创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::stencilAttachmentFormat必须为VK_FORMAT_UNDEFINED
                                                                （7）如果VkRenderingInfo::pStencilAttachment->imageView不为VK_NULL_HANDLE，则创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::stencilAttachmentFormat必须和创建VkRenderingInfo::pStencilAttachment->imageView的VkFormat相同
        90.如果dynamicRenderingUnusedAttachments特性开启，且当前的render pass instance以vkCmdBeginRendering开始，则
                                                                （1）如果VkRenderingInfo::colorAttachmentCount大于0，则VkRenderingInfo::pColorAttachments 中每一个其imageView不为VK_NULL_HANDLE的元素的VkImageView必须以VkFormat对应绑定的graphics pipeline的VkPipelineRenderingCreateInfo::pColorAttachmentFormats指明的format创建，或者是对应元素为VK_FORMAT_UNDEFINED创建
                                                                （2）如果VkRenderingInfo::pDepthAttachment->imageView不为VK_NULL_HANDLE，且创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::depthAttachmentFormat和创建VkRenderingInfo::pDepthAttachment->imageView的VkFormat不同，则该format必须为VK_FORMAT_UNDEFINED
                                                                （3）如果VkRenderingInfo::pStencilAttachment->imageView不为VK_NULL_HANDLE，且创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::stencilAttachmentFormat和创建VkRenderingInfo::pStencilAttachment->imageView的VkFormat不同，则该format必须为VK_FORMAT_UNDEFINED
        91.如果没有shader object绑定到任何graphics stage，且当前的render pass instance以vkCmdBeginRendering开始且VkRenderingInfo::colorAttachmentCount为1，且一个color attachment的 resolve mode为VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID，则VkRenderingInfo::pColorAttachments中每个resolveImageView不为VK_NULL_HANDLE的元素其对应image必须以和创建当前绑定的pipeline 相同的VkExternalFormatANDROID::externalFormat创建
        92.如果有一个shader object绑定到任何graphics stage，且当前的render pass 包含一个使用VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID resolve mode的color attachment，则（1）vkCmdSetColorBlendEnableEXT必须在该命令前设置blend enable为VK_FALSE
                                                                                                                                                                                 （2）则vkCmdSetRasterizationSamplesEXT必须在该命令前设置rasterizationSamples为VK_SAMPLE_COUNT_1_BIT
                                                                                                                                                                                 （3）则vkCmdSetFragmentShadingRateKHR必须在该命令前设置pFragmentSize->width为1，pFragmentSize->height为1
        93.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT动态state开启创建， 则vkCmdSetColorWriteEnableEXT 必须在该命令之前设置，且设置的attachmentCount必须大于等于创建当前绑定的pipeline的VkPipelineColorBlendStateCreateInfo::attachmentCount
                                        （2）以VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT动态state开启创建， 则vkCmdSetDiscardRectangleEXT 必须在该命令之前为每个VkPipelineDiscardRectangleStateCreateInfoEXT::discardRectangleCount指明的discard rectangle 设置
                                        （3）以VK_DYNAMIC_STATE_DISCARD_RECTANGLE_ENABLE_EXT动态state开启创建， 则vkCmdSetDiscardRectangleEnableEXT 必须在该命令之前设置
                                        （4）以VK_DYNAMIC_STATE_DISCARD_RECTANGLE_MODE_EXT动态state开启创建， 则vkCmdSetDiscardRectangleModeEXT 必须在该命令之前设置
        94.如果有一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                        （1）如果colorWriteEnable特性在device上开启，则vkCmdSetColorWriteEnableEXT 必须在该命令之前设置，且设置的attachmentCount必须大于等于当前render pass instance的color attachment的数量
                                        （2）如果VK_EXT_discard_rectangles拓展开启，且最近的vkCmdSetDiscardRectangleEnableEXT设置discardRectangleEnable为VK_TRUE， 则vkCmdSetDiscardRectangleEXT 必须在该命令之前设置
                                        （3）如果VK_EXT_discard_rectangles拓展开启， 则vkCmdSetDiscardRectangleEnableEXT 必须在该命令之前设置
                                        （4）如果VK_EXT_discard_rectangles拓展开启， 则最近的vkCmdSetDiscardRectangleEnableEXT设置discardRectangleEnable为VK_TRUE，则vkCmdSetDiscardRectangleModeEXT 必须在该命令之前设置
        95.如果当前的render pass instance以vkCmdBeginRendering开始，则（1）如果VkRenderingFragmentShadingRateAttachmentInfoKHR::imageView不为VK_NULL_HANDLE，则当前绑定的graphics pipeline必须以VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR创建
                                                                      （2）如果VkRenderingFragmentDensityMapAttachmentInfoEXT::imageView不为VK_NULL_HANDLE，则当前绑定的graphics pipeline必须以VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT创建
                                                                      （3）且含VkRenderingInfo::colorAttachmentCount大于0，如果当前的绑定的pipeline以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，则VkRenderingInfo::pColorAttachments中每个imageView不为VK_NULL_HANDLE的元素的imageView，必须以当前pipeline的VkAttachmentSampleCountInfoAMD 或者 VkAttachmentSampleCountInfoNV中的pColorAttachmentSamples中对应元素的sample count进行创建
                                                                      （4）如果当前的绑定的pipeline以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且VkRenderingInfo::pDepthAttachment中的imageView不为VK_NULL_HANDLE，则当前pipeline的VkAttachmentSampleCountInfoAMD 或者 VkAttachmentSampleCountInfoNV中的depthStencilAttachmentSamples必须等于创建VkRenderingInfo::pDepthAttachment->imageView的sample count
                                                                      （5）如果当前的绑定的pipeline以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且VkRenderingInfo::pStencilAttachment中的imageView不为VK_NULL_HANDLE，则当前pipeline的VkAttachmentSampleCountInfoAMD 或者 VkAttachmentSampleCountInfoNV中的depthStencilAttachmentSamples必须等于创建VkRenderingInfo::pStencilAttachment->imageView的sample count
                                                                      （6）且含VkRenderingInfo::colorAttachmentCount大于0，如果当前的绑定的pipeline不以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且multisampledRenderToSingleSampled特性没有开启，则VkRenderingInfo::pColorAttachments中每个imageView不为VK_NULL_HANDLE的元素的imageView，其创建的sample count必须等于当前绑定的graphics pipeline的rasterizationSamples
                                                                      （7）如果当前的绑定的pipeline不以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且VkRenderingInfo::pDepthAttachment中的imageView不为VK_NULL_HANDLE，且multisampledRenderToSingleSampled特性没有开启，则当前pipeline的rasterizationSamples 必须等于创建VkRenderingInfo::pDepthAttachment->imageView的sample count
                                                                      （8）如果当前的绑定的pipeline不以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且VkRenderingInfo::pStencilAttachment中的imageView不为VK_NULL_HANDLE，且multisampledRenderToSingleSampled特性没有开启，则当前pipeline的rasterizationSamples 必须等于创建VkRenderingInfo::pStencilAttachment->imageView的sample count
                                                                      （9）当前绑定的pipeline必须VkGraphicsPipelineCreateInfo::renderPass为VK_NULL_HANDLE创建
                                                                      （10）如果绑定的pipeline的fragment shader静态写入一个color attachment，且color write mask不为0，启用了color writes，且该附件对应的VkRenderingInfo::pColorAttachments->imageView 不为VK_NULL_HANDLE，则对应的创建pipeline的VkPipelineRenderingCreateInfo::pColorAttachmentFormats中的元素不能为VK_FORMAT_UNDEFINED
                                                                      （11）如果绑定的pipeline启用了depth test，启用了depth writes，且VkRenderingInfo::pDepthAttachment->imageView 不为VK_NULL_HANDLE，则创建pipeline的VkPipelineRenderingCreateInfo::depthAttachmentFormat不能为VK_FORMAT_UNDEFINED
                                                                      （12）如果绑定的pipeline启用了stencil test，且VkRenderingInfo::pStencilAttachment->imageView 不为VK_NULL_HANDLE，则创建pipeline的VkPipelineRenderingCreateInfo::stencilAttachmentFormat不能为VK_FORMAT_UNDEFINED
        96.如果该命令在以vkCmdBeginRendering开始的render pass instance中调用，且VkRenderingInfo的pNext中包含一个multisampledRenderToSingleSampledEnable设为VK_TRUE的VkMultisampledRenderToSingleSampledInfoEXT，则当前绑定的graphics pipeline的rasterizationSamples必须等于VkMultisampledRenderToSingleSampledInfoEXT::rasterizationSamples
        97.如果primitivesGeneratedQueryWithRasterizerDiscard特性未开启，且VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query激活，则不能启用rasterization discard
        98.如果primitivesGeneratedQueryWithNonZeroStreams特性未开启，且VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query激活，则 绑定的graphics pipeline不能以VkPipelineRasterizationStateStreamCreateInfoEXT::rasterizationStream为非零值创建
        98.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_TESSELLATION_DOMAIN_ORIGIN_EXT动态state开启创建，则vkCmdSetTessellationDomainOriginEXT必须在该命令之前设置
                                        （2）以VK_DYNAMIC_STATE_DEPTH_CLAMP_ENABLE_EXT动态state开启创建，则vkCmdSetDepthClampEnableEXT必须在该命令之前设置
                                        （3）以VK_DYNAMIC_STATE_POLYGON_MODE_EXT动态state开启创建，则vkCmdSetPolygonModeEXT必须在该命令之前设置
                                        （4）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，则vkCmdSetRasterizationSamplesEXT必须在该命令之前设置
                                        （5）以VK_DYNAMIC_STATE_SAMPLE_MASK_EXT动态state开启创建，则vkCmdSetSampleMaskEXT必须在该命令之前设置
                                        （6）以VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT动态state开启创建，则vkCmdSetAlphaToCoverageEnableEXT必须在该命令之前设置
                                        （7）以VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT动态state开启创建，则最近的vkCmdSetAlphaToCoverageEnableEXT设置alphaToCoverageEnable为VK_TRUE，则Fragment Output Interface中 Index 0的Location 0必须有一个含alpha Component的变量
                                        （8）以VK_DYNAMIC_STATE_ALPHA_TO_ONE_ENABLE_EXT动态state开启创建，则vkCmdSetAlphaToOneEnableEXT必须在该命令之前设置
                                        （9）以VK_DYNAMIC_STATE_LOGIC_OP_ENABLE_EXT动态state开启创建，则vkCmdSetLogicOpEnableEXT必须在该命令之前设置
                                        （10）以VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态state开启创建，则vkCmdSetColorBlendEnableEXT必须在该命令之前设置
                                        （11）以VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT动态state开启创建，则vkCmdSetColorBlendEquationEXT必须在该命令之前设置
                                        （12）以VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT动态state开启创建，则vkCmdSetColorWriteMaskEXT必须在该命令之前设置
        
        99.如果一个shader object绑定到VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT stage，则vkCmdSetTessellationDomainOriginEXT必须在该命令之前设置
        100.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                                        （1）如果depthClamp特性启用，则vkCmdSetDepthClampEnableEXT必须在该命令之前设置
                                                        （2）则vkCmdSetPolygonModeEXT必须在该命令之前设置
                                                        （3）则vkCmdSetRasterizationSamplesEXT必须在该命令之前设置
                                                        （4）则vkCmdSetSampleMaskEXT必须在该命令之前设置
                                                        （5）则vkCmdSetAlphaToCoverageEnableEXT必须在该命令之前设置
                                                        （6）如果alphaToOne特性启用，则vkCmdSetAlphaToOneEnableEXT必须在该命令之前设置
        
        101.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetAlphaToCoverageEnableEXT设置alphaToCoverageEnable为VK_TRUE，则Fragment Output Interface中 Index 0的Location 0必须有一个含alpha Component的变量
        102.如果一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                            （1）如果logicOp特性开启 ,vkCmdSetLogicOpEnableEXT必须在该命令之前设置
                                            （2）如果绑定了color attachments，则vkCmdSetColorBlendEnableEXT必须在该命令之前设置
                                            （3）如果最近的vkCmdSetColorBlendEnableEXT设置任何附件在pColorBlendEnables中的值为VK_TRUE ，则vkCmdSetColorBlendEquationEXT必须在该命令之前设置
                                            （4）如果绑定了color attachments，则vkCmdSetColorWriteMaskEXT必须在该命令之前设置
        
        103.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT动态state开启创建，则vkCmdSetRasterizationStreamEXT必须在该命令之前设置
                                         （2）以VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT动态state开启创建，则vkCmdSetConservativeRasterizationModeEXT必须在该命令之前设置
                                         （3）以VK_DYNAMIC_STATE_EXTRA_PRIMITIVE_OVERESTIMATION_SIZE_EXT动态state开启创建，则vkCmdSetExtraPrimitiveOverestimationSizeEXT必须在该命令之前设置
                                         （4）以VK_DYNAMIC_STATE_DEPTH_CLIP_ENABLE_EXT动态state开启创建，则vkCmdSetDepthClipEnableEXT必须在该命令之前设置
                                         （5）以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT动态state开启创建，则vkCmdSetSampleLocationsEnableEXT必须在该命令之前设置
                                         （6）以VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT动态state开启创建，则vkCmdSetColorBlendAdvancedEXT必须在该命令之前设置
                                         （7）以VK_DYNAMIC_STATE_PROVOKING_VERTEX_MODE_EXT动态state开启创建，则vkCmdSetProvokingVertexModeEXT必须在该命令之前设置
                                         （8）以VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT动态state开启创建，则vkCmdSetLineRasterizationModeEXT必须在该命令之前设置
                                         （9）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT动态state开启创建，则vkCmdSetLineStippleEnableEXT必须在该命令之前设置
                                         （10）以VK_DYNAMIC_STATE_LINE_STIPPLE_KHR动态state开启创建，则vkCmdSetLineStippleKHR必须在该命令之前设置
                                         （11）以VK_DYNAMIC_STATE_DEPTH_CLIP_NEGATIVE_ONE_TO_ONE_EXT动态state开启创建，则vkCmdSetDepthClipNegativeOneToOneEXT必须在该命令之前设置
                                         （12）以VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_ENABLE_NV动态state开启创建，则vkCmdSetViewportWScalingEnableNV必须在该命令之前设置
                                         （13）以VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV动态state开启创建，则vkCmdSetViewportSwizzleNV必须在该命令之前设置
                                         （14）以VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV动态state开启创建，则vkCmdSetCoverageToColorEnableNV必须在该命令之前设置
                                         （15）以VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_LOCATION_NV动态state开启创建，则vkCmdSetCoverageToColorLocationNV必须在该命令之前设置
                                         （16）以VK_DYNAMIC_STATE_COVERAGE_MODULATION_MODE_NV动态state开启创建，则vkCmdSetCoverageModulationModeNV必须在该命令之前设置
                                         （17）以VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV动态state开启创建，则vkCmdSetCoverageModulationTableEnableNV必须在该命令之前设置
                                         （18）以VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_NV动态state开启创建，则vkCmdSetCoverageModulationTableNV必须在该命令之前设置
                                         （19）以VK_DYNAMIC_STATE_SHADING_RATE_IMAGE_ENABLE_NV动态state开启创建，则vkCmdSetShadingRateImageEnableNV必须在该命令之前设置
                                         （20）以VK_DYNAMIC_STATE_REPRESENTATIVE_FRAGMENT_TEST_ENABLE_NV动态state开启创建，则vkCmdSetRepresentativeFragmentTestEnableNV必须在该命令之前设置
                                         （21）以VK_DYNAMIC_STATE_COVERAGE_REDUCTION_MODE_NV动态state开启创建，则vkCmdSetCoverageReductionModeNV必须在该命令之前设置
        
        104.如果一个shader object绑定到VK_SHADER_STAGE_GEOMETRY_BIT stage，且如果geometryStreams 特性开启，则vkCmdSetRasterizationStreamEXT必须在该命令之前设置
        105.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                （1）如果VK_EXT_conservative_rasterization 拓展开启，vkCmdSetConservativeRasterizationModeEXT必须在该命令之前设置
                                （2）如果VK_EXT_conservative_rasterization 拓展开启，且最近的vkCmdSetConservativeRasterizationModeEXT设置conservativeRasterizationMode为VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT，则vkCmdSetExtraPrimitiveOverestimationSizeEXT必须在该命令之前设置
                                （3）如果VK_EXT_sample_locations 拓展开启，则vkCmdSetSampleLocationsEnableEXT必须在该命令之前设置
        106.如果一个shader object绑定到任何graphics stage，且depthClipEnable 特性开启，则vkCmdSetDepthClipEnableEXT必须在该命令之前设置
        107.如果如果一个shader object绑定到任何VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且如果VK_EXT_blend_operation_advanced 拓展开启，则vkCmdSetColorBlendEquationEXT 和 vkCmdSetColorBlendAdvancedEXT中至少一个必须在该命令之前设置
        108.如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，如果VK_EXT_provoking_vertex拓展开启， 则vkCmdSetProvokingVertexModeEXT必须在该命令之前设置
        109.如果VK_KHR_line_rasterization 或者 VK_EXT_line_rasterization拓展开启，则（1）如果一个shader object绑定到任意一个graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetPolygonModeEXT设置polygonMode 为VK_POLYGON_MODE_LINE ，则vkCmdSetLineRasterizationModeEXT必须在该命令之前设置
                                                                                    （2）如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetPrimitiveTopology设置primitiveTopology 为任何line topology ，则vkCmdSetLineRasterizationModeEXT必须在该命令之前设置
                                                                                    （3）如果一个输出为line primitive的shader object绑定到VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或 VK_SHADER_STAGE_GEOMETRY_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则vkCmdSetLineRasterizationModeEXT必须在该命令之前设置
                                                                                    （4）如果一个shader object绑定到任意一个graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetPolygonModeEXT设置polygonMode 为VK_POLYGON_MODE_LINE ，则vkCmdSetLineStippleEnableEXT必须在该命令之前设置
                                                                                    （5）如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetPrimitiveTopology设置primitiveTopology 为任何line topology ，则vkCmdSetLineStippleEnableEXT必须在该命令之前设置
                                                                                    （6）如果一个输出为line primitive的shader object绑定到VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或 VK_SHADER_STAGE_GEOMETRY_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则vkCmdSetLineStippleEnableEXT必须在该命令之前设置
                                                                                    （7）如果一个shader object绑定到任意一个graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetLineStippleEnableEXT设置stippledLineEnable 为VK_TRUE ，则vkCmdSetLineStippleEXT必须在该命令之前设置
        110.如果一个shader object绑定到任何graphics stage，（1）如果depthClipControl 特性开启，则vkCmdSetDepthClipNegativeOneToOneEXT必须在该命令之前设置
                                                           （2）VK_NV_clip_space_w_scaling 拓展开启，则vkCmdSetViewportWScalingEnableNV必须在该命令之前设置
                                                           （3）VK_NV_viewport_swizzle 拓展开启，则vkCmdSetViewportSwizzleNV必须在该命令之前设置
        111.如果如果一个shader object绑定到任何VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                            （1）如果VK_NV_fragment_coverage_to_color 拓展开启，则vkCmdSetCoverageToColorEnableNV 必须在该命令之前设置
                            （2）如果VK_NV_fragment_coverage_to_color 拓展开启，且最近的vkCmdSetCoverageToColorEnableNV 设置coverageToColorEnable 为VK_TRUE，则vkCmdSetCoverageToColorLocationNV 必须在该命令之前设置
                            （3）如果pipelineFragmentShadingRate 特性开启，则vkCmdSetFragmentShadingRateKHR 必须在该命令之前设置
        112.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                    （1）如果VK_NV_framebuffer_mixed_samples 拓展开启，则vkCmdSetCoverageModulationModeNV 必须在该命令之前设置
                                    （2）如果VK_NV_framebuffer_mixed_samples 拓展开启，且最近的vkCmdSetCoverageModulationModeNV设置coverageModulationMode为任何除VK_COVERAGE_MODULATION_MODE_NONE_NV之外的值，则vkCmdSetCoverageModulationTableEnableNV 必须在该命令之前设置
                                    （3）如果VK_NV_framebuffer_mixed_samples 拓展开启，最近的vkCmdSetCoverageModulationTableEnableNV设置coverageModulationTableEnable为VK_TRUE，则vkCmdSetCoverageModulationTableNV 必须在该命令之前设置
                                    （4）如果shadingRateImage 特性开启，则vkCmdSetShadingRateImageEnableNV 必须在该命令之前设置
                                    （5）如果representativeFragmentTest 特性开启，则vkCmdSetRepresentativeFragmentTestEnableNV 必须在该命令之前设置
                                    （6）如果coverageReductionMode 特性开启，则vkCmdSetCoverageReductionModeNV 必须在该命令之前设置
        113.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态state开启创建，且最近的vkCmdSetColorBlendEnableEXT设置任何附件在pColorBlendEnables中的值为VK_TRUE 则subpas中这些附件对应的image view的format features中必须包含VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT
                                         （2）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，且当前subpass不使用任何color和/或者 depth/stencil attachments，则最后的vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples必须符合zero￾attachment subpass的规则
                                         （3）以VK_DYNAMIC_STATE_SAMPLE_MASK_EXT不以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT 动态state开启创建，则最后调用的vkCmdSetSampleMaskEXT中设置的samples参数必须大于等于创建该pipeline的VkPipelineMultisampleStateCreateInfo::rasterizationSamples
                                         （4）以VK_DYNAMIC_STATE_SAMPLE_MASK_EXT和 VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT 动态state开启创建，则最后调用的vkCmdSetSampleMaskEXT中设置的samples参数必须大于等于最后的vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples
                                         （5）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，且VK_AMD_mixed_attachment_samples和VK_NV_framebuffer_mixed_samples拓展都没有开启，则最后的vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples必须等于subpass中color和/或者 depth/stencil attachments使用的相同
                                         （6）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，或者一个shader object绑定到任意graphics stage，且当前的subpass包含一个multisampledRenderToSingleSampledEnable 为VK_TRUE的VkMultisampledRenderToSingleSampledInfoEXT，则最后的vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples必须等于该VkMultisampledRenderToSingleSampledInfoEXT中的对应成员
                                         （7）以VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态state开启创建，则vkCmdSetColorBlendEnableEXT 必须在该命令之前设置，且vkCmdSetColorBlendEnableEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定值
                                         （8）以VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT动态state开启创建，则vkCmdSetColorBlendEquationEXT 必须在该命令之前设置，且vkCmdSetColorBlendEquationEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定blend equations
                                         （9）以VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT动态state开启创建，则vkCmdSetColorWriteMaskEXT 必须在该命令之前设置，且vkCmdSetColorWriteMaskEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定color write mask
                                         （10）以VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT动态state开启创建，则vkCmdSetColorBlendAdvancedEXT 必须在该命令之前设置，且vkCmdSetColorBlendAdvancedEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活blend的color attachments指定advanced blend equations
                                         （11）以VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT和VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态state开启创建，且最后的vkCmdSetColorBlendEnableEXT和vkCmdSetColorBlendAdvancedEXT设置启用了advanced blending，则当前subpass中激活的color attachments的数量不能超过advancedBlendMaxColorAttachments
                                         （12）以VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT动态state开启创建，且如果primitivesGeneratedQueryWithNonZeroStreams特性未开启且VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query已经激活，则最后的vkCmdSetRasterizationStreamEXT必须设置rasterizationStream为0
                                         （13）以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT但不以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，则最后的vkCmdSetSampleLocationsEXT设置的pSampleLocationsInfo->sampleLocationsPerPixel必须等于创建pipeline的VkPipelineMultisampleStateCreateInfo::rasterizationSamples
                                         （14）以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT和VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，则最后的vkCmdSetSampleLocationsEXT设置的pSampleLocationsInfo->sampleLocationsPerPixel必须等于最后vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples
                                         （15）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT但不以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT动态state开启创建，且绑定的pipeline的VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable为VK_TRUE 或者以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT动态state开启，则sampleLocationsInfo.sampleLocationsPerPixel 必须等于最后vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples
                                         （16）以VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV动态state开启创建，且最后的vkCmdSetCoverageToColorEnableNV设置coverageToColorEnable为VK_TRUE，则当前subpass必须有color attachment，且该attachment的format必须为VK_FORMAT_R8_UINT, VK_FORMAT_R8_SINT, VK_FORMAT_R16_UINT, VK_FORMAT_R16_SINT, VK_FORMAT_R32_UINT, 或者 VK_FORMAT_R32_SINT，且该attachment的location 有最后的vkCmdSetCoverageToColorLocationNV设置的coverageToColorLocation决定
                                         （17）以VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV和VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT 动态state开启创建，且如果VK_NV_coverage_reduction_mode 拓展开启，则当前的 coverageReductionMode，rasterizationSamples 以及color 以及 depth/stencil attachments（如果subpass有）的sample count必须是有效的返回值vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV的值的组合
                                         （18）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT但不以VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV 动态state开启创建，则绑定的graphics pipeline的VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount 必须大于等于最后vkCmdSetViewportWithCount设置的viewportCount
                                         （19）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT和VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV 动态state开启创建，则最后vkCmdSetViewportSwizzleNV设置的viewportCount 必须大于等于最后vkCmdSetViewportWithCount设置的viewportCount
                                         （20）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT或者 VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT 动态state开启创建，如果当前的stippledLineEnable为VK_TRUE，且当前的lineRasterizationMode为VK_LINE_RASTERIZATION_MODE_RECTANGULAR_KHR，则stippledRectangularLines 特性必须开启
                                         （21）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT或者 VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT 动态state开启创建，如果当前的stippledLineEnable为VK_TRUE，且当前的lineRasterizationMode为VK_LINE_RASTERIZATION_MODE_BRESENHAM_KHR，则stippledBresenhamLines 特性必须开启
                                         （22）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT或者 VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT 动态state开启创建，如果当前的stippledLineEnable为VK_TRUE，且当前的lineRasterizationMode为VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_KHR，则stippledSmoothLines 特性必须开启
                                         （23）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT或者 VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT 动态state开启创建，如果当前的stippledLineEnable为VK_TRUE，且当前的lineRasterizationMode为VK_LINE_RASTERIZATION_MODE_DEFAULT_KHR，则stippledRectangularLines 特性必须开启且VkPhysicalDeviceLimits::strictLines 必须为VK_TRUE
                                         （24）以VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT 动态state开启创建，且conservativePointAndLineRasterization不支持，最后的 pre-rasterization shader stage输出的有效图元拓扑为点或者线，则最后vkCmdSetConservativeRasterizationModeEXT设置的conservativeRasterizationMode 必须为VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT
                                         （25）以VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT 动态state开启创建，则vkCmdSetAttachmentFeedbackLoopEnableEXT 必须在该命令之前调用
        114.如果一个shader object绑定到 VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                                                                            （1）则vkCmdSetColorBlendEnableEXT 必须在该命令之前设置，且vkCmdSetColorBlendEnableEXT指定的firstAttachment开始的attachmentCount的值必须为当前subpass所有激活的color attachments指定
                                                                                            （2）则vkCmdSetColorBlendEquationEXT 必须在该命令之前设置，且vkCmdSetColorBlendEquationEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定blend equations
                                                                                            （3）则vkCmdSetColorWriteMaskEXT 必须在该命令之前设置，且vkCmdSetColorWriteMaskEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定color write mask
                                                                                            （4）如果VK_NV_fragment_coverage_to_color拓展开启， 最后的vkCmdSetCoverageToColorEnableNV设置coverageToColorEnable为VK_TRUE，则当前subpass必须有color attachment，且该attachment的format必须为VK_FORMAT_R8_UINT, VK_FORMAT_R8_SINT, VK_FORMAT_R16_UINT, VK_FORMAT_R16_SINT, VK_FORMAT_R32_UINT, 或者 VK_FORMAT_R32_SINT，且该attachment的location 有最后的vkCmdSetCoverageToColorLocationNV设置的coverageToColorLocation决定
        115.如果一个shader object绑定到 VK_SHADER_STAGE_FRAGMENT_BIT stage，（1）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT动态state开启创建，且最近的vkCmdSetSampleLocationsEnableEXT设置sampleLocationsEnable为VK_TRUE，且该subpass含有depth/stencil attachment，则该附件必须以VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT创建
                                                                            （2）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT和VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT 动态state开启创建，且最近的vkCmdSetSampleLocationsEnableEXT设置sampleLocationsEnable为VK_TRUE，则 最后vkCmdSetSampleLocationsEXT设置的sampleLocationsInfo.sampleLocationGridSize.width以及height 必须等于被调用vkGetPhysicalDeviceMultisamplePropertiesEXT传入rasterizationSamples返回的VkMultisamplePropertiesEXT::sampleLocationGridSize.width以及height一一对应均匀整除
                                                                            （3）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT 动态state开启创建，且最近的vkCmdSetSampleLocationsEnableEXT设置sampleLocationsEnable为VK_TRUE，则fragment shader代码中不能静态使用扩展指令InterpolateAtSample
                                                                            （4）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT但不以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT 动态state开启创建，且绑定的pipeline的VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable为VK_TRUE 或者以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT动态state开启，则 最后vkCmdSetRasterizationSamplesEXT设置的sampleLocationsInfo.sampleLocationGridSize.width以及height 必须等于被调用vkGetPhysicalDeviceMultisamplePropertiesEXT传入和vkCmdSetRasterizationSamplesEXT设置的相同rasterizationSamples的samples返回的VkMultisamplePropertiesEXT::sampleLocationGridSize.width以及height一一对应均匀整除
        116.如果一个shader object绑定到任何graphics stage，（1）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV 动态state开启创建，且最近的vkCmdSetCoverageModulationTableEnableNV设置coverageModulationTableEnable为VK_TRUE，则最近的vkCmdSetCoverageModulationTableNV 设置的coverageModulationTableCount 必须等于当前rasterizationSamples除以当前subppas的color samples
                                                           （2）如果VK_NV_viewport_swizzle 拓展开启，则最后vkCmdSetViewportSwizzleNV设置的viewportCount 必须大于等于最后vkCmdSetViewportWithCount设置的viewportCount
        117.如果VK_NV_framebuffer_mixed_samples 拓展开启，且如果在绑定的graphics pipeline中当前subpass有一个depth/stencil attachment以及dep test, stencil test, 或depth bounds test 启用，则当前rasterizationSamples 必须等于depth/stencil attachment的sample count
        118.如果VK_NV_framebuffer_mixed_samples 拓展开启，且如果最后的vkCmdSetRasterizationSamplesEXT设置的当前subpass的任何color attachments的rasterizationSamples 都大于 color samples，则sampleShadingEnable 必须为VK_FALSE
        119.如果当前绑定的graphics pipeline以VkGraphicsPipelineCreateInfo::pStages中的元素的VkPipelineShaderStageCreateInfo::stage设置为VK_SHADER_STAGE_VERTEX_BIT, VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT, VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或者 VK_SHADER_STAGE_GEOMETRY_BIT创建，则Mesh Shader Queries 不能激活
        120.如果dynamic state继承自VkCommandBufferInheritanceViewportScissorInfoNV，则这些动态state的设置必须在该命令之前设置
        121.如果没有绑定graphics pipeline，则（1）vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_VERTEX_BIT
                                             （2）如果tessellationShader 特性开启，vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT，VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT
                                             （3）如果geometryShader 特性开启，vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_GEOMETRY_BIT
                                             （4）vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_FRAGMENT_BIT
                                             （5）如果taskShader 特性开启，vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_TASK_BIT_EXT
                                             （6）如果meshShader 特性开启，vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_MESH_BIT_EXT
                                             （8）如果至少taskShader 和 meshShader一个特性开启，VK_SHADER_STAGE_VERTEX_BIT 或者VK_SHADER_STAGE_MESH_BIT_EXT stages中的一个必须含有有效的VkShaderEXT绑定，另外一个则不含有VkShaderEXT绑定
                                             （9）如果taskShader 和 meshShader特性同时开启，且一个有效的VkShaderEXT 绑定到VK_SHADER_STAGE_MESH_BIT_EXT stage，且该VkShaderEXT不以VK_SHADER_CREATE_NO_TASK_SHADER_BIT_EXT 创建，则一个有效的VkShaderEXT必须绑定到VK_SHADER_STAGE_TASK_BIT_EXT stage
                                             （10）如果taskShader 和 meshShader特性同时开启，且一个有效的VkShaderEXT 绑定到VK_SHADER_STAGE_MESH_BIT_EXT stage，且该VkShaderEXT以VK_SHADER_CREATE_NO_TASK_SHADER_BIT_EXT 创建，则不能有VkShaderEXT绑定到VK_SHADER_STAGE_TASK_BIT_EXT stage
                                             （11）如果一个有效的VkShaderEXT 绑定到VK_SHADER_STAGE_VERTEX_BIT stage，则不能有VkShaderEXT绑定到VK_SHADER_STAGE_TASK_BIT_EXT stage或者VK_SHADER_STAGE_MESH_BIT_EXT stage中的一个
        122.如果任何绑定的graphics shader以VK_SHADER_CREATE_LINK_STAGE_BIT_EXT 创建，（1）所有在相同vkCreateShadersEXT中以VK_SHADER_CREATE_LINK_STAGE_BIT_EXT创建的shaders必须也要绑定
                                                                                     （2）任何相同vkCreateShadersEXT中不以VK_SHADER_CREATE_LINK_STAGE_BIT_EXT创建的shaders不能有任何VkShaderEXT绑定
        123.所有绑定的graphics shader objects 必须以相同或者相同定义的push constant ranges创建
        124.所有绑定的graphics shader objects 必须以相同或者相同定义的descriptor set layouts的数组创建
        125.如果当前的render pass instance以vkCmdBeginRendering开始，且VkRenderingInfo::colorAttachmentCount为1，且有一个resolve mode为 VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID 的color attachment，且绑定了fragment shader，则DepthReplacing 和 StencilRefReplacingEXT execution modes 不能声明
        126.如果一个shader object绑定到 VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则 （1）如果attachmentFeedbackLoopDynamicState 特性开启，则 vkCmdSetAttachmentFeedbackLoopEnableEXT 必须在该命令之前调用
        127.如果包含一个fragment shader stage的绑定的graphics pipeline，（1）且该pipeline以VkPipelineDynamicStateCreateInfo::pDynamicStates中设置有VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE创建，且该fragment shader声明了EarlyFragmentTests execution mode且使用了OpDepthAttachmentReadEXT，则最后vkCmdSetDepthWriteEnable 设置的 depthWriteEnable 必须为VK_FALSE
                                                                        （2）且该pipeline以VkPipelineDynamicStateCreateInfo::pDynamicStates中设置有VK_DYNAMIC_STATE_STENCIL_WRITE_MASK创建，且该fragment shader声明了EarlyFragmentTests execution mode且使用了OpStencilAttachmentReadEXT，则最后vkCmdSetStencilWriteMask 设置的 writeMask 必须为0
        128.如果一个shader object绑定到任何graphics stage 或者绑定的graphics pipeline 以VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT 动态state开启创建，且任何color attachment的format为VK_FORMAT_E5B9G9R9_UFLOAT_PACK32，则vkCmdSetColorWriteMaskEXT设置的pColorWriteMasks参数的对应元素必须包含VK_COLOR_COMPONENT_R_BIT, VK_COLOR_COMPONENT_G_BIT, 和 VK_COLOR_COMPONENT_B_BIT，或者都不包含
        129.如果任何附件开启了blending，且该附件的source 或者 destination blend factors使用第二个颜色输入，则该命令执行的Fragment Execution Model静态使用的任何输出output attachment的Location的最大值必须小于maxFragmentDualSrcAttachments
        130.如果当前的render pass instance以vkCmdBeginRendering开始，（1）如果没有任何shader object绑定到任何graphics stage，则vkCmdSetRenderingAttachmentLocationsKHR 设置的VkRenderingAttachmentLocationInfoKHR::pColorAttachmentLocations中的每个元素必须匹配设置在当前绑定的graphics pipeline中的对应元素
                                                                     （2）如果没有任何shader object绑定到任何graphics stage，绑定的graphics pipeline中的input attchment 索引中映射的附件必须匹配在当前render pass instance的VkRenderingInputAttachmentIndexInfoKHR中设置的
        131.如果当前的render pass instance以vkCmdBeginRendering开始且以VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT标志开始，则绑定的graphics pipeline必须以VK_PIPELINE_CREATE_2_ENABLE_LEGACY_DITHERING_BIT_EXT创建
        132.如果绑定的graphics pipeline以VK_PIPELINE_CREATE_2_ENABLE_LEGACY_DITHERING_BIT_EXT创建，则当前的render pass 必须以vkCmdBeginRendering开始且以VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT标志开始
        135.所有在vertex shader entry point 的 interface通过声明的vertex input variables访问的vertex input bindings必须是有效的buffer绑定或者为VK_NULL_HANDLE绑定
        136.如果nullDescriptor 特性未开启，则所有在vertex shader entry point 的 interface通过声明的vertex input variables访问的vertex input bindings不能为VK_NULL_HANDLE绑定
        137.如果robustBufferAccess 特性未开启，且pipeline的创建不对vertexInputs以VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT开启创建，则对于指定的vertex buffer binding，任何获取的顶点属性数据必须包含在对应的vertex buffer binding中，参见Vertex Input Description p2586
        138.如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage或者绑定的graphics pipeline以VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY动态state开启创建，则vkCmdSetPrimitiveTopology必须在该命令前设置
        140.如果绑定的graphics pipeline以VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY动态state开启创建，且dynamicPrimitiveTopologyUnrestricted为VK_FALSE，则vkCmdSetPrimitiveTopology设置的primitiveTopology 必须和pipeline创建的VkPipelineInputAssemblyStateCreateInfo::topology相同
        141.如果绑定的graphics pipeline以VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT但不以VK_DYNAMIC_STATE_VERTEX_INPUT_EXT 动态state开启创建，则vkCmdBindVertexBuffers2EXT必须在该命令前设置，且pStrides参数不能为NULL
        142.如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage或者绑定的graphics pipeline以VK_DYNAMIC_STATE_VERTEX_INPUT_EXT动态state开启创建，则
                                            （1）vkCmdSetVertexInputEXT必须在该命令前设置
                                            （2）所有以Input storage class修饰的Vertex Execution Model OpEntryPoint中的变量其Location必须包含在VkVertexInputAttributeDescription2EXT::location指定的location中
                                            （3）如果满足legacyVertexAttributes未开启或者Vertex Execution Model OpEntryPoint中给定对应Location的Input variable的 SPIR-V Type为64-bit的中的一个，则Vertex Execution Model OpEntryPoint中对应Location的所有Input variable的numeric type必须和VkVertexInputAttributeDescription2EXT::format的相同
                                            （4）如果VkVertexInputAttributeDescription2EXT::format含有64-bit 分量，Vertex Execution Model OpEntryPoint中对应Location的所有Input variable的scalar width必须是64-bit的
                                            （5）如果Vertex Execution Model OpEntryPoint中对应Location的Input variable的scalar width是64-bit的，则对应VkVertexInputAttributeDescription2EXT::format必须含有64-bit 分量
                                            （6）如果VkVertexInputAttributeDescription2EXT::format含有64-bit 分量，则Vertex Execution Model OpEntryPoint中对应Location的所有Input variable不能使用该format未呈现的分量
        143.如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage且最近的vkCmdSetPrimitiveTopology设置primitiveTopology为VK_PRIMITIVE_TOPOLOGY_PATCH_LIST，或者绑定的graphics pipeline以VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT动态state开启创建，则vkCmdSetPatchControlPointsEXT必须在该命令前设置
        144.如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage或者绑定的graphics pipeline以VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE动态state开启创建，则vkCmdSetPrimitiveRestartEnable必须在该命令前设置
        145.如果primitiveTopologyListRestart特性未开启，且topology 为VK_PRIMITIVE_TOPOLOGY_POINT_LIST, VK_PRIMITIVE_TOPOLOGY_LINE_LIST, VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST, VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY, 或者 VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY，
                    且有一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage或者绑定的graphics pipeline以VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE动态state开启创建，则vkCmdSetPrimitiveRestartEnable必须设置为VK_FALSE
        146.绑定的graphics pipeline不能以VkGraphicsPipelineCreateInfo::pStages中元素的VkPipelineShaderStageCreateInfo::stage设置为VK_SHADER_STAGE_TASK_BIT_EXT 或者 VK_SHADER_STAGE_MESH_BIT_EXT创建
        147.不能有shader object绑定到VK_SHADER_STAGE_TASK_BIT_EXT或者 VK_SHADER_STAGE_MESH_BIT_EXT中的一个stage
        148.如果buffer为non-sparse的，则该buffer必须绑定到完整的连续的单独的VkDeviceMemory上
        149.buffer必须以VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT 创建
        150.offset必须是4的倍数
        151.commandBuffer不能为一个protected command buffer
        152.如果multiDrawIndirect未开启，则drawCount必须为0或1
        153.drawCount必须小于等于VkPhysicalDeviceLimits::maxDrawIndirectCount
        154.如果maintenance6 未开启，则一个有效的index buffer必须已经绑定
        155.如果robustBufferAccess2未开启，则(indexSize × (firstIndex + indexCount) + offset)必须小于等于绑定的index buffer的大小，其中indexSize取决于indexType，且index buffer ， indexType, 以及 offset由vkCmdBindIndexBuffer 指定
        156.如果drawCount大于1，则stride必须为4的倍数且大于等于sizeof(VkDrawIndexedIndirectCommand)
        157.如果drawCount为1，则(offset + sizeof(VkDrawIndexedIndirectCommand))必须小于等于buffer的大小
        158.如果drawCount大于1，则(stride × (drawCount - 1) + offset + sizeof(VkDrawIndexedIndirectCommand))必须小于等于buffer的大小
        
        */
        
        

        //记录索引的从buffer中指定绘制次数的绘制  等效于vkCmdDrawIndexedIndirectCountKHR或者vkCmdDrawIndexedIndirectCountAMD   ，该命令类似于  vkCmdDrawIndexedIndirect,其中绘制次数会从countBuffer中获取，绘制参数以VkDrawIndirectCommand组织
        vkCmdDrawIndexedIndirectCount(commandBuffer, VkBuffer{/*假设只是一个有效的VkBuffer*/ }/*buffer ,包含绘制参数的buffer.*/, 0/*offset,为buffer中绘制参数开始的起始字节偏移量.*/,
            VkBuffer{/*假设只是一个有效的VkBuffer*/ }/*countBuffer，是包含绘制计数的buffer.*/, 0/*• countBufferOffset，为countBuffer中绘制计数参数开始的起始字节偏移量.*/,
            1/*maxDrawCount，是要执行的最大的绘制的次数.实际上绘制的次数为maxDrawCount以及countBuffer中记录的绘制次数的最小值.*/, 3/*stride，是buffer中连续绘制设置组之间的字节步长.*/);
        /*

         vkCmdDrawIndexedIndirectCount有效用法:
        1.如果一个VkSampler以其magFilter或者minFilter等于VK_FILTER_LINEAR创建，则（1）如果reductionMode为VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE，如果用于采样一个VkImageView作为该命令的结果的compareEnable为VK_FALSE，则该image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT
                                                                                 （2）如果reductionMode为VK_SAMPLER_REDUCTION_MODE_MIN 或者VK_SAMPLER_REDUCTION_MODE_MAX之一 用于采样一个VkImageView作为该命令的结果，则该image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT
        2.如果一个VkSampler以其mipmapMode 等于VK_SAMPLER_MIPMAP_MODE_LINEAR创建，则（1）如果reductionMode为VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE，如果用于采样一个VkImageView作为该命令的结果的compareEnable为VK_FALSE，则该image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT
                                                                                 （2）如果reductionMode为VK_SAMPLER_REDUCTION_MODE_MIN 或者VK_SAMPLER_REDUCTION_MODE_MAX之一 用于采样一个VkImageView作为该命令的结果，则该image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT
        3.如果一个VkSampler以其unnormalizedCoordinates等于VK_TRUE用于采样一个VkImageView作为该命令的结果创建，则（1）该image view的levelCount以及layerCount必须为1
                                                                                                                （2）该image view的viewType必须为VK_IMAGE_VIEW_TYPE_1D 或者 VK_IMAGE_VIEW_TYPE_2D
        4.如果一个VkImageView的采样带depth comparison操作，则image view的format features必须包含VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT
        5.如果一个VkImageView使用atomic operations作为该命令的结果进行访问，则image view的format features必须包含VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT
        6.如果一个VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER类型的 descriptor使用atomic operations作为该命令的结果进行访问，则storage texel buffer的format features必须包含VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT
        7.如果一个以VK_FILTER_CUBIC_EXT进行采样的VkImageView作为该命令的结果，则image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT
        8.如果VK_EXT_filter_cubic拓展没有开启，且有任何一个以VK_FILTER_CUBIC_EXT进行采样的VkImageView作为该命令的结果，则其VkImageViewType不能为VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, 或者 VK_IMAGE_VIEW_TYPE_CUBE_ARRAY
        9.任何一个以VK_FILTER_CUBIC_EXT进行采样的作为该命令的结果的VkImageView，其VkImageViewType和format 必须支持cubic filtering，参见vkGetPhysicalDeviceImageFormatProperties2返回的VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic
        10.任何一个以VK_FILTER_CUBIC_EXT进行采样且reduction mode为VK_SAMPLER_REDUCTION_MODE_MIN 或者 VK_SAMPLER_REDUCTION_MODE_MAX之一的作为该命令的结果的VkImageView，其VkImageViewType和format 必须支持带minmax filtering的cubic filtering，参见vkGetPhysicalDeviceImageFormatProperties2返回的VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax
        11.如果cubicRangeClamp特性没有开启，则有任何一个以VK_FILTER_CUBIC_EXT进行采样VkImageView的作为该命令的结果，VkSamplerReductionModeCreateInfo::reductionMode不能为VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM
        12.任何一个以VkSamplerReductionModeCreateInfo::reductionMode为VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM进行采样的作为该命令的结果的VkImageView必须以VK_FILTER_CUBIC_EXT进行采样
        13.如果selectableCubicWeights特性没有开启，则有任何一个以VK_FILTER_CUBIC_EXT进行采样VkImageView的作为该命令的结果，VkSamplerCubicWeightsCreateInfoQCOM::cubicWeights必须为VK_CUBIC_FILTER_WEIGHTS_CATMULL_ROM_QCOM
        14.任何一个以VkImageCreateInfo::flags含VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV创建的采样作为该命令结果的VkImage必须以VkSamplerAddressMode为VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE 进行采样
        15.对于任何作为storage image写入的VkImageView，且其OpTypeImage的format未知，则该image view的 format features必须包含VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT
        16.对于任何作为storage image读取的VkImageView，且其OpTypeImage的format未知，则该image view的 format features必须包含VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT
        17.对于任何作为storage storage texel buffer写入的VkBufferView，且其OpTypeImage的format未知，则该buffer view的 buffer features必须包含VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT
        18.对于任何作为storage storage texel buffer读取的VkBufferView，且其OpTypeImage的format未知，则该buffer view的 buffer features必须包含VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT
        19.对于每个在绑定的shader中静态使用的set n，一个descriptor set必须被绑定到相同pipeline bind point的set n处，该set n必须和创建当前VkPipeline的VkPipelineLayout或者和创建当前VkShaderEXT的VkDescriptorSetLayout 数组的set n处的布局兼容，参见Pipeline Layout Compatibility p1280
        20.对于每个在绑定的shader中静态使用的push constant，一个push constant值必须被绑定到相同pipeline bind point的对应处，该push constant必须和创建当前VkPipeline的VkPipelineLayout或者和创建当前VkShaderEXT的VkDescriptorSetLayout 数组中的对应处的布局兼容，参见Pipeline Layout Compatibility p1280
        21.如果maintenance4特性没有开启，则对于每个在绑定的shader中静态使用的push constant，一个push constant值必须被设置到相同pipeline bind point的对应处，该push constant必须和创建当前VkPipeline的VkPipelineLayout或者和创建当前VkShaderEXT的VkDescriptorSetLayout 数组中的对应处的布局兼容，参见Pipeline Layout Compatibility p1280
        22.每一个通过vkCmdBindDescriptorSets绑定的descriptor set的descriptors,如果是被不以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建的，且已经绑定到该命令使用的pipeline bind point的VkPipeline静态使用的，则这些descriptors必须是有效的，参见 descriptor validity p1328
        23.如果通过vkCmdBindDescriptorSets指定绑定到pipeline bind point的VkPipeline要使用的descriptors，则绑定的VkPipeline不能以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建
        24.在vkCmdSetDescriptorBufferOffsetsEXT中指定绑定的descriptor buffers的descriptors，则（1）如果绑定到pipeline bind point的该命令会使用的VkPipeline以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建，且这些descriptors是动态使用的，则这些descriptors必须是有效的
                                                                                              （2）如果绑定到pipeline bind point的对应stage的该命令会使用的VkShaderEXT，且这些descriptors是动态使用的，则这些descriptors必须是有效的
        25.在vkCmdSetDescriptorBufferOffsetsEXT中指定的descriptors在绑定到pipeline bind point的VkPipeline中使用，则VkPipeline必须以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建
        26.如果一个descriptor在以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建的VkPipeline中动态使用，则descriptor memory必须是驻留内存
        27.如果一个descriptor在以其VkDescriptorSetLayout以VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建的VkShaderEXT中动态使用，则descriptor memory必须是驻留内存
        28.如果shaderObject 特性没有开启，一个有效的pipeline必须绑定到这个命令使用的绑定到pipeline bind point上
        29.如果一个pipeline绑定到该命令使用的pipeline bind point上，则不能有任何动态state 设置命令设置任何该VkPipeline 中没有指定的动态 state
        30.如果一个VkPipeline绑定到该命令使用的pipeline bind point上 或者任何一个会访问一个使用unnormalized coordinates的VkSampler的 VkShaderEXT绑定到该命令使用的pipeline bind point上的pipeline的对应stage，则
                                                                                    （1）在任何shader stage中，VkSampler不能用来采样任何类型为VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY 或者 VK_IMAGE_VIEW_TYPE_CUBE_ARRAY的VkImageView
                                                                                    （2）在任何shader stage中，该VkSampler不能和任何带有名字中带有ImplicitLod，Dref 或者 Proj 的SPIR-V OpImageSample* 或者 OpImageSparseSample*指令一起使用
                                                                                    （3）在任何shader stage中，该VkSampler不能和任何包含 LOD bias或者offset 值 的SPIR-V OpImageSample* or OpImageSparseSample*指令一起使用
        31.如果shaderObject开启，一个有效的pipeline必须绑定到该命令使用的pipeline bind point上或者一个有效的shader objects以及VK_NULL_HANDLE的组合必须绑定到该命令使用的pipeline bind point每一个支持的shader stage上
        32.如何绑定到该命令使用的pipeline bind point上的VkPipeline的任何stage会访问一个uniform buffer，且该stage对uniformBuffers不以启用VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT或者VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT 创建，且robustBufferAccess特性未开启，则该stage就不能访问绑定到相同pipeline bind point的descriptor set指定的buffer范围外的值
        33.如果robustBufferAccess特性未开启，且任何会访问uniform buffer的绑定到该命令使用的pipeline bind point上对应shader stage的VkShaderEXT，则其不能访问绑定到相同pipeline bind point的descriptor set指定的buffer范围外的值
        34.如何绑定到该命令使用的pipeline bind point上的VkPipeline的任何stage会访问一个storage buffer，且该stage对storageBuffers不以启用VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT或者VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT 创建，且robustBufferAccess特性未开启，则该stage就不能访问绑定到相同pipeline bind point的descriptor set指定的buffer范围外的值
        35.如果robustBufferAccess特性未开启，且任何会访问storage buffer的绑定到该命令使用的pipeline bind point上对应shader stage的VkShaderEXT，则其不能访问绑定到相同pipeline bind point的descriptor set指定的buffer范围外的值
        36.如果commandBuffer 是一个unprotected command buffer，且protectedNoFault 未支持，则任何绑定的shaders访问的资源不能是一个protected resource
        37.如果一个绑定的shader访问一个VkSampler 或者 VkImageView ，且启用了sampler Y′C BCR conversion，则只能使用OpImageSample* 或者 OpImageSparseSample*指令，不能使用ConstOffset 以及 Offset操作符
        38.如果一个VkImageView作为该命令的结果进行访问，则（1）image view 的viewType 必须匹配Instruction/Sampler/Image View Validation p1481中描述的OpTypeImage的Dim操作符
                                                          （2）image view 的foamrt的numeric type 必须匹配OpTypeImage的Sampled Type操作符
        39.如果一个VkImageView以一个不是VK_FORMAT_A8_UNORM_KHR的format创建且通过OpImageWrite作为该命令的结果进行访问，则该命令的Texel 操作符的Type必须至少包含和 image view的 format含有的components的个数相同的components个数
        40.如果一个VkImageView以VK_FORMAT_A8_UNORM_KHR的format创建且通过OpImageWrite作为该命令的结果进行访问，则该命令的Texel 操作符的Type必须包含4个components
        41.如果一个VkBufferView通过OpImageWrite作为该命令的结果进行访问，则该命令的Texel 操作符的Type必须至少包含和 buffer view的 format含有的components的个数相同的components个数
        42.如果一个带64-bit component的VkFormat的VkImageView作为该命令的结果进行访问，则该命令的OpTypeImage操作符的SampledType的宽度必须为64
        43.如果一个带少于64-bit component的VkFormat的VkImageView作为该命令的结果进行访问，则该命令的OpTypeImage操作符的SampledType的宽度必须为32
        44.如果一个带64-bit component的VkFormat的VkBufferView作为该命令的结果进行访问，则该命令的OpTypeImage操作符的SampledType的宽度必须为64位
        45.如果一个带少于64-bit component的VkFormat的VkBufferView作为该命令的结果进行访问，则该命令的OpTypeImage操作符的SampledType的宽度必须为32
        46.如果sparseImageInt64Atomics 特性未开启，则以VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT创建的VkImage对象不能被SampledType宽度为64位的OpTypeImage的atomic instructions访问
        47.如果sparseImageInt64Atomics 特性未开启，则以VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT创建的VkBuffer对象不能被SampledType宽度为64位的OpTypeImage的atomic instructions访问
        48.如果OpImageWeightedSampleQCOM用来采样一个作为该命令的结果的VkImageView，则该image view的format features必须包含VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM
        49.如果OpImageWeightedSampleQCOM用来采样一个作为该命令的结果的sample weight image的VkImageView，则该image view的format features必须包含VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM
        50.如果OpImageBoxFilterQCOM用来采样一个作为该命令的结果的VkImageView，则该image view的format features必须包含VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM
        51.如果OpImageBlockMatchSSDQCOM，或者 OpImageBlockMatchSADQCOM用来读取一个作为该命令的结果的VkImageView，则（1）该image view的format features必须包含VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM
                                                                                                                   （2）如果是读取的reference image，指定的reference coordinates不能在integer texel coordinate validation 时候失败
        52.如果OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchWindowSSDQCOM, OpImageBlockMatchWindowSADQCOM, OpImageBlockMatchGatherSSDQCOM,
                                                    OpImageBlockMatchGatherSADQCOM, OpImageBlockMatchSSDQCOM, 或者 OpImageBlockMatchSADQCOM用来采样一个作为该命令的结果的VkImageView，则该VkSampler必须以VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM创建
        53.如果任何除了OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchWindowSSDQCOM, OpImageBlockMatchWindowSADQCOM, OpImageBlockMatchGatherSSDQCOM, OpImageBlockMatchGatherSADQCOM, OpImageBlockMatchSSDQCOM, 或者 OpImageBlockMatchSADQCOM之外的指令使用VkSampler进行采样作为该命令的结果，则该sampler不能以VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM 创建
        54.如果OpImageBlockMatchWindow*QCOM or OpImageBlockMatchGather*QCOM指令用来读取VkImageView作为该命令的结果，则（1）VkImageView的format features必须包含VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM
                                                                                                                      （2）VkImageView的format必须只含有一个component
        55.如果OpImageBlockMatchWindow*QCOM or OpImageBlockMatchGather*QCOM指令用来读取一个引用的image作为该命令的结果，则指定的 reference coordinates不能在integer texel coordinate validation 时候失败
        56.任何该命令执行的shader invocation必须已经终止
        57.如果有一个类型位为VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM, VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, 或者 VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT中任意一个的descriptor作为该命令的结果进行访问，则该descriptor所指的image subresource的layout必须和该descriptor被写入时的layout相同。
        58.当前的 render pass  必须和绑定到VK_PIPELINE_BIND_POINT_GRAPHICS上的VkPipeline 创建时候的VkGraphicsPipelineCreateInfo中指定的renderPass兼容
        59.当前的 render pass  的subpass index必须和绑定到VK_PIPELINE_BIND_POINT_GRAPHICS上的VkPipeline 创建时候的VkGraphicsPipelineCreateInfo中指定的subpass相同
        60.如果任何shader静态访问一个input attachment，则有效的descriptor必须通过VkDescriptorSet被绑定到该pipeline中
        61.如果任何该pipeline执行shader以SubpassData的Dim操作符访问一个OpTypeImage变量，则该变量必须被一个对应当前subpass的input attachment的InputAttachmentIndex修饰
        62.在subpass中访问的Input attachment views必须以和该subpass相同定义的VkFormat创建，且必须以一个和当前绑定的VkFramebuffer的该附件引用的subpass的pInputAttachments[InputAttachmentIndex]附件兼容的VkImageView创建，参见Fragment Input Attachment Compatibility p1408
        63.在动态render pass中访问以VkRenderingInputAttachmentIndexInfoKHR的InputAttachmentIndex，或者VkRenderingInputAttachmentIndexInfoKHR:pDepthInputAttachmentIndex 或者 VkRenderingInputAttachmentIndexInfoKHR:pStencilInputAttachmentIndex为NULL情况下不指定InputAttachmentIndex的引用的Input attachment views，必须以和VkRenderingInfo中对应color, depth, 或者 stencil attachment兼容的VkImageView创建
        64.如果VkRenderingInputAttachmentIndexInfoKHR::pDepthInputAttachmentIndex 以及 VkRenderingInputAttachmentIndexInfoKHR::pStencilInputAttachmentIndex不为NULL，则在动态render pass中通过shader object访问Input attachment views必须指明InputAttachmentIndex
        65.如果在动态render pass中通过shader object访问Input attachment views指明了InputAttachmentIndex，则InputAttachmentIndex必须匹配VkRenderingInputAttachmentIndexInfoKHR中的index
        66.当前render pass所用的附件对应的image subresource底层内存的写入只能作为该命令的一个附件写入
        67.如果一个color attachment在之前的该subpass的命令中以load, store, 或者 resolve operations进行了写入，则其layout不为VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT，且有当前绑定的pipeline设有VK_PIPELINE_CREATE_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT，或者
                                        最后的vkCmdSetAttachmentFeedbackLoopEnableEXT调用包含VK_IMAGE_ASPECT_COLOR_BIT以及 没有绑定的pipeline 或者绑定的pipeline以VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT创建，则该附件只能以附件进行访问的，这两种情况中之一
        68.如果一个depth attachment在之前的该subpass的命令中以load, store, 或者 resolve operations进行了写入，则其layout不为VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT，且有当前绑定的pipeline设有VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT，或者
                                        最后的vkCmdSetAttachmentFeedbackLoopEnableEXT调用包含VK_IMAGE_ASPECT_DEPTH_BIT以及 没有绑定的pipeline 或者绑定的pipeline以VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT创建，则该附件只能以附件进行访问的，这两种情况中之一
        69.如果一个stencil attachment在之前的该subpass的命令中以load, store, 或者 resolve operations进行了写入，则其layout不为VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT，且有当前绑定的pipeline设有VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT，或者
                                        最后的vkCmdSetAttachmentFeedbackLoopEnableEXT调用包含VK_IMAGE_ASPECT_STENCIL_BIT以及 没有绑定的pipeline 或者绑定的pipeline以VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT创建，则该附件只能以附件进行访问的，这两种情况中之一
        70.如果一个attachment在之前的该subpass的命令中以load, store, 或者 resolve operations进行了写入,则该附件就不能再以除作为一个附件，storage image或者sampled image被该命令访问
        71.如果在之前的命令的subpass中以用作附件外的方式访问访问了一个当权subpass的附件所对的image subresource，则该命令就不能再将该image subresource用作附件进行写入
        72.如果当前render pass使用一个depth/stencil attachment，则（1）如果depth aspect的layout为read-only的layout，则不能启用depth writes
                                                                  （2）如果stencil aspect的layout为read-only的layout，front 以及 back writeMask不为0，且stencil 测试开启，则所有stencil 操作必须为VK_STENCIL_OP_KEEP
        73.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_VIEWPORT动态state开启创建，则vkCmdSetViewport必须在该命令之前设置
                                        （2）以VK_DYNAMIC_STATE_SCISSOR动态state开启创建，则vkCmdSetScissor必须在该命令之前设置
                                        （3）以VK_DYNAMIC_STATE_LINE_WIDTH动态state开启创建，则vkCmdSetLineWidth必须在该命令之前设置
                                        （4）以VK_DYNAMIC_STATE_DEPTH_BIAS动态state开启创建，则vkCmdSetDepthBias或者vkCmdSetDepthBias2EXT 必须在该命令之前设置
                                        （5）以VK_DYNAMIC_STATE_BLEND_CONSTANTS动态state开启创建，则vkCmdSetBlendConstants 必须在该命令之前设置
                                        （6）以VK_DYNAMIC_STATE_DEPTH_BOUNDS动态state开启创建，且如果当前depthBoundsTestEnable为VK_TRUE， 则vkCmdSetDepthBounds 必须在该命令之前设置
                                        （7）以VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK动态state开启创建，且如果当前stencilTestEnable为VK_TRUE， 则vkCmdSetStencilCompareMask 必须在该命令之前设置
                                        （8）以VK_DYNAMIC_STATE_STENCIL_WRITE_MASK动态state开启创建，且如果当前stencilTestEnable为VK_TRUE， 则vkCmdSetStencilWriteMask 必须在该命令之前设置
                                        （9）以VK_DYNAMIC_STATE_STENCIL_REFERENCE动态state开启创建，且如果当前stencilTestEnable为VK_TRUE， 则vkCmdSetStencilReference 必须在该命令之前设置
                                        （10）以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT动态state开启创建， 则vkCmdSetSampleLocationsEXT 必须在该命令之前设置
                                        （11）以VK_DYNAMIC_STATE_CULL_MODE动态state开启创建， 则vkCmdSetCullMode 必须在该命令之前设置
                                        （12）以VK_DYNAMIC_STATE_FRONT_FACE动态state开启创建， 则vkCmdSetFrontFace 必须在该命令之前设置
                                        （13）以VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE动态state开启创建， 则vkCmdSetDepthTestEnable 必须在该命令之前设置
                                        （14）以VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE动态state开启创建， 则vkCmdSetDepthWriteEnable 必须在该命令之前设置
                                        （15）以VK_DYNAMIC_STATE_DEPTH_COMPARE_OP动态state开启创建， 则vkCmdSetDepthCompareOp 必须在该命令之前设置
                                        （16）以VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE动态state开启创建， 则vkCmdSetDepthBoundsTestEnable 必须在该命令之前设置
                                        （17）以VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE动态state开启创建， 则vkCmdSetStencilTestEnable 必须在该命令之前设置
                                        （18）以VK_DYNAMIC_STATE_STENCIL_OP动态state开启创建， 则vkCmdSetStencilOp 必须在该命令之前设置
                                        （19）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT但不以VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT 动态state开启创建， 则vkCmdSetViewportWithCount 必须在该命令之前设置，且vkCmdSetViewportWithCount设置的viewportCount必须匹配pipeline的VkPipelineViewportStateCreateInfo::scissorCount
                                        （20）以VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT但不以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT 动态state开启创建， 则vkCmdSetScissorWithCount 必须在该命令之前设置，且vkCmdSetScissorWithCount设置的scissorCount必须匹配pipeline的VkPipelineViewportStateCreateInfo::viewportCount
                                        （21）以VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT和VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT 动态state同时开启创建， 则vkCmdSetViewportWithCount以及vkCmdSetScissorWithCount 必须在该命令之前设置，且vkCmdSetViewportWithCount设置的viewportCount必须匹配vkCmdSetScissorWithCount设置的scissorCount
                                        （22）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT但不以VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV 动态state开启创建， 则绑定的pipeline必须以VkPipelineViewportWScalingStateCreateInfoNV::viewportCount 大于等于最近vkCmdSetViewportWithCount设置的viewportCount创建
                                        （23）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT和VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV 动态state开启创建， 则最近调用的vkCmdSetViewportWScalingNV设置的viewportCount 必须大于等于最近vkCmdSetViewportWithCount设置的viewportCount
                                        （24）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT但不以VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV 动态state开启创建， 则绑定的pipeline必须以VkPipelineViewportShadingRateImageStateCreateInfoNV::viewportCount 大于等于最近vkCmdSetViewportWithCount设置的viewportCount创建
                                        （25）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT和VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV 动态state开启创建， 则最近调用的vkCmdSetViewportShadingRatePaletteNV设置的viewportCount 必须大于等于最近vkCmdSetViewportWithCount设置的viewportCount
                                        （26）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT动态state开启且VkPipelineViewportStateCreateInfo的pNext中含有一个VkPipelineViewportSwizzleStateCreateInfoNV 创建， 则绑定的pipeline必须以VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount 大于等于最近vkCmdSetViewportWithCount设置的viewportCount创建
                                        （27）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT动态state开启且VkPipelineViewportStateCreateInfo的pNext中含有一个VkPipelineViewportExclusiveScissorStateCreateInfoNV 创建， 则绑定的pipeline必须以VkPipelineViewportExclusiveScissorStateCreateInfoNV::exclusiveScissorCount 大于等于最近vkCmdSetViewportWithCount设置的viewportCount创建
                                        （28）以VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_ENABLE_NV动态state开启创建， 则vkCmdSetExclusiveScissorEnableNV 必须在该命令之前设置
                                        （29）以VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV动态state开启创建， 则vkCmdSetExclusiveScissorNV 必须在该命令之前设置
                                        （30）以VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE动态state开启创建， 则vkCmdSetRasterizerDiscardEnable 必须在该命令之前设置
                                        （31）以VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE动态state开启创建， 则vkCmdSetDepthBiasEnable 必须在该命令之前设置
                                        （32）以VK_DYNAMIC_STATE_LOGIC_OP_EXT动态state开启创建， 则vkCmdSetLogicOpEXT 必须在该命令之前设置且参数logicOp必须是一个有效的VkLogicOp值
        74.如果一个shader object绑定到任何graphics stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                        （1）如果最靠近当前命令的vkCmdSetPolygonModeEXT设置polygonMode为VK_POLYGON_MODE_LINE或者是任何line topology，则vkCmdSetLineWidth必须在该命令之前设置
                                        （2）如果最靠近当前命令的vkCmdSetDepthBiasEnable设置depthBiasEnable为VK_TRUE，则vkCmdSetDepthBias 或者 vkCmdSetDepthBias2EXT必须在该命令之前设置
                                        （3）如果最靠近当前命令的vkCmdSetDepthBoundsTestEnable设置depthBoundsTestEnable为VK_TRUE，则vkCmdSetDepthBounds必须在该命令之前设置
                                        （4）如果最靠近当前命令的vkCmdSetStencilTestEnable设置stencilTestEnable为VK_TRUE，则vkCmdSetStencilCompareMask必须在该命令之前设置
                                        （5）如果最靠近当前命令的vkCmdSetStencilTestEnable设置stencilTestEnable为VK_TRUE，则vkCmdSetStencilWriteMask必须在该命令之前设置
                                        （6）如果最靠近当前命令的vkCmdSetStencilTestEnable设置stencilTestEnable为VK_TRUE，则vkCmdSetStencilReference必须在该命令之前设置
                                        （7）如果最靠近当前命令的vkCmdSetSampleLocationsEnableEXT设置sampleLocationsEnable为VK_TRUE，则vkCmdSetSampleLocationsEXT必须在该命令之前设置
                                        （8）则vkCmdSetCullMode必须在该命令之前设置
                                        （9）则vkCmdSetFrontFace必须在该命令之前设置
                                        （10）则vkCmdSetDepthTestEnable 必须在该命令之前设置
                                        （11）则vkCmdSetDepthWriteEnable 必须在该命令之前设置
                                        （12）如果最靠近当前命令的vkCmdSetDepthTestEnable设置depthTestEnable为VK_TRUE，则vkCmdSetDepthCompareOp 必须在该命令之前设置
                                        （13）则vkCmdSetDepthBoundsTestEnable 必须在该命令之前设置
                                        （14）则vkCmdSetStencilTestEnable 必须在该命令之前设置
                                        （15）如果最靠近当前命令的vkCmdSetStencilTestEnable设置stencilTestEnable为VK_TRUE，则vkCmdSetStencilOp 必须在该命令之前设置
                                        （16）
                                        （17）如果shadingRateImage特性开启，则vkCmdSetCoarseSampleOrderNV 必须在该命令之前设置
                                        （18）如果shadingRateImage特性开启，且最靠近当前命令的vkCmdSetShadingRateImageEnableNV设置shadingRateImageEnable为VK_TRUE，则vkCmdSetViewportShadingRatePaletteNV 必须在该命令之前设置
                                        （19）如果shadingRateImage特性开启，且最靠近当前命令的vkCmdSetShadingRateImageEnableNV设置shadingRateImageEnable为VK_TRUE，则最近的vkCmdSetViewportShadingRatePaletteNV设置的viewportCount 必须大于等于vkCmdSetViewportWithCount设置的viewportCount
                                        （20）则vkCmdSetDepthBiasEnable必须在该命令之前设置
        75.如果一个输出line primitives的shader object绑定到VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或者 VK_SHADER_STAGE_GEOMETRY_BIT，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则vkCmdSetLineWidth必须在该命令之前设置
        76.如果一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最靠近当前命令的vkCmdSetColorBlendEnableEXT设置pColorBlendEnables任何元素为VK_TRUE，且
                            最靠近当前命令的vkCmdSetColorBlendEquationEXT设置pColorBlendEquations相同元素的VkColorBlendEquationEXT的VkBlendFactor成员为VK_BLEND_FACTOR_CONSTANT_COLOR, VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR, VK_BLEND_FACTOR_CONSTANT_ALPHA, 或者 VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA，则vkCmdSetBlendConstants必须在该命令之前设置
        77.如果该命令记录在开启了multiview的render pass instance中，则最大的instance 索引必须小于等于VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex
        78.如果绑定的graphics pipeline以VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable设置为VK_TRUE创建且当前的subpass含有一个 depth/stencil attachment，则该attachment必须以VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT创建
        >>78.5  .如果一个shader object绑定到任何graphics stage，则（1）vkCmdSetViewportWithCount 和vkCmdSetScissorWithCount 必须同时在该命令之前设置，且vkCmdSetViewportWithCount设置的viewportCount必须匹配vkCmdSetScissorWithCount设置的scissorCount
                                                                  （2）则vkCmdSetRasterizerDiscardEnable 必须在该命令之前设置
        79.如果VK_NV_clip_space_w_scaling拓展开启，且shader object绑定到任何graphics stage，且最近的vkCmdSetViewportWScalingEnableNV设置viewportWScalingEnable为VK_TRUE，则（1）vkCmdSetViewportWScalingNV必须在该命令前设置
                                                                                                                                                                           （2）最近vkCmdSetViewportWScalingNV设置的viewportCount必须大于等于vkCmdSetViewportWithCount设置的viewportCount
        80.如果exclusiveScissor 特性开启，且shader object绑定到任何graphics stage，，则（1）vkCmdSetExclusiveScissorEnableNV必须在该命令前设置
                                                                                       （2）最近的vkCmdSetExclusiveScissorEnableNV调用设置的pExclusiveScissorEnables中的任何元素为VK_TRUE,则vkCmdSetExclusiveScissorNV必须在该命令前设置
        81.如果一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最靠近当前命令的vkCmdSetLogicOpEnableEXT设置logicOpEnable任何元素为VK_TRUE，则vkCmdSetLogicOpEXT 必须在该命令之前设置且参数logicOp必须是一个有效的VkLogicOp值
        82.如果primitiveFragmentShadingRateWithMultipleViewports限制不支持，则（1）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT动态state开启创建，且任何该pipeline的shader stage会写入PrimitiveShadingRateKHR built-in修饰的变量，则vkCmdSetViewportWithCount 必须在该命令之前设置且参数viewportCount必须是1
                                                                              （2）任何绑定的graphics pipeline的shader stage会写入PrimitiveShadingRateKHR built-in修饰的变量，则vkCmdSetViewportWithCount 必须在该命令之前设置且参数viewportCount必须是1
        83.如果graphics pipeline中未开启rasterization，则对subpass中的每个color attachment，如果其对应的image view 的format features不包含VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT，则pColorBlendState中其对应pAttachments中元素的blendEnable必须为VK_FALSE
        84.如果一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则对于render pass中的每个color attachment，如果其对应的image view 的format features不包含VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT， 则最近的vkCmdSetColorBlendEnableEXT设置的pColorBlendEnables中该附件的对应元素必须为VK_FALSE
        85.如果graphics pipeline中未开启rasterization，有VK_AMD_mixed_attachment_samples拓展未开启，VK_NV_framebuffer_mixed_samples拓展未开启，multisampledRenderToSingleSampled特性未开启，则当前绑定的pipeline的rasterizationSamples必须和当前subpass的color 以及/或者 depth/stencil attachments的相同
        86.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且有VK_AMD_mixed_attachment_samples拓展未开启，VK_NV_framebuffer_mixed_samples拓展未开启，multisampledRenderToSingleSampled特性未开启，则最近vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples必须和当前subpass的color 以及/或者 depth/stencil attachments的相同
        87.如果一个shader object绑定到任何graphics stage，则当前的render pass instance必须以vkCmdBeginRendering开始
        88.如果当前的render pass instance以vkCmdBeginRendering开始，（1）如果pDepthAttachment的imageView不为VK_NULL_HANDLE，且pDepthAttachment的layout不为VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL，则该命令不能写入任何值到depth attachment
                                                                    （2）如果pStencilAttachment的imageView不为VK_NULL_HANDLE，且pStencilAttachment的layout不为VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL，则该命令不能写入任何值到stencil attachment
                                                                    （3）如果pDepthAttachment的imageView不为VK_NULL_HANDLE，且pDepthAttachment的layout为VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL，则该命令不能写入任何值到depth attachment
                                                                    （4）如果pStencilAttachment的imageView不为VK_NULL_HANDLE，且pStencilAttachment的layout为VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL，则该命令不能写入任何值到stencil attachment
                                                                    （5）如果pDepthAttachment的imageView不为VK_NULL_HANDLE，且pDepthAttachment的layout为VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL，则该命令不能写入任何值到depth attachment
                                                                    （6）如果pStencilAttachment的imageView不为VK_NULL_HANDLE，且pStencilAttachment的layout为VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL，则该命令不能写入任何值到stencil attachment
                                                                    （7）则当前绑定的graphics pipeline必须以含VkPipelineRenderingCreateInfo::viewMask等于VkRenderingInfo::viewMask创建
                                                                    （8）如果带有VkRenderingInfo::colorAttachmentCount为1，则没有shader object绑定到任何graphics stage，且一个color attachment的 resolve mode为VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID，则VkRenderingInfo::pColorAttachments中每个resolveImageView不为VK_NULL_HANDLE的元素其对应image必须以和创建当前绑定的pipeline 相同的VkExternalFormatANDROID::externalFormat创建
                                                                    （9）如果没有shader object绑定到任何graphics stage，如果绑定的graphics pipeline以一个非零值VkExternalFormatANDROID::externalFormat创建且启用VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态设置，则vkCmdSetColorBlendEnableEXT必须在该命令前设置blend enable为VK_FALSE
                                                                    （10）如果没有shader object绑定到任何graphics stage，如果绑定的graphics pipeline以一个非零值VkExternalFormatANDROID::externalFormat创建且启用VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态设置，则vkCmdSetRasterizationSamplesEXT必须在该命令前设置rasterizationSamples为VK_SAMPLE_COUNT_1_BIT
                                                                    （11）如果没有shader object绑定到任何graphics stage，如果绑定的graphics pipeline以一个非零值VkExternalFormatANDROID::externalFormat创建且启用VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR动态设置，则vkCmdSetFragmentShadingRateKHR必须在该命令前设置pFragmentSize->width为1，pFragmentSize->height为1
        89.如果dynamicRenderingUnusedAttachments特性未开启，且当前的render pass instance以vkCmdBeginRendering开始，则
                                                                （1）当前绑定的graphics pipeline必须以含VkPipelineRenderingCreateInfo::colorAttachmentCount等于VkRenderingInfo::colorAttachmentCount创建
                                                                （2）如果VkRenderingInfo::colorAttachmentCount大于0，则VkRenderingInfo::pColorAttachments 中每一个其imageView不为VK_NULL_HANDLE的元素的VkImageView必须以VkFormat对应绑定的graphics pipeline的VkPipelineRenderingCreateInfo::pColorAttachmentFormats指明的format创建
                                                                （3）如果VkRenderingInfo::colorAttachmentCount大于0，则VkRenderingInfo::pColorAttachments 中每一个其imageView为VK_NULL_HANDLE的元素对应绑定的graphics pipeline的VkPipelineRenderingCreateInfo::pColorAttachmentFormats指明的format必须为VK_FORMAT_UNDEFINED
                                                                （4）如果VkRenderingInfo::pDepthAttachment->imageView为VK_NULL_HANDLE，则创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::depthAttachmentFormat必须为VK_FORMAT_UNDEFINED
                                                                （5）如果VkRenderingInfo::pDepthAttachment->imageView不为VK_NULL_HANDLE，则创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::depthAttachmentFormat必须和创建VkRenderingInfo::pDepthAttachment->imageView的VkFormat相同
                                                                （6）如果VkRenderingInfo::pStencilAttachment->imageView为VK_NULL_HANDLE，则创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::stencilAttachmentFormat必须为VK_FORMAT_UNDEFINED
                                                                （7）如果VkRenderingInfo::pStencilAttachment->imageView不为VK_NULL_HANDLE，则创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::stencilAttachmentFormat必须和创建VkRenderingInfo::pStencilAttachment->imageView的VkFormat相同
        90.如果dynamicRenderingUnusedAttachments特性开启，且当前的render pass instance以vkCmdBeginRendering开始，则
                                                                （1）如果VkRenderingInfo::colorAttachmentCount大于0，则VkRenderingInfo::pColorAttachments 中每一个其imageView不为VK_NULL_HANDLE的元素的VkImageView必须以VkFormat对应绑定的graphics pipeline的VkPipelineRenderingCreateInfo::pColorAttachmentFormats指明的format创建，或者是对应元素为VK_FORMAT_UNDEFINED创建
                                                                （2）如果VkRenderingInfo::pDepthAttachment->imageView不为VK_NULL_HANDLE，且创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::depthAttachmentFormat和创建VkRenderingInfo::pDepthAttachment->imageView的VkFormat不同，则该format必须为VK_FORMAT_UNDEFINED
                                                                （3）如果VkRenderingInfo::pStencilAttachment->imageView不为VK_NULL_HANDLE，且创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::stencilAttachmentFormat和创建VkRenderingInfo::pStencilAttachment->imageView的VkFormat不同，则该format必须为VK_FORMAT_UNDEFINED
        91.如果没有shader object绑定到任何graphics stage，且当前的render pass instance以vkCmdBeginRendering开始且VkRenderingInfo::colorAttachmentCount为1，且一个color attachment的 resolve mode为VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID，则VkRenderingInfo::pColorAttachments中每个resolveImageView不为VK_NULL_HANDLE的元素其对应image必须以和创建当前绑定的pipeline 相同的VkExternalFormatANDROID::externalFormat创建
        92.如果有一个shader object绑定到任何graphics stage，且当前的render pass 包含一个使用VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID resolve mode的color attachment，则（1）vkCmdSetColorBlendEnableEXT必须在该命令前设置blend enable为VK_FALSE
                                                                                                                                                                                 （2）则vkCmdSetRasterizationSamplesEXT必须在该命令前设置rasterizationSamples为VK_SAMPLE_COUNT_1_BIT
                                                                                                                                                                                 （3）则vkCmdSetFragmentShadingRateKHR必须在该命令前设置pFragmentSize->width为1，pFragmentSize->height为1
        93.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT动态state开启创建， 则vkCmdSetColorWriteEnableEXT 必须在该命令之前设置，且设置的attachmentCount必须大于等于创建当前绑定的pipeline的VkPipelineColorBlendStateCreateInfo::attachmentCount
                                        （2）以VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT动态state开启创建， 则vkCmdSetDiscardRectangleEXT 必须在该命令之前为每个VkPipelineDiscardRectangleStateCreateInfoEXT::discardRectangleCount指明的discard rectangle 设置
                                        （3）以VK_DYNAMIC_STATE_DISCARD_RECTANGLE_ENABLE_EXT动态state开启创建， 则vkCmdSetDiscardRectangleEnableEXT 必须在该命令之前设置
                                        （4）以VK_DYNAMIC_STATE_DISCARD_RECTANGLE_MODE_EXT动态state开启创建， 则vkCmdSetDiscardRectangleModeEXT 必须在该命令之前设置
        94.如果有一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                        （1）如果colorWriteEnable特性在device上开启，则vkCmdSetColorWriteEnableEXT 必须在该命令之前设置，且设置的attachmentCount必须大于等于当前render pass instance的color attachment的数量
                                        （2）如果VK_EXT_discard_rectangles拓展开启，且最近的vkCmdSetDiscardRectangleEnableEXT设置discardRectangleEnable为VK_TRUE， 则vkCmdSetDiscardRectangleEXT 必须在该命令之前设置
                                        （3）如果VK_EXT_discard_rectangles拓展开启， 则vkCmdSetDiscardRectangleEnableEXT 必须在该命令之前设置
                                        （4）如果VK_EXT_discard_rectangles拓展开启， 则最近的vkCmdSetDiscardRectangleEnableEXT设置discardRectangleEnable为VK_TRUE，则vkCmdSetDiscardRectangleModeEXT 必须在该命令之前设置
        95.如果当前的render pass instance以vkCmdBeginRendering开始，则（1）如果VkRenderingFragmentShadingRateAttachmentInfoKHR::imageView不为VK_NULL_HANDLE，则当前绑定的graphics pipeline必须以VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR创建
                                                                      （2）如果VkRenderingFragmentDensityMapAttachmentInfoEXT::imageView不为VK_NULL_HANDLE，则当前绑定的graphics pipeline必须以VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT创建
                                                                      （3）且含VkRenderingInfo::colorAttachmentCount大于0，如果当前的绑定的pipeline以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，则VkRenderingInfo::pColorAttachments中每个imageView不为VK_NULL_HANDLE的元素的imageView，必须以当前pipeline的VkAttachmentSampleCountInfoAMD 或者 VkAttachmentSampleCountInfoNV中的pColorAttachmentSamples中对应元素的sample count进行创建
                                                                      （4）如果当前的绑定的pipeline以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且VkRenderingInfo::pDepthAttachment中的imageView不为VK_NULL_HANDLE，则当前pipeline的VkAttachmentSampleCountInfoAMD 或者 VkAttachmentSampleCountInfoNV中的depthStencilAttachmentSamples必须等于创建VkRenderingInfo::pDepthAttachment->imageView的sample count
                                                                      （5）如果当前的绑定的pipeline以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且VkRenderingInfo::pStencilAttachment中的imageView不为VK_NULL_HANDLE，则当前pipeline的VkAttachmentSampleCountInfoAMD 或者 VkAttachmentSampleCountInfoNV中的depthStencilAttachmentSamples必须等于创建VkRenderingInfo::pStencilAttachment->imageView的sample count
                                                                      （6）且含VkRenderingInfo::colorAttachmentCount大于0，如果当前的绑定的pipeline不以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且multisampledRenderToSingleSampled特性没有开启，则VkRenderingInfo::pColorAttachments中每个imageView不为VK_NULL_HANDLE的元素的imageView，其创建的sample count必须等于当前绑定的graphics pipeline的rasterizationSamples
                                                                      （7）如果当前的绑定的pipeline不以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且VkRenderingInfo::pDepthAttachment中的imageView不为VK_NULL_HANDLE，且multisampledRenderToSingleSampled特性没有开启，则当前pipeline的rasterizationSamples 必须等于创建VkRenderingInfo::pDepthAttachment->imageView的sample count
                                                                      （8）如果当前的绑定的pipeline不以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且VkRenderingInfo::pStencilAttachment中的imageView不为VK_NULL_HANDLE，且multisampledRenderToSingleSampled特性没有开启，则当前pipeline的rasterizationSamples 必须等于创建VkRenderingInfo::pStencilAttachment->imageView的sample count
                                                                      （9）当前绑定的pipeline必须VkGraphicsPipelineCreateInfo::renderPass为VK_NULL_HANDLE创建
                                                                      （10）如果绑定的pipeline的fragment shader静态写入一个color attachment，且color write mask不为0，启用了color writes，且该附件对应的VkRenderingInfo::pColorAttachments->imageView 不为VK_NULL_HANDLE，则对应的创建pipeline的VkPipelineRenderingCreateInfo::pColorAttachmentFormats中的元素不能为VK_FORMAT_UNDEFINED
                                                                      （11）如果绑定的pipeline启用了depth test，启用了depth writes，且VkRenderingInfo::pDepthAttachment->imageView 不为VK_NULL_HANDLE，则创建pipeline的VkPipelineRenderingCreateInfo::depthAttachmentFormat不能为VK_FORMAT_UNDEFINED
                                                                      （12）如果绑定的pipeline启用了stencil test，且VkRenderingInfo::pStencilAttachment->imageView 不为VK_NULL_HANDLE，则创建pipeline的VkPipelineRenderingCreateInfo::stencilAttachmentFormat不能为VK_FORMAT_UNDEFINED
        96.如果该命令在以vkCmdBeginRendering开始的render pass instance中调用，且VkRenderingInfo的pNext中包含一个multisampledRenderToSingleSampledEnable设为VK_TRUE的VkMultisampledRenderToSingleSampledInfoEXT，则当前绑定的graphics pipeline的rasterizationSamples必须等于VkMultisampledRenderToSingleSampledInfoEXT::rasterizationSamples
        97.如果primitivesGeneratedQueryWithRasterizerDiscard特性未开启，且VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query激活，则不能启用rasterization discard
        98.如果primitivesGeneratedQueryWithNonZeroStreams特性未开启，且VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query激活，则 绑定的graphics pipeline不能以VkPipelineRasterizationStateStreamCreateInfoEXT::rasterizationStream为非零值创建
        98.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_TESSELLATION_DOMAIN_ORIGIN_EXT动态state开启创建，则vkCmdSetTessellationDomainOriginEXT必须在该命令之前设置
                                        （2）以VK_DYNAMIC_STATE_DEPTH_CLAMP_ENABLE_EXT动态state开启创建，则vkCmdSetDepthClampEnableEXT必须在该命令之前设置
                                        （3）以VK_DYNAMIC_STATE_POLYGON_MODE_EXT动态state开启创建，则vkCmdSetPolygonModeEXT必须在该命令之前设置
                                        （4）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，则vkCmdSetRasterizationSamplesEXT必须在该命令之前设置
                                        （5）以VK_DYNAMIC_STATE_SAMPLE_MASK_EXT动态state开启创建，则vkCmdSetSampleMaskEXT必须在该命令之前设置
                                        （6）以VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT动态state开启创建，则vkCmdSetAlphaToCoverageEnableEXT必须在该命令之前设置
                                        （7）以VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT动态state开启创建，则最近的vkCmdSetAlphaToCoverageEnableEXT设置alphaToCoverageEnable为VK_TRUE，则Fragment Output Interface中 Index 0的Location 0必须有一个含alpha Component的变量
                                        （8）以VK_DYNAMIC_STATE_ALPHA_TO_ONE_ENABLE_EXT动态state开启创建，则vkCmdSetAlphaToOneEnableEXT必须在该命令之前设置
                                        （9）以VK_DYNAMIC_STATE_LOGIC_OP_ENABLE_EXT动态state开启创建，则vkCmdSetLogicOpEnableEXT必须在该命令之前设置
                                        （10）以VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态state开启创建，则vkCmdSetColorBlendEnableEXT必须在该命令之前设置
                                        （11）以VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT动态state开启创建，则vkCmdSetColorBlendEquationEXT必须在该命令之前设置
                                        （12）以VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT动态state开启创建，则vkCmdSetColorWriteMaskEXT必须在该命令之前设置

        99.如果一个shader object绑定到VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT stage，则vkCmdSetTessellationDomainOriginEXT必须在该命令之前设置
        100.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                                        （1）如果depthClamp特性启用，则vkCmdSetDepthClampEnableEXT必须在该命令之前设置
                                                        （2）则vkCmdSetPolygonModeEXT必须在该命令之前设置
                                                        （3）则vkCmdSetRasterizationSamplesEXT必须在该命令之前设置
                                                        （4）则vkCmdSetSampleMaskEXT必须在该命令之前设置
                                                        （5）则vkCmdSetAlphaToCoverageEnableEXT必须在该命令之前设置
                                                        （6）如果alphaToOne特性启用，则vkCmdSetAlphaToOneEnableEXT必须在该命令之前设置

        101.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetAlphaToCoverageEnableEXT设置alphaToCoverageEnable为VK_TRUE，则Fragment Output Interface中 Index 0的Location 0必须有一个含alpha Component的变量
        102.如果一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                            （1）如果logicOp特性开启 ,vkCmdSetLogicOpEnableEXT必须在该命令之前设置
                                            （2）如果绑定了color attachments，则vkCmdSetColorBlendEnableEXT必须在该命令之前设置
                                            （3）如果最近的vkCmdSetColorBlendEnableEXT设置任何附件在pColorBlendEnables中的值为VK_TRUE ，则vkCmdSetColorBlendEquationEXT必须在该命令之前设置
                                            （4）如果绑定了color attachments，则vkCmdSetColorWriteMaskEXT必须在该命令之前设置

        103.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT动态state开启创建，则vkCmdSetRasterizationStreamEXT必须在该命令之前设置
                                         （2）以VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT动态state开启创建，则vkCmdSetConservativeRasterizationModeEXT必须在该命令之前设置
                                         （3）以VK_DYNAMIC_STATE_EXTRA_PRIMITIVE_OVERESTIMATION_SIZE_EXT动态state开启创建，则vkCmdSetExtraPrimitiveOverestimationSizeEXT必须在该命令之前设置
                                         （4）以VK_DYNAMIC_STATE_DEPTH_CLIP_ENABLE_EXT动态state开启创建，则vkCmdSetDepthClipEnableEXT必须在该命令之前设置
                                         （5）以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT动态state开启创建，则vkCmdSetSampleLocationsEnableEXT必须在该命令之前设置
                                         （6）以VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT动态state开启创建，则vkCmdSetColorBlendAdvancedEXT必须在该命令之前设置
                                         （7）以VK_DYNAMIC_STATE_PROVOKING_VERTEX_MODE_EXT动态state开启创建，则vkCmdSetProvokingVertexModeEXT必须在该命令之前设置
                                         （8）以VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT动态state开启创建，则vkCmdSetLineRasterizationModeEXT必须在该命令之前设置
                                         （9）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT动态state开启创建，则vkCmdSetLineStippleEnableEXT必须在该命令之前设置
                                         （10）以VK_DYNAMIC_STATE_LINE_STIPPLE_KHR动态state开启创建，则vkCmdSetLineStippleKHR必须在该命令之前设置
                                         （11）以VK_DYNAMIC_STATE_DEPTH_CLIP_NEGATIVE_ONE_TO_ONE_EXT动态state开启创建，则vkCmdSetDepthClipNegativeOneToOneEXT必须在该命令之前设置
                                         （12）以VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_ENABLE_NV动态state开启创建，则vkCmdSetViewportWScalingEnableNV必须在该命令之前设置
                                         （13）以VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV动态state开启创建，则vkCmdSetViewportSwizzleNV必须在该命令之前设置
                                         （14）以VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV动态state开启创建，则vkCmdSetCoverageToColorEnableNV必须在该命令之前设置
                                         （15）以VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_LOCATION_NV动态state开启创建，则vkCmdSetCoverageToColorLocationNV必须在该命令之前设置
                                         （16）以VK_DYNAMIC_STATE_COVERAGE_MODULATION_MODE_NV动态state开启创建，则vkCmdSetCoverageModulationModeNV必须在该命令之前设置
                                         （17）以VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV动态state开启创建，则vkCmdSetCoverageModulationTableEnableNV必须在该命令之前设置
                                         （18）以VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_NV动态state开启创建，则vkCmdSetCoverageModulationTableNV必须在该命令之前设置
                                         （19）以VK_DYNAMIC_STATE_SHADING_RATE_IMAGE_ENABLE_NV动态state开启创建，则vkCmdSetShadingRateImageEnableNV必须在该命令之前设置
                                         （20）以VK_DYNAMIC_STATE_REPRESENTATIVE_FRAGMENT_TEST_ENABLE_NV动态state开启创建，则vkCmdSetRepresentativeFragmentTestEnableNV必须在该命令之前设置
                                         （21）以VK_DYNAMIC_STATE_COVERAGE_REDUCTION_MODE_NV动态state开启创建，则vkCmdSetCoverageReductionModeNV必须在该命令之前设置

        104.如果一个shader object绑定到VK_SHADER_STAGE_GEOMETRY_BIT stage，且如果geometryStreams 特性开启，则vkCmdSetRasterizationStreamEXT必须在该命令之前设置
        105.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                （1）如果VK_EXT_conservative_rasterization 拓展开启，vkCmdSetConservativeRasterizationModeEXT必须在该命令之前设置
                                （2）如果VK_EXT_conservative_rasterization 拓展开启，且最近的vkCmdSetConservativeRasterizationModeEXT设置conservativeRasterizationMode为VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT，则vkCmdSetExtraPrimitiveOverestimationSizeEXT必须在该命令之前设置
                                （3）如果VK_EXT_sample_locations 拓展开启，则vkCmdSetSampleLocationsEnableEXT必须在该命令之前设置
        106.如果一个shader object绑定到任何graphics stage，且depthClipEnable 特性开启，则vkCmdSetDepthClipEnableEXT必须在该命令之前设置
        107.如果如果一个shader object绑定到任何VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且如果VK_EXT_blend_operation_advanced 拓展开启，则vkCmdSetColorBlendEquationEXT 和 vkCmdSetColorBlendAdvancedEXT中至少一个必须在该命令之前设置
        108.如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，如果VK_EXT_provoking_vertex拓展开启， 则vkCmdSetProvokingVertexModeEXT必须在该命令之前设置
        109.如果VK_KHR_line_rasterization 或者 VK_EXT_line_rasterization拓展开启，则（1）如果一个shader object绑定到任意一个graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetPolygonModeEXT设置polygonMode 为VK_POLYGON_MODE_LINE ，则vkCmdSetLineRasterizationModeEXT必须在该命令之前设置
                                                                                    （2）如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetPrimitiveTopology设置primitiveTopology 为任何line topology ，则vkCmdSetLineRasterizationModeEXT必须在该命令之前设置
                                                                                    （3）如果一个输出为line primitive的shader object绑定到VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或 VK_SHADER_STAGE_GEOMETRY_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则vkCmdSetLineRasterizationModeEXT必须在该命令之前设置
                                                                                    （4）如果一个shader object绑定到任意一个graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetPolygonModeEXT设置polygonMode 为VK_POLYGON_MODE_LINE ，则vkCmdSetLineStippleEnableEXT必须在该命令之前设置
                                                                                    （5）如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetPrimitiveTopology设置primitiveTopology 为任何line topology ，则vkCmdSetLineStippleEnableEXT必须在该命令之前设置
                                                                                    （6）如果一个输出为line primitive的shader object绑定到VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或 VK_SHADER_STAGE_GEOMETRY_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则vkCmdSetLineStippleEnableEXT必须在该命令之前设置
                                                                                    （7）如果一个shader object绑定到任意一个graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetLineStippleEnableEXT设置stippledLineEnable 为VK_TRUE ，则vkCmdSetLineStippleEXT必须在该命令之前设置
        110.如果一个shader object绑定到任何graphics stage，（1）如果depthClipControl 特性开启，则vkCmdSetDepthClipNegativeOneToOneEXT必须在该命令之前设置
                                                           （2）VK_NV_clip_space_w_scaling 拓展开启，则vkCmdSetViewportWScalingEnableNV必须在该命令之前设置
                                                           （3）VK_NV_viewport_swizzle 拓展开启，则vkCmdSetViewportSwizzleNV必须在该命令之前设置
        111.如果如果一个shader object绑定到任何VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                            （1）如果VK_NV_fragment_coverage_to_color 拓展开启，则vkCmdSetCoverageToColorEnableNV 必须在该命令之前设置
                            （2）如果VK_NV_fragment_coverage_to_color 拓展开启，且最近的vkCmdSetCoverageToColorEnableNV 设置coverageToColorEnable 为VK_TRUE，则vkCmdSetCoverageToColorLocationNV 必须在该命令之前设置
                            （3）如果pipelineFragmentShadingRate 特性开启，则vkCmdSetFragmentShadingRateKHR 必须在该命令之前设置
        112.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                    （1）如果VK_NV_framebuffer_mixed_samples 拓展开启，则vkCmdSetCoverageModulationModeNV 必须在该命令之前设置
                                    （2）如果VK_NV_framebuffer_mixed_samples 拓展开启，且最近的vkCmdSetCoverageModulationModeNV设置coverageModulationMode为任何除VK_COVERAGE_MODULATION_MODE_NONE_NV之外的值，则vkCmdSetCoverageModulationTableEnableNV 必须在该命令之前设置
                                    （3）如果VK_NV_framebuffer_mixed_samples 拓展开启，最近的vkCmdSetCoverageModulationTableEnableNV设置coverageModulationTableEnable为VK_TRUE，则vkCmdSetCoverageModulationTableNV 必须在该命令之前设置
                                    （4）如果shadingRateImage 特性开启，则vkCmdSetShadingRateImageEnableNV 必须在该命令之前设置
                                    （5）如果representativeFragmentTest 特性开启，则vkCmdSetRepresentativeFragmentTestEnableNV 必须在该命令之前设置
                                    （6）如果coverageReductionMode 特性开启，则vkCmdSetCoverageReductionModeNV 必须在该命令之前设置
        113.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态state开启创建，且最近的vkCmdSetColorBlendEnableEXT设置任何附件在pColorBlendEnables中的值为VK_TRUE 则subpas中这些附件对应的image view的format features中必须包含VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT
                                         （2）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，且当前subpass不使用任何color和/或者 depth/stencil attachments，则最后的vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples必须符合zero￾attachment subpass的规则
                                         （3）以VK_DYNAMIC_STATE_SAMPLE_MASK_EXT不以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT 动态state开启创建，则最后调用的vkCmdSetSampleMaskEXT中设置的samples参数必须大于等于创建该pipeline的VkPipelineMultisampleStateCreateInfo::rasterizationSamples
                                         （4）以VK_DYNAMIC_STATE_SAMPLE_MASK_EXT和 VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT 动态state开启创建，则最后调用的vkCmdSetSampleMaskEXT中设置的samples参数必须大于等于最后的vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples
                                         （5）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，且VK_AMD_mixed_attachment_samples和VK_NV_framebuffer_mixed_samples拓展都没有开启，则最后的vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples必须等于subpass中color和/或者 depth/stencil attachments使用的相同
                                         （6）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，或者一个shader object绑定到任意graphics stage，且当前的subpass包含一个multisampledRenderToSingleSampledEnable 为VK_TRUE的VkMultisampledRenderToSingleSampledInfoEXT，则最后的vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples必须等于该VkMultisampledRenderToSingleSampledInfoEXT中的对应成员
                                         （7）以VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态state开启创建，则vkCmdSetColorBlendEnableEXT 必须在该命令之前设置，且vkCmdSetColorBlendEnableEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定值
                                         （8）以VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT动态state开启创建，则vkCmdSetColorBlendEquationEXT 必须在该命令之前设置，且vkCmdSetColorBlendEquationEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定blend equations
                                         （9）以VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT动态state开启创建，则vkCmdSetColorWriteMaskEXT 必须在该命令之前设置，且vkCmdSetColorWriteMaskEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定color write mask
                                         （10）以VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT动态state开启创建，则vkCmdSetColorBlendAdvancedEXT 必须在该命令之前设置，且vkCmdSetColorBlendAdvancedEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活blend的color attachments指定advanced blend equations
                                         （11）以VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT和VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态state开启创建，且最后的vkCmdSetColorBlendEnableEXT和vkCmdSetColorBlendAdvancedEXT设置启用了advanced blending，则当前subpass中激活的color attachments的数量不能超过advancedBlendMaxColorAttachments
                                         （12）以VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT动态state开启创建，且如果primitivesGeneratedQueryWithNonZeroStreams特性未开启且VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query已经激活，则最后的vkCmdSetRasterizationStreamEXT必须设置rasterizationStream为0
                                         （13）以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT但不以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，则最后的vkCmdSetSampleLocationsEXT设置的pSampleLocationsInfo->sampleLocationsPerPixel必须等于创建pipeline的VkPipelineMultisampleStateCreateInfo::rasterizationSamples
                                         （14）以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT和VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，则最后的vkCmdSetSampleLocationsEXT设置的pSampleLocationsInfo->sampleLocationsPerPixel必须等于最后vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples
                                         （15）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT但不以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT动态state开启创建，且绑定的pipeline的VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable为VK_TRUE 或者以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT动态state开启，则sampleLocationsInfo.sampleLocationsPerPixel 必须等于最后vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples
                                         （16）以VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV动态state开启创建，且最后的vkCmdSetCoverageToColorEnableNV设置coverageToColorEnable为VK_TRUE，则当前subpass必须有color attachment，且该attachment的format必须为VK_FORMAT_R8_UINT, VK_FORMAT_R8_SINT, VK_FORMAT_R16_UINT, VK_FORMAT_R16_SINT, VK_FORMAT_R32_UINT, 或者 VK_FORMAT_R32_SINT，且该attachment的location 有最后的vkCmdSetCoverageToColorLocationNV设置的coverageToColorLocation决定
                                         （17）以VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV和VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT 动态state开启创建，且如果VK_NV_coverage_reduction_mode 拓展开启，则当前的 coverageReductionMode，rasterizationSamples 以及color 以及 depth/stencil attachments（如果subpass有）的sample count必须是有效的返回值vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV的值的组合
                                         （18）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT但不以VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV 动态state开启创建，则绑定的graphics pipeline的VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount 必须大于等于最后vkCmdSetViewportWithCount设置的viewportCount
                                         （19）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT和VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV 动态state开启创建，则最后vkCmdSetViewportSwizzleNV设置的viewportCount 必须大于等于最后vkCmdSetViewportWithCount设置的viewportCount
                                         （20）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT或者 VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT 动态state开启创建，如果当前的stippledLineEnable为VK_TRUE，且当前的lineRasterizationMode为VK_LINE_RASTERIZATION_MODE_RECTANGULAR_KHR，则stippledRectangularLines 特性必须开启
                                         （21）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT或者 VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT 动态state开启创建，如果当前的stippledLineEnable为VK_TRUE，且当前的lineRasterizationMode为VK_LINE_RASTERIZATION_MODE_BRESENHAM_KHR，则stippledBresenhamLines 特性必须开启
                                         （22）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT或者 VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT 动态state开启创建，如果当前的stippledLineEnable为VK_TRUE，且当前的lineRasterizationMode为VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_KHR，则stippledSmoothLines 特性必须开启
                                         （23）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT或者 VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT 动态state开启创建，如果当前的stippledLineEnable为VK_TRUE，且当前的lineRasterizationMode为VK_LINE_RASTERIZATION_MODE_DEFAULT_KHR，则stippledRectangularLines 特性必须开启且VkPhysicalDeviceLimits::strictLines 必须为VK_TRUE
                                         （24）以VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT 动态state开启创建，且conservativePointAndLineRasterization不支持，最后的 pre-rasterization shader stage输出的有效图元拓扑为点或者线，则最后vkCmdSetConservativeRasterizationModeEXT设置的conservativeRasterizationMode 必须为VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT
                                         （25）以VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT 动态state开启创建，则vkCmdSetAttachmentFeedbackLoopEnableEXT 必须在该命令之前调用
        114.如果一个shader object绑定到 VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                                                                            （1）则vkCmdSetColorBlendEnableEXT 必须在该命令之前设置，且vkCmdSetColorBlendEnableEXT指定的firstAttachment开始的attachmentCount的值必须为当前subpass所有激活的color attachments指定
                                                                                            （2）则vkCmdSetColorBlendEquationEXT 必须在该命令之前设置，且vkCmdSetColorBlendEquationEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定blend equations
                                                                                            （3）则vkCmdSetColorWriteMaskEXT 必须在该命令之前设置，且vkCmdSetColorWriteMaskEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定color write mask
                                                                                            （4）如果VK_NV_fragment_coverage_to_color拓展开启， 最后的vkCmdSetCoverageToColorEnableNV设置coverageToColorEnable为VK_TRUE，则当前subpass必须有color attachment，且该attachment的format必须为VK_FORMAT_R8_UINT, VK_FORMAT_R8_SINT, VK_FORMAT_R16_UINT, VK_FORMAT_R16_SINT, VK_FORMAT_R32_UINT, 或者 VK_FORMAT_R32_SINT，且该attachment的location 有最后的vkCmdSetCoverageToColorLocationNV设置的coverageToColorLocation决定
        115.如果一个shader object绑定到 VK_SHADER_STAGE_FRAGMENT_BIT stage，（1）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT动态state开启创建，且最近的vkCmdSetSampleLocationsEnableEXT设置sampleLocationsEnable为VK_TRUE，且该subpass含有depth/stencil attachment，则该附件必须以VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT创建
                                                                            （2）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT和VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT 动态state开启创建，且最近的vkCmdSetSampleLocationsEnableEXT设置sampleLocationsEnable为VK_TRUE，则 最后vkCmdSetSampleLocationsEXT设置的sampleLocationsInfo.sampleLocationGridSize.width以及height 必须等于被调用vkGetPhysicalDeviceMultisamplePropertiesEXT传入rasterizationSamples返回的VkMultisamplePropertiesEXT::sampleLocationGridSize.width以及height一一对应均匀整除
                                                                            （3）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT 动态state开启创建，且最近的vkCmdSetSampleLocationsEnableEXT设置sampleLocationsEnable为VK_TRUE，则fragment shader代码中不能静态使用扩展指令InterpolateAtSample
                                                                            （4）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT但不以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT 动态state开启创建，且绑定的pipeline的VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable为VK_TRUE 或者以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT动态state开启，则 最后vkCmdSetRasterizationSamplesEXT设置的sampleLocationsInfo.sampleLocationGridSize.width以及height 必须等于被调用vkGetPhysicalDeviceMultisamplePropertiesEXT传入和vkCmdSetRasterizationSamplesEXT设置的相同rasterizationSamples的samples返回的VkMultisamplePropertiesEXT::sampleLocationGridSize.width以及height一一对应均匀整除
        116.如果一个shader object绑定到任何graphics stage，（1）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV 动态state开启创建，且最近的vkCmdSetCoverageModulationTableEnableNV设置coverageModulationTableEnable为VK_TRUE，则最近的vkCmdSetCoverageModulationTableNV 设置的coverageModulationTableCount 必须等于当前rasterizationSamples除以当前subppas的color samples
                                                           （2）如果VK_NV_viewport_swizzle 拓展开启，则最后vkCmdSetViewportSwizzleNV设置的viewportCount 必须大于等于最后vkCmdSetViewportWithCount设置的viewportCount
        117.如果VK_NV_framebuffer_mixed_samples 拓展开启，且如果在绑定的graphics pipeline中当前subpass有一个depth/stencil attachment以及dep test, stencil test, 或depth bounds test 启用，则当前rasterizationSamples 必须等于depth/stencil attachment的sample count
        118.如果VK_NV_framebuffer_mixed_samples 拓展开启，且如果最后的vkCmdSetRasterizationSamplesEXT设置的当前subpass的任何color attachments的rasterizationSamples 都大于 color samples，则sampleShadingEnable 必须为VK_FALSE
        119.如果当前绑定的graphics pipeline以VkGraphicsPipelineCreateInfo::pStages中的元素的VkPipelineShaderStageCreateInfo::stage设置为VK_SHADER_STAGE_VERTEX_BIT, VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT, VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或者 VK_SHADER_STAGE_GEOMETRY_BIT创建，则Mesh Shader Queries 不能激活
        120.如果dynamic state继承自VkCommandBufferInheritanceViewportScissorInfoNV，则这些动态state的设置必须在该命令之前设置
        121.如果没有绑定graphics pipeline，则（1）vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_VERTEX_BIT
                                             （2）如果tessellationShader 特性开启，vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT，VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT
                                             （3）如果geometryShader 特性开启，vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_GEOMETRY_BIT
                                             （4）vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_FRAGMENT_BIT
                                             （5）如果taskShader 特性开启，vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_TASK_BIT_EXT
                                             （6）如果meshShader 特性开启，vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_MESH_BIT_EXT
                                             （8）如果至少taskShader 和 meshShader一个特性开启，VK_SHADER_STAGE_VERTEX_BIT 或者VK_SHADER_STAGE_MESH_BIT_EXT stages中的一个必须含有有效的VkShaderEXT绑定，另外一个则不含有VkShaderEXT绑定
                                             （9）如果taskShader 和 meshShader特性同时开启，且一个有效的VkShaderEXT 绑定到VK_SHADER_STAGE_MESH_BIT_EXT stage，且该VkShaderEXT不以VK_SHADER_CREATE_NO_TASK_SHADER_BIT_EXT 创建，则一个有效的VkShaderEXT必须绑定到VK_SHADER_STAGE_TASK_BIT_EXT stage
                                             （10）如果taskShader 和 meshShader特性同时开启，且一个有效的VkShaderEXT 绑定到VK_SHADER_STAGE_MESH_BIT_EXT stage，且该VkShaderEXT以VK_SHADER_CREATE_NO_TASK_SHADER_BIT_EXT 创建，则不能有VkShaderEXT绑定到VK_SHADER_STAGE_TASK_BIT_EXT stage
                                             （11）如果一个有效的VkShaderEXT 绑定到VK_SHADER_STAGE_VERTEX_BIT stage，则不能有VkShaderEXT绑定到VK_SHADER_STAGE_TASK_BIT_EXT stage或者VK_SHADER_STAGE_MESH_BIT_EXT stage中的一个
        122.如果任何绑定的graphics shader以VK_SHADER_CREATE_LINK_STAGE_BIT_EXT 创建，（1）所有在相同vkCreateShadersEXT中以VK_SHADER_CREATE_LINK_STAGE_BIT_EXT创建的shaders必须也要绑定
                                                                                     （2）任何相同vkCreateShadersEXT中不以VK_SHADER_CREATE_LINK_STAGE_BIT_EXT创建的shaders不能有任何VkShaderEXT绑定
        123.所有绑定的graphics shader objects 必须以相同或者相同定义的push constant ranges创建
        124.所有绑定的graphics shader objects 必须以相同或者相同定义的descriptor set layouts的数组创建
        125.如果当前的render pass instance以vkCmdBeginRendering开始，且VkRenderingInfo::colorAttachmentCount为1，且有一个resolve mode为 VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID 的color attachment，且绑定了fragment shader，则DepthReplacing 和 StencilRefReplacingEXT execution modes 不能声明
        126.如果一个shader object绑定到 VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则 （1）如果attachmentFeedbackLoopDynamicState 特性开启，则 vkCmdSetAttachmentFeedbackLoopEnableEXT 必须在该命令之前调用
        127.如果包含一个fragment shader stage的绑定的graphics pipeline，（1）且该pipeline以VkPipelineDynamicStateCreateInfo::pDynamicStates中设置有VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE创建，且该fragment shader声明了EarlyFragmentTests execution mode且使用了OpDepthAttachmentReadEXT，则最后vkCmdSetDepthWriteEnable 设置的 depthWriteEnable 必须为VK_FALSE
                                                                        （2）且该pipeline以VkPipelineDynamicStateCreateInfo::pDynamicStates中设置有VK_DYNAMIC_STATE_STENCIL_WRITE_MASK创建，且该fragment shader声明了EarlyFragmentTests execution mode且使用了OpStencilAttachmentReadEXT，则最后vkCmdSetStencilWriteMask 设置的 writeMask 必须为0
        128.如果一个shader object绑定到任何graphics stage 或者绑定的graphics pipeline 以VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT 动态state开启创建，且任何color attachment的format为VK_FORMAT_E5B9G9R9_UFLOAT_PACK32，则vkCmdSetColorWriteMaskEXT设置的pColorWriteMasks参数的对应元素必须包含VK_COLOR_COMPONENT_R_BIT, VK_COLOR_COMPONENT_G_BIT, 和 VK_COLOR_COMPONENT_B_BIT，或者都不包含
        129.如果任何附件开启了blending，且该附件的source 或者 destination blend factors使用第二个颜色输入，则该命令执行的Fragment Execution Model静态使用的任何输出output attachment的Location的最大值必须小于maxFragmentDualSrcAttachments
        130.如果当前的render pass instance以vkCmdBeginRendering开始，（1）如果没有任何shader object绑定到任何graphics stage，则vkCmdSetRenderingAttachmentLocationsKHR 设置的VkRenderingAttachmentLocationInfoKHR::pColorAttachmentLocations中的每个元素必须匹配设置在当前绑定的graphics pipeline中的对应元素
                                                                     （2）如果没有任何shader object绑定到任何graphics stage，绑定的graphics pipeline中的input attchment 索引中映射的附件必须匹配在当前render pass instance的VkRenderingInputAttachmentIndexInfoKHR中设置的
        131.如果当前的render pass instance以vkCmdBeginRendering开始且以VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT标志开始，则绑定的graphics pipeline必须以VK_PIPELINE_CREATE_2_ENABLE_LEGACY_DITHERING_BIT_EXT创建
        132.如果绑定的graphics pipeline以VK_PIPELINE_CREATE_2_ENABLE_LEGACY_DITHERING_BIT_EXT创建，则当前的render pass 必须以vkCmdBeginRendering开始且以VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT标志开始
        135.所有在vertex shader entry point 的 interface通过声明的vertex input variables访问的vertex input bindings必须是有效的buffer绑定或者为VK_NULL_HANDLE绑定
        136.如果nullDescriptor 特性未开启，则所有在vertex shader entry point 的 interface通过声明的vertex input variables访问的vertex input bindings不能为VK_NULL_HANDLE绑定
        137.如果robustBufferAccess 特性未开启，且pipeline的创建不对vertexInputs以VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT开启创建，则对于指定的vertex buffer binding，任何获取的顶点属性数据必须包含在对应的vertex buffer binding中，参见Vertex Input Description p2586
        138.如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage或者绑定的graphics pipeline以VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY动态state开启创建，则vkCmdSetPrimitiveTopology必须在该命令前设置
        140.如果绑定的graphics pipeline以VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY动态state开启创建，且dynamicPrimitiveTopologyUnrestricted为VK_FALSE，则vkCmdSetPrimitiveTopology设置的primitiveTopology 必须和pipeline创建的VkPipelineInputAssemblyStateCreateInfo::topology相同
        141.如果绑定的graphics pipeline以VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT但不以VK_DYNAMIC_STATE_VERTEX_INPUT_EXT 动态state开启创建，则vkCmdBindVertexBuffers2EXT必须在该命令前设置，且pStrides参数不能为NULL
        142.如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage或者绑定的graphics pipeline以VK_DYNAMIC_STATE_VERTEX_INPUT_EXT动态state开启创建，则
                                            （1）vkCmdSetVertexInputEXT必须在该命令前设置
                                            （2）所有以Input storage class修饰的Vertex Execution Model OpEntryPoint中的变量其Location必须包含在VkVertexInputAttributeDescription2EXT::location指定的location中
                                            （3）如果满足legacyVertexAttributes未开启或者Vertex Execution Model OpEntryPoint中给定对应Location的Input variable的 SPIR-V Type为64-bit的中的一个，则Vertex Execution Model OpEntryPoint中对应Location的所有Input variable的numeric type必须和VkVertexInputAttributeDescription2EXT::format的相同
                                            （4）如果VkVertexInputAttributeDescription2EXT::format含有64-bit 分量，Vertex Execution Model OpEntryPoint中对应Location的所有Input variable的scalar width必须是64-bit的
                                            （5）如果Vertex Execution Model OpEntryPoint中对应Location的Input variable的scalar width是64-bit的，则对应VkVertexInputAttributeDescription2EXT::format必须含有64-bit 分量
                                            （6）如果VkVertexInputAttributeDescription2EXT::format含有64-bit 分量，则Vertex Execution Model OpEntryPoint中对应Location的所有Input variable不能使用该format未呈现的分量
        143.如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage且最近的vkCmdSetPrimitiveTopology设置primitiveTopology为VK_PRIMITIVE_TOPOLOGY_PATCH_LIST，或者绑定的graphics pipeline以VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT动态state开启创建，则vkCmdSetPatchControlPointsEXT必须在该命令前设置
        144.如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage或者绑定的graphics pipeline以VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE动态state开启创建，则vkCmdSetPrimitiveRestartEnable必须在该命令前设置
        145.如果primitiveTopologyListRestart特性未开启，且topology 为VK_PRIMITIVE_TOPOLOGY_POINT_LIST, VK_PRIMITIVE_TOPOLOGY_LINE_LIST, VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST, VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY, 或者 VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY，
                    且有一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage或者绑定的graphics pipeline以VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE动态state开启创建，则vkCmdSetPrimitiveRestartEnable必须设置为VK_FALSE
        146.绑定的graphics pipeline不能以VkGraphicsPipelineCreateInfo::pStages中元素的VkPipelineShaderStageCreateInfo::stage设置为VK_SHADER_STAGE_TASK_BIT_EXT 或者 VK_SHADER_STAGE_MESH_BIT_EXT创建
        147.不能有shader object绑定到VK_SHADER_STAGE_TASK_BIT_EXT或者 VK_SHADER_STAGE_MESH_BIT_EXT中的一个stage
        148.如果buffer为non-sparse的，则该buffer必须绑定到完整的连续的单独的VkDeviceMemory上
        149.buffer必须以VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT 创建
        150.offset必须是4的倍数
        151.commandBuffer不能为一个protected command buffer
        152.如果countBuffer为non-sparse的，则该buffer必须绑定到完整的连续的单独的VkDeviceMemory上
        153.countBuffer必须以VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT 创建
        154.countBufferOffset必须是4的倍数
        155.存储在countBuffer中的绘制次数值必须小于等于VkPhysicalDeviceLimits::maxDrawIndirectCount
        156.(countBufferOffset + sizeof(uint32_t))必须小于等于countBuffer的大小
        157.如果drawIndirectCount 没有启用则该命令就不能使用
        158.如果maintenance6 未开启，则一个有效的index buffer必须已经绑定
        159.如果robustBufferAccess2未开启，则(indexSize × (firstIndex + indexCount) + offset)必须小于等于绑定的index buffer的大小，其中indexSize取决于indexType，且index buffer ， indexType, 以及 offset由vkCmdBindIndexBuffer 指定
        160.stride必须为4的倍数，且必须大于或者等于sizeof(VkDrawIndexedIndirectCommand)
        161.如果maxDrawCount大于1，则(stride × (maxDrawCount - 1) + offset + sizeof(VkDrawIndexedIndirectCommand))必须小于等于buffer的大小
        162.如果存储在countBuffer中的绘制次数值为1，则(offset + sizeof(VkDrawIndexedIndirectCommand))必须小于或者等于buffer的大小
        163.如果存储在countBuffer中的绘制次数值大于1，则(stride × (drawCount - 1) + offset + sizeof(VkDrawIndexedIndirectCommand))必须小于等于buffer的大小
        */

        

        // Drawing Transform Feedback参见 p2153
        /*
        概述:在之前捕获的 transform feedback buffers中的数据可以作为顶点缓冲的数据被绘制，其中transform feedback buffers中可以绘制的顶点数由 vkCmdEndTransformFeedbackEXT给出，然后调用 vkCmdDrawIndirectByteCountEXT即可绘制这些buffers中的顶点数据，这两个命令是需要pipeline barrier进行同步的，主要是前者会将顶点个数写入到指定buffer，后者从该buffer中读取顶点数来进行绘制
        */
        
        //记录一个非索引的绘制，其中顶点计数基于从缓冲区读取的字节计数和传递的顶点步幅参数，图元组装依据vkCmdDraw的规则，有效的 firstVertex为0
        // 实际的顶点个数计算:
        //const uint32_t * counterBufferPtr = (const uint8_t *)counterBuffer.address + counterBufferOffset;
        // vertexCount = floor(max(0, (*counterBufferPtr - counterOffset)) / vertexStride);
        vkCmdDrawIndirectByteCountEXT(commandBuffer, 1/*instanceCount,要绘制的instances的个数*/, 0/*firstInstance,要绘制的第一个instance的ID.*/, 
                     VkBuffer{/*假设只是一个有效的VkBuffer*/ }/*countBuffer，是包含绘制顶点计数的buffer.*/, 0/*• countBufferOffset，为countBuffer中绘制计数参数开始的起始字节偏移量.*/, 
                     0/* counterOffset，为counterBuffer读取的字节计数减去counterBufferOffset */, 3/*vertexStride，为vertex data中元素之间的字节步长，可以用来从字节计数来计算顶点的个数，这个值就等于graphics pipeline state中进行transform feedback捕获使用的XfbStride.*/);
        /*

         vkCmdDrawIndirectByteCountEXT有效用法:
        1.如果一个VkSampler以其magFilter或者minFilter等于VK_FILTER_LINEAR创建，则（1）如果reductionMode为VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE，如果用于采样一个VkImageView作为该命令的结果的compareEnable为VK_FALSE，则该image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT
                                                                                 （2）如果reductionMode为VK_SAMPLER_REDUCTION_MODE_MIN 或者VK_SAMPLER_REDUCTION_MODE_MAX之一 用于采样一个VkImageView作为该命令的结果，则该image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT
        2.如果一个VkSampler以其mipmapMode 等于VK_SAMPLER_MIPMAP_MODE_LINEAR创建，则（1）如果reductionMode为VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE，如果用于采样一个VkImageView作为该命令的结果的compareEnable为VK_FALSE，则该image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT
                                                                                 （2）如果reductionMode为VK_SAMPLER_REDUCTION_MODE_MIN 或者VK_SAMPLER_REDUCTION_MODE_MAX之一 用于采样一个VkImageView作为该命令的结果，则该image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT
        3.如果一个VkSampler以其unnormalizedCoordinates等于VK_TRUE用于采样一个VkImageView作为该命令的结果创建，则（1）该image view的levelCount以及layerCount必须为1
                                                                                                                （2）该image view的viewType必须为VK_IMAGE_VIEW_TYPE_1D 或者 VK_IMAGE_VIEW_TYPE_2D
        4.如果一个VkImageView的采样带depth comparison操作，则image view的format features必须包含VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT
        5.如果一个VkImageView使用atomic operations作为该命令的结果进行访问，则image view的format features必须包含VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT
        6.如果一个VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER类型的 descriptor使用atomic operations作为该命令的结果进行访问，则storage texel buffer的format features必须包含VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT
        7.如果一个以VK_FILTER_CUBIC_EXT进行采样的VkImageView作为该命令的结果，则image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT
        8.如果VK_EXT_filter_cubic拓展没有开启，且有任何一个以VK_FILTER_CUBIC_EXT进行采样的VkImageView作为该命令的结果，则其VkImageViewType不能为VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, 或者 VK_IMAGE_VIEW_TYPE_CUBE_ARRAY
        9.任何一个以VK_FILTER_CUBIC_EXT进行采样的作为该命令的结果的VkImageView，其VkImageViewType和format 必须支持cubic filtering，参见vkGetPhysicalDeviceImageFormatProperties2返回的VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic
        10.任何一个以VK_FILTER_CUBIC_EXT进行采样且reduction mode为VK_SAMPLER_REDUCTION_MODE_MIN 或者 VK_SAMPLER_REDUCTION_MODE_MAX之一的作为该命令的结果的VkImageView，其VkImageViewType和format 必须支持带minmax filtering的cubic filtering，参见vkGetPhysicalDeviceImageFormatProperties2返回的VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax
        11.如果cubicRangeClamp特性没有开启，则有任何一个以VK_FILTER_CUBIC_EXT进行采样VkImageView的作为该命令的结果，VkSamplerReductionModeCreateInfo::reductionMode不能为VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM
        12.任何一个以VkSamplerReductionModeCreateInfo::reductionMode为VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM进行采样的作为该命令的结果的VkImageView必须以VK_FILTER_CUBIC_EXT进行采样
        13.如果selectableCubicWeights特性没有开启，则有任何一个以VK_FILTER_CUBIC_EXT进行采样VkImageView的作为该命令的结果，VkSamplerCubicWeightsCreateInfoQCOM::cubicWeights必须为VK_CUBIC_FILTER_WEIGHTS_CATMULL_ROM_QCOM
        14.任何一个以VkImageCreateInfo::flags含VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV创建的采样作为该命令结果的VkImage必须以VkSamplerAddressMode为VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE 进行采样
        15.对于任何作为storage image写入的VkImageView，且其OpTypeImage的format未知，则该image view的 format features必须包含VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT
        16.对于任何作为storage image读取的VkImageView，且其OpTypeImage的format未知，则该image view的 format features必须包含VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT
        17.对于任何作为storage storage texel buffer写入的VkBufferView，且其OpTypeImage的format未知，则该buffer view的 buffer features必须包含VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT
        18.对于任何作为storage storage texel buffer读取的VkBufferView，且其OpTypeImage的format未知，则该buffer view的 buffer features必须包含VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT
        19.对于每个在绑定的shader中静态使用的set n，一个descriptor set必须被绑定到相同pipeline bind point的set n处，该set n必须和创建当前VkPipeline的VkPipelineLayout或者和创建当前VkShaderEXT的VkDescriptorSetLayout 数组的set n处的布局兼容，参见Pipeline Layout Compatibility p1280
        20.对于每个在绑定的shader中静态使用的push constant，一个push constant值必须被绑定到相同pipeline bind point的对应处，该push constant必须和创建当前VkPipeline的VkPipelineLayout或者和创建当前VkShaderEXT的VkDescriptorSetLayout 数组中的对应处的布局兼容，参见Pipeline Layout Compatibility p1280
        21.如果maintenance4特性没有开启，则对于每个在绑定的shader中静态使用的push constant，一个push constant值必须被设置到相同pipeline bind point的对应处，该push constant必须和创建当前VkPipeline的VkPipelineLayout或者和创建当前VkShaderEXT的VkDescriptorSetLayout 数组中的对应处的布局兼容，参见Pipeline Layout Compatibility p1280
        22.每一个通过vkCmdBindDescriptorSets绑定的descriptor set的descriptors,如果是被不以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建的，且已经绑定到该命令使用的pipeline bind point的VkPipeline静态使用的，则这些descriptors必须是有效的，参见 descriptor validity p1328
        23.如果通过vkCmdBindDescriptorSets指定绑定到pipeline bind point的VkPipeline要使用的descriptors，则绑定的VkPipeline不能以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建
        24.在vkCmdSetDescriptorBufferOffsetsEXT中指定绑定的descriptor buffers的descriptors，则（1）如果绑定到pipeline bind point的该命令会使用的VkPipeline以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建，且这些descriptors是动态使用的，则这些descriptors必须是有效的
                                                                                              （2）如果绑定到pipeline bind point的对应stage的该命令会使用的VkShaderEXT，且这些descriptors是动态使用的，则这些descriptors必须是有效的
        25.在vkCmdSetDescriptorBufferOffsetsEXT中指定的descriptors在绑定到pipeline bind point的VkPipeline中使用，则VkPipeline必须以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建
        26.如果一个descriptor在以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建的VkPipeline中动态使用，则descriptor memory必须是驻留内存
        27.如果一个descriptor在以其VkDescriptorSetLayout以VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建的VkShaderEXT中动态使用，则descriptor memory必须是驻留内存
        28.如果shaderObject 特性没有开启，一个有效的pipeline必须绑定到这个命令使用的绑定到pipeline bind point上
        29.如果一个pipeline绑定到该命令使用的pipeline bind point上，则不能有任何动态state 设置命令设置任何该VkPipeline 中没有指定的动态 state
        30.如果一个VkPipeline绑定到该命令使用的pipeline bind point上 或者任何一个会访问一个使用unnormalized coordinates的VkSampler的 VkShaderEXT绑定到该命令使用的pipeline bind point上的pipeline的对应stage，则
                                                                                    （1）在任何shader stage中，VkSampler不能用来采样任何类型为VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY 或者 VK_IMAGE_VIEW_TYPE_CUBE_ARRAY的VkImageView
                                                                                    （2）在任何shader stage中，该VkSampler不能和任何带有名字中带有ImplicitLod，Dref 或者 Proj 的SPIR-V OpImageSample* 或者 OpImageSparseSample*指令一起使用
                                                                                    （3）在任何shader stage中，该VkSampler不能和任何包含 LOD bias或者offset 值 的SPIR-V OpImageSample* or OpImageSparseSample*指令一起使用
        31.如果shaderObject开启，一个有效的pipeline必须绑定到该命令使用的pipeline bind point上或者一个有效的shader objects以及VK_NULL_HANDLE的组合必须绑定到该命令使用的pipeline bind point每一个支持的shader stage上
        32.如何绑定到该命令使用的pipeline bind point上的VkPipeline的任何stage会访问一个uniform buffer，且该stage对uniformBuffers不以启用VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT或者VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT 创建，且robustBufferAccess特性未开启，则该stage就不能访问绑定到相同pipeline bind point的descriptor set指定的buffer范围外的值
        33.如果robustBufferAccess特性未开启，且任何会访问uniform buffer的绑定到该命令使用的pipeline bind point上对应shader stage的VkShaderEXT，则其不能访问绑定到相同pipeline bind point的descriptor set指定的buffer范围外的值
        34.如何绑定到该命令使用的pipeline bind point上的VkPipeline的任何stage会访问一个storage buffer，且该stage对storageBuffers不以启用VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT或者VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT 创建，且robustBufferAccess特性未开启，则该stage就不能访问绑定到相同pipeline bind point的descriptor set指定的buffer范围外的值
        35.如果robustBufferAccess特性未开启，且任何会访问storage buffer的绑定到该命令使用的pipeline bind point上对应shader stage的VkShaderEXT，则其不能访问绑定到相同pipeline bind point的descriptor set指定的buffer范围外的值
        36.如果commandBuffer 是一个unprotected command buffer，且protectedNoFault 未支持，则任何绑定的shaders访问的资源不能是一个protected resource
        37.如果一个绑定的shader访问一个VkSampler 或者 VkImageView ，且启用了sampler Y′C BCR conversion，则只能使用OpImageSample* 或者 OpImageSparseSample*指令，不能使用ConstOffset 以及 Offset操作符
        38.如果一个VkImageView作为该命令的结果进行访问，则（1）image view 的viewType 必须匹配Instruction/Sampler/Image View Validation p1481中描述的OpTypeImage的Dim操作符
                                                          （2）image view 的foamrt的numeric type 必须匹配OpTypeImage的Sampled Type操作符
        39.如果一个VkImageView以一个不是VK_FORMAT_A8_UNORM_KHR的format创建且通过OpImageWrite作为该命令的结果进行访问，则该命令的Texel 操作符的Type必须至少包含和 image view的 format含有的components的个数相同的components个数
        40.如果一个VkImageView以VK_FORMAT_A8_UNORM_KHR的format创建且通过OpImageWrite作为该命令的结果进行访问，则该命令的Texel 操作符的Type必须包含4个components
        41.如果一个VkBufferView通过OpImageWrite作为该命令的结果进行访问，则该命令的Texel 操作符的Type必须至少包含和 buffer view的 format含有的components的个数相同的components个数
        42.如果一个带64-bit component的VkFormat的VkImageView作为该命令的结果进行访问，则该命令的OpTypeImage操作符的SampledType的宽度必须为64
        43.如果一个带少于64-bit component的VkFormat的VkImageView作为该命令的结果进行访问，则该命令的OpTypeImage操作符的SampledType的宽度必须为32
        44.如果一个带64-bit component的VkFormat的VkBufferView作为该命令的结果进行访问，则该命令的OpTypeImage操作符的SampledType的宽度必须为64位
        45.如果一个带少于64-bit component的VkFormat的VkBufferView作为该命令的结果进行访问，则该命令的OpTypeImage操作符的SampledType的宽度必须为32
        46.如果sparseImageInt64Atomics 特性未开启，则以VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT创建的VkImage对象不能被SampledType宽度为64位的OpTypeImage的atomic instructions访问
        47.如果sparseImageInt64Atomics 特性未开启，则以VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT创建的VkBuffer对象不能被SampledType宽度为64位的OpTypeImage的atomic instructions访问
        48.如果OpImageWeightedSampleQCOM用来采样一个作为该命令的结果的VkImageView，则该image view的format features必须包含VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM
        49.如果OpImageWeightedSampleQCOM用来采样一个作为该命令的结果的sample weight image的VkImageView，则该image view的format features必须包含VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM
        50.如果OpImageBoxFilterQCOM用来采样一个作为该命令的结果的VkImageView，则该image view的format features必须包含VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM
        51.如果OpImageBlockMatchSSDQCOM，或者 OpImageBlockMatchSADQCOM用来读取一个作为该命令的结果的VkImageView，则（1）该image view的format features必须包含VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM
                                                                                                                   （2）如果是读取的reference image，指定的reference coordinates不能在integer texel coordinate validation 时候失败
        52.如果OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchWindowSSDQCOM, OpImageBlockMatchWindowSADQCOM, OpImageBlockMatchGatherSSDQCOM,
                                                    OpImageBlockMatchGatherSADQCOM, OpImageBlockMatchSSDQCOM, 或者 OpImageBlockMatchSADQCOM用来采样一个作为该命令的结果的VkImageView，则该VkSampler必须以VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM创建
        53.如果任何除了OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchWindowSSDQCOM, OpImageBlockMatchWindowSADQCOM, OpImageBlockMatchGatherSSDQCOM, OpImageBlockMatchGatherSADQCOM, OpImageBlockMatchSSDQCOM, 或者 OpImageBlockMatchSADQCOM之外的指令使用VkSampler进行采样作为该命令的结果，则该sampler不能以VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM 创建
        54.如果OpImageBlockMatchWindow*QCOM or OpImageBlockMatchGather*QCOM指令用来读取VkImageView作为该命令的结果，则（1）VkImageView的format features必须包含VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM
                                                                                                                      （2）VkImageView的format必须只含有一个component
        55.如果OpImageBlockMatchWindow*QCOM or OpImageBlockMatchGather*QCOM指令用来读取一个引用的image作为该命令的结果，则指定的 reference coordinates不能在integer texel coordinate validation 时候失败
        56.任何该命令执行的shader invocation必须已经终止
        57.如果有一个类型位为VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM, VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, 或者 VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT中任意一个的descriptor作为该命令的结果进行访问，则该descriptor所指的image subresource的layout必须和该descriptor被写入时的layout相同。
        58.当前的 render pass  必须和绑定到VK_PIPELINE_BIND_POINT_GRAPHICS上的VkPipeline 创建时候的VkGraphicsPipelineCreateInfo中指定的renderPass兼容
        59.当前的 render pass  的subpass index必须和绑定到VK_PIPELINE_BIND_POINT_GRAPHICS上的VkPipeline 创建时候的VkGraphicsPipelineCreateInfo中指定的subpass相同
        60.如果任何shader静态访问一个input attachment，则有效的descriptor必须通过VkDescriptorSet被绑定到该pipeline中
        61.如果任何该pipeline执行shader以SubpassData的Dim操作符访问一个OpTypeImage变量，则该变量必须被一个对应当前subpass的input attachment的InputAttachmentIndex修饰
        62.在subpass中访问的Input attachment views必须以和该subpass相同定义的VkFormat创建，且必须以一个和当前绑定的VkFramebuffer的该附件引用的subpass的pInputAttachments[InputAttachmentIndex]附件兼容的VkImageView创建，参见Fragment Input Attachment Compatibility p1408
        63.在动态render pass中访问以VkRenderingInputAttachmentIndexInfoKHR的InputAttachmentIndex，或者VkRenderingInputAttachmentIndexInfoKHR:pDepthInputAttachmentIndex 或者 VkRenderingInputAttachmentIndexInfoKHR:pStencilInputAttachmentIndex为NULL情况下不指定InputAttachmentIndex的引用的Input attachment views，必须以和VkRenderingInfo中对应color, depth, 或者 stencil attachment兼容的VkImageView创建
        64.如果VkRenderingInputAttachmentIndexInfoKHR::pDepthInputAttachmentIndex 以及 VkRenderingInputAttachmentIndexInfoKHR::pStencilInputAttachmentIndex不为NULL，则在动态render pass中通过shader object访问Input attachment views必须指明InputAttachmentIndex
        65.如果在动态render pass中通过shader object访问Input attachment views指明了InputAttachmentIndex，则InputAttachmentIndex必须匹配VkRenderingInputAttachmentIndexInfoKHR中的index
        66.当前render pass所用的附件对应的image subresource底层内存的写入只能作为该命令的一个附件写入
        67.如果一个color attachment在之前的该subpass的命令中以load, store, 或者 resolve operations进行了写入，则其layout不为VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT，且有当前绑定的pipeline设有VK_PIPELINE_CREATE_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT，或者
                                        最后的vkCmdSetAttachmentFeedbackLoopEnableEXT调用包含VK_IMAGE_ASPECT_COLOR_BIT以及 没有绑定的pipeline 或者绑定的pipeline以VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT创建，则该附件只能以附件进行访问的，这两种情况中之一
        68.如果一个depth attachment在之前的该subpass的命令中以load, store, 或者 resolve operations进行了写入，则其layout不为VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT，且有当前绑定的pipeline设有VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT，或者
                                        最后的vkCmdSetAttachmentFeedbackLoopEnableEXT调用包含VK_IMAGE_ASPECT_DEPTH_BIT以及 没有绑定的pipeline 或者绑定的pipeline以VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT创建，则该附件只能以附件进行访问的，这两种情况中之一
        69.如果一个stencil attachment在之前的该subpass的命令中以load, store, 或者 resolve operations进行了写入，则其layout不为VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT，且有当前绑定的pipeline设有VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT，或者
                                        最后的vkCmdSetAttachmentFeedbackLoopEnableEXT调用包含VK_IMAGE_ASPECT_STENCIL_BIT以及 没有绑定的pipeline 或者绑定的pipeline以VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT创建，则该附件只能以附件进行访问的，这两种情况中之一
        70.如果一个attachment在之前的该subpass的命令中以load, store, 或者 resolve operations进行了写入,则该附件就不能再以除作为一个附件，storage image或者sampled image被该命令访问
        71.如果在之前的命令的subpass中以用作附件外的方式访问访问了一个当权subpass的附件所对的image subresource，则该命令就不能再将该image subresource用作附件进行写入
        72.如果当前render pass使用一个depth/stencil attachment，则（1）如果depth aspect的layout为read-only的layout，则不能启用depth writes
                                                                  （2）如果stencil aspect的layout为read-only的layout，front 以及 back writeMask不为0，且stencil 测试开启，则所有stencil 操作必须为VK_STENCIL_OP_KEEP
        73.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_VIEWPORT动态state开启创建，则vkCmdSetViewport必须在该命令之前设置
                                        （2）以VK_DYNAMIC_STATE_SCISSOR动态state开启创建，则vkCmdSetScissor必须在该命令之前设置
                                        （3）以VK_DYNAMIC_STATE_LINE_WIDTH动态state开启创建，则vkCmdSetLineWidth必须在该命令之前设置
                                        （4）以VK_DYNAMIC_STATE_DEPTH_BIAS动态state开启创建，则vkCmdSetDepthBias或者vkCmdSetDepthBias2EXT 必须在该命令之前设置
                                        （5）以VK_DYNAMIC_STATE_BLEND_CONSTANTS动态state开启创建，则vkCmdSetBlendConstants 必须在该命令之前设置
                                        （6）以VK_DYNAMIC_STATE_DEPTH_BOUNDS动态state开启创建，且如果当前depthBoundsTestEnable为VK_TRUE， 则vkCmdSetDepthBounds 必须在该命令之前设置
                                        （7）以VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK动态state开启创建，且如果当前stencilTestEnable为VK_TRUE， 则vkCmdSetStencilCompareMask 必须在该命令之前设置
                                        （8）以VK_DYNAMIC_STATE_STENCIL_WRITE_MASK动态state开启创建，且如果当前stencilTestEnable为VK_TRUE， 则vkCmdSetStencilWriteMask 必须在该命令之前设置
                                        （9）以VK_DYNAMIC_STATE_STENCIL_REFERENCE动态state开启创建，且如果当前stencilTestEnable为VK_TRUE， 则vkCmdSetStencilReference 必须在该命令之前设置
                                        （10）以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT动态state开启创建， 则vkCmdSetSampleLocationsEXT 必须在该命令之前设置
                                        （11）以VK_DYNAMIC_STATE_CULL_MODE动态state开启创建， 则vkCmdSetCullMode 必须在该命令之前设置
                                        （12）以VK_DYNAMIC_STATE_FRONT_FACE动态state开启创建， 则vkCmdSetFrontFace 必须在该命令之前设置
                                        （13）以VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE动态state开启创建， 则vkCmdSetDepthTestEnable 必须在该命令之前设置
                                        （14）以VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE动态state开启创建， 则vkCmdSetDepthWriteEnable 必须在该命令之前设置
                                        （15）以VK_DYNAMIC_STATE_DEPTH_COMPARE_OP动态state开启创建， 则vkCmdSetDepthCompareOp 必须在该命令之前设置
                                        （16）以VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE动态state开启创建， 则vkCmdSetDepthBoundsTestEnable 必须在该命令之前设置
                                        （17）以VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE动态state开启创建， 则vkCmdSetStencilTestEnable 必须在该命令之前设置
                                        （18）以VK_DYNAMIC_STATE_STENCIL_OP动态state开启创建， 则vkCmdSetStencilOp 必须在该命令之前设置
                                        （19）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT但不以VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT 动态state开启创建， 则vkCmdSetViewportWithCount 必须在该命令之前设置，且vkCmdSetViewportWithCount设置的viewportCount必须匹配pipeline的VkPipelineViewportStateCreateInfo::scissorCount
                                        （20）以VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT但不以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT 动态state开启创建， 则vkCmdSetScissorWithCount 必须在该命令之前设置，且vkCmdSetScissorWithCount设置的scissorCount必须匹配pipeline的VkPipelineViewportStateCreateInfo::viewportCount
                                        （21）以VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT和VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT 动态state同时开启创建， 则vkCmdSetViewportWithCount以及vkCmdSetScissorWithCount 必须在该命令之前设置，且vkCmdSetViewportWithCount设置的viewportCount必须匹配vkCmdSetScissorWithCount设置的scissorCount
                                        （22）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT但不以VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV 动态state开启创建， 则绑定的pipeline必须以VkPipelineViewportWScalingStateCreateInfoNV::viewportCount 大于等于最近vkCmdSetViewportWithCount设置的viewportCount创建
                                        （23）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT和VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV 动态state开启创建， 则最近调用的vkCmdSetViewportWScalingNV设置的viewportCount 必须大于等于最近vkCmdSetViewportWithCount设置的viewportCount
                                        （24）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT但不以VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV 动态state开启创建， 则绑定的pipeline必须以VkPipelineViewportShadingRateImageStateCreateInfoNV::viewportCount 大于等于最近vkCmdSetViewportWithCount设置的viewportCount创建
                                        （25）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT和VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV 动态state开启创建， 则最近调用的vkCmdSetViewportShadingRatePaletteNV设置的viewportCount 必须大于等于最近vkCmdSetViewportWithCount设置的viewportCount
                                        （26）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT动态state开启且VkPipelineViewportStateCreateInfo的pNext中含有一个VkPipelineViewportSwizzleStateCreateInfoNV 创建， 则绑定的pipeline必须以VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount 大于等于最近vkCmdSetViewportWithCount设置的viewportCount创建
                                        （27）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT动态state开启且VkPipelineViewportStateCreateInfo的pNext中含有一个VkPipelineViewportExclusiveScissorStateCreateInfoNV 创建， 则绑定的pipeline必须以VkPipelineViewportExclusiveScissorStateCreateInfoNV::exclusiveScissorCount 大于等于最近vkCmdSetViewportWithCount设置的viewportCount创建
                                        （28）以VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_ENABLE_NV动态state开启创建， 则vkCmdSetExclusiveScissorEnableNV 必须在该命令之前设置
                                        （29）以VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV动态state开启创建， 则vkCmdSetExclusiveScissorNV 必须在该命令之前设置
                                        （30）以VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE动态state开启创建， 则vkCmdSetRasterizerDiscardEnable 必须在该命令之前设置
                                        （31）以VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE动态state开启创建， 则vkCmdSetDepthBiasEnable 必须在该命令之前设置
                                        （32）以VK_DYNAMIC_STATE_LOGIC_OP_EXT动态state开启创建， 则vkCmdSetLogicOpEXT 必须在该命令之前设置且参数logicOp必须是一个有效的VkLogicOp值
        74.如果一个shader object绑定到任何graphics stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                        （1）如果最靠近当前命令的vkCmdSetPolygonModeEXT设置polygonMode为VK_POLYGON_MODE_LINE或者是任何line topology，则vkCmdSetLineWidth必须在该命令之前设置
                                        （2）如果最靠近当前命令的vkCmdSetDepthBiasEnable设置depthBiasEnable为VK_TRUE，则vkCmdSetDepthBias 或者 vkCmdSetDepthBias2EXT必须在该命令之前设置
                                        （3）如果最靠近当前命令的vkCmdSetDepthBoundsTestEnable设置depthBoundsTestEnable为VK_TRUE，则vkCmdSetDepthBounds必须在该命令之前设置
                                        （4）如果最靠近当前命令的vkCmdSetStencilTestEnable设置stencilTestEnable为VK_TRUE，则vkCmdSetStencilCompareMask必须在该命令之前设置
                                        （5）如果最靠近当前命令的vkCmdSetStencilTestEnable设置stencilTestEnable为VK_TRUE，则vkCmdSetStencilWriteMask必须在该命令之前设置
                                        （6）如果最靠近当前命令的vkCmdSetStencilTestEnable设置stencilTestEnable为VK_TRUE，则vkCmdSetStencilReference必须在该命令之前设置
                                        （7）如果最靠近当前命令的vkCmdSetSampleLocationsEnableEXT设置sampleLocationsEnable为VK_TRUE，则vkCmdSetSampleLocationsEXT必须在该命令之前设置
                                        （8）则vkCmdSetCullMode必须在该命令之前设置
                                        （9）则vkCmdSetFrontFace必须在该命令之前设置
                                        （10）则vkCmdSetDepthTestEnable 必须在该命令之前设置
                                        （11）则vkCmdSetDepthWriteEnable 必须在该命令之前设置
                                        （12）如果最靠近当前命令的vkCmdSetDepthTestEnable设置depthTestEnable为VK_TRUE，则vkCmdSetDepthCompareOp 必须在该命令之前设置
                                        （13）则vkCmdSetDepthBoundsTestEnable 必须在该命令之前设置
                                        （14）则vkCmdSetStencilTestEnable 必须在该命令之前设置
                                        （15）如果最靠近当前命令的vkCmdSetStencilTestEnable设置stencilTestEnable为VK_TRUE，则vkCmdSetStencilOp 必须在该命令之前设置
                                        （16）
                                        （17）如果shadingRateImage特性开启，则vkCmdSetCoarseSampleOrderNV 必须在该命令之前设置
                                        （18）如果shadingRateImage特性开启，且最靠近当前命令的vkCmdSetShadingRateImageEnableNV设置shadingRateImageEnable为VK_TRUE，则vkCmdSetViewportShadingRatePaletteNV 必须在该命令之前设置
                                        （19）如果shadingRateImage特性开启，且最靠近当前命令的vkCmdSetShadingRateImageEnableNV设置shadingRateImageEnable为VK_TRUE，则最近的vkCmdSetViewportShadingRatePaletteNV设置的viewportCount 必须大于等于vkCmdSetViewportWithCount设置的viewportCount
                                        （20）则vkCmdSetDepthBiasEnable必须在该命令之前设置
        75.如果一个输出line primitives的shader object绑定到VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或者 VK_SHADER_STAGE_GEOMETRY_BIT，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则vkCmdSetLineWidth必须在该命令之前设置
        76.如果一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最靠近当前命令的vkCmdSetColorBlendEnableEXT设置pColorBlendEnables任何元素为VK_TRUE，且
                            最靠近当前命令的vkCmdSetColorBlendEquationEXT设置pColorBlendEquations相同元素的VkColorBlendEquationEXT的VkBlendFactor成员为VK_BLEND_FACTOR_CONSTANT_COLOR, VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR, VK_BLEND_FACTOR_CONSTANT_ALPHA, 或者 VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA，则vkCmdSetBlendConstants必须在该命令之前设置
        77.如果该命令记录在开启了multiview的render pass instance中，则最大的instance 索引必须小于等于VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex
        78.如果绑定的graphics pipeline以VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable设置为VK_TRUE创建且当前的subpass含有一个 depth/stencil attachment，则该attachment必须以VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT创建
        >>78.5  .如果一个shader object绑定到任何graphics stage，则（1）vkCmdSetViewportWithCount 和vkCmdSetScissorWithCount 必须同时在该命令之前设置，且vkCmdSetViewportWithCount设置的viewportCount必须匹配vkCmdSetScissorWithCount设置的scissorCount
                                                                  （2）则vkCmdSetRasterizerDiscardEnable 必须在该命令之前设置
        79.如果VK_NV_clip_space_w_scaling拓展开启，且shader object绑定到任何graphics stage，且最近的vkCmdSetViewportWScalingEnableNV设置viewportWScalingEnable为VK_TRUE，则（1）vkCmdSetViewportWScalingNV必须在该命令前设置
                                                                                                                                                                           （2）最近vkCmdSetViewportWScalingNV设置的viewportCount必须大于等于vkCmdSetViewportWithCount设置的viewportCount
        80.如果exclusiveScissor 特性开启，且shader object绑定到任何graphics stage，，则（1）vkCmdSetExclusiveScissorEnableNV必须在该命令前设置
                                                                                       （2）最近的vkCmdSetExclusiveScissorEnableNV调用设置的pExclusiveScissorEnables中的任何元素为VK_TRUE,则vkCmdSetExclusiveScissorNV必须在该命令前设置
        81.如果一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最靠近当前命令的vkCmdSetLogicOpEnableEXT设置logicOpEnable任何元素为VK_TRUE，则vkCmdSetLogicOpEXT 必须在该命令之前设置且参数logicOp必须是一个有效的VkLogicOp值
        82.如果primitiveFragmentShadingRateWithMultipleViewports限制不支持，则（1）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT动态state开启创建，且任何该pipeline的shader stage会写入PrimitiveShadingRateKHR built-in修饰的变量，则vkCmdSetViewportWithCount 必须在该命令之前设置且参数viewportCount必须是1
                                                                              （2）任何绑定的graphics pipeline的shader stage会写入PrimitiveShadingRateKHR built-in修饰的变量，则vkCmdSetViewportWithCount 必须在该命令之前设置且参数viewportCount必须是1
        83.如果graphics pipeline中未开启rasterization，则对subpass中的每个color attachment，如果其对应的image view 的format features不包含VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT，则pColorBlendState中其对应pAttachments中元素的blendEnable必须为VK_FALSE
        84.如果一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则对于render pass中的每个color attachment，如果其对应的image view 的format features不包含VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT， 则最近的vkCmdSetColorBlendEnableEXT设置的pColorBlendEnables中该附件的对应元素必须为VK_FALSE
        85.如果graphics pipeline中未开启rasterization，有VK_AMD_mixed_attachment_samples拓展未开启，VK_NV_framebuffer_mixed_samples拓展未开启，multisampledRenderToSingleSampled特性未开启，则当前绑定的pipeline的rasterizationSamples必须和当前subpass的color 以及/或者 depth/stencil attachments的相同
        86.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且有VK_AMD_mixed_attachment_samples拓展未开启，VK_NV_framebuffer_mixed_samples拓展未开启，multisampledRenderToSingleSampled特性未开启，则最近vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples必须和当前subpass的color 以及/或者 depth/stencil attachments的相同
        87.如果一个shader object绑定到任何graphics stage，则当前的render pass instance必须以vkCmdBeginRendering开始
        88.如果当前的render pass instance以vkCmdBeginRendering开始，（1）如果pDepthAttachment的imageView不为VK_NULL_HANDLE，且pDepthAttachment的layout不为VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL，则该命令不能写入任何值到depth attachment
                                                                    （2）如果pStencilAttachment的imageView不为VK_NULL_HANDLE，且pStencilAttachment的layout不为VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL，则该命令不能写入任何值到stencil attachment
                                                                    （3）如果pDepthAttachment的imageView不为VK_NULL_HANDLE，且pDepthAttachment的layout为VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL，则该命令不能写入任何值到depth attachment
                                                                    （4）如果pStencilAttachment的imageView不为VK_NULL_HANDLE，且pStencilAttachment的layout为VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL，则该命令不能写入任何值到stencil attachment
                                                                    （5）如果pDepthAttachment的imageView不为VK_NULL_HANDLE，且pDepthAttachment的layout为VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL，则该命令不能写入任何值到depth attachment
                                                                    （6）如果pStencilAttachment的imageView不为VK_NULL_HANDLE，且pStencilAttachment的layout为VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL，则该命令不能写入任何值到stencil attachment
                                                                    （7）则当前绑定的graphics pipeline必须以含VkPipelineRenderingCreateInfo::viewMask等于VkRenderingInfo::viewMask创建
                                                                    （8）如果带有VkRenderingInfo::colorAttachmentCount为1，则没有shader object绑定到任何graphics stage，且一个color attachment的 resolve mode为VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID，则VkRenderingInfo::pColorAttachments中每个resolveImageView不为VK_NULL_HANDLE的元素其对应image必须以和创建当前绑定的pipeline 相同的VkExternalFormatANDROID::externalFormat创建
                                                                    （9）如果没有shader object绑定到任何graphics stage，如果绑定的graphics pipeline以一个非零值VkExternalFormatANDROID::externalFormat创建且启用VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态设置，则vkCmdSetColorBlendEnableEXT必须在该命令前设置blend enable为VK_FALSE
                                                                    （10）如果没有shader object绑定到任何graphics stage，如果绑定的graphics pipeline以一个非零值VkExternalFormatANDROID::externalFormat创建且启用VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态设置，则vkCmdSetRasterizationSamplesEXT必须在该命令前设置rasterizationSamples为VK_SAMPLE_COUNT_1_BIT
                                                                    （11）如果没有shader object绑定到任何graphics stage，如果绑定的graphics pipeline以一个非零值VkExternalFormatANDROID::externalFormat创建且启用VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR动态设置，则vkCmdSetFragmentShadingRateKHR必须在该命令前设置pFragmentSize->width为1，pFragmentSize->height为1
        89.如果dynamicRenderingUnusedAttachments特性未开启，且当前的render pass instance以vkCmdBeginRendering开始，则
                                                                （1）当前绑定的graphics pipeline必须以含VkPipelineRenderingCreateInfo::colorAttachmentCount等于VkRenderingInfo::colorAttachmentCount创建
                                                                （2）如果VkRenderingInfo::colorAttachmentCount大于0，则VkRenderingInfo::pColorAttachments 中每一个其imageView不为VK_NULL_HANDLE的元素的VkImageView必须以VkFormat对应绑定的graphics pipeline的VkPipelineRenderingCreateInfo::pColorAttachmentFormats指明的format创建
                                                                （3）如果VkRenderingInfo::colorAttachmentCount大于0，则VkRenderingInfo::pColorAttachments 中每一个其imageView为VK_NULL_HANDLE的元素对应绑定的graphics pipeline的VkPipelineRenderingCreateInfo::pColorAttachmentFormats指明的format必须为VK_FORMAT_UNDEFINED
                                                                （4）如果VkRenderingInfo::pDepthAttachment->imageView为VK_NULL_HANDLE，则创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::depthAttachmentFormat必须为VK_FORMAT_UNDEFINED
                                                                （5）如果VkRenderingInfo::pDepthAttachment->imageView不为VK_NULL_HANDLE，则创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::depthAttachmentFormat必须和创建VkRenderingInfo::pDepthAttachment->imageView的VkFormat相同
                                                                （6）如果VkRenderingInfo::pStencilAttachment->imageView为VK_NULL_HANDLE，则创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::stencilAttachmentFormat必须为VK_FORMAT_UNDEFINED
                                                                （7）如果VkRenderingInfo::pStencilAttachment->imageView不为VK_NULL_HANDLE，则创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::stencilAttachmentFormat必须和创建VkRenderingInfo::pStencilAttachment->imageView的VkFormat相同
        90.如果dynamicRenderingUnusedAttachments特性开启，且当前的render pass instance以vkCmdBeginRendering开始，则
                                                                （1）如果VkRenderingInfo::colorAttachmentCount大于0，则VkRenderingInfo::pColorAttachments 中每一个其imageView不为VK_NULL_HANDLE的元素的VkImageView必须以VkFormat对应绑定的graphics pipeline的VkPipelineRenderingCreateInfo::pColorAttachmentFormats指明的format创建，或者是对应元素为VK_FORMAT_UNDEFINED创建
                                                                （2）如果VkRenderingInfo::pDepthAttachment->imageView不为VK_NULL_HANDLE，且创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::depthAttachmentFormat和创建VkRenderingInfo::pDepthAttachment->imageView的VkFormat不同，则该format必须为VK_FORMAT_UNDEFINED
                                                                （3）如果VkRenderingInfo::pStencilAttachment->imageView不为VK_NULL_HANDLE，且创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::stencilAttachmentFormat和创建VkRenderingInfo::pStencilAttachment->imageView的VkFormat不同，则该format必须为VK_FORMAT_UNDEFINED
        91.如果没有shader object绑定到任何graphics stage，且当前的render pass instance以vkCmdBeginRendering开始且VkRenderingInfo::colorAttachmentCount为1，且一个color attachment的 resolve mode为VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID，则VkRenderingInfo::pColorAttachments中每个resolveImageView不为VK_NULL_HANDLE的元素其对应image必须以和创建当前绑定的pipeline 相同的VkExternalFormatANDROID::externalFormat创建
        92.如果有一个shader object绑定到任何graphics stage，且当前的render pass 包含一个使用VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID resolve mode的color attachment，则（1）vkCmdSetColorBlendEnableEXT必须在该命令前设置blend enable为VK_FALSE
                                                                                                                                                                                 （2）则vkCmdSetRasterizationSamplesEXT必须在该命令前设置rasterizationSamples为VK_SAMPLE_COUNT_1_BIT
                                                                                                                                                                                 （3）则vkCmdSetFragmentShadingRateKHR必须在该命令前设置pFragmentSize->width为1，pFragmentSize->height为1
        93.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT动态state开启创建， 则vkCmdSetColorWriteEnableEXT 必须在该命令之前设置，且设置的attachmentCount必须大于等于创建当前绑定的pipeline的VkPipelineColorBlendStateCreateInfo::attachmentCount
                                        （2）以VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT动态state开启创建， 则vkCmdSetDiscardRectangleEXT 必须在该命令之前为每个VkPipelineDiscardRectangleStateCreateInfoEXT::discardRectangleCount指明的discard rectangle 设置
                                        （3）以VK_DYNAMIC_STATE_DISCARD_RECTANGLE_ENABLE_EXT动态state开启创建， 则vkCmdSetDiscardRectangleEnableEXT 必须在该命令之前设置
                                        （4）以VK_DYNAMIC_STATE_DISCARD_RECTANGLE_MODE_EXT动态state开启创建， 则vkCmdSetDiscardRectangleModeEXT 必须在该命令之前设置
        94.如果有一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                        （1）如果colorWriteEnable特性在device上开启，则vkCmdSetColorWriteEnableEXT 必须在该命令之前设置，且设置的attachmentCount必须大于等于当前render pass instance的color attachment的数量
                                        （2）如果VK_EXT_discard_rectangles拓展开启，且最近的vkCmdSetDiscardRectangleEnableEXT设置discardRectangleEnable为VK_TRUE， 则vkCmdSetDiscardRectangleEXT 必须在该命令之前设置
                                        （3）如果VK_EXT_discard_rectangles拓展开启， 则vkCmdSetDiscardRectangleEnableEXT 必须在该命令之前设置
                                        （4）如果VK_EXT_discard_rectangles拓展开启， 则最近的vkCmdSetDiscardRectangleEnableEXT设置discardRectangleEnable为VK_TRUE，则vkCmdSetDiscardRectangleModeEXT 必须在该命令之前设置
        95.如果当前的render pass instance以vkCmdBeginRendering开始，则（1）如果VkRenderingFragmentShadingRateAttachmentInfoKHR::imageView不为VK_NULL_HANDLE，则当前绑定的graphics pipeline必须以VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR创建
                                                                      （2）如果VkRenderingFragmentDensityMapAttachmentInfoEXT::imageView不为VK_NULL_HANDLE，则当前绑定的graphics pipeline必须以VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT创建
                                                                      （3）且含VkRenderingInfo::colorAttachmentCount大于0，如果当前的绑定的pipeline以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，则VkRenderingInfo::pColorAttachments中每个imageView不为VK_NULL_HANDLE的元素的imageView，必须以当前pipeline的VkAttachmentSampleCountInfoAMD 或者 VkAttachmentSampleCountInfoNV中的pColorAttachmentSamples中对应元素的sample count进行创建
                                                                      （4）如果当前的绑定的pipeline以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且VkRenderingInfo::pDepthAttachment中的imageView不为VK_NULL_HANDLE，则当前pipeline的VkAttachmentSampleCountInfoAMD 或者 VkAttachmentSampleCountInfoNV中的depthStencilAttachmentSamples必须等于创建VkRenderingInfo::pDepthAttachment->imageView的sample count
                                                                      （5）如果当前的绑定的pipeline以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且VkRenderingInfo::pStencilAttachment中的imageView不为VK_NULL_HANDLE，则当前pipeline的VkAttachmentSampleCountInfoAMD 或者 VkAttachmentSampleCountInfoNV中的depthStencilAttachmentSamples必须等于创建VkRenderingInfo::pStencilAttachment->imageView的sample count
                                                                      （6）且含VkRenderingInfo::colorAttachmentCount大于0，如果当前的绑定的pipeline不以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且multisampledRenderToSingleSampled特性没有开启，则VkRenderingInfo::pColorAttachments中每个imageView不为VK_NULL_HANDLE的元素的imageView，其创建的sample count必须等于当前绑定的graphics pipeline的rasterizationSamples
                                                                      （7）如果当前的绑定的pipeline不以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且VkRenderingInfo::pDepthAttachment中的imageView不为VK_NULL_HANDLE，且multisampledRenderToSingleSampled特性没有开启，则当前pipeline的rasterizationSamples 必须等于创建VkRenderingInfo::pDepthAttachment->imageView的sample count
                                                                      （8）如果当前的绑定的pipeline不以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且VkRenderingInfo::pStencilAttachment中的imageView不为VK_NULL_HANDLE，且multisampledRenderToSingleSampled特性没有开启，则当前pipeline的rasterizationSamples 必须等于创建VkRenderingInfo::pStencilAttachment->imageView的sample count
                                                                      （9）当前绑定的pipeline必须VkGraphicsPipelineCreateInfo::renderPass为VK_NULL_HANDLE创建
                                                                      （10）如果绑定的pipeline的fragment shader静态写入一个color attachment，且color write mask不为0，启用了color writes，且该附件对应的VkRenderingInfo::pColorAttachments->imageView 不为VK_NULL_HANDLE，则对应的创建pipeline的VkPipelineRenderingCreateInfo::pColorAttachmentFormats中的元素不能为VK_FORMAT_UNDEFINED
                                                                      （11）如果绑定的pipeline启用了depth test，启用了depth writes，且VkRenderingInfo::pDepthAttachment->imageView 不为VK_NULL_HANDLE，则创建pipeline的VkPipelineRenderingCreateInfo::depthAttachmentFormat不能为VK_FORMAT_UNDEFINED
                                                                      （12）如果绑定的pipeline启用了stencil test，且VkRenderingInfo::pStencilAttachment->imageView 不为VK_NULL_HANDLE，则创建pipeline的VkPipelineRenderingCreateInfo::stencilAttachmentFormat不能为VK_FORMAT_UNDEFINED
        96.如果该命令在以vkCmdBeginRendering开始的render pass instance中调用，且VkRenderingInfo的pNext中包含一个multisampledRenderToSingleSampledEnable设为VK_TRUE的VkMultisampledRenderToSingleSampledInfoEXT，则当前绑定的graphics pipeline的rasterizationSamples必须等于VkMultisampledRenderToSingleSampledInfoEXT::rasterizationSamples
        97.如果primitivesGeneratedQueryWithRasterizerDiscard特性未开启，且VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query激活，则不能启用rasterization discard
        98.如果primitivesGeneratedQueryWithNonZeroStreams特性未开启，且VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query激活，则 绑定的graphics pipeline不能以VkPipelineRasterizationStateStreamCreateInfoEXT::rasterizationStream为非零值创建
        98.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_TESSELLATION_DOMAIN_ORIGIN_EXT动态state开启创建，则vkCmdSetTessellationDomainOriginEXT必须在该命令之前设置
                                        （2）以VK_DYNAMIC_STATE_DEPTH_CLAMP_ENABLE_EXT动态state开启创建，则vkCmdSetDepthClampEnableEXT必须在该命令之前设置
                                        （3）以VK_DYNAMIC_STATE_POLYGON_MODE_EXT动态state开启创建，则vkCmdSetPolygonModeEXT必须在该命令之前设置
                                        （4）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，则vkCmdSetRasterizationSamplesEXT必须在该命令之前设置
                                        （5）以VK_DYNAMIC_STATE_SAMPLE_MASK_EXT动态state开启创建，则vkCmdSetSampleMaskEXT必须在该命令之前设置
                                        （6）以VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT动态state开启创建，则vkCmdSetAlphaToCoverageEnableEXT必须在该命令之前设置
                                        （7）以VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT动态state开启创建，则最近的vkCmdSetAlphaToCoverageEnableEXT设置alphaToCoverageEnable为VK_TRUE，则Fragment Output Interface中 Index 0的Location 0必须有一个含alpha Component的变量
                                        （8）以VK_DYNAMIC_STATE_ALPHA_TO_ONE_ENABLE_EXT动态state开启创建，则vkCmdSetAlphaToOneEnableEXT必须在该命令之前设置
                                        （9）以VK_DYNAMIC_STATE_LOGIC_OP_ENABLE_EXT动态state开启创建，则vkCmdSetLogicOpEnableEXT必须在该命令之前设置
                                        （10）以VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态state开启创建，则vkCmdSetColorBlendEnableEXT必须在该命令之前设置
                                        （11）以VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT动态state开启创建，则vkCmdSetColorBlendEquationEXT必须在该命令之前设置
                                        （12）以VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT动态state开启创建，则vkCmdSetColorWriteMaskEXT必须在该命令之前设置
        
        99.如果一个shader object绑定到VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT stage，则vkCmdSetTessellationDomainOriginEXT必须在该命令之前设置
        100.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                                        （1）如果depthClamp特性启用，则vkCmdSetDepthClampEnableEXT必须在该命令之前设置
                                                        （2）则vkCmdSetPolygonModeEXT必须在该命令之前设置
                                                        （3）则vkCmdSetRasterizationSamplesEXT必须在该命令之前设置
                                                        （4）则vkCmdSetSampleMaskEXT必须在该命令之前设置
                                                        （5）则vkCmdSetAlphaToCoverageEnableEXT必须在该命令之前设置
                                                        （6）如果alphaToOne特性启用，则vkCmdSetAlphaToOneEnableEXT必须在该命令之前设置
        
        101.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetAlphaToCoverageEnableEXT设置alphaToCoverageEnable为VK_TRUE，则Fragment Output Interface中 Index 0的Location 0必须有一个含alpha Component的变量
        102.如果一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                            （1）如果logicOp特性开启 ,vkCmdSetLogicOpEnableEXT必须在该命令之前设置
                                            （2）如果绑定了color attachments，则vkCmdSetColorBlendEnableEXT必须在该命令之前设置
                                            （3）如果最近的vkCmdSetColorBlendEnableEXT设置任何附件在pColorBlendEnables中的值为VK_TRUE ，则vkCmdSetColorBlendEquationEXT必须在该命令之前设置
                                            （4）如果绑定了color attachments，则vkCmdSetColorWriteMaskEXT必须在该命令之前设置
        
        103.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT动态state开启创建，则vkCmdSetRasterizationStreamEXT必须在该命令之前设置
                                         （2）以VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT动态state开启创建，则vkCmdSetConservativeRasterizationModeEXT必须在该命令之前设置
                                         （3）以VK_DYNAMIC_STATE_EXTRA_PRIMITIVE_OVERESTIMATION_SIZE_EXT动态state开启创建，则vkCmdSetExtraPrimitiveOverestimationSizeEXT必须在该命令之前设置
                                         （4）以VK_DYNAMIC_STATE_DEPTH_CLIP_ENABLE_EXT动态state开启创建，则vkCmdSetDepthClipEnableEXT必须在该命令之前设置
                                         （5）以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT动态state开启创建，则vkCmdSetSampleLocationsEnableEXT必须在该命令之前设置
                                         （6）以VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT动态state开启创建，则vkCmdSetColorBlendAdvancedEXT必须在该命令之前设置
                                         （7）以VK_DYNAMIC_STATE_PROVOKING_VERTEX_MODE_EXT动态state开启创建，则vkCmdSetProvokingVertexModeEXT必须在该命令之前设置
                                         （8）以VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT动态state开启创建，则vkCmdSetLineRasterizationModeEXT必须在该命令之前设置
                                         （9）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT动态state开启创建，则vkCmdSetLineStippleEnableEXT必须在该命令之前设置
                                         （10）以VK_DYNAMIC_STATE_LINE_STIPPLE_KHR动态state开启创建，则vkCmdSetLineStippleKHR必须在该命令之前设置
                                         （11）以VK_DYNAMIC_STATE_DEPTH_CLIP_NEGATIVE_ONE_TO_ONE_EXT动态state开启创建，则vkCmdSetDepthClipNegativeOneToOneEXT必须在该命令之前设置
                                         （12）以VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_ENABLE_NV动态state开启创建，则vkCmdSetViewportWScalingEnableNV必须在该命令之前设置
                                         （13）以VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV动态state开启创建，则vkCmdSetViewportSwizzleNV必须在该命令之前设置
                                         （14）以VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV动态state开启创建，则vkCmdSetCoverageToColorEnableNV必须在该命令之前设置
                                         （15）以VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_LOCATION_NV动态state开启创建，则vkCmdSetCoverageToColorLocationNV必须在该命令之前设置
                                         （16）以VK_DYNAMIC_STATE_COVERAGE_MODULATION_MODE_NV动态state开启创建，则vkCmdSetCoverageModulationModeNV必须在该命令之前设置
                                         （17）以VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV动态state开启创建，则vkCmdSetCoverageModulationTableEnableNV必须在该命令之前设置
                                         （18）以VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_NV动态state开启创建，则vkCmdSetCoverageModulationTableNV必须在该命令之前设置
                                         （19）以VK_DYNAMIC_STATE_SHADING_RATE_IMAGE_ENABLE_NV动态state开启创建，则vkCmdSetShadingRateImageEnableNV必须在该命令之前设置
                                         （20）以VK_DYNAMIC_STATE_REPRESENTATIVE_FRAGMENT_TEST_ENABLE_NV动态state开启创建，则vkCmdSetRepresentativeFragmentTestEnableNV必须在该命令之前设置
                                         （21）以VK_DYNAMIC_STATE_COVERAGE_REDUCTION_MODE_NV动态state开启创建，则vkCmdSetCoverageReductionModeNV必须在该命令之前设置
        
        104.如果一个shader object绑定到VK_SHADER_STAGE_GEOMETRY_BIT stage，且如果geometryStreams 特性开启，则vkCmdSetRasterizationStreamEXT必须在该命令之前设置
        105.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                （1）如果VK_EXT_conservative_rasterization 拓展开启，vkCmdSetConservativeRasterizationModeEXT必须在该命令之前设置
                                （2）如果VK_EXT_conservative_rasterization 拓展开启，且最近的vkCmdSetConservativeRasterizationModeEXT设置conservativeRasterizationMode为VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT，则vkCmdSetExtraPrimitiveOverestimationSizeEXT必须在该命令之前设置
                                （3）如果VK_EXT_sample_locations 拓展开启，则vkCmdSetSampleLocationsEnableEXT必须在该命令之前设置
        106.如果一个shader object绑定到任何graphics stage，且depthClipEnable 特性开启，则vkCmdSetDepthClipEnableEXT必须在该命令之前设置
        107.如果如果一个shader object绑定到任何VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且如果VK_EXT_blend_operation_advanced 拓展开启，则vkCmdSetColorBlendEquationEXT 和 vkCmdSetColorBlendAdvancedEXT中至少一个必须在该命令之前设置
        108.如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，如果VK_EXT_provoking_vertex拓展开启， 则vkCmdSetProvokingVertexModeEXT必须在该命令之前设置
        109.如果VK_KHR_line_rasterization 或者 VK_EXT_line_rasterization拓展开启，则（1）如果一个shader object绑定到任意一个graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetPolygonModeEXT设置polygonMode 为VK_POLYGON_MODE_LINE ，则vkCmdSetLineRasterizationModeEXT必须在该命令之前设置
                                                                                    （2）如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetPrimitiveTopology设置primitiveTopology 为任何line topology ，则vkCmdSetLineRasterizationModeEXT必须在该命令之前设置
                                                                                    （3）如果一个输出为line primitive的shader object绑定到VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或 VK_SHADER_STAGE_GEOMETRY_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则vkCmdSetLineRasterizationModeEXT必须在该命令之前设置
                                                                                    （4）如果一个shader object绑定到任意一个graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetPolygonModeEXT设置polygonMode 为VK_POLYGON_MODE_LINE ，则vkCmdSetLineStippleEnableEXT必须在该命令之前设置
                                                                                    （5）如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetPrimitiveTopology设置primitiveTopology 为任何line topology ，则vkCmdSetLineStippleEnableEXT必须在该命令之前设置
                                                                                    （6）如果一个输出为line primitive的shader object绑定到VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或 VK_SHADER_STAGE_GEOMETRY_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则vkCmdSetLineStippleEnableEXT必须在该命令之前设置
                                                                                    （7）如果一个shader object绑定到任意一个graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetLineStippleEnableEXT设置stippledLineEnable 为VK_TRUE ，则vkCmdSetLineStippleEXT必须在该命令之前设置
        110.如果一个shader object绑定到任何graphics stage，（1）如果depthClipControl 特性开启，则vkCmdSetDepthClipNegativeOneToOneEXT必须在该命令之前设置
                                                           （2）VK_NV_clip_space_w_scaling 拓展开启，则vkCmdSetViewportWScalingEnableNV必须在该命令之前设置
                                                           （3）VK_NV_viewport_swizzle 拓展开启，则vkCmdSetViewportSwizzleNV必须在该命令之前设置
        111.如果如果一个shader object绑定到任何VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                            （1）如果VK_NV_fragment_coverage_to_color 拓展开启，则vkCmdSetCoverageToColorEnableNV 必须在该命令之前设置
                            （2）如果VK_NV_fragment_coverage_to_color 拓展开启，且最近的vkCmdSetCoverageToColorEnableNV 设置coverageToColorEnable 为VK_TRUE，则vkCmdSetCoverageToColorLocationNV 必须在该命令之前设置
                            （3）如果pipelineFragmentShadingRate 特性开启，则vkCmdSetFragmentShadingRateKHR 必须在该命令之前设置
        112.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                    （1）如果VK_NV_framebuffer_mixed_samples 拓展开启，则vkCmdSetCoverageModulationModeNV 必须在该命令之前设置
                                    （2）如果VK_NV_framebuffer_mixed_samples 拓展开启，且最近的vkCmdSetCoverageModulationModeNV设置coverageModulationMode为任何除VK_COVERAGE_MODULATION_MODE_NONE_NV之外的值，则vkCmdSetCoverageModulationTableEnableNV 必须在该命令之前设置
                                    （3）如果VK_NV_framebuffer_mixed_samples 拓展开启，最近的vkCmdSetCoverageModulationTableEnableNV设置coverageModulationTableEnable为VK_TRUE，则vkCmdSetCoverageModulationTableNV 必须在该命令之前设置
                                    （4）如果shadingRateImage 特性开启，则vkCmdSetShadingRateImageEnableNV 必须在该命令之前设置
                                    （5）如果representativeFragmentTest 特性开启，则vkCmdSetRepresentativeFragmentTestEnableNV 必须在该命令之前设置
                                    （6）如果coverageReductionMode 特性开启，则vkCmdSetCoverageReductionModeNV 必须在该命令之前设置
        113.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态state开启创建，且最近的vkCmdSetColorBlendEnableEXT设置任何附件在pColorBlendEnables中的值为VK_TRUE 则subpas中这些附件对应的image view的format features中必须包含VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT
                                         （2）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，且当前subpass不使用任何color和/或者 depth/stencil attachments，则最后的vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples必须符合zero￾attachment subpass的规则
                                         （3）以VK_DYNAMIC_STATE_SAMPLE_MASK_EXT不以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT 动态state开启创建，则最后调用的vkCmdSetSampleMaskEXT中设置的samples参数必须大于等于创建该pipeline的VkPipelineMultisampleStateCreateInfo::rasterizationSamples
                                         （4）以VK_DYNAMIC_STATE_SAMPLE_MASK_EXT和 VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT 动态state开启创建，则最后调用的vkCmdSetSampleMaskEXT中设置的samples参数必须大于等于最后的vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples
                                         （5）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，且VK_AMD_mixed_attachment_samples和VK_NV_framebuffer_mixed_samples拓展都没有开启，则最后的vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples必须等于subpass中color和/或者 depth/stencil attachments使用的相同
                                         （6）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，或者一个shader object绑定到任意graphics stage，且当前的subpass包含一个multisampledRenderToSingleSampledEnable 为VK_TRUE的VkMultisampledRenderToSingleSampledInfoEXT，则最后的vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples必须等于该VkMultisampledRenderToSingleSampledInfoEXT中的对应成员
                                         （7）以VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态state开启创建，则vkCmdSetColorBlendEnableEXT 必须在该命令之前设置，且vkCmdSetColorBlendEnableEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定值
                                         （8）以VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT动态state开启创建，则vkCmdSetColorBlendEquationEXT 必须在该命令之前设置，且vkCmdSetColorBlendEquationEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定blend equations
                                         （9）以VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT动态state开启创建，则vkCmdSetColorWriteMaskEXT 必须在该命令之前设置，且vkCmdSetColorWriteMaskEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定color write mask
                                         （10）以VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT动态state开启创建，则vkCmdSetColorBlendAdvancedEXT 必须在该命令之前设置，且vkCmdSetColorBlendAdvancedEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活blend的color attachments指定advanced blend equations
                                         （11）以VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT和VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态state开启创建，且最后的vkCmdSetColorBlendEnableEXT和vkCmdSetColorBlendAdvancedEXT设置启用了advanced blending，则当前subpass中激活的color attachments的数量不能超过advancedBlendMaxColorAttachments
                                         （12）以VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT动态state开启创建，且如果primitivesGeneratedQueryWithNonZeroStreams特性未开启且VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query已经激活，则最后的vkCmdSetRasterizationStreamEXT必须设置rasterizationStream为0
                                         （13）以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT但不以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，则最后的vkCmdSetSampleLocationsEXT设置的pSampleLocationsInfo->sampleLocationsPerPixel必须等于创建pipeline的VkPipelineMultisampleStateCreateInfo::rasterizationSamples
                                         （14）以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT和VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，则最后的vkCmdSetSampleLocationsEXT设置的pSampleLocationsInfo->sampleLocationsPerPixel必须等于最后vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples
                                         （15）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT但不以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT动态state开启创建，且绑定的pipeline的VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable为VK_TRUE 或者以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT动态state开启，则sampleLocationsInfo.sampleLocationsPerPixel 必须等于最后vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples
                                         （16）以VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV动态state开启创建，且最后的vkCmdSetCoverageToColorEnableNV设置coverageToColorEnable为VK_TRUE，则当前subpass必须有color attachment，且该attachment的format必须为VK_FORMAT_R8_UINT, VK_FORMAT_R8_SINT, VK_FORMAT_R16_UINT, VK_FORMAT_R16_SINT, VK_FORMAT_R32_UINT, 或者 VK_FORMAT_R32_SINT，且该attachment的location 有最后的vkCmdSetCoverageToColorLocationNV设置的coverageToColorLocation决定
                                         （17）以VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV和VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT 动态state开启创建，且如果VK_NV_coverage_reduction_mode 拓展开启，则当前的 coverageReductionMode，rasterizationSamples 以及color 以及 depth/stencil attachments（如果subpass有）的sample count必须是有效的返回值vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV的值的组合
                                         （18）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT但不以VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV 动态state开启创建，则绑定的graphics pipeline的VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount 必须大于等于最后vkCmdSetViewportWithCount设置的viewportCount
                                         （19）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT和VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV 动态state开启创建，则最后vkCmdSetViewportSwizzleNV设置的viewportCount 必须大于等于最后vkCmdSetViewportWithCount设置的viewportCount
                                         （20）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT或者 VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT 动态state开启创建，如果当前的stippledLineEnable为VK_TRUE，且当前的lineRasterizationMode为VK_LINE_RASTERIZATION_MODE_RECTANGULAR_KHR，则stippledRectangularLines 特性必须开启
                                         （21）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT或者 VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT 动态state开启创建，如果当前的stippledLineEnable为VK_TRUE，且当前的lineRasterizationMode为VK_LINE_RASTERIZATION_MODE_BRESENHAM_KHR，则stippledBresenhamLines 特性必须开启
                                         （22）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT或者 VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT 动态state开启创建，如果当前的stippledLineEnable为VK_TRUE，且当前的lineRasterizationMode为VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_KHR，则stippledSmoothLines 特性必须开启
                                         （23）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT或者 VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT 动态state开启创建，如果当前的stippledLineEnable为VK_TRUE，且当前的lineRasterizationMode为VK_LINE_RASTERIZATION_MODE_DEFAULT_KHR，则stippledRectangularLines 特性必须开启且VkPhysicalDeviceLimits::strictLines 必须为VK_TRUE
                                         （24）以VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT 动态state开启创建，且conservativePointAndLineRasterization不支持，最后的 pre-rasterization shader stage输出的有效图元拓扑为点或者线，则最后vkCmdSetConservativeRasterizationModeEXT设置的conservativeRasterizationMode 必须为VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT
                                         （25）以VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT 动态state开启创建，则vkCmdSetAttachmentFeedbackLoopEnableEXT 必须在该命令之前调用
        114.如果一个shader object绑定到 VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                                                                            （1）则vkCmdSetColorBlendEnableEXT 必须在该命令之前设置，且vkCmdSetColorBlendEnableEXT指定的firstAttachment开始的attachmentCount的值必须为当前subpass所有激活的color attachments指定
                                                                                            （2）则vkCmdSetColorBlendEquationEXT 必须在该命令之前设置，且vkCmdSetColorBlendEquationEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定blend equations
                                                                                            （3）则vkCmdSetColorWriteMaskEXT 必须在该命令之前设置，且vkCmdSetColorWriteMaskEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定color write mask
                                                                                            （4）如果VK_NV_fragment_coverage_to_color拓展开启， 最后的vkCmdSetCoverageToColorEnableNV设置coverageToColorEnable为VK_TRUE，则当前subpass必须有color attachment，且该attachment的format必须为VK_FORMAT_R8_UINT, VK_FORMAT_R8_SINT, VK_FORMAT_R16_UINT, VK_FORMAT_R16_SINT, VK_FORMAT_R32_UINT, 或者 VK_FORMAT_R32_SINT，且该attachment的location 有最后的vkCmdSetCoverageToColorLocationNV设置的coverageToColorLocation决定
        115.如果一个shader object绑定到 VK_SHADER_STAGE_FRAGMENT_BIT stage，（1）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT动态state开启创建，且最近的vkCmdSetSampleLocationsEnableEXT设置sampleLocationsEnable为VK_TRUE，且该subpass含有depth/stencil attachment，则该附件必须以VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT创建
                                                                            （2）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT和VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT 动态state开启创建，且最近的vkCmdSetSampleLocationsEnableEXT设置sampleLocationsEnable为VK_TRUE，则 最后vkCmdSetSampleLocationsEXT设置的sampleLocationsInfo.sampleLocationGridSize.width以及height 必须等于被调用vkGetPhysicalDeviceMultisamplePropertiesEXT传入rasterizationSamples返回的VkMultisamplePropertiesEXT::sampleLocationGridSize.width以及height一一对应均匀整除
                                                                            （3）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT 动态state开启创建，且最近的vkCmdSetSampleLocationsEnableEXT设置sampleLocationsEnable为VK_TRUE，则fragment shader代码中不能静态使用扩展指令InterpolateAtSample
                                                                            （4）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT但不以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT 动态state开启创建，且绑定的pipeline的VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable为VK_TRUE 或者以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT动态state开启，则 最后vkCmdSetRasterizationSamplesEXT设置的sampleLocationsInfo.sampleLocationGridSize.width以及height 必须等于被调用vkGetPhysicalDeviceMultisamplePropertiesEXT传入和vkCmdSetRasterizationSamplesEXT设置的相同rasterizationSamples的samples返回的VkMultisamplePropertiesEXT::sampleLocationGridSize.width以及height一一对应均匀整除
        116.如果一个shader object绑定到任何graphics stage，（1）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV 动态state开启创建，且最近的vkCmdSetCoverageModulationTableEnableNV设置coverageModulationTableEnable为VK_TRUE，则最近的vkCmdSetCoverageModulationTableNV 设置的coverageModulationTableCount 必须等于当前rasterizationSamples除以当前subppas的color samples
                                                           （2）如果VK_NV_viewport_swizzle 拓展开启，则最后vkCmdSetViewportSwizzleNV设置的viewportCount 必须大于等于最后vkCmdSetViewportWithCount设置的viewportCount
        117.如果VK_NV_framebuffer_mixed_samples 拓展开启，且如果在绑定的graphics pipeline中当前subpass有一个depth/stencil attachment以及dep test, stencil test, 或depth bounds test 启用，则当前rasterizationSamples 必须等于depth/stencil attachment的sample count
        118.如果VK_NV_framebuffer_mixed_samples 拓展开启，且如果最后的vkCmdSetRasterizationSamplesEXT设置的当前subpass的任何color attachments的rasterizationSamples 都大于 color samples，则sampleShadingEnable 必须为VK_FALSE
        119.如果当前绑定的graphics pipeline以VkGraphicsPipelineCreateInfo::pStages中的元素的VkPipelineShaderStageCreateInfo::stage设置为VK_SHADER_STAGE_VERTEX_BIT, VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT, VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或者 VK_SHADER_STAGE_GEOMETRY_BIT创建，则Mesh Shader Queries 不能激活
        120.如果dynamic state继承自VkCommandBufferInheritanceViewportScissorInfoNV，则这些动态state的设置必须在该命令之前设置
        121.如果没有绑定graphics pipeline，则（1）vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_VERTEX_BIT
                                             （2）如果tessellationShader 特性开启，vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT，VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT
                                             （3）如果geometryShader 特性开启，vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_GEOMETRY_BIT
                                             （4）vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_FRAGMENT_BIT
                                             （5）如果taskShader 特性开启，vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_TASK_BIT_EXT
                                             （6）如果meshShader 特性开启，vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_MESH_BIT_EXT
                                             （8）如果至少taskShader 和 meshShader一个特性开启，VK_SHADER_STAGE_VERTEX_BIT 或者VK_SHADER_STAGE_MESH_BIT_EXT stages中的一个必须含有有效的VkShaderEXT绑定，另外一个则不含有VkShaderEXT绑定
                                             （9）如果taskShader 和 meshShader特性同时开启，且一个有效的VkShaderEXT 绑定到VK_SHADER_STAGE_MESH_BIT_EXT stage，且该VkShaderEXT不以VK_SHADER_CREATE_NO_TASK_SHADER_BIT_EXT 创建，则一个有效的VkShaderEXT必须绑定到VK_SHADER_STAGE_TASK_BIT_EXT stage
                                             （10）如果taskShader 和 meshShader特性同时开启，且一个有效的VkShaderEXT 绑定到VK_SHADER_STAGE_MESH_BIT_EXT stage，且该VkShaderEXT以VK_SHADER_CREATE_NO_TASK_SHADER_BIT_EXT 创建，则不能有VkShaderEXT绑定到VK_SHADER_STAGE_TASK_BIT_EXT stage
                                             （11）如果一个有效的VkShaderEXT 绑定到VK_SHADER_STAGE_VERTEX_BIT stage，则不能有VkShaderEXT绑定到VK_SHADER_STAGE_TASK_BIT_EXT stage或者VK_SHADER_STAGE_MESH_BIT_EXT stage中的一个
        122.如果任何绑定的graphics shader以VK_SHADER_CREATE_LINK_STAGE_BIT_EXT 创建，（1）所有在相同vkCreateShadersEXT中以VK_SHADER_CREATE_LINK_STAGE_BIT_EXT创建的shaders必须也要绑定
                                                                                     （2）任何相同vkCreateShadersEXT中不以VK_SHADER_CREATE_LINK_STAGE_BIT_EXT创建的shaders不能有任何VkShaderEXT绑定
        123.所有绑定的graphics shader objects 必须以相同或者相同定义的push constant ranges创建
        124.所有绑定的graphics shader objects 必须以相同或者相同定义的descriptor set layouts的数组创建
        125.如果当前的render pass instance以vkCmdBeginRendering开始，且VkRenderingInfo::colorAttachmentCount为1，且有一个resolve mode为 VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID 的color attachment，且绑定了fragment shader，则DepthReplacing 和 StencilRefReplacingEXT execution modes 不能声明
        126.如果一个shader object绑定到 VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则 （1）如果attachmentFeedbackLoopDynamicState 特性开启，则 vkCmdSetAttachmentFeedbackLoopEnableEXT 必须在该命令之前调用
        127.如果包含一个fragment shader stage的绑定的graphics pipeline，（1）且该pipeline以VkPipelineDynamicStateCreateInfo::pDynamicStates中设置有VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE创建，且该fragment shader声明了EarlyFragmentTests execution mode且使用了OpDepthAttachmentReadEXT，则最后vkCmdSetDepthWriteEnable 设置的 depthWriteEnable 必须为VK_FALSE
                                                                        （2）且该pipeline以VkPipelineDynamicStateCreateInfo::pDynamicStates中设置有VK_DYNAMIC_STATE_STENCIL_WRITE_MASK创建，且该fragment shader声明了EarlyFragmentTests execution mode且使用了OpStencilAttachmentReadEXT，则最后vkCmdSetStencilWriteMask 设置的 writeMask 必须为0
        128.如果一个shader object绑定到任何graphics stage 或者绑定的graphics pipeline 以VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT 动态state开启创建，且任何color attachment的format为VK_FORMAT_E5B9G9R9_UFLOAT_PACK32，则vkCmdSetColorWriteMaskEXT设置的pColorWriteMasks参数的对应元素必须包含VK_COLOR_COMPONENT_R_BIT, VK_COLOR_COMPONENT_G_BIT, 和 VK_COLOR_COMPONENT_B_BIT，或者都不包含
        129.如果任何附件开启了blending，且该附件的source 或者 destination blend factors使用第二个颜色输入，则该命令执行的Fragment Execution Model静态使用的任何输出output attachment的Location的最大值必须小于maxFragmentDualSrcAttachments
        130.如果当前的render pass instance以vkCmdBeginRendering开始，（1）如果没有任何shader object绑定到任何graphics stage，则vkCmdSetRenderingAttachmentLocationsKHR 设置的VkRenderingAttachmentLocationInfoKHR::pColorAttachmentLocations中的每个元素必须匹配设置在当前绑定的graphics pipeline中的对应元素
                                                                     （2）如果没有任何shader object绑定到任何graphics stage，绑定的graphics pipeline中的input attchment 索引中映射的附件必须匹配在当前render pass instance的VkRenderingInputAttachmentIndexInfoKHR中设置的
        131.如果当前的render pass instance以vkCmdBeginRendering开始且以VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT标志开始，则绑定的graphics pipeline必须以VK_PIPELINE_CREATE_2_ENABLE_LEGACY_DITHERING_BIT_EXT创建
        132.如果绑定的graphics pipeline以VK_PIPELINE_CREATE_2_ENABLE_LEGACY_DITHERING_BIT_EXT创建，则当前的render pass 必须以vkCmdBeginRendering开始且以VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT标志开始
        135.所有在vertex shader entry point 的 interface通过声明的vertex input variables访问的vertex input bindings必须是有效的buffer绑定或者为VK_NULL_HANDLE绑定
        136.如果nullDescriptor 特性未开启，则所有在vertex shader entry point 的 interface通过声明的vertex input variables访问的vertex input bindings不能为VK_NULL_HANDLE绑定
        137.如果robustBufferAccess 特性未开启，且pipeline的创建不对vertexInputs以VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT开启创建，则对于指定的vertex buffer binding，任何获取的顶点属性数据必须包含在对应的vertex buffer binding中，参见Vertex Input Description p2586
        138.如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage或者绑定的graphics pipeline以VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY动态state开启创建，则vkCmdSetPrimitiveTopology必须在该命令前设置
        140.如果绑定的graphics pipeline以VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY动态state开启创建，且dynamicPrimitiveTopologyUnrestricted为VK_FALSE，则vkCmdSetPrimitiveTopology设置的primitiveTopology 必须和pipeline创建的VkPipelineInputAssemblyStateCreateInfo::topology相同
        141.如果绑定的graphics pipeline以VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT但不以VK_DYNAMIC_STATE_VERTEX_INPUT_EXT 动态state开启创建，则vkCmdBindVertexBuffers2EXT必须在该命令前设置，且pStrides参数不能为NULL
        142.如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage或者绑定的graphics pipeline以VK_DYNAMIC_STATE_VERTEX_INPUT_EXT动态state开启创建，则
                                            （1）vkCmdSetVertexInputEXT必须在该命令前设置
                                            （2）所有以Input storage class修饰的Vertex Execution Model OpEntryPoint中的变量其Location必须包含在VkVertexInputAttributeDescription2EXT::location指定的location中
                                            （3）如果满足legacyVertexAttributes未开启或者Vertex Execution Model OpEntryPoint中给定对应Location的Input variable的 SPIR-V Type为64-bit的中的一个，则Vertex Execution Model OpEntryPoint中对应Location的所有Input variable的numeric type必须和VkVertexInputAttributeDescription2EXT::format的相同
                                            （4）如果VkVertexInputAttributeDescription2EXT::format含有64-bit 分量，Vertex Execution Model OpEntryPoint中对应Location的所有Input variable的scalar width必须是64-bit的
                                            （5）如果Vertex Execution Model OpEntryPoint中对应Location的Input variable的scalar width是64-bit的，则对应VkVertexInputAttributeDescription2EXT::format必须含有64-bit 分量
                                            （6）如果VkVertexInputAttributeDescription2EXT::format含有64-bit 分量，则Vertex Execution Model OpEntryPoint中对应Location的所有Input variable不能使用该format未呈现的分量
        143.如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage且最近的vkCmdSetPrimitiveTopology设置primitiveTopology为VK_PRIMITIVE_TOPOLOGY_PATCH_LIST，或者绑定的graphics pipeline以VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT动态state开启创建，则vkCmdSetPatchControlPointsEXT必须在该命令前设置
        144.如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage或者绑定的graphics pipeline以VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE动态state开启创建，则vkCmdSetPrimitiveRestartEnable必须在该命令前设置
        145.如果primitiveTopologyListRestart特性未开启，且topology 为VK_PRIMITIVE_TOPOLOGY_POINT_LIST, VK_PRIMITIVE_TOPOLOGY_LINE_LIST, VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST, VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY, 或者 VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY，
                    且有一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage或者绑定的graphics pipeline以VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE动态state开启创建，则vkCmdSetPrimitiveRestartEnable必须设置为VK_FALSE
        146.绑定的graphics pipeline不能以VkGraphicsPipelineCreateInfo::pStages中元素的VkPipelineShaderStageCreateInfo::stage设置为VK_SHADER_STAGE_TASK_BIT_EXT 或者 VK_SHADER_STAGE_MESH_BIT_EXT创建
        147.不能有shader object绑定到VK_SHADER_STAGE_TASK_BIT_EXT或者 VK_SHADER_STAGE_MESH_BIT_EXT中的一个stage
        148.如果绑定的graphics pipeline 以VkGraphicsPipelineCreateInfo::pVertexInputState->pNext中包含一个VkPipelineVertexInputDivisorStateCreateInfoKHR创建，且VkPipelineVertexInputDivisorStateCreateInfoKHR::pVertexBindingDivisors任何元素为除数为1外的值，且VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR::supportsNonZeroFirstInstance 为VK_FALSE，则firstInstance必须为0
        149.如果shader objects用于绘制或者绑定的graphics pipeline以VK_DYNAMIC_STATE_VERTEX_INPUT_EXT动态state开启创建，且vkCmdSetVertexInputEXT设置的pVertexBindingDescriptions中设置该动态state的任何元素有为除数为1外的值，且VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR::supportsNonZeroFirstInstance 为VK_FALSE，则firstInstance必须为0
        150.VkPhysicalDeviceTransformFeedbackFeaturesEXT::transformFeedback必须开启
        151.实现必须支持VkPhysicalDeviceTransformFeedbackFeaturesEXT::transformFeedback
        152.vertexStride必须大于0小于等于VkPhysicalDeviceTransformFeedbackPropertiesEXT::maxTransformFeedbackBufferDataStride
        153.如果counterBuffer 是non-sparse的则其必须绑定到一个完整的连续的单独的VkDeviceMemory上
        154.counterBuffer必须以VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT创建
        155.counterBufferOffset必须是4的倍数
        
        */
        



    }

}

void DrawingCommandsTest::ConditinalRenderingTest()
{
    /*
    概述
    指定的rendering commands可以在基于buffer memory中的值有条件的进行执行，这些rendering commands指定是 drawing commands, dispatching commands,以及 vkCmdClearAttachments命令，
    这些命令由vkCmdBeginConditionalRenderingEXT 和vkCmdEndConditionalRenderingEXT定义的条件渲染块影响.
    一旦调用vkCmdBeginConditionalRenderingEXT即表示conditional rendering激活直到遇到vkCmdEndConditionalRenderingEXT
    vkCmdBeginConditionalRenderingEXT 和vkCmdEndConditionalRenderingEXT的使用:
    (1)只能同时记录在render pass instance外或相同subpass内
    (2)在primary command buffer中需要有inheritedConditionalRendering特性开启
    (3)在secondary command buffer中需要有其所在的primary command buffer开启inheritedConditionalRendering  ，且设置在 VkCommandBufferInheritanceConditionalRenderingInfoEXT的conditionalRenderingEnable中
    
    */


    VkCommandBuffer commandBuffer{/*假设这是一个有效的VkCommandBuffer*/ };

    VkConditionalRenderingBeginInfoEXT conditionalRenderingBeginInfoEXT{};
    conditionalRenderingBeginInfoEXT.sType = VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT;
    conditionalRenderingBeginInfoEXT.pNext = nullptr;
    conditionalRenderingBeginInfoEXT.flags = VK_CONDITIONAL_RENDERING_INVERTED_BIT_EXT;/*是 VkConditionalRenderingFlagsEXT组合值位掩码，指明conditional rendering的行为
    VkConditionalRenderingFlagsEXT:
    VK_CONDITIONAL_RENDERING_INVERTED_BIT_EXT:  指明该条件决定是否要丢弃vkCmdBeginConditionalRenderingEXT开始的rendering commands， 如果从VkConditionalRenderingBeginInfoEXT中的buffer在offset处读取的32-bit值为0，则便不会丢弃以该命令开始的绘制信息，否则便会丢弃  
    */
    conditionalRenderingBeginInfoEXT.offset = 0;//为buffer中断定信息位置的起始字节偏移量
    conditionalRenderingBeginInfoEXT.buffer = VkBuffer{/*假设这是一个有效的VkBuffer*/ };//包含conditional rendering的断定信息的buffer
    /*
    VkConditionalRenderingBeginInfoEXT有效用法:
    1.如果buffer是non-sparse的，则其必须绑定到完整的连续的单独的VkDeviceMemory上
    2.buffer必须以VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT创建
    3.offset必须小于buffer的大小，且buffer的大小至少是32-bit
    4.offset必须是4的倍数
    */


    //开始条件渲染                       如果从VkConditionalRenderingBeginInfoEXT中的buffer在offset处读取的32-bit值为0，则便不会进行以该命令开始的绘制信息
    vkCmdBeginConditionalRenderingEXT(commandBuffer, &conditionalRenderingBeginInfoEXT);//当前conditional rendering不能激活

    /*
    这里记录一些rendering commands
    */

    //结束条件渲染
    vkCmdEndConditionalRenderingEXT(commandBuffer);
    /*
    vkCmdEndConditionalRenderingEXT有效用法:
    1.conditional rendering必须激活
    2.如果 conditional rendering在render pass instance外激活，则该命令不能在render pass instance内部结束conditional rendering
    3.如果 conditional rendering在subpass内激活，则该命令必须在相同subpass内部结束conditional rendering
    */

}

void DrawingCommandsTest::MeshShadingTest()
{
    //图元可以在mesh shader中进行组装，mesh shading类似于 dispatching compute因为shader使用了workgroups

    VkCommandBuffer commandBuffer{/*假设这是一个有效的VkCommandBuffer*/ };

	//记录一个mesh task 绘制命令   当该命令执行时，包含taskCount个mesh shader workgroups会用来组装图元
	vkCmdDrawMeshTasksNV(commandBuffer, 1/*taskCount,是X维度dispatch的 local workgroups 数量，Y，Z维度上隐式为1.*/, 0/*firstTask,为X维度的第一个 workgroup 的 ID*/);
    /*

     vkCmdDrawMeshTasksNV有效用法:
    1.如果一个VkSampler以其magFilter或者minFilter等于VK_FILTER_LINEAR创建，则（1）如果reductionMode为VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE，如果用于采样一个VkImageView作为该命令的结果的compareEnable为VK_FALSE，则该image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT
                                                                             （2）如果reductionMode为VK_SAMPLER_REDUCTION_MODE_MIN 或者VK_SAMPLER_REDUCTION_MODE_MAX之一 用于采样一个VkImageView作为该命令的结果，则该image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT
    2.如果一个VkSampler以其mipmapMode 等于VK_SAMPLER_MIPMAP_MODE_LINEAR创建，则（1）如果reductionMode为VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE，如果用于采样一个VkImageView作为该命令的结果的compareEnable为VK_FALSE，则该image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT
                                                                             （2）如果reductionMode为VK_SAMPLER_REDUCTION_MODE_MIN 或者VK_SAMPLER_REDUCTION_MODE_MAX之一 用于采样一个VkImageView作为该命令的结果，则该image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT
    3.如果一个VkSampler以其unnormalizedCoordinates等于VK_TRUE用于采样一个VkImageView作为该命令的结果创建，则（1）该image view的levelCount以及layerCount必须为1
                                                                                                            （2）该image view的viewType必须为VK_IMAGE_VIEW_TYPE_1D 或者 VK_IMAGE_VIEW_TYPE_2D
    4.如果一个VkImageView的采样带depth comparison操作，则image view的format features必须包含VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT
    5.如果一个VkImageView使用atomic operations作为该命令的结果进行访问，则image view的format features必须包含VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT
    6.如果一个VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER类型的 descriptor使用atomic operations作为该命令的结果进行访问，则storage texel buffer的format features必须包含VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT
    7.如果一个以VK_FILTER_CUBIC_EXT进行采样的VkImageView作为该命令的结果，则image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT
    8.如果VK_EXT_filter_cubic拓展没有开启，且有任何一个以VK_FILTER_CUBIC_EXT进行采样的VkImageView作为该命令的结果，则其VkImageViewType不能为VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, 或者 VK_IMAGE_VIEW_TYPE_CUBE_ARRAY
    9.任何一个以VK_FILTER_CUBIC_EXT进行采样的作为该命令的结果的VkImageView，其VkImageViewType和format 必须支持cubic filtering，参见vkGetPhysicalDeviceImageFormatProperties2返回的VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic
    10.任何一个以VK_FILTER_CUBIC_EXT进行采样且reduction mode为VK_SAMPLER_REDUCTION_MODE_MIN 或者 VK_SAMPLER_REDUCTION_MODE_MAX之一的作为该命令的结果的VkImageView，其VkImageViewType和format 必须支持带minmax filtering的cubic filtering，参见vkGetPhysicalDeviceImageFormatProperties2返回的VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax
    11.如果cubicRangeClamp特性没有开启，则有任何一个以VK_FILTER_CUBIC_EXT进行采样VkImageView的作为该命令的结果，VkSamplerReductionModeCreateInfo::reductionMode不能为VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM
    12.任何一个以VkSamplerReductionModeCreateInfo::reductionMode为VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM进行采样的作为该命令的结果的VkImageView必须以VK_FILTER_CUBIC_EXT进行采样
    13.如果selectableCubicWeights特性没有开启，则有任何一个以VK_FILTER_CUBIC_EXT进行采样VkImageView的作为该命令的结果，VkSamplerCubicWeightsCreateInfoQCOM::cubicWeights必须为VK_CUBIC_FILTER_WEIGHTS_CATMULL_ROM_QCOM
    14.任何一个以VkImageCreateInfo::flags含VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV创建的采样作为该命令结果的VkImage必须以VkSamplerAddressMode为VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE 进行采样
    15.对于任何作为storage image写入的VkImageView，且其OpTypeImage的format未知，则该image view的 format features必须包含VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT
    16.对于任何作为storage image读取的VkImageView，且其OpTypeImage的format未知，则该image view的 format features必须包含VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT
    17.对于任何作为storage storage texel buffer写入的VkBufferView，且其OpTypeImage的format未知，则该buffer view的 buffer features必须包含VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT
    18.对于任何作为storage storage texel buffer读取的VkBufferView，且其OpTypeImage的format未知，则该buffer view的 buffer features必须包含VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT
    19.对于每个在绑定的shader中静态使用的set n，一个descriptor set必须被绑定到相同pipeline bind point的set n处，该set n必须和创建当前VkPipeline的VkPipelineLayout或者和创建当前VkShaderEXT的VkDescriptorSetLayout 数组的set n处的布局兼容，参见Pipeline Layout Compatibility p1280
    20.对于每个在绑定的shader中静态使用的push constant，一个push constant值必须被绑定到相同pipeline bind point的对应处，该push constant必须和创建当前VkPipeline的VkPipelineLayout或者和创建当前VkShaderEXT的VkDescriptorSetLayout 数组中的对应处的布局兼容，参见Pipeline Layout Compatibility p1280
    21.如果maintenance4特性没有开启，则对于每个在绑定的shader中静态使用的push constant，一个push constant值必须被设置到相同pipeline bind point的对应处，该push constant必须和创建当前VkPipeline的VkPipelineLayout或者和创建当前VkShaderEXT的VkDescriptorSetLayout 数组中的对应处的布局兼容，参见Pipeline Layout Compatibility p1280
    22.每一个通过vkCmdBindDescriptorSets绑定的descriptor set的descriptors,如果是被不以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建的，且已经绑定到该命令使用的pipeline bind point的VkPipeline静态使用的，则这些descriptors必须是有效的，参见 descriptor validity p1328
    23.如果通过vkCmdBindDescriptorSets指定绑定到pipeline bind point的VkPipeline要使用的descriptors，则绑定的VkPipeline不能以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建
    24.在vkCmdSetDescriptorBufferOffsetsEXT中指定绑定的descriptor buffers的descriptors，则（1）如果绑定到pipeline bind point的该命令会使用的VkPipeline以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建，且这些descriptors是动态使用的，则这些descriptors必须是有效的
                                                                                          （2）如果绑定到pipeline bind point的对应stage的该命令会使用的VkShaderEXT，且这些descriptors是动态使用的，则这些descriptors必须是有效的
    25.在vkCmdSetDescriptorBufferOffsetsEXT中指定的descriptors在绑定到pipeline bind point的VkPipeline中使用，则VkPipeline必须以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建
    26.如果一个descriptor在以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建的VkPipeline中动态使用，则descriptor memory必须是驻留内存
    27.如果一个descriptor在以其VkDescriptorSetLayout以VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建的VkShaderEXT中动态使用，则descriptor memory必须是驻留内存
    28.如果shaderObject 特性没有开启，一个有效的pipeline必须绑定到这个命令使用的绑定到pipeline bind point上
    29.如果一个pipeline绑定到该命令使用的pipeline bind point上，则不能有任何动态state 设置命令设置任何该VkPipeline 中没有指定的动态 state
    30.如果一个VkPipeline绑定到该命令使用的pipeline bind point上 或者任何一个会访问一个使用unnormalized coordinates的VkSampler的 VkShaderEXT绑定到该命令使用的pipeline bind point上的pipeline的对应stage，则
                                                                                （1）在任何shader stage中，VkSampler不能用来采样任何类型为VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY 或者 VK_IMAGE_VIEW_TYPE_CUBE_ARRAY的VkImageView
                                                                                （2）在任何shader stage中，该VkSampler不能和任何带有名字中带有ImplicitLod，Dref 或者 Proj 的SPIR-V OpImageSample* 或者 OpImageSparseSample*指令一起使用
                                                                                （3）在任何shader stage中，该VkSampler不能和任何包含 LOD bias或者offset 值 的SPIR-V OpImageSample* or OpImageSparseSample*指令一起使用
    31.如果shaderObject开启，一个有效的pipeline必须绑定到该命令使用的pipeline bind point上或者一个有效的shader objects以及VK_NULL_HANDLE的组合必须绑定到该命令使用的pipeline bind point每一个支持的shader stage上
    32.如何绑定到该命令使用的pipeline bind point上的VkPipeline的任何stage会访问一个uniform buffer，且该stage对uniformBuffers不以启用VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT或者VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT 创建，且robustBufferAccess特性未开启，则该stage就不能访问绑定到相同pipeline bind point的descriptor set指定的buffer范围外的值
    33.如果robustBufferAccess特性未开启，且任何会访问uniform buffer的绑定到该命令使用的pipeline bind point上对应shader stage的VkShaderEXT，则其不能访问绑定到相同pipeline bind point的descriptor set指定的buffer范围外的值
    34.如何绑定到该命令使用的pipeline bind point上的VkPipeline的任何stage会访问一个storage buffer，且该stage对storageBuffers不以启用VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT或者VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT 创建，且robustBufferAccess特性未开启，则该stage就不能访问绑定到相同pipeline bind point的descriptor set指定的buffer范围外的值
    35.如果robustBufferAccess特性未开启，且任何会访问storage buffer的绑定到该命令使用的pipeline bind point上对应shader stage的VkShaderEXT，则其不能访问绑定到相同pipeline bind point的descriptor set指定的buffer范围外的值
    36.如果commandBuffer 是一个unprotected command buffer，且protectedNoFault 未支持，则任何绑定的shaders访问的资源不能是一个protected resource
    37.如果一个绑定的shader访问一个VkSampler 或者 VkImageView ，且启用了sampler Y′C BCR conversion，则只能使用OpImageSample* 或者 OpImageSparseSample*指令，不能使用ConstOffset 以及 Offset操作符
    38.如果一个VkImageView作为该命令的结果进行访问，则（1）image view 的viewType 必须匹配Instruction/Sampler/Image View Validation p1481中描述的OpTypeImage的Dim操作符
                                                      （2）image view 的foamrt的numeric type 必须匹配OpTypeImage的Sampled Type操作符
    39.如果一个VkImageView以一个不是VK_FORMAT_A8_UNORM_KHR的format创建且通过OpImageWrite作为该命令的结果进行访问，则该命令的Texel 操作符的Type必须至少包含和 image view的 format含有的components的个数相同的components个数
    40.如果一个VkImageView以VK_FORMAT_A8_UNORM_KHR的format创建且通过OpImageWrite作为该命令的结果进行访问，则该命令的Texel 操作符的Type必须包含4个components
    41.如果一个VkBufferView通过OpImageWrite作为该命令的结果进行访问，则该命令的Texel 操作符的Type必须至少包含和 buffer view的 format含有的components的个数相同的components个数
    42.如果一个带64-bit component的VkFormat的VkImageView作为该命令的结果进行访问，则该命令的OpTypeImage操作符的SampledType的宽度必须为64
    43.如果一个带少于64-bit component的VkFormat的VkImageView作为该命令的结果进行访问，则该命令的OpTypeImage操作符的SampledType的宽度必须为32
    44.如果一个带64-bit component的VkFormat的VkBufferView作为该命令的结果进行访问，则该命令的OpTypeImage操作符的SampledType的宽度必须为64位
    45.如果一个带少于64-bit component的VkFormat的VkBufferView作为该命令的结果进行访问，则该命令的OpTypeImage操作符的SampledType的宽度必须为32
    46.如果sparseImageInt64Atomics 特性未开启，则以VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT创建的VkImage对象不能被SampledType宽度为64位的OpTypeImage的atomic instructions访问
    47.如果sparseImageInt64Atomics 特性未开启，则以VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT创建的VkBuffer对象不能被SampledType宽度为64位的OpTypeImage的atomic instructions访问
    48.如果OpImageWeightedSampleQCOM用来采样一个作为该命令的结果的VkImageView，则该image view的format features必须包含VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM
    49.如果OpImageWeightedSampleQCOM用来采样一个作为该命令的结果的sample weight image的VkImageView，则该image view的format features必须包含VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM
    50.如果OpImageBoxFilterQCOM用来采样一个作为该命令的结果的VkImageView，则该image view的format features必须包含VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM
    51.如果OpImageBlockMatchSSDQCOM，或者 OpImageBlockMatchSADQCOM用来读取一个作为该命令的结果的VkImageView，则（1）该image view的format features必须包含VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM
                                                                                                               （2）如果是读取的reference image，指定的reference coordinates不能在integer texel coordinate validation 时候失败
    52.如果OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchWindowSSDQCOM, OpImageBlockMatchWindowSADQCOM, OpImageBlockMatchGatherSSDQCOM,
                                                OpImageBlockMatchGatherSADQCOM, OpImageBlockMatchSSDQCOM, 或者 OpImageBlockMatchSADQCOM用来采样一个作为该命令的结果的VkImageView，则该VkSampler必须以VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM创建
    53.如果任何除了OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchWindowSSDQCOM, OpImageBlockMatchWindowSADQCOM, OpImageBlockMatchGatherSSDQCOM, OpImageBlockMatchGatherSADQCOM, OpImageBlockMatchSSDQCOM, 或者 OpImageBlockMatchSADQCOM之外的指令使用VkSampler进行采样作为该命令的结果，则该sampler不能以VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM 创建
    54.如果OpImageBlockMatchWindow*QCOM or OpImageBlockMatchGather*QCOM指令用来读取VkImageView作为该命令的结果，则（1）VkImageView的format features必须包含VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM
                                                                                                                  （2）VkImageView的format必须只含有一个component
    55.如果OpImageBlockMatchWindow*QCOM or OpImageBlockMatchGather*QCOM指令用来读取一个引用的image作为该命令的结果，则指定的 reference coordinates不能在integer texel coordinate validation 时候失败
    56.任何该命令执行的shader invocation必须已经终止
    57.如果有一个类型位为VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM, VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, 或者 VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT中任意一个的descriptor作为该命令的结果进行访问，则该descriptor所指的image subresource的layout必须和该descriptor被写入时的layout相同。
    58.当前的 render pass  必须和绑定到VK_PIPELINE_BIND_POINT_GRAPHICS上的VkPipeline 创建时候的VkGraphicsPipelineCreateInfo中指定的renderPass兼容
    59.当前的 render pass  的subpass index必须和绑定到VK_PIPELINE_BIND_POINT_GRAPHICS上的VkPipeline 创建时候的VkGraphicsPipelineCreateInfo中指定的subpass相同
    60.如果任何shader静态访问一个input attachment，则有效的descriptor必须通过VkDescriptorSet被绑定到该pipeline中
    61.如果任何该pipeline执行shader以SubpassData的Dim操作符访问一个OpTypeImage变量，则该变量必须被一个对应当前subpass的input attachment的InputAttachmentIndex修饰
    62.在subpass中访问的Input attachment views必须以和该subpass相同定义的VkFormat创建，且必须以一个和当前绑定的VkFramebuffer的该附件引用的subpass的pInputAttachments[InputAttachmentIndex]附件兼容的VkImageView创建，参见Fragment Input Attachment Compatibility p1408
    63.在动态render pass中访问以VkRenderingInputAttachmentIndexInfoKHR的InputAttachmentIndex，或者VkRenderingInputAttachmentIndexInfoKHR:pDepthInputAttachmentIndex 或者 VkRenderingInputAttachmentIndexInfoKHR:pStencilInputAttachmentIndex为NULL情况下不指定InputAttachmentIndex的引用的Input attachment views，必须以和VkRenderingInfo中对应color, depth, 或者 stencil attachment兼容的VkImageView创建
    64.如果VkRenderingInputAttachmentIndexInfoKHR::pDepthInputAttachmentIndex 以及 VkRenderingInputAttachmentIndexInfoKHR::pStencilInputAttachmentIndex不为NULL，则在动态render pass中通过shader object访问Input attachment views必须指明InputAttachmentIndex
    65.如果在动态render pass中通过shader object访问Input attachment views指明了InputAttachmentIndex，则InputAttachmentIndex必须匹配VkRenderingInputAttachmentIndexInfoKHR中的index
    66.当前render pass所用的附件对应的image subresource底层内存的写入只能作为该命令的一个附件写入
    67.如果一个color attachment在之前的该subpass的命令中以load, store, 或者 resolve operations进行了写入，则其layout不为VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT，且有当前绑定的pipeline设有VK_PIPELINE_CREATE_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT，或者
                                    最后的vkCmdSetAttachmentFeedbackLoopEnableEXT调用包含VK_IMAGE_ASPECT_COLOR_BIT以及 没有绑定的pipeline 或者绑定的pipeline以VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT创建，则该附件只能以附件进行访问的，这两种情况中之一
    68.如果一个depth attachment在之前的该subpass的命令中以load, store, 或者 resolve operations进行了写入，则其layout不为VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT，且有当前绑定的pipeline设有VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT，或者
                                    最后的vkCmdSetAttachmentFeedbackLoopEnableEXT调用包含VK_IMAGE_ASPECT_DEPTH_BIT以及 没有绑定的pipeline 或者绑定的pipeline以VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT创建，则该附件只能以附件进行访问的，这两种情况中之一
    69.如果一个stencil attachment在之前的该subpass的命令中以load, store, 或者 resolve operations进行了写入，则其layout不为VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT，且有当前绑定的pipeline设有VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT，或者
                                    最后的vkCmdSetAttachmentFeedbackLoopEnableEXT调用包含VK_IMAGE_ASPECT_STENCIL_BIT以及 没有绑定的pipeline 或者绑定的pipeline以VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT创建，则该附件只能以附件进行访问的，这两种情况中之一
    70.如果一个attachment在之前的该subpass的命令中以load, store, 或者 resolve operations进行了写入,则该附件就不能再以除作为一个附件，storage image或者sampled image被该命令访问
    71.如果在之前的命令的subpass中以用作附件外的方式访问访问了一个当权subpass的附件所对的image subresource，则该命令就不能再将该image subresource用作附件进行写入
    72.如果当前render pass使用一个depth/stencil attachment，则（1）如果depth aspect的layout为read-only的layout，则不能启用depth writes
                                                              （2）如果stencil aspect的layout为read-only的layout，front 以及 back writeMask不为0，且stencil 测试开启，则所有stencil 操作必须为VK_STENCIL_OP_KEEP
    73.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_VIEWPORT动态state开启创建，则vkCmdSetViewport必须在该命令之前设置
                                    （2）以VK_DYNAMIC_STATE_SCISSOR动态state开启创建，则vkCmdSetScissor必须在该命令之前设置
                                    （3）以VK_DYNAMIC_STATE_LINE_WIDTH动态state开启创建，则vkCmdSetLineWidth必须在该命令之前设置
                                    （4）以VK_DYNAMIC_STATE_DEPTH_BIAS动态state开启创建，则vkCmdSetDepthBias或者vkCmdSetDepthBias2EXT 必须在该命令之前设置
                                    （5）以VK_DYNAMIC_STATE_BLEND_CONSTANTS动态state开启创建，则vkCmdSetBlendConstants 必须在该命令之前设置
                                    （6）以VK_DYNAMIC_STATE_DEPTH_BOUNDS动态state开启创建，且如果当前depthBoundsTestEnable为VK_TRUE， 则vkCmdSetDepthBounds 必须在该命令之前设置
                                    （7）以VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK动态state开启创建，且如果当前stencilTestEnable为VK_TRUE， 则vkCmdSetStencilCompareMask 必须在该命令之前设置
                                    （8）以VK_DYNAMIC_STATE_STENCIL_WRITE_MASK动态state开启创建，且如果当前stencilTestEnable为VK_TRUE， 则vkCmdSetStencilWriteMask 必须在该命令之前设置
                                    （9）以VK_DYNAMIC_STATE_STENCIL_REFERENCE动态state开启创建，且如果当前stencilTestEnable为VK_TRUE， 则vkCmdSetStencilReference 必须在该命令之前设置
                                    （10）以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT动态state开启创建， 则vkCmdSetSampleLocationsEXT 必须在该命令之前设置
                                    （11）以VK_DYNAMIC_STATE_CULL_MODE动态state开启创建， 则vkCmdSetCullMode 必须在该命令之前设置
                                    （12）以VK_DYNAMIC_STATE_FRONT_FACE动态state开启创建， 则vkCmdSetFrontFace 必须在该命令之前设置
                                    （13）以VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE动态state开启创建， 则vkCmdSetDepthTestEnable 必须在该命令之前设置
                                    （14）以VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE动态state开启创建， 则vkCmdSetDepthWriteEnable 必须在该命令之前设置
                                    （15）以VK_DYNAMIC_STATE_DEPTH_COMPARE_OP动态state开启创建， 则vkCmdSetDepthCompareOp 必须在该命令之前设置
                                    （16）以VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE动态state开启创建， 则vkCmdSetDepthBoundsTestEnable 必须在该命令之前设置
                                    （17）以VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE动态state开启创建， 则vkCmdSetStencilTestEnable 必须在该命令之前设置
                                    （18）以VK_DYNAMIC_STATE_STENCIL_OP动态state开启创建， 则vkCmdSetStencilOp 必须在该命令之前设置
                                    （19）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT但不以VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT 动态state开启创建， 则vkCmdSetViewportWithCount 必须在该命令之前设置，且vkCmdSetViewportWithCount设置的viewportCount必须匹配pipeline的VkPipelineViewportStateCreateInfo::scissorCount
                                    （20）以VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT但不以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT 动态state开启创建， 则vkCmdSetScissorWithCount 必须在该命令之前设置，且vkCmdSetScissorWithCount设置的scissorCount必须匹配pipeline的VkPipelineViewportStateCreateInfo::viewportCount
                                    （21）以VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT和VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT 动态state同时开启创建， 则vkCmdSetViewportWithCount以及vkCmdSetScissorWithCount 必须在该命令之前设置，且vkCmdSetViewportWithCount设置的viewportCount必须匹配vkCmdSetScissorWithCount设置的scissorCount
                                    （22）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT但不以VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV 动态state开启创建， 则绑定的pipeline必须以VkPipelineViewportWScalingStateCreateInfoNV::viewportCount 大于等于最近vkCmdSetViewportWithCount设置的viewportCount创建
                                    （23）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT和VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV 动态state开启创建， 则最近调用的vkCmdSetViewportWScalingNV设置的viewportCount 必须大于等于最近vkCmdSetViewportWithCount设置的viewportCount
                                    （24）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT但不以VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV 动态state开启创建， 则绑定的pipeline必须以VkPipelineViewportShadingRateImageStateCreateInfoNV::viewportCount 大于等于最近vkCmdSetViewportWithCount设置的viewportCount创建
                                    （25）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT和VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV 动态state开启创建， 则最近调用的vkCmdSetViewportShadingRatePaletteNV设置的viewportCount 必须大于等于最近vkCmdSetViewportWithCount设置的viewportCount
                                    （26）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT动态state开启且VkPipelineViewportStateCreateInfo的pNext中含有一个VkPipelineViewportSwizzleStateCreateInfoNV 创建， 则绑定的pipeline必须以VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount 大于等于最近vkCmdSetViewportWithCount设置的viewportCount创建
                                    （27）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT动态state开启且VkPipelineViewportStateCreateInfo的pNext中含有一个VkPipelineViewportExclusiveScissorStateCreateInfoNV 创建， 则绑定的pipeline必须以VkPipelineViewportExclusiveScissorStateCreateInfoNV::exclusiveScissorCount 大于等于最近vkCmdSetViewportWithCount设置的viewportCount创建
                                    （28）以VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_ENABLE_NV动态state开启创建， 则vkCmdSetExclusiveScissorEnableNV 必须在该命令之前设置
                                    （29）以VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV动态state开启创建， 则vkCmdSetExclusiveScissorNV 必须在该命令之前设置
                                    （30）以VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE动态state开启创建， 则vkCmdSetRasterizerDiscardEnable 必须在该命令之前设置
                                    （31）以VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE动态state开启创建， 则vkCmdSetDepthBiasEnable 必须在该命令之前设置
                                    （32）以VK_DYNAMIC_STATE_LOGIC_OP_EXT动态state开启创建， 则vkCmdSetLogicOpEXT 必须在该命令之前设置且参数logicOp必须是一个有效的VkLogicOp值
    74.如果一个shader object绑定到任何graphics stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                    （1）如果最靠近当前命令的vkCmdSetPolygonModeEXT设置polygonMode为VK_POLYGON_MODE_LINE或者是任何line topology，则vkCmdSetLineWidth必须在该命令之前设置
                                    （2）如果最靠近当前命令的vkCmdSetDepthBiasEnable设置depthBiasEnable为VK_TRUE，则vkCmdSetDepthBias 或者 vkCmdSetDepthBias2EXT必须在该命令之前设置
                                    （3）如果最靠近当前命令的vkCmdSetDepthBoundsTestEnable设置depthBoundsTestEnable为VK_TRUE，则vkCmdSetDepthBounds必须在该命令之前设置
                                    （4）如果最靠近当前命令的vkCmdSetStencilTestEnable设置stencilTestEnable为VK_TRUE，则vkCmdSetStencilCompareMask必须在该命令之前设置
                                    （5）如果最靠近当前命令的vkCmdSetStencilTestEnable设置stencilTestEnable为VK_TRUE，则vkCmdSetStencilWriteMask必须在该命令之前设置
                                    （6）如果最靠近当前命令的vkCmdSetStencilTestEnable设置stencilTestEnable为VK_TRUE，则vkCmdSetStencilReference必须在该命令之前设置
                                    （7）如果最靠近当前命令的vkCmdSetSampleLocationsEnableEXT设置sampleLocationsEnable为VK_TRUE，则vkCmdSetSampleLocationsEXT必须在该命令之前设置
                                    （8）则vkCmdSetCullMode必须在该命令之前设置
                                    （9）则vkCmdSetFrontFace必须在该命令之前设置
                                    （10）则vkCmdSetDepthTestEnable 必须在该命令之前设置
                                    （11）则vkCmdSetDepthWriteEnable 必须在该命令之前设置
                                    （12）如果最靠近当前命令的vkCmdSetDepthTestEnable设置depthTestEnable为VK_TRUE，则vkCmdSetDepthCompareOp 必须在该命令之前设置
                                    （13）则vkCmdSetDepthBoundsTestEnable 必须在该命令之前设置
                                    （14）则vkCmdSetStencilTestEnable 必须在该命令之前设置
                                    （15）如果最靠近当前命令的vkCmdSetStencilTestEnable设置stencilTestEnable为VK_TRUE，则vkCmdSetStencilOp 必须在该命令之前设置
                                    （16）
                                    （17）如果shadingRateImage特性开启，则vkCmdSetCoarseSampleOrderNV 必须在该命令之前设置
                                    （18）如果shadingRateImage特性开启，且最靠近当前命令的vkCmdSetShadingRateImageEnableNV设置shadingRateImageEnable为VK_TRUE，则vkCmdSetViewportShadingRatePaletteNV 必须在该命令之前设置
                                    （19）如果shadingRateImage特性开启，且最靠近当前命令的vkCmdSetShadingRateImageEnableNV设置shadingRateImageEnable为VK_TRUE，则最近的vkCmdSetViewportShadingRatePaletteNV设置的viewportCount 必须大于等于vkCmdSetViewportWithCount设置的viewportCount
                                    （20）则vkCmdSetDepthBiasEnable必须在该命令之前设置
    75.如果一个输出line primitives的shader object绑定到VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或者 VK_SHADER_STAGE_GEOMETRY_BIT，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则vkCmdSetLineWidth必须在该命令之前设置
    76.如果一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最靠近当前命令的vkCmdSetColorBlendEnableEXT设置pColorBlendEnables任何元素为VK_TRUE，且
                        最靠近当前命令的vkCmdSetColorBlendEquationEXT设置pColorBlendEquations相同元素的VkColorBlendEquationEXT的VkBlendFactor成员为VK_BLEND_FACTOR_CONSTANT_COLOR, VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR, VK_BLEND_FACTOR_CONSTANT_ALPHA, 或者 VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA，则vkCmdSetBlendConstants必须在该命令之前设置
    77.如果该命令记录在开启了multiview的render pass instance中，则最大的instance 索引必须小于等于VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex
    78.如果绑定的graphics pipeline以VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable设置为VK_TRUE创建且当前的subpass含有一个 depth/stencil attachment，则该attachment必须以VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT创建
    >>78.5  .如果一个shader object绑定到任何graphics stage，则（1）vkCmdSetViewportWithCount 和vkCmdSetScissorWithCount 必须同时在该命令之前设置，且vkCmdSetViewportWithCount设置的viewportCount必须匹配vkCmdSetScissorWithCount设置的scissorCount
                                                              （2）则vkCmdSetRasterizerDiscardEnable 必须在该命令之前设置
    79.如果VK_NV_clip_space_w_scaling拓展开启，且shader object绑定到任何graphics stage，且最近的vkCmdSetViewportWScalingEnableNV设置viewportWScalingEnable为VK_TRUE，则（1）vkCmdSetViewportWScalingNV必须在该命令前设置
                                                                                                                                                                       （2）最近vkCmdSetViewportWScalingNV设置的viewportCount必须大于等于vkCmdSetViewportWithCount设置的viewportCount
    80.如果exclusiveScissor 特性开启，且shader object绑定到任何graphics stage，，则（1）vkCmdSetExclusiveScissorEnableNV必须在该命令前设置
                                                                                   （2）最近的vkCmdSetExclusiveScissorEnableNV调用设置的pExclusiveScissorEnables中的任何元素为VK_TRUE,则vkCmdSetExclusiveScissorNV必须在该命令前设置
    81.如果一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最靠近当前命令的vkCmdSetLogicOpEnableEXT设置logicOpEnable任何元素为VK_TRUE，则vkCmdSetLogicOpEXT 必须在该命令之前设置且参数logicOp必须是一个有效的VkLogicOp值
    82.如果primitiveFragmentShadingRateWithMultipleViewports限制不支持，则（1）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT动态state开启创建，且任何该pipeline的shader stage会写入PrimitiveShadingRateKHR built-in修饰的变量，则vkCmdSetViewportWithCount 必须在该命令之前设置且参数viewportCount必须是1
                                                                          （2）任何绑定的graphics pipeline的shader stage会写入PrimitiveShadingRateKHR built-in修饰的变量，则vkCmdSetViewportWithCount 必须在该命令之前设置且参数viewportCount必须是1
    83.如果graphics pipeline中未开启rasterization，则对subpass中的每个color attachment，如果其对应的image view 的format features不包含VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT，则pColorBlendState中其对应pAttachments中元素的blendEnable必须为VK_FALSE
    84.如果一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则对于render pass中的每个color attachment，如果其对应的image view 的format features不包含VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT， 则最近的vkCmdSetColorBlendEnableEXT设置的pColorBlendEnables中该附件的对应元素必须为VK_FALSE
    85.如果graphics pipeline中未开启rasterization，有VK_AMD_mixed_attachment_samples拓展未开启，VK_NV_framebuffer_mixed_samples拓展未开启，multisampledRenderToSingleSampled特性未开启，则当前绑定的pipeline的rasterizationSamples必须和当前subpass的color 以及/或者 depth/stencil attachments的相同
    86.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且有VK_AMD_mixed_attachment_samples拓展未开启，VK_NV_framebuffer_mixed_samples拓展未开启，multisampledRenderToSingleSampled特性未开启，则最近vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples必须和当前subpass的color 以及/或者 depth/stencil attachments的相同
    87.如果一个shader object绑定到任何graphics stage，则当前的render pass instance必须以vkCmdBeginRendering开始
    88.如果当前的render pass instance以vkCmdBeginRendering开始，（1）如果pDepthAttachment的imageView不为VK_NULL_HANDLE，且pDepthAttachment的layout不为VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL，则该命令不能写入任何值到depth attachment
                                                                （2）如果pStencilAttachment的imageView不为VK_NULL_HANDLE，且pStencilAttachment的layout不为VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL，则该命令不能写入任何值到stencil attachment
                                                                （3）如果pDepthAttachment的imageView不为VK_NULL_HANDLE，且pDepthAttachment的layout为VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL，则该命令不能写入任何值到depth attachment
                                                                （4）如果pStencilAttachment的imageView不为VK_NULL_HANDLE，且pStencilAttachment的layout为VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL，则该命令不能写入任何值到stencil attachment
                                                                （5）如果pDepthAttachment的imageView不为VK_NULL_HANDLE，且pDepthAttachment的layout为VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL，则该命令不能写入任何值到depth attachment
                                                                （6）如果pStencilAttachment的imageView不为VK_NULL_HANDLE，且pStencilAttachment的layout为VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL，则该命令不能写入任何值到stencil attachment
                                                                （7）则当前绑定的graphics pipeline必须以含VkPipelineRenderingCreateInfo::viewMask等于VkRenderingInfo::viewMask创建
                                                                （8）如果带有VkRenderingInfo::colorAttachmentCount为1，则没有shader object绑定到任何graphics stage，且一个color attachment的 resolve mode为VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID，则VkRenderingInfo::pColorAttachments中每个resolveImageView不为VK_NULL_HANDLE的元素其对应image必须以和创建当前绑定的pipeline 相同的VkExternalFormatANDROID::externalFormat创建
                                                                （9）如果没有shader object绑定到任何graphics stage，如果绑定的graphics pipeline以一个非零值VkExternalFormatANDROID::externalFormat创建且启用VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态设置，则vkCmdSetColorBlendEnableEXT必须在该命令前设置blend enable为VK_FALSE
                                                                （10）如果没有shader object绑定到任何graphics stage，如果绑定的graphics pipeline以一个非零值VkExternalFormatANDROID::externalFormat创建且启用VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态设置，则vkCmdSetRasterizationSamplesEXT必须在该命令前设置rasterizationSamples为VK_SAMPLE_COUNT_1_BIT
                                                                （11）如果没有shader object绑定到任何graphics stage，如果绑定的graphics pipeline以一个非零值VkExternalFormatANDROID::externalFormat创建且启用VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR动态设置，则vkCmdSetFragmentShadingRateKHR必须在该命令前设置pFragmentSize->width为1，pFragmentSize->height为1
    89.如果dynamicRenderingUnusedAttachments特性未开启，且当前的render pass instance以vkCmdBeginRendering开始，则
                                                            （1）当前绑定的graphics pipeline必须以含VkPipelineRenderingCreateInfo::colorAttachmentCount等于VkRenderingInfo::colorAttachmentCount创建
                                                            （2）如果VkRenderingInfo::colorAttachmentCount大于0，则VkRenderingInfo::pColorAttachments 中每一个其imageView不为VK_NULL_HANDLE的元素的VkImageView必须以VkFormat对应绑定的graphics pipeline的VkPipelineRenderingCreateInfo::pColorAttachmentFormats指明的format创建
                                                            （3）如果VkRenderingInfo::colorAttachmentCount大于0，则VkRenderingInfo::pColorAttachments 中每一个其imageView为VK_NULL_HANDLE的元素对应绑定的graphics pipeline的VkPipelineRenderingCreateInfo::pColorAttachmentFormats指明的format必须为VK_FORMAT_UNDEFINED
                                                            （4）如果VkRenderingInfo::pDepthAttachment->imageView为VK_NULL_HANDLE，则创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::depthAttachmentFormat必须为VK_FORMAT_UNDEFINED
                                                            （5）如果VkRenderingInfo::pDepthAttachment->imageView不为VK_NULL_HANDLE，则创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::depthAttachmentFormat必须和创建VkRenderingInfo::pDepthAttachment->imageView的VkFormat相同
                                                            （6）如果VkRenderingInfo::pStencilAttachment->imageView为VK_NULL_HANDLE，则创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::stencilAttachmentFormat必须为VK_FORMAT_UNDEFINED
                                                            （7）如果VkRenderingInfo::pStencilAttachment->imageView不为VK_NULL_HANDLE，则创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::stencilAttachmentFormat必须和创建VkRenderingInfo::pStencilAttachment->imageView的VkFormat相同
    90.如果dynamicRenderingUnusedAttachments特性开启，且当前的render pass instance以vkCmdBeginRendering开始，则
                                                            （1）如果VkRenderingInfo::colorAttachmentCount大于0，则VkRenderingInfo::pColorAttachments 中每一个其imageView不为VK_NULL_HANDLE的元素的VkImageView必须以VkFormat对应绑定的graphics pipeline的VkPipelineRenderingCreateInfo::pColorAttachmentFormats指明的format创建，或者是对应元素为VK_FORMAT_UNDEFINED创建
                                                            （2）如果VkRenderingInfo::pDepthAttachment->imageView不为VK_NULL_HANDLE，且创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::depthAttachmentFormat和创建VkRenderingInfo::pDepthAttachment->imageView的VkFormat不同，则该format必须为VK_FORMAT_UNDEFINED
                                                            （3）如果VkRenderingInfo::pStencilAttachment->imageView不为VK_NULL_HANDLE，且创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::stencilAttachmentFormat和创建VkRenderingInfo::pStencilAttachment->imageView的VkFormat不同，则该format必须为VK_FORMAT_UNDEFINED
    91.如果没有shader object绑定到任何graphics stage，且当前的render pass instance以vkCmdBeginRendering开始且VkRenderingInfo::colorAttachmentCount为1，且一个color attachment的 resolve mode为VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID，则VkRenderingInfo::pColorAttachments中每个resolveImageView不为VK_NULL_HANDLE的元素其对应image必须以和创建当前绑定的pipeline 相同的VkExternalFormatANDROID::externalFormat创建
    92.如果有一个shader object绑定到任何graphics stage，且当前的render pass 包含一个使用VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID resolve mode的color attachment，则（1）vkCmdSetColorBlendEnableEXT必须在该命令前设置blend enable为VK_FALSE
                                                                                                                                                                             （2）则vkCmdSetRasterizationSamplesEXT必须在该命令前设置rasterizationSamples为VK_SAMPLE_COUNT_1_BIT
                                                                                                                                                                             （3）则vkCmdSetFragmentShadingRateKHR必须在该命令前设置pFragmentSize->width为1，pFragmentSize->height为1
    93.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT动态state开启创建， 则vkCmdSetColorWriteEnableEXT 必须在该命令之前设置，且设置的attachmentCount必须大于等于创建当前绑定的pipeline的VkPipelineColorBlendStateCreateInfo::attachmentCount
                                    （2）以VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT动态state开启创建， 则vkCmdSetDiscardRectangleEXT 必须在该命令之前为每个VkPipelineDiscardRectangleStateCreateInfoEXT::discardRectangleCount指明的discard rectangle 设置
                                    （3）以VK_DYNAMIC_STATE_DISCARD_RECTANGLE_ENABLE_EXT动态state开启创建， 则vkCmdSetDiscardRectangleEnableEXT 必须在该命令之前设置
                                    （4）以VK_DYNAMIC_STATE_DISCARD_RECTANGLE_MODE_EXT动态state开启创建， 则vkCmdSetDiscardRectangleModeEXT 必须在该命令之前设置
    94.如果有一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                    （1）如果colorWriteEnable特性在device上开启，则vkCmdSetColorWriteEnableEXT 必须在该命令之前设置，且设置的attachmentCount必须大于等于当前render pass instance的color attachment的数量
                                    （2）如果VK_EXT_discard_rectangles拓展开启，且最近的vkCmdSetDiscardRectangleEnableEXT设置discardRectangleEnable为VK_TRUE， 则vkCmdSetDiscardRectangleEXT 必须在该命令之前设置
                                    （3）如果VK_EXT_discard_rectangles拓展开启， 则vkCmdSetDiscardRectangleEnableEXT 必须在该命令之前设置
                                    （4）如果VK_EXT_discard_rectangles拓展开启， 则最近的vkCmdSetDiscardRectangleEnableEXT设置discardRectangleEnable为VK_TRUE，则vkCmdSetDiscardRectangleModeEXT 必须在该命令之前设置
    95.如果当前的render pass instance以vkCmdBeginRendering开始，则（1）如果VkRenderingFragmentShadingRateAttachmentInfoKHR::imageView不为VK_NULL_HANDLE，则当前绑定的graphics pipeline必须以VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR创建
                                                                  （2）如果VkRenderingFragmentDensityMapAttachmentInfoEXT::imageView不为VK_NULL_HANDLE，则当前绑定的graphics pipeline必须以VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT创建
                                                                  （3）且含VkRenderingInfo::colorAttachmentCount大于0，如果当前的绑定的pipeline以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，则VkRenderingInfo::pColorAttachments中每个imageView不为VK_NULL_HANDLE的元素的imageView，必须以当前pipeline的VkAttachmentSampleCountInfoAMD 或者 VkAttachmentSampleCountInfoNV中的pColorAttachmentSamples中对应元素的sample count进行创建
                                                                  （4）如果当前的绑定的pipeline以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且VkRenderingInfo::pDepthAttachment中的imageView不为VK_NULL_HANDLE，则当前pipeline的VkAttachmentSampleCountInfoAMD 或者 VkAttachmentSampleCountInfoNV中的depthStencilAttachmentSamples必须等于创建VkRenderingInfo::pDepthAttachment->imageView的sample count
                                                                  （5）如果当前的绑定的pipeline以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且VkRenderingInfo::pStencilAttachment中的imageView不为VK_NULL_HANDLE，则当前pipeline的VkAttachmentSampleCountInfoAMD 或者 VkAttachmentSampleCountInfoNV中的depthStencilAttachmentSamples必须等于创建VkRenderingInfo::pStencilAttachment->imageView的sample count
                                                                  （6）且含VkRenderingInfo::colorAttachmentCount大于0，如果当前的绑定的pipeline不以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且multisampledRenderToSingleSampled特性没有开启，则VkRenderingInfo::pColorAttachments中每个imageView不为VK_NULL_HANDLE的元素的imageView，其创建的sample count必须等于当前绑定的graphics pipeline的rasterizationSamples
                                                                  （7）如果当前的绑定的pipeline不以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且VkRenderingInfo::pDepthAttachment中的imageView不为VK_NULL_HANDLE，且multisampledRenderToSingleSampled特性没有开启，则当前pipeline的rasterizationSamples 必须等于创建VkRenderingInfo::pDepthAttachment->imageView的sample count
                                                                  （8）如果当前的绑定的pipeline不以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且VkRenderingInfo::pStencilAttachment中的imageView不为VK_NULL_HANDLE，且multisampledRenderToSingleSampled特性没有开启，则当前pipeline的rasterizationSamples 必须等于创建VkRenderingInfo::pStencilAttachment->imageView的sample count
                                                                  （9）当前绑定的pipeline必须VkGraphicsPipelineCreateInfo::renderPass为VK_NULL_HANDLE创建
                                                                  （10）如果绑定的pipeline的fragment shader静态写入一个color attachment，且color write mask不为0，启用了color writes，且该附件对应的VkRenderingInfo::pColorAttachments->imageView 不为VK_NULL_HANDLE，则对应的创建pipeline的VkPipelineRenderingCreateInfo::pColorAttachmentFormats中的元素不能为VK_FORMAT_UNDEFINED
                                                                  （11）如果绑定的pipeline启用了depth test，启用了depth writes，且VkRenderingInfo::pDepthAttachment->imageView 不为VK_NULL_HANDLE，则创建pipeline的VkPipelineRenderingCreateInfo::depthAttachmentFormat不能为VK_FORMAT_UNDEFINED
                                                                  （12）如果绑定的pipeline启用了stencil test，且VkRenderingInfo::pStencilAttachment->imageView 不为VK_NULL_HANDLE，则创建pipeline的VkPipelineRenderingCreateInfo::stencilAttachmentFormat不能为VK_FORMAT_UNDEFINED
    96.如果该命令在以vkCmdBeginRendering开始的render pass instance中调用，且VkRenderingInfo的pNext中包含一个multisampledRenderToSingleSampledEnable设为VK_TRUE的VkMultisampledRenderToSingleSampledInfoEXT，则当前绑定的graphics pipeline的rasterizationSamples必须等于VkMultisampledRenderToSingleSampledInfoEXT::rasterizationSamples
    97.如果primitivesGeneratedQueryWithRasterizerDiscard特性未开启，且VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query激活，则不能启用rasterization discard
    98.如果primitivesGeneratedQueryWithNonZeroStreams特性未开启，且VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query激活，则 绑定的graphics pipeline不能以VkPipelineRasterizationStateStreamCreateInfoEXT::rasterizationStream为非零值创建
    98.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_TESSELLATION_DOMAIN_ORIGIN_EXT动态state开启创建，则vkCmdSetTessellationDomainOriginEXT必须在该命令之前设置
                                    （2）以VK_DYNAMIC_STATE_DEPTH_CLAMP_ENABLE_EXT动态state开启创建，则vkCmdSetDepthClampEnableEXT必须在该命令之前设置
                                    （3）以VK_DYNAMIC_STATE_POLYGON_MODE_EXT动态state开启创建，则vkCmdSetPolygonModeEXT必须在该命令之前设置
                                    （4）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，则vkCmdSetRasterizationSamplesEXT必须在该命令之前设置
                                    （5）以VK_DYNAMIC_STATE_SAMPLE_MASK_EXT动态state开启创建，则vkCmdSetSampleMaskEXT必须在该命令之前设置
                                    （6）以VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT动态state开启创建，则vkCmdSetAlphaToCoverageEnableEXT必须在该命令之前设置
                                    （7）以VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT动态state开启创建，则最近的vkCmdSetAlphaToCoverageEnableEXT设置alphaToCoverageEnable为VK_TRUE，则Fragment Output Interface中 Index 0的Location 0必须有一个含alpha Component的变量
                                    （8）以VK_DYNAMIC_STATE_ALPHA_TO_ONE_ENABLE_EXT动态state开启创建，则vkCmdSetAlphaToOneEnableEXT必须在该命令之前设置
                                    （9）以VK_DYNAMIC_STATE_LOGIC_OP_ENABLE_EXT动态state开启创建，则vkCmdSetLogicOpEnableEXT必须在该命令之前设置
                                    （10）以VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态state开启创建，则vkCmdSetColorBlendEnableEXT必须在该命令之前设置
                                    （11）以VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT动态state开启创建，则vkCmdSetColorBlendEquationEXT必须在该命令之前设置
                                    （12）以VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT动态state开启创建，则vkCmdSetColorWriteMaskEXT必须在该命令之前设置

    99.如果一个shader object绑定到VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT stage，则vkCmdSetTessellationDomainOriginEXT必须在该命令之前设置
    100.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                                    （1）如果depthClamp特性启用，则vkCmdSetDepthClampEnableEXT必须在该命令之前设置
                                                    （2）则vkCmdSetPolygonModeEXT必须在该命令之前设置
                                                    （3）则vkCmdSetRasterizationSamplesEXT必须在该命令之前设置
                                                    （4）则vkCmdSetSampleMaskEXT必须在该命令之前设置
                                                    （5）则vkCmdSetAlphaToCoverageEnableEXT必须在该命令之前设置
                                                    （6）如果alphaToOne特性启用，则vkCmdSetAlphaToOneEnableEXT必须在该命令之前设置

    101.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetAlphaToCoverageEnableEXT设置alphaToCoverageEnable为VK_TRUE，则Fragment Output Interface中 Index 0的Location 0必须有一个含alpha Component的变量
    102.如果一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                        （1）如果logicOp特性开启 ,vkCmdSetLogicOpEnableEXT必须在该命令之前设置
                                        （2）如果绑定了color attachments，则vkCmdSetColorBlendEnableEXT必须在该命令之前设置
                                        （3）如果最近的vkCmdSetColorBlendEnableEXT设置任何附件在pColorBlendEnables中的值为VK_TRUE ，则vkCmdSetColorBlendEquationEXT必须在该命令之前设置
                                        （4）如果绑定了color attachments，则vkCmdSetColorWriteMaskEXT必须在该命令之前设置

    103.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT动态state开启创建，则vkCmdSetRasterizationStreamEXT必须在该命令之前设置
                                     （2）以VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT动态state开启创建，则vkCmdSetConservativeRasterizationModeEXT必须在该命令之前设置
                                     （3）以VK_DYNAMIC_STATE_EXTRA_PRIMITIVE_OVERESTIMATION_SIZE_EXT动态state开启创建，则vkCmdSetExtraPrimitiveOverestimationSizeEXT必须在该命令之前设置
                                     （4）以VK_DYNAMIC_STATE_DEPTH_CLIP_ENABLE_EXT动态state开启创建，则vkCmdSetDepthClipEnableEXT必须在该命令之前设置
                                     （5）以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT动态state开启创建，则vkCmdSetSampleLocationsEnableEXT必须在该命令之前设置
                                     （6）以VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT动态state开启创建，则vkCmdSetColorBlendAdvancedEXT必须在该命令之前设置
                                     （7）以VK_DYNAMIC_STATE_PROVOKING_VERTEX_MODE_EXT动态state开启创建，则vkCmdSetProvokingVertexModeEXT必须在该命令之前设置
                                     （8）以VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT动态state开启创建，则vkCmdSetLineRasterizationModeEXT必须在该命令之前设置
                                     （9）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT动态state开启创建，则vkCmdSetLineStippleEnableEXT必须在该命令之前设置
                                     （10）以VK_DYNAMIC_STATE_LINE_STIPPLE_KHR动态state开启创建，则vkCmdSetLineStippleKHR必须在该命令之前设置
                                     （11）以VK_DYNAMIC_STATE_DEPTH_CLIP_NEGATIVE_ONE_TO_ONE_EXT动态state开启创建，则vkCmdSetDepthClipNegativeOneToOneEXT必须在该命令之前设置
                                     （12）以VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_ENABLE_NV动态state开启创建，则vkCmdSetViewportWScalingEnableNV必须在该命令之前设置
                                     （13）以VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV动态state开启创建，则vkCmdSetViewportSwizzleNV必须在该命令之前设置
                                     （14）以VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV动态state开启创建，则vkCmdSetCoverageToColorEnableNV必须在该命令之前设置
                                     （15）以VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_LOCATION_NV动态state开启创建，则vkCmdSetCoverageToColorLocationNV必须在该命令之前设置
                                     （16）以VK_DYNAMIC_STATE_COVERAGE_MODULATION_MODE_NV动态state开启创建，则vkCmdSetCoverageModulationModeNV必须在该命令之前设置
                                     （17）以VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV动态state开启创建，则vkCmdSetCoverageModulationTableEnableNV必须在该命令之前设置
                                     （18）以VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_NV动态state开启创建，则vkCmdSetCoverageModulationTableNV必须在该命令之前设置
                                     （19）以VK_DYNAMIC_STATE_SHADING_RATE_IMAGE_ENABLE_NV动态state开启创建，则vkCmdSetShadingRateImageEnableNV必须在该命令之前设置
                                     （20）以VK_DYNAMIC_STATE_REPRESENTATIVE_FRAGMENT_TEST_ENABLE_NV动态state开启创建，则vkCmdSetRepresentativeFragmentTestEnableNV必须在该命令之前设置
                                     （21）以VK_DYNAMIC_STATE_COVERAGE_REDUCTION_MODE_NV动态state开启创建，则vkCmdSetCoverageReductionModeNV必须在该命令之前设置

    104.如果一个shader object绑定到VK_SHADER_STAGE_GEOMETRY_BIT stage，且如果geometryStreams 特性开启，则vkCmdSetRasterizationStreamEXT必须在该命令之前设置
    105.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                            （1）如果VK_EXT_conservative_rasterization 拓展开启，vkCmdSetConservativeRasterizationModeEXT必须在该命令之前设置
                            （2）如果VK_EXT_conservative_rasterization 拓展开启，且最近的vkCmdSetConservativeRasterizationModeEXT设置conservativeRasterizationMode为VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT，则vkCmdSetExtraPrimitiveOverestimationSizeEXT必须在该命令之前设置
                            （3）如果VK_EXT_sample_locations 拓展开启，则vkCmdSetSampleLocationsEnableEXT必须在该命令之前设置
    106.如果一个shader object绑定到任何graphics stage，且depthClipEnable 特性开启，则vkCmdSetDepthClipEnableEXT必须在该命令之前设置
    107.如果如果一个shader object绑定到任何VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且如果VK_EXT_blend_operation_advanced 拓展开启，则vkCmdSetColorBlendEquationEXT 和 vkCmdSetColorBlendAdvancedEXT中至少一个必须在该命令之前设置
    108.如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，如果VK_EXT_provoking_vertex拓展开启， 则vkCmdSetProvokingVertexModeEXT必须在该命令之前设置
    109.如果VK_KHR_line_rasterization 或者 VK_EXT_line_rasterization拓展开启，则（1）如果一个shader object绑定到任意一个graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetPolygonModeEXT设置polygonMode 为VK_POLYGON_MODE_LINE ，则vkCmdSetLineRasterizationModeEXT必须在该命令之前设置
                                                                                （2）如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetPrimitiveTopology设置primitiveTopology 为任何line topology ，则vkCmdSetLineRasterizationModeEXT必须在该命令之前设置
                                                                                （3）如果一个输出为line primitive的shader object绑定到VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或 VK_SHADER_STAGE_GEOMETRY_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则vkCmdSetLineRasterizationModeEXT必须在该命令之前设置
                                                                                （4）如果一个shader object绑定到任意一个graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetPolygonModeEXT设置polygonMode 为VK_POLYGON_MODE_LINE ，则vkCmdSetLineStippleEnableEXT必须在该命令之前设置
                                                                                （5）如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetPrimitiveTopology设置primitiveTopology 为任何line topology ，则vkCmdSetLineStippleEnableEXT必须在该命令之前设置
                                                                                （6）如果一个输出为line primitive的shader object绑定到VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或 VK_SHADER_STAGE_GEOMETRY_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则vkCmdSetLineStippleEnableEXT必须在该命令之前设置
                                                                                （7）如果一个shader object绑定到任意一个graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetLineStippleEnableEXT设置stippledLineEnable 为VK_TRUE ，则vkCmdSetLineStippleEXT必须在该命令之前设置
    110.如果一个shader object绑定到任何graphics stage，（1）如果depthClipControl 特性开启，则vkCmdSetDepthClipNegativeOneToOneEXT必须在该命令之前设置
                                                       （2）VK_NV_clip_space_w_scaling 拓展开启，则vkCmdSetViewportWScalingEnableNV必须在该命令之前设置
                                                       （3）VK_NV_viewport_swizzle 拓展开启，则vkCmdSetViewportSwizzleNV必须在该命令之前设置
    111.如果如果一个shader object绑定到任何VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                        （1）如果VK_NV_fragment_coverage_to_color 拓展开启，则vkCmdSetCoverageToColorEnableNV 必须在该命令之前设置
                        （2）如果VK_NV_fragment_coverage_to_color 拓展开启，且最近的vkCmdSetCoverageToColorEnableNV 设置coverageToColorEnable 为VK_TRUE，则vkCmdSetCoverageToColorLocationNV 必须在该命令之前设置
                        （3）如果pipelineFragmentShadingRate 特性开启，则vkCmdSetFragmentShadingRateKHR 必须在该命令之前设置
    112.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                （1）如果VK_NV_framebuffer_mixed_samples 拓展开启，则vkCmdSetCoverageModulationModeNV 必须在该命令之前设置
                                （2）如果VK_NV_framebuffer_mixed_samples 拓展开启，且最近的vkCmdSetCoverageModulationModeNV设置coverageModulationMode为任何除VK_COVERAGE_MODULATION_MODE_NONE_NV之外的值，则vkCmdSetCoverageModulationTableEnableNV 必须在该命令之前设置
                                （3）如果VK_NV_framebuffer_mixed_samples 拓展开启，最近的vkCmdSetCoverageModulationTableEnableNV设置coverageModulationTableEnable为VK_TRUE，则vkCmdSetCoverageModulationTableNV 必须在该命令之前设置
                                （4）如果shadingRateImage 特性开启，则vkCmdSetShadingRateImageEnableNV 必须在该命令之前设置
                                （5）如果representativeFragmentTest 特性开启，则vkCmdSetRepresentativeFragmentTestEnableNV 必须在该命令之前设置
                                （6）如果coverageReductionMode 特性开启，则vkCmdSetCoverageReductionModeNV 必须在该命令之前设置
    113.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态state开启创建，且最近的vkCmdSetColorBlendEnableEXT设置任何附件在pColorBlendEnables中的值为VK_TRUE 则subpas中这些附件对应的image view的format features中必须包含VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT
                                     （2）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，且当前subpass不使用任何color和/或者 depth/stencil attachments，则最后的vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples必须符合zero￾attachment subpass的规则
                                     （3）以VK_DYNAMIC_STATE_SAMPLE_MASK_EXT不以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT 动态state开启创建，则最后调用的vkCmdSetSampleMaskEXT中设置的samples参数必须大于等于创建该pipeline的VkPipelineMultisampleStateCreateInfo::rasterizationSamples
                                     （4）以VK_DYNAMIC_STATE_SAMPLE_MASK_EXT和 VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT 动态state开启创建，则最后调用的vkCmdSetSampleMaskEXT中设置的samples参数必须大于等于最后的vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples
                                     （5）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，且VK_AMD_mixed_attachment_samples和VK_NV_framebuffer_mixed_samples拓展都没有开启，则最后的vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples必须等于subpass中color和/或者 depth/stencil attachments使用的相同
                                     （6）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，或者一个shader object绑定到任意graphics stage，且当前的subpass包含一个multisampledRenderToSingleSampledEnable 为VK_TRUE的VkMultisampledRenderToSingleSampledInfoEXT，则最后的vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples必须等于该VkMultisampledRenderToSingleSampledInfoEXT中的对应成员
                                     （7）以VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态state开启创建，则vkCmdSetColorBlendEnableEXT 必须在该命令之前设置，且vkCmdSetColorBlendEnableEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定值
                                     （8）以VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT动态state开启创建，则vkCmdSetColorBlendEquationEXT 必须在该命令之前设置，且vkCmdSetColorBlendEquationEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定blend equations
                                     （9）以VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT动态state开启创建，则vkCmdSetColorWriteMaskEXT 必须在该命令之前设置，且vkCmdSetColorWriteMaskEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定color write mask
                                     （10）以VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT动态state开启创建，则vkCmdSetColorBlendAdvancedEXT 必须在该命令之前设置，且vkCmdSetColorBlendAdvancedEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活blend的color attachments指定advanced blend equations
                                     （11）以VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT和VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态state开启创建，且最后的vkCmdSetColorBlendEnableEXT和vkCmdSetColorBlendAdvancedEXT设置启用了advanced blending，则当前subpass中激活的color attachments的数量不能超过advancedBlendMaxColorAttachments
                                     （12）以VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT动态state开启创建，且如果primitivesGeneratedQueryWithNonZeroStreams特性未开启且VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query已经激活，则最后的vkCmdSetRasterizationStreamEXT必须设置rasterizationStream为0
                                     （13）以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT但不以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，则最后的vkCmdSetSampleLocationsEXT设置的pSampleLocationsInfo->sampleLocationsPerPixel必须等于创建pipeline的VkPipelineMultisampleStateCreateInfo::rasterizationSamples
                                     （14）以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT和VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，则最后的vkCmdSetSampleLocationsEXT设置的pSampleLocationsInfo->sampleLocationsPerPixel必须等于最后vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples
                                     （15）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT但不以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT动态state开启创建，且绑定的pipeline的VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable为VK_TRUE 或者以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT动态state开启，则sampleLocationsInfo.sampleLocationsPerPixel 必须等于最后vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples
                                     （16）以VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV动态state开启创建，且最后的vkCmdSetCoverageToColorEnableNV设置coverageToColorEnable为VK_TRUE，则当前subpass必须有color attachment，且该attachment的format必须为VK_FORMAT_R8_UINT, VK_FORMAT_R8_SINT, VK_FORMAT_R16_UINT, VK_FORMAT_R16_SINT, VK_FORMAT_R32_UINT, 或者 VK_FORMAT_R32_SINT，且该attachment的location 有最后的vkCmdSetCoverageToColorLocationNV设置的coverageToColorLocation决定
                                     （17）以VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV和VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT 动态state开启创建，且如果VK_NV_coverage_reduction_mode 拓展开启，则当前的 coverageReductionMode，rasterizationSamples 以及color 以及 depth/stencil attachments（如果subpass有）的sample count必须是有效的返回值vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV的值的组合
                                     （18）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT但不以VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV 动态state开启创建，则绑定的graphics pipeline的VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount 必须大于等于最后vkCmdSetViewportWithCount设置的viewportCount
                                     （19）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT和VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV 动态state开启创建，则最后vkCmdSetViewportSwizzleNV设置的viewportCount 必须大于等于最后vkCmdSetViewportWithCount设置的viewportCount
                                     （20）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT或者 VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT 动态state开启创建，如果当前的stippledLineEnable为VK_TRUE，且当前的lineRasterizationMode为VK_LINE_RASTERIZATION_MODE_RECTANGULAR_KHR，则stippledRectangularLines 特性必须开启
                                     （21）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT或者 VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT 动态state开启创建，如果当前的stippledLineEnable为VK_TRUE，且当前的lineRasterizationMode为VK_LINE_RASTERIZATION_MODE_BRESENHAM_KHR，则stippledBresenhamLines 特性必须开启
                                     （22）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT或者 VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT 动态state开启创建，如果当前的stippledLineEnable为VK_TRUE，且当前的lineRasterizationMode为VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_KHR，则stippledSmoothLines 特性必须开启
                                     （23）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT或者 VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT 动态state开启创建，如果当前的stippledLineEnable为VK_TRUE，且当前的lineRasterizationMode为VK_LINE_RASTERIZATION_MODE_DEFAULT_KHR，则stippledRectangularLines 特性必须开启且VkPhysicalDeviceLimits::strictLines 必须为VK_TRUE
                                     （24）以VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT 动态state开启创建，且conservativePointAndLineRasterization不支持，最后的 pre-rasterization shader stage输出的有效图元拓扑为点或者线，则最后vkCmdSetConservativeRasterizationModeEXT设置的conservativeRasterizationMode 必须为VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT
                                     （25）以VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT 动态state开启创建，则vkCmdSetAttachmentFeedbackLoopEnableEXT 必须在该命令之前调用
    114.如果一个shader object绑定到 VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                                                                        （1）则vkCmdSetColorBlendEnableEXT 必须在该命令之前设置，且vkCmdSetColorBlendEnableEXT指定的firstAttachment开始的attachmentCount的值必须为当前subpass所有激活的color attachments指定
                                                                                        （2）则vkCmdSetColorBlendEquationEXT 必须在该命令之前设置，且vkCmdSetColorBlendEquationEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定blend equations
                                                                                        （3）则vkCmdSetColorWriteMaskEXT 必须在该命令之前设置，且vkCmdSetColorWriteMaskEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定color write mask
                                                                                        （4）如果VK_NV_fragment_coverage_to_color拓展开启， 最后的vkCmdSetCoverageToColorEnableNV设置coverageToColorEnable为VK_TRUE，则当前subpass必须有color attachment，且该attachment的format必须为VK_FORMAT_R8_UINT, VK_FORMAT_R8_SINT, VK_FORMAT_R16_UINT, VK_FORMAT_R16_SINT, VK_FORMAT_R32_UINT, 或者 VK_FORMAT_R32_SINT，且该attachment的location 有最后的vkCmdSetCoverageToColorLocationNV设置的coverageToColorLocation决定
    115.如果一个shader object绑定到 VK_SHADER_STAGE_FRAGMENT_BIT stage，（1）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT动态state开启创建，且最近的vkCmdSetSampleLocationsEnableEXT设置sampleLocationsEnable为VK_TRUE，且该subpass含有depth/stencil attachment，则该附件必须以VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT创建
                                                                        （2）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT和VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT 动态state开启创建，且最近的vkCmdSetSampleLocationsEnableEXT设置sampleLocationsEnable为VK_TRUE，则 最后vkCmdSetSampleLocationsEXT设置的sampleLocationsInfo.sampleLocationGridSize.width以及height 必须等于被调用vkGetPhysicalDeviceMultisamplePropertiesEXT传入rasterizationSamples返回的VkMultisamplePropertiesEXT::sampleLocationGridSize.width以及height一一对应均匀整除
                                                                        （3）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT 动态state开启创建，且最近的vkCmdSetSampleLocationsEnableEXT设置sampleLocationsEnable为VK_TRUE，则fragment shader代码中不能静态使用扩展指令InterpolateAtSample
                                                                        （4）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT但不以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT 动态state开启创建，且绑定的pipeline的VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable为VK_TRUE 或者以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT动态state开启，则 最后vkCmdSetRasterizationSamplesEXT设置的sampleLocationsInfo.sampleLocationGridSize.width以及height 必须等于被调用vkGetPhysicalDeviceMultisamplePropertiesEXT传入和vkCmdSetRasterizationSamplesEXT设置的相同rasterizationSamples的samples返回的VkMultisamplePropertiesEXT::sampleLocationGridSize.width以及height一一对应均匀整除
    116.如果一个shader object绑定到任何graphics stage，（1）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV 动态state开启创建，且最近的vkCmdSetCoverageModulationTableEnableNV设置coverageModulationTableEnable为VK_TRUE，则最近的vkCmdSetCoverageModulationTableNV 设置的coverageModulationTableCount 必须等于当前rasterizationSamples除以当前subppas的color samples
                                                       （2）如果VK_NV_viewport_swizzle 拓展开启，则最后vkCmdSetViewportSwizzleNV设置的viewportCount 必须大于等于最后vkCmdSetViewportWithCount设置的viewportCount
    117.如果VK_NV_framebuffer_mixed_samples 拓展开启，且如果在绑定的graphics pipeline中当前subpass有一个depth/stencil attachment以及dep test, stencil test, 或depth bounds test 启用，则当前rasterizationSamples 必须等于depth/stencil attachment的sample count
    118.如果VK_NV_framebuffer_mixed_samples 拓展开启，且如果最后的vkCmdSetRasterizationSamplesEXT设置的当前subpass的任何color attachments的rasterizationSamples 都大于 color samples，则sampleShadingEnable 必须为VK_FALSE
    119.如果当前绑定的graphics pipeline以VkGraphicsPipelineCreateInfo::pStages中的元素的VkPipelineShaderStageCreateInfo::stage设置为VK_SHADER_STAGE_VERTEX_BIT, VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT, VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或者 VK_SHADER_STAGE_GEOMETRY_BIT创建，则Mesh Shader Queries 不能激活
    120.如果dynamic state继承自VkCommandBufferInheritanceViewportScissorInfoNV，则这些动态state的设置必须在该命令之前设置
    121.如果没有绑定graphics pipeline，则（1）vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_VERTEX_BIT
                                         （2）如果tessellationShader 特性开启，vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT，VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT
                                         （3）如果geometryShader 特性开启，vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_GEOMETRY_BIT
                                         （4）vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_FRAGMENT_BIT
                                         （5）如果taskShader 特性开启，vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_TASK_BIT_EXT
                                         （6）如果meshShader 特性开启，vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_MESH_BIT_EXT
                                         （8）如果至少taskShader 和 meshShader一个特性开启，VK_SHADER_STAGE_VERTEX_BIT 或者VK_SHADER_STAGE_MESH_BIT_EXT stages中的一个必须含有有效的VkShaderEXT绑定，另外一个则不含有VkShaderEXT绑定
                                         （9）如果taskShader 和 meshShader特性同时开启，且一个有效的VkShaderEXT 绑定到VK_SHADER_STAGE_MESH_BIT_EXT stage，且该VkShaderEXT不以VK_SHADER_CREATE_NO_TASK_SHADER_BIT_EXT 创建，则一个有效的VkShaderEXT必须绑定到VK_SHADER_STAGE_TASK_BIT_EXT stage
                                         （10）如果taskShader 和 meshShader特性同时开启，且一个有效的VkShaderEXT 绑定到VK_SHADER_STAGE_MESH_BIT_EXT stage，且该VkShaderEXT以VK_SHADER_CREATE_NO_TASK_SHADER_BIT_EXT 创建，则不能有VkShaderEXT绑定到VK_SHADER_STAGE_TASK_BIT_EXT stage
                                         （11）如果一个有效的VkShaderEXT 绑定到VK_SHADER_STAGE_VERTEX_BIT stage，则不能有VkShaderEXT绑定到VK_SHADER_STAGE_TASK_BIT_EXT stage或者VK_SHADER_STAGE_MESH_BIT_EXT stage中的一个
    122.如果任何绑定的graphics shader以VK_SHADER_CREATE_LINK_STAGE_BIT_EXT 创建，（1）所有在相同vkCreateShadersEXT中以VK_SHADER_CREATE_LINK_STAGE_BIT_EXT创建的shaders必须也要绑定
                                                                                 （2）任何相同vkCreateShadersEXT中不以VK_SHADER_CREATE_LINK_STAGE_BIT_EXT创建的shaders不能有任何VkShaderEXT绑定
    123.所有绑定的graphics shader objects 必须以相同或者相同定义的push constant ranges创建
    124.所有绑定的graphics shader objects 必须以相同或者相同定义的descriptor set layouts的数组创建
    125.如果当前的render pass instance以vkCmdBeginRendering开始，且VkRenderingInfo::colorAttachmentCount为1，且有一个resolve mode为 VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID 的color attachment，且绑定了fragment shader，则DepthReplacing 和 StencilRefReplacingEXT execution modes 不能声明
    126.如果一个shader object绑定到 VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则 （1）如果attachmentFeedbackLoopDynamicState 特性开启，则 vkCmdSetAttachmentFeedbackLoopEnableEXT 必须在该命令之前调用
    127.如果包含一个fragment shader stage的绑定的graphics pipeline，（1）且该pipeline以VkPipelineDynamicStateCreateInfo::pDynamicStates中设置有VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE创建，且该fragment shader声明了EarlyFragmentTests execution mode且使用了OpDepthAttachmentReadEXT，则最后vkCmdSetDepthWriteEnable 设置的 depthWriteEnable 必须为VK_FALSE
                                                                    （2）且该pipeline以VkPipelineDynamicStateCreateInfo::pDynamicStates中设置有VK_DYNAMIC_STATE_STENCIL_WRITE_MASK创建，且该fragment shader声明了EarlyFragmentTests execution mode且使用了OpStencilAttachmentReadEXT，则最后vkCmdSetStencilWriteMask 设置的 writeMask 必须为0
    128.如果一个shader object绑定到任何graphics stage 或者绑定的graphics pipeline 以VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT 动态state开启创建，且任何color attachment的format为VK_FORMAT_E5B9G9R9_UFLOAT_PACK32，则vkCmdSetColorWriteMaskEXT设置的pColorWriteMasks参数的对应元素必须包含VK_COLOR_COMPONENT_R_BIT, VK_COLOR_COMPONENT_G_BIT, 和 VK_COLOR_COMPONENT_B_BIT，或者都不包含
    129.如果任何附件开启了blending，且该附件的source 或者 destination blend factors使用第二个颜色输入，则该命令执行的Fragment Execution Model静态使用的任何输出output attachment的Location的最大值必须小于maxFragmentDualSrcAttachments
    130.如果当前的render pass instance以vkCmdBeginRendering开始，（1）如果没有任何shader object绑定到任何graphics stage，则vkCmdSetRenderingAttachmentLocationsKHR 设置的VkRenderingAttachmentLocationInfoKHR::pColorAttachmentLocations中的每个元素必须匹配设置在当前绑定的graphics pipeline中的对应元素
                                                                 （2）如果没有任何shader object绑定到任何graphics stage，绑定的graphics pipeline中的input attchment 索引中映射的附件必须匹配在当前render pass instance的VkRenderingInputAttachmentIndexInfoKHR中设置的
    131.如果当前的render pass instance以vkCmdBeginRendering开始且以VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT标志开始，则绑定的graphics pipeline必须以VK_PIPELINE_CREATE_2_ENABLE_LEGACY_DITHERING_BIT_EXT创建
    132.如果绑定的graphics pipeline以VK_PIPELINE_CREATE_2_ENABLE_LEGACY_DITHERING_BIT_EXT创建，则当前的render pass 必须以vkCmdBeginRendering开始且以VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT标志开始
    133.绑定的graphics pipeline不能以VkGraphicsPipelineCreateInfo::pStages中元素的VkPipelineShaderStageCreateInfo::stage设置为VK_SHADER_STAGE_VERTEX_BIT, VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT, VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或者 VK_SHADER_STAGE_GEOMETRY_BIT创建
    134.Transform Feedback Queries不能激活
    135.Primitives Generated Queries不能激活
    136.用于创建任何激活的Pipeline Statistics Query的pipelineStatistics 不能包含VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT,
                                                                                VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT,
                                                                                VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT,
                                                                                VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT,
                                                                                VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT,
                                                                                VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT,
                                                                                VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT,
                                                                                VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT, 或者
                                                                                VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT
    137.taskCount必须小于等于VkPhysicalDeviceMeshShaderPropertiesNV::maxDrawMeshTasksCount
    138.绑定到VK_PIPELINE_BIND_POINT_GRAPHICS绑定点的当前pipeline必须包含一个使用MeshNV Execution Model的shader stage
    */

    
    VkDrawMeshTasksIndirectCommandNV drawMeshTasksIndirectCommandNV{};//和vkCmdDrawMeshTasksNV中对应参数等效
    drawMeshTasksIndirectCommandNV.firstTask = 0;//为X维度的第一个 workgroup 的 ID
    drawMeshTasksIndirectCommandNV.taskCount = 1;//是X维度dispatch的 local workgroups 数量，Y，Z维度上隐式为1.必须小于等于VkPhysicalDeviceMeshShaderPropertiesNV::maxDrawMeshTasksCount
    //记录一个间接的mesh task 绘制命令   类似于vkCmdDrawMeshTasksNV，只不过参数由buffer给出，buffer中从offset开始，每stride的字节表示一组绘制参数 ，如果drawCount为0，则忽略stride
    vkCmdDrawMeshTasksIndirectNV(commandBuffer, VkBuffer{/*假设这是一个有效的VkBuffer*/ }/*buffer,包含绘制参数的的buffer.*/, 0/*offset，为buffer中起始参数的字节偏移量.*/, 
                    1/*drawCount，是buffer中的绘制参数个数 ，指明绘制个数，可以为0.*/, sizeof(VkDrawMeshTasksIndirectCommandNV)/*stride,为buffer中两组连续参数之间的字节步长.*/);
    /*
    
     vkCmdDrawMeshTasksIndirectNV有效用法:
    1.如果一个VkSampler以其magFilter或者minFilter等于VK_FILTER_LINEAR创建，则（1）如果reductionMode为VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE，如果用于采样一个VkImageView作为该命令的结果的compareEnable为VK_FALSE，则该image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT
                                                                             （2）如果reductionMode为VK_SAMPLER_REDUCTION_MODE_MIN 或者VK_SAMPLER_REDUCTION_MODE_MAX之一 用于采样一个VkImageView作为该命令的结果，则该image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT
    2.如果一个VkSampler以其mipmapMode 等于VK_SAMPLER_MIPMAP_MODE_LINEAR创建，则（1）如果reductionMode为VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE，如果用于采样一个VkImageView作为该命令的结果的compareEnable为VK_FALSE，则该image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT
                                                                             （2）如果reductionMode为VK_SAMPLER_REDUCTION_MODE_MIN 或者VK_SAMPLER_REDUCTION_MODE_MAX之一 用于采样一个VkImageView作为该命令的结果，则该image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT
    3.如果一个VkSampler以其unnormalizedCoordinates等于VK_TRUE用于采样一个VkImageView作为该命令的结果创建，则（1）该image view的levelCount以及layerCount必须为1
                                                                                                            （2）该image view的viewType必须为VK_IMAGE_VIEW_TYPE_1D 或者 VK_IMAGE_VIEW_TYPE_2D
    4.如果一个VkImageView的采样带depth comparison操作，则image view的format features必须包含VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT
    5.如果一个VkImageView使用atomic operations作为该命令的结果进行访问，则image view的format features必须包含VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT
    6.如果一个VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER类型的 descriptor使用atomic operations作为该命令的结果进行访问，则storage texel buffer的format features必须包含VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT
    7.如果一个以VK_FILTER_CUBIC_EXT进行采样的VkImageView作为该命令的结果，则image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT
    8.如果VK_EXT_filter_cubic拓展没有开启，且有任何一个以VK_FILTER_CUBIC_EXT进行采样的VkImageView作为该命令的结果，则其VkImageViewType不能为VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, 或者 VK_IMAGE_VIEW_TYPE_CUBE_ARRAY
    9.任何一个以VK_FILTER_CUBIC_EXT进行采样的作为该命令的结果的VkImageView，其VkImageViewType和format 必须支持cubic filtering，参见vkGetPhysicalDeviceImageFormatProperties2返回的VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic
    10.任何一个以VK_FILTER_CUBIC_EXT进行采样且reduction mode为VK_SAMPLER_REDUCTION_MODE_MIN 或者 VK_SAMPLER_REDUCTION_MODE_MAX之一的作为该命令的结果的VkImageView，其VkImageViewType和format 必须支持带minmax filtering的cubic filtering，参见vkGetPhysicalDeviceImageFormatProperties2返回的VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax
    11.如果cubicRangeClamp特性没有开启，则有任何一个以VK_FILTER_CUBIC_EXT进行采样VkImageView的作为该命令的结果，VkSamplerReductionModeCreateInfo::reductionMode不能为VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM
    12.任何一个以VkSamplerReductionModeCreateInfo::reductionMode为VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM进行采样的作为该命令的结果的VkImageView必须以VK_FILTER_CUBIC_EXT进行采样
    13.如果selectableCubicWeights特性没有开启，则有任何一个以VK_FILTER_CUBIC_EXT进行采样VkImageView的作为该命令的结果，VkSamplerCubicWeightsCreateInfoQCOM::cubicWeights必须为VK_CUBIC_FILTER_WEIGHTS_CATMULL_ROM_QCOM
    14.任何一个以VkImageCreateInfo::flags含VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV创建的采样作为该命令结果的VkImage必须以VkSamplerAddressMode为VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE 进行采样
    15.对于任何作为storage image写入的VkImageView，且其OpTypeImage的format未知，则该image view的 format features必须包含VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT
    16.对于任何作为storage image读取的VkImageView，且其OpTypeImage的format未知，则该image view的 format features必须包含VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT
    17.对于任何作为storage storage texel buffer写入的VkBufferView，且其OpTypeImage的format未知，则该buffer view的 buffer features必须包含VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT
    18.对于任何作为storage storage texel buffer读取的VkBufferView，且其OpTypeImage的format未知，则该buffer view的 buffer features必须包含VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT
    19.对于每个在绑定的shader中静态使用的set n，一个descriptor set必须被绑定到相同pipeline bind point的set n处，该set n必须和创建当前VkPipeline的VkPipelineLayout或者和创建当前VkShaderEXT的VkDescriptorSetLayout 数组的set n处的布局兼容，参见Pipeline Layout Compatibility p1280
    20.对于每个在绑定的shader中静态使用的push constant，一个push constant值必须被绑定到相同pipeline bind point的对应处，该push constant必须和创建当前VkPipeline的VkPipelineLayout或者和创建当前VkShaderEXT的VkDescriptorSetLayout 数组中的对应处的布局兼容，参见Pipeline Layout Compatibility p1280
    21.如果maintenance4特性没有开启，则对于每个在绑定的shader中静态使用的push constant，一个push constant值必须被设置到相同pipeline bind point的对应处，该push constant必须和创建当前VkPipeline的VkPipelineLayout或者和创建当前VkShaderEXT的VkDescriptorSetLayout 数组中的对应处的布局兼容，参见Pipeline Layout Compatibility p1280
    22.每一个通过vkCmdBindDescriptorSets绑定的descriptor set的descriptors,如果是被不以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建的，且已经绑定到该命令使用的pipeline bind point的VkPipeline静态使用的，则这些descriptors必须是有效的，参见 descriptor validity p1328
    23.如果通过vkCmdBindDescriptorSets指定绑定到pipeline bind point的VkPipeline要使用的descriptors，则绑定的VkPipeline不能以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建
    24.在vkCmdSetDescriptorBufferOffsetsEXT中指定绑定的descriptor buffers的descriptors，则（1）如果绑定到pipeline bind point的该命令会使用的VkPipeline以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建，且这些descriptors是动态使用的，则这些descriptors必须是有效的
                                                                                          （2）如果绑定到pipeline bind point的对应stage的该命令会使用的VkShaderEXT，且这些descriptors是动态使用的，则这些descriptors必须是有效的
    25.在vkCmdSetDescriptorBufferOffsetsEXT中指定的descriptors在绑定到pipeline bind point的VkPipeline中使用，则VkPipeline必须以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建
    26.如果一个descriptor在以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建的VkPipeline中动态使用，则descriptor memory必须是驻留内存
    27.如果一个descriptor在以其VkDescriptorSetLayout以VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建的VkShaderEXT中动态使用，则descriptor memory必须是驻留内存
    28.如果shaderObject 特性没有开启，一个有效的pipeline必须绑定到这个命令使用的绑定到pipeline bind point上
    29.如果一个pipeline绑定到该命令使用的pipeline bind point上，则不能有任何动态state 设置命令设置任何该VkPipeline 中没有指定的动态 state
    30.如果一个VkPipeline绑定到该命令使用的pipeline bind point上 或者任何一个会访问一个使用unnormalized coordinates的VkSampler的 VkShaderEXT绑定到该命令使用的pipeline bind point上的pipeline的对应stage，则
                                                                                （1）在任何shader stage中，VkSampler不能用来采样任何类型为VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY 或者 VK_IMAGE_VIEW_TYPE_CUBE_ARRAY的VkImageView
                                                                                （2）在任何shader stage中，该VkSampler不能和任何带有名字中带有ImplicitLod，Dref 或者 Proj 的SPIR-V OpImageSample* 或者 OpImageSparseSample*指令一起使用
                                                                                （3）在任何shader stage中，该VkSampler不能和任何包含 LOD bias或者offset 值 的SPIR-V OpImageSample* or OpImageSparseSample*指令一起使用
    31.如果shaderObject开启，一个有效的pipeline必须绑定到该命令使用的pipeline bind point上或者一个有效的shader objects以及VK_NULL_HANDLE的组合必须绑定到该命令使用的pipeline bind point每一个支持的shader stage上
    32.如何绑定到该命令使用的pipeline bind point上的VkPipeline的任何stage会访问一个uniform buffer，且该stage对uniformBuffers不以启用VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT或者VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT 创建，且robustBufferAccess特性未开启，则该stage就不能访问绑定到相同pipeline bind point的descriptor set指定的buffer范围外的值
    33.如果robustBufferAccess特性未开启，且任何会访问uniform buffer的绑定到该命令使用的pipeline bind point上对应shader stage的VkShaderEXT，则其不能访问绑定到相同pipeline bind point的descriptor set指定的buffer范围外的值
    34.如何绑定到该命令使用的pipeline bind point上的VkPipeline的任何stage会访问一个storage buffer，且该stage对storageBuffers不以启用VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT或者VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT 创建，且robustBufferAccess特性未开启，则该stage就不能访问绑定到相同pipeline bind point的descriptor set指定的buffer范围外的值
    35.如果robustBufferAccess特性未开启，且任何会访问storage buffer的绑定到该命令使用的pipeline bind point上对应shader stage的VkShaderEXT，则其不能访问绑定到相同pipeline bind point的descriptor set指定的buffer范围外的值
    36.如果commandBuffer 是一个unprotected command buffer，且protectedNoFault 未支持，则任何绑定的shaders访问的资源不能是一个protected resource
    37.如果一个绑定的shader访问一个VkSampler 或者 VkImageView ，且启用了sampler Y′C BCR conversion，则只能使用OpImageSample* 或者 OpImageSparseSample*指令，不能使用ConstOffset 以及 Offset操作符
    38.如果一个VkImageView作为该命令的结果进行访问，则（1）image view 的viewType 必须匹配Instruction/Sampler/Image View Validation p1481中描述的OpTypeImage的Dim操作符
                                                      （2）image view 的foamrt的numeric type 必须匹配OpTypeImage的Sampled Type操作符
    39.如果一个VkImageView以一个不是VK_FORMAT_A8_UNORM_KHR的format创建且通过OpImageWrite作为该命令的结果进行访问，则该命令的Texel 操作符的Type必须至少包含和 image view的 format含有的components的个数相同的components个数
    40.如果一个VkImageView以VK_FORMAT_A8_UNORM_KHR的format创建且通过OpImageWrite作为该命令的结果进行访问，则该命令的Texel 操作符的Type必须包含4个components
    41.如果一个VkBufferView通过OpImageWrite作为该命令的结果进行访问，则该命令的Texel 操作符的Type必须至少包含和 buffer view的 format含有的components的个数相同的components个数
    42.如果一个带64-bit component的VkFormat的VkImageView作为该命令的结果进行访问，则该命令的OpTypeImage操作符的SampledType的宽度必须为64
    43.如果一个带少于64-bit component的VkFormat的VkImageView作为该命令的结果进行访问，则该命令的OpTypeImage操作符的SampledType的宽度必须为32
    44.如果一个带64-bit component的VkFormat的VkBufferView作为该命令的结果进行访问，则该命令的OpTypeImage操作符的SampledType的宽度必须为64位
    45.如果一个带少于64-bit component的VkFormat的VkBufferView作为该命令的结果进行访问，则该命令的OpTypeImage操作符的SampledType的宽度必须为32
    46.如果sparseImageInt64Atomics 特性未开启，则以VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT创建的VkImage对象不能被SampledType宽度为64位的OpTypeImage的atomic instructions访问
    47.如果sparseImageInt64Atomics 特性未开启，则以VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT创建的VkBuffer对象不能被SampledType宽度为64位的OpTypeImage的atomic instructions访问
    48.如果OpImageWeightedSampleQCOM用来采样一个作为该命令的结果的VkImageView，则该image view的format features必须包含VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM
    49.如果OpImageWeightedSampleQCOM用来采样一个作为该命令的结果的sample weight image的VkImageView，则该image view的format features必须包含VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM
    50.如果OpImageBoxFilterQCOM用来采样一个作为该命令的结果的VkImageView，则该image view的format features必须包含VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM
    51.如果OpImageBlockMatchSSDQCOM，或者 OpImageBlockMatchSADQCOM用来读取一个作为该命令的结果的VkImageView，则（1）该image view的format features必须包含VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM
                                                                                                               （2）如果是读取的reference image，指定的reference coordinates不能在integer texel coordinate validation 时候失败
    52.如果OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchWindowSSDQCOM, OpImageBlockMatchWindowSADQCOM, OpImageBlockMatchGatherSSDQCOM,
                                                OpImageBlockMatchGatherSADQCOM, OpImageBlockMatchSSDQCOM, 或者 OpImageBlockMatchSADQCOM用来采样一个作为该命令的结果的VkImageView，则该VkSampler必须以VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM创建
    53.如果任何除了OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchWindowSSDQCOM, OpImageBlockMatchWindowSADQCOM, OpImageBlockMatchGatherSSDQCOM, OpImageBlockMatchGatherSADQCOM, OpImageBlockMatchSSDQCOM, 或者 OpImageBlockMatchSADQCOM之外的指令使用VkSampler进行采样作为该命令的结果，则该sampler不能以VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM 创建
    54.如果OpImageBlockMatchWindow*QCOM or OpImageBlockMatchGather*QCOM指令用来读取VkImageView作为该命令的结果，则（1）VkImageView的format features必须包含VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM
                                                                                                                  （2）VkImageView的format必须只含有一个component
    55.如果OpImageBlockMatchWindow*QCOM or OpImageBlockMatchGather*QCOM指令用来读取一个引用的image作为该命令的结果，则指定的 reference coordinates不能在integer texel coordinate validation 时候失败
    56.任何该命令执行的shader invocation必须已经终止
    57.如果有一个类型位为VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM, VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, 或者 VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT中任意一个的descriptor作为该命令的结果进行访问，则该descriptor所指的image subresource的layout必须和该descriptor被写入时的layout相同。
    58.当前的 render pass  必须和绑定到VK_PIPELINE_BIND_POINT_GRAPHICS上的VkPipeline 创建时候的VkGraphicsPipelineCreateInfo中指定的renderPass兼容
    59.当前的 render pass  的subpass index必须和绑定到VK_PIPELINE_BIND_POINT_GRAPHICS上的VkPipeline 创建时候的VkGraphicsPipelineCreateInfo中指定的subpass相同
    60.如果任何shader静态访问一个input attachment，则有效的descriptor必须通过VkDescriptorSet被绑定到该pipeline中
    61.如果任何该pipeline执行shader以SubpassData的Dim操作符访问一个OpTypeImage变量，则该变量必须被一个对应当前subpass的input attachment的InputAttachmentIndex修饰
    62.在subpass中访问的Input attachment views必须以和该subpass相同定义的VkFormat创建，且必须以一个和当前绑定的VkFramebuffer的该附件引用的subpass的pInputAttachments[InputAttachmentIndex]附件兼容的VkImageView创建，参见Fragment Input Attachment Compatibility p1408
    63.在动态render pass中访问以VkRenderingInputAttachmentIndexInfoKHR的InputAttachmentIndex，或者VkRenderingInputAttachmentIndexInfoKHR:pDepthInputAttachmentIndex 或者 VkRenderingInputAttachmentIndexInfoKHR:pStencilInputAttachmentIndex为NULL情况下不指定InputAttachmentIndex的引用的Input attachment views，必须以和VkRenderingInfo中对应color, depth, 或者 stencil attachment兼容的VkImageView创建
    64.如果VkRenderingInputAttachmentIndexInfoKHR::pDepthInputAttachmentIndex 以及 VkRenderingInputAttachmentIndexInfoKHR::pStencilInputAttachmentIndex不为NULL，则在动态render pass中通过shader object访问Input attachment views必须指明InputAttachmentIndex
    65.如果在动态render pass中通过shader object访问Input attachment views指明了InputAttachmentIndex，则InputAttachmentIndex必须匹配VkRenderingInputAttachmentIndexInfoKHR中的index
    66.当前render pass所用的附件对应的image subresource底层内存的写入只能作为该命令的一个附件写入
    67.如果一个color attachment在之前的该subpass的命令中以load, store, 或者 resolve operations进行了写入，则其layout不为VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT，且有当前绑定的pipeline设有VK_PIPELINE_CREATE_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT，或者
                                    最后的vkCmdSetAttachmentFeedbackLoopEnableEXT调用包含VK_IMAGE_ASPECT_COLOR_BIT以及 没有绑定的pipeline 或者绑定的pipeline以VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT创建，则该附件只能以附件进行访问的，这两种情况中之一
    68.如果一个depth attachment在之前的该subpass的命令中以load, store, 或者 resolve operations进行了写入，则其layout不为VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT，且有当前绑定的pipeline设有VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT，或者
                                    最后的vkCmdSetAttachmentFeedbackLoopEnableEXT调用包含VK_IMAGE_ASPECT_DEPTH_BIT以及 没有绑定的pipeline 或者绑定的pipeline以VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT创建，则该附件只能以附件进行访问的，这两种情况中之一
    69.如果一个stencil attachment在之前的该subpass的命令中以load, store, 或者 resolve operations进行了写入，则其layout不为VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT，且有当前绑定的pipeline设有VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT，或者
                                    最后的vkCmdSetAttachmentFeedbackLoopEnableEXT调用包含VK_IMAGE_ASPECT_STENCIL_BIT以及 没有绑定的pipeline 或者绑定的pipeline以VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT创建，则该附件只能以附件进行访问的，这两种情况中之一
    70.如果一个attachment在之前的该subpass的命令中以load, store, 或者 resolve operations进行了写入,则该附件就不能再以除作为一个附件，storage image或者sampled image被该命令访问
    71.如果在之前的命令的subpass中以用作附件外的方式访问访问了一个当权subpass的附件所对的image subresource，则该命令就不能再将该image subresource用作附件进行写入
    72.如果当前render pass使用一个depth/stencil attachment，则（1）如果depth aspect的layout为read-only的layout，则不能启用depth writes
                                                              （2）如果stencil aspect的layout为read-only的layout，front 以及 back writeMask不为0，且stencil 测试开启，则所有stencil 操作必须为VK_STENCIL_OP_KEEP
    73.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_VIEWPORT动态state开启创建，则vkCmdSetViewport必须在该命令之前设置
                                    （2）以VK_DYNAMIC_STATE_SCISSOR动态state开启创建，则vkCmdSetScissor必须在该命令之前设置
                                    （3）以VK_DYNAMIC_STATE_LINE_WIDTH动态state开启创建，则vkCmdSetLineWidth必须在该命令之前设置
                                    （4）以VK_DYNAMIC_STATE_DEPTH_BIAS动态state开启创建，则vkCmdSetDepthBias或者vkCmdSetDepthBias2EXT 必须在该命令之前设置
                                    （5）以VK_DYNAMIC_STATE_BLEND_CONSTANTS动态state开启创建，则vkCmdSetBlendConstants 必须在该命令之前设置
                                    （6）以VK_DYNAMIC_STATE_DEPTH_BOUNDS动态state开启创建，且如果当前depthBoundsTestEnable为VK_TRUE， 则vkCmdSetDepthBounds 必须在该命令之前设置
                                    （7）以VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK动态state开启创建，且如果当前stencilTestEnable为VK_TRUE， 则vkCmdSetStencilCompareMask 必须在该命令之前设置
                                    （8）以VK_DYNAMIC_STATE_STENCIL_WRITE_MASK动态state开启创建，且如果当前stencilTestEnable为VK_TRUE， 则vkCmdSetStencilWriteMask 必须在该命令之前设置
                                    （9）以VK_DYNAMIC_STATE_STENCIL_REFERENCE动态state开启创建，且如果当前stencilTestEnable为VK_TRUE， 则vkCmdSetStencilReference 必须在该命令之前设置
                                    （10）以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT动态state开启创建， 则vkCmdSetSampleLocationsEXT 必须在该命令之前设置
                                    （11）以VK_DYNAMIC_STATE_CULL_MODE动态state开启创建， 则vkCmdSetCullMode 必须在该命令之前设置
                                    （12）以VK_DYNAMIC_STATE_FRONT_FACE动态state开启创建， 则vkCmdSetFrontFace 必须在该命令之前设置
                                    （13）以VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE动态state开启创建， 则vkCmdSetDepthTestEnable 必须在该命令之前设置
                                    （14）以VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE动态state开启创建， 则vkCmdSetDepthWriteEnable 必须在该命令之前设置
                                    （15）以VK_DYNAMIC_STATE_DEPTH_COMPARE_OP动态state开启创建， 则vkCmdSetDepthCompareOp 必须在该命令之前设置
                                    （16）以VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE动态state开启创建， 则vkCmdSetDepthBoundsTestEnable 必须在该命令之前设置
                                    （17）以VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE动态state开启创建， 则vkCmdSetStencilTestEnable 必须在该命令之前设置
                                    （18）以VK_DYNAMIC_STATE_STENCIL_OP动态state开启创建， 则vkCmdSetStencilOp 必须在该命令之前设置
                                    （19）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT但不以VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT 动态state开启创建， 则vkCmdSetViewportWithCount 必须在该命令之前设置，且vkCmdSetViewportWithCount设置的viewportCount必须匹配pipeline的VkPipelineViewportStateCreateInfo::scissorCount
                                    （20）以VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT但不以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT 动态state开启创建， 则vkCmdSetScissorWithCount 必须在该命令之前设置，且vkCmdSetScissorWithCount设置的scissorCount必须匹配pipeline的VkPipelineViewportStateCreateInfo::viewportCount
                                    （21）以VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT和VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT 动态state同时开启创建， 则vkCmdSetViewportWithCount以及vkCmdSetScissorWithCount 必须在该命令之前设置，且vkCmdSetViewportWithCount设置的viewportCount必须匹配vkCmdSetScissorWithCount设置的scissorCount
                                    （22）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT但不以VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV 动态state开启创建， 则绑定的pipeline必须以VkPipelineViewportWScalingStateCreateInfoNV::viewportCount 大于等于最近vkCmdSetViewportWithCount设置的viewportCount创建
                                    （23）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT和VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV 动态state开启创建， 则最近调用的vkCmdSetViewportWScalingNV设置的viewportCount 必须大于等于最近vkCmdSetViewportWithCount设置的viewportCount
                                    （24）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT但不以VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV 动态state开启创建， 则绑定的pipeline必须以VkPipelineViewportShadingRateImageStateCreateInfoNV::viewportCount 大于等于最近vkCmdSetViewportWithCount设置的viewportCount创建
                                    （25）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT和VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV 动态state开启创建， 则最近调用的vkCmdSetViewportShadingRatePaletteNV设置的viewportCount 必须大于等于最近vkCmdSetViewportWithCount设置的viewportCount
                                    （26）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT动态state开启且VkPipelineViewportStateCreateInfo的pNext中含有一个VkPipelineViewportSwizzleStateCreateInfoNV 创建， 则绑定的pipeline必须以VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount 大于等于最近vkCmdSetViewportWithCount设置的viewportCount创建
                                    （27）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT动态state开启且VkPipelineViewportStateCreateInfo的pNext中含有一个VkPipelineViewportExclusiveScissorStateCreateInfoNV 创建， 则绑定的pipeline必须以VkPipelineViewportExclusiveScissorStateCreateInfoNV::exclusiveScissorCount 大于等于最近vkCmdSetViewportWithCount设置的viewportCount创建
                                    （28）以VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_ENABLE_NV动态state开启创建， 则vkCmdSetExclusiveScissorEnableNV 必须在该命令之前设置
                                    （29）以VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV动态state开启创建， 则vkCmdSetExclusiveScissorNV 必须在该命令之前设置
                                    （30）以VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE动态state开启创建， 则vkCmdSetRasterizerDiscardEnable 必须在该命令之前设置
                                    （31）以VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE动态state开启创建， 则vkCmdSetDepthBiasEnable 必须在该命令之前设置
                                    （32）以VK_DYNAMIC_STATE_LOGIC_OP_EXT动态state开启创建， 则vkCmdSetLogicOpEXT 必须在该命令之前设置且参数logicOp必须是一个有效的VkLogicOp值
    74.如果一个shader object绑定到任何graphics stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                    （1）如果最靠近当前命令的vkCmdSetPolygonModeEXT设置polygonMode为VK_POLYGON_MODE_LINE或者是任何line topology，则vkCmdSetLineWidth必须在该命令之前设置
                                    （2）如果最靠近当前命令的vkCmdSetDepthBiasEnable设置depthBiasEnable为VK_TRUE，则vkCmdSetDepthBias 或者 vkCmdSetDepthBias2EXT必须在该命令之前设置
                                    （3）如果最靠近当前命令的vkCmdSetDepthBoundsTestEnable设置depthBoundsTestEnable为VK_TRUE，则vkCmdSetDepthBounds必须在该命令之前设置
                                    （4）如果最靠近当前命令的vkCmdSetStencilTestEnable设置stencilTestEnable为VK_TRUE，则vkCmdSetStencilCompareMask必须在该命令之前设置
                                    （5）如果最靠近当前命令的vkCmdSetStencilTestEnable设置stencilTestEnable为VK_TRUE，则vkCmdSetStencilWriteMask必须在该命令之前设置
                                    （6）如果最靠近当前命令的vkCmdSetStencilTestEnable设置stencilTestEnable为VK_TRUE，则vkCmdSetStencilReference必须在该命令之前设置
                                    （7）如果最靠近当前命令的vkCmdSetSampleLocationsEnableEXT设置sampleLocationsEnable为VK_TRUE，则vkCmdSetSampleLocationsEXT必须在该命令之前设置
                                    （8）则vkCmdSetCullMode必须在该命令之前设置
                                    （9）则vkCmdSetFrontFace必须在该命令之前设置
                                    （10）则vkCmdSetDepthTestEnable 必须在该命令之前设置
                                    （11）则vkCmdSetDepthWriteEnable 必须在该命令之前设置
                                    （12）如果最靠近当前命令的vkCmdSetDepthTestEnable设置depthTestEnable为VK_TRUE，则vkCmdSetDepthCompareOp 必须在该命令之前设置
                                    （13）则vkCmdSetDepthBoundsTestEnable 必须在该命令之前设置
                                    （14）则vkCmdSetStencilTestEnable 必须在该命令之前设置
                                    （15）如果最靠近当前命令的vkCmdSetStencilTestEnable设置stencilTestEnable为VK_TRUE，则vkCmdSetStencilOp 必须在该命令之前设置
                                    （16）
                                    （17）如果shadingRateImage特性开启，则vkCmdSetCoarseSampleOrderNV 必须在该命令之前设置
                                    （18）如果shadingRateImage特性开启，且最靠近当前命令的vkCmdSetShadingRateImageEnableNV设置shadingRateImageEnable为VK_TRUE，则vkCmdSetViewportShadingRatePaletteNV 必须在该命令之前设置
                                    （19）如果shadingRateImage特性开启，且最靠近当前命令的vkCmdSetShadingRateImageEnableNV设置shadingRateImageEnable为VK_TRUE，则最近的vkCmdSetViewportShadingRatePaletteNV设置的viewportCount 必须大于等于vkCmdSetViewportWithCount设置的viewportCount
                                    （20）则vkCmdSetDepthBiasEnable必须在该命令之前设置
    75.如果一个输出line primitives的shader object绑定到VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或者 VK_SHADER_STAGE_GEOMETRY_BIT，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则vkCmdSetLineWidth必须在该命令之前设置
    76.如果一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最靠近当前命令的vkCmdSetColorBlendEnableEXT设置pColorBlendEnables任何元素为VK_TRUE，且
                        最靠近当前命令的vkCmdSetColorBlendEquationEXT设置pColorBlendEquations相同元素的VkColorBlendEquationEXT的VkBlendFactor成员为VK_BLEND_FACTOR_CONSTANT_COLOR, VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR, VK_BLEND_FACTOR_CONSTANT_ALPHA, 或者 VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA，则vkCmdSetBlendConstants必须在该命令之前设置
    77.如果该命令记录在开启了multiview的render pass instance中，则最大的instance 索引必须小于等于VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex
    78.如果绑定的graphics pipeline以VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable设置为VK_TRUE创建且当前的subpass含有一个 depth/stencil attachment，则该attachment必须以VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT创建
    >>78.5  .如果一个shader object绑定到任何graphics stage，则（1）vkCmdSetViewportWithCount 和vkCmdSetScissorWithCount 必须同时在该命令之前设置，且vkCmdSetViewportWithCount设置的viewportCount必须匹配vkCmdSetScissorWithCount设置的scissorCount
                                                              （2）则vkCmdSetRasterizerDiscardEnable 必须在该命令之前设置
    79.如果VK_NV_clip_space_w_scaling拓展开启，且shader object绑定到任何graphics stage，且最近的vkCmdSetViewportWScalingEnableNV设置viewportWScalingEnable为VK_TRUE，则（1）vkCmdSetViewportWScalingNV必须在该命令前设置
                                                                                                                                                                       （2）最近vkCmdSetViewportWScalingNV设置的viewportCount必须大于等于vkCmdSetViewportWithCount设置的viewportCount
    80.如果exclusiveScissor 特性开启，且shader object绑定到任何graphics stage，，则（1）vkCmdSetExclusiveScissorEnableNV必须在该命令前设置
                                                                                   （2）最近的vkCmdSetExclusiveScissorEnableNV调用设置的pExclusiveScissorEnables中的任何元素为VK_TRUE,则vkCmdSetExclusiveScissorNV必须在该命令前设置
    81.如果一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最靠近当前命令的vkCmdSetLogicOpEnableEXT设置logicOpEnable任何元素为VK_TRUE，则vkCmdSetLogicOpEXT 必须在该命令之前设置且参数logicOp必须是一个有效的VkLogicOp值
    82.如果primitiveFragmentShadingRateWithMultipleViewports限制不支持，则（1）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT动态state开启创建，且任何该pipeline的shader stage会写入PrimitiveShadingRateKHR built-in修饰的变量，则vkCmdSetViewportWithCount 必须在该命令之前设置且参数viewportCount必须是1
                                                                          （2）任何绑定的graphics pipeline的shader stage会写入PrimitiveShadingRateKHR built-in修饰的变量，则vkCmdSetViewportWithCount 必须在该命令之前设置且参数viewportCount必须是1
    83.如果graphics pipeline中未开启rasterization，则对subpass中的每个color attachment，如果其对应的image view 的format features不包含VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT，则pColorBlendState中其对应pAttachments中元素的blendEnable必须为VK_FALSE
    84.如果一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则对于render pass中的每个color attachment，如果其对应的image view 的format features不包含VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT， 则最近的vkCmdSetColorBlendEnableEXT设置的pColorBlendEnables中该附件的对应元素必须为VK_FALSE
    85.如果graphics pipeline中未开启rasterization，有VK_AMD_mixed_attachment_samples拓展未开启，VK_NV_framebuffer_mixed_samples拓展未开启，multisampledRenderToSingleSampled特性未开启，则当前绑定的pipeline的rasterizationSamples必须和当前subpass的color 以及/或者 depth/stencil attachments的相同
    86.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且有VK_AMD_mixed_attachment_samples拓展未开启，VK_NV_framebuffer_mixed_samples拓展未开启，multisampledRenderToSingleSampled特性未开启，则最近vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples必须和当前subpass的color 以及/或者 depth/stencil attachments的相同
    87.如果一个shader object绑定到任何graphics stage，则当前的render pass instance必须以vkCmdBeginRendering开始
    88.如果当前的render pass instance以vkCmdBeginRendering开始，（1）如果pDepthAttachment的imageView不为VK_NULL_HANDLE，且pDepthAttachment的layout不为VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL，则该命令不能写入任何值到depth attachment
                                                                （2）如果pStencilAttachment的imageView不为VK_NULL_HANDLE，且pStencilAttachment的layout不为VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL，则该命令不能写入任何值到stencil attachment
                                                                （3）如果pDepthAttachment的imageView不为VK_NULL_HANDLE，且pDepthAttachment的layout为VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL，则该命令不能写入任何值到depth attachment
                                                                （4）如果pStencilAttachment的imageView不为VK_NULL_HANDLE，且pStencilAttachment的layout为VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL，则该命令不能写入任何值到stencil attachment
                                                                （5）如果pDepthAttachment的imageView不为VK_NULL_HANDLE，且pDepthAttachment的layout为VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL，则该命令不能写入任何值到depth attachment
                                                                （6）如果pStencilAttachment的imageView不为VK_NULL_HANDLE，且pStencilAttachment的layout为VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL，则该命令不能写入任何值到stencil attachment
                                                                （7）则当前绑定的graphics pipeline必须以含VkPipelineRenderingCreateInfo::viewMask等于VkRenderingInfo::viewMask创建
                                                                （8）如果带有VkRenderingInfo::colorAttachmentCount为1，则没有shader object绑定到任何graphics stage，且一个color attachment的 resolve mode为VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID，则VkRenderingInfo::pColorAttachments中每个resolveImageView不为VK_NULL_HANDLE的元素其对应image必须以和创建当前绑定的pipeline 相同的VkExternalFormatANDROID::externalFormat创建
                                                                （9）如果没有shader object绑定到任何graphics stage，如果绑定的graphics pipeline以一个非零值VkExternalFormatANDROID::externalFormat创建且启用VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态设置，则vkCmdSetColorBlendEnableEXT必须在该命令前设置blend enable为VK_FALSE
                                                                （10）如果没有shader object绑定到任何graphics stage，如果绑定的graphics pipeline以一个非零值VkExternalFormatANDROID::externalFormat创建且启用VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态设置，则vkCmdSetRasterizationSamplesEXT必须在该命令前设置rasterizationSamples为VK_SAMPLE_COUNT_1_BIT
                                                                （11）如果没有shader object绑定到任何graphics stage，如果绑定的graphics pipeline以一个非零值VkExternalFormatANDROID::externalFormat创建且启用VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR动态设置，则vkCmdSetFragmentShadingRateKHR必须在该命令前设置pFragmentSize->width为1，pFragmentSize->height为1
    89.如果dynamicRenderingUnusedAttachments特性未开启，且当前的render pass instance以vkCmdBeginRendering开始，则
                                                            （1）当前绑定的graphics pipeline必须以含VkPipelineRenderingCreateInfo::colorAttachmentCount等于VkRenderingInfo::colorAttachmentCount创建
                                                            （2）如果VkRenderingInfo::colorAttachmentCount大于0，则VkRenderingInfo::pColorAttachments 中每一个其imageView不为VK_NULL_HANDLE的元素的VkImageView必须以VkFormat对应绑定的graphics pipeline的VkPipelineRenderingCreateInfo::pColorAttachmentFormats指明的format创建
                                                            （3）如果VkRenderingInfo::colorAttachmentCount大于0，则VkRenderingInfo::pColorAttachments 中每一个其imageView为VK_NULL_HANDLE的元素对应绑定的graphics pipeline的VkPipelineRenderingCreateInfo::pColorAttachmentFormats指明的format必须为VK_FORMAT_UNDEFINED
                                                            （4）如果VkRenderingInfo::pDepthAttachment->imageView为VK_NULL_HANDLE，则创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::depthAttachmentFormat必须为VK_FORMAT_UNDEFINED
                                                            （5）如果VkRenderingInfo::pDepthAttachment->imageView不为VK_NULL_HANDLE，则创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::depthAttachmentFormat必须和创建VkRenderingInfo::pDepthAttachment->imageView的VkFormat相同
                                                            （6）如果VkRenderingInfo::pStencilAttachment->imageView为VK_NULL_HANDLE，则创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::stencilAttachmentFormat必须为VK_FORMAT_UNDEFINED
                                                            （7）如果VkRenderingInfo::pStencilAttachment->imageView不为VK_NULL_HANDLE，则创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::stencilAttachmentFormat必须和创建VkRenderingInfo::pStencilAttachment->imageView的VkFormat相同
    90.如果dynamicRenderingUnusedAttachments特性开启，且当前的render pass instance以vkCmdBeginRendering开始，则
                                                            （1）如果VkRenderingInfo::colorAttachmentCount大于0，则VkRenderingInfo::pColorAttachments 中每一个其imageView不为VK_NULL_HANDLE的元素的VkImageView必须以VkFormat对应绑定的graphics pipeline的VkPipelineRenderingCreateInfo::pColorAttachmentFormats指明的format创建，或者是对应元素为VK_FORMAT_UNDEFINED创建
                                                            （2）如果VkRenderingInfo::pDepthAttachment->imageView不为VK_NULL_HANDLE，且创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::depthAttachmentFormat和创建VkRenderingInfo::pDepthAttachment->imageView的VkFormat不同，则该format必须为VK_FORMAT_UNDEFINED
                                                            （3）如果VkRenderingInfo::pStencilAttachment->imageView不为VK_NULL_HANDLE，且创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::stencilAttachmentFormat和创建VkRenderingInfo::pStencilAttachment->imageView的VkFormat不同，则该format必须为VK_FORMAT_UNDEFINED
    91.如果没有shader object绑定到任何graphics stage，且当前的render pass instance以vkCmdBeginRendering开始且VkRenderingInfo::colorAttachmentCount为1，且一个color attachment的 resolve mode为VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID，则VkRenderingInfo::pColorAttachments中每个resolveImageView不为VK_NULL_HANDLE的元素其对应image必须以和创建当前绑定的pipeline 相同的VkExternalFormatANDROID::externalFormat创建
    92.如果有一个shader object绑定到任何graphics stage，且当前的render pass 包含一个使用VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID resolve mode的color attachment，则（1）vkCmdSetColorBlendEnableEXT必须在该命令前设置blend enable为VK_FALSE
                                                                                                                                                                             （2）则vkCmdSetRasterizationSamplesEXT必须在该命令前设置rasterizationSamples为VK_SAMPLE_COUNT_1_BIT
                                                                                                                                                                             （3）则vkCmdSetFragmentShadingRateKHR必须在该命令前设置pFragmentSize->width为1，pFragmentSize->height为1
    93.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT动态state开启创建， 则vkCmdSetColorWriteEnableEXT 必须在该命令之前设置，且设置的attachmentCount必须大于等于创建当前绑定的pipeline的VkPipelineColorBlendStateCreateInfo::attachmentCount
                                    （2）以VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT动态state开启创建， 则vkCmdSetDiscardRectangleEXT 必须在该命令之前为每个VkPipelineDiscardRectangleStateCreateInfoEXT::discardRectangleCount指明的discard rectangle 设置
                                    （3）以VK_DYNAMIC_STATE_DISCARD_RECTANGLE_ENABLE_EXT动态state开启创建， 则vkCmdSetDiscardRectangleEnableEXT 必须在该命令之前设置
                                    （4）以VK_DYNAMIC_STATE_DISCARD_RECTANGLE_MODE_EXT动态state开启创建， 则vkCmdSetDiscardRectangleModeEXT 必须在该命令之前设置
    94.如果有一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                    （1）如果colorWriteEnable特性在device上开启，则vkCmdSetColorWriteEnableEXT 必须在该命令之前设置，且设置的attachmentCount必须大于等于当前render pass instance的color attachment的数量
                                    （2）如果VK_EXT_discard_rectangles拓展开启，且最近的vkCmdSetDiscardRectangleEnableEXT设置discardRectangleEnable为VK_TRUE， 则vkCmdSetDiscardRectangleEXT 必须在该命令之前设置
                                    （3）如果VK_EXT_discard_rectangles拓展开启， 则vkCmdSetDiscardRectangleEnableEXT 必须在该命令之前设置
                                    （4）如果VK_EXT_discard_rectangles拓展开启， 则最近的vkCmdSetDiscardRectangleEnableEXT设置discardRectangleEnable为VK_TRUE，则vkCmdSetDiscardRectangleModeEXT 必须在该命令之前设置
    95.如果当前的render pass instance以vkCmdBeginRendering开始，则（1）如果VkRenderingFragmentShadingRateAttachmentInfoKHR::imageView不为VK_NULL_HANDLE，则当前绑定的graphics pipeline必须以VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR创建
                                                                  （2）如果VkRenderingFragmentDensityMapAttachmentInfoEXT::imageView不为VK_NULL_HANDLE，则当前绑定的graphics pipeline必须以VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT创建
                                                                  （3）且含VkRenderingInfo::colorAttachmentCount大于0，如果当前的绑定的pipeline以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，则VkRenderingInfo::pColorAttachments中每个imageView不为VK_NULL_HANDLE的元素的imageView，必须以当前pipeline的VkAttachmentSampleCountInfoAMD 或者 VkAttachmentSampleCountInfoNV中的pColorAttachmentSamples中对应元素的sample count进行创建
                                                                  （4）如果当前的绑定的pipeline以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且VkRenderingInfo::pDepthAttachment中的imageView不为VK_NULL_HANDLE，则当前pipeline的VkAttachmentSampleCountInfoAMD 或者 VkAttachmentSampleCountInfoNV中的depthStencilAttachmentSamples必须等于创建VkRenderingInfo::pDepthAttachment->imageView的sample count
                                                                  （5）如果当前的绑定的pipeline以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且VkRenderingInfo::pStencilAttachment中的imageView不为VK_NULL_HANDLE，则当前pipeline的VkAttachmentSampleCountInfoAMD 或者 VkAttachmentSampleCountInfoNV中的depthStencilAttachmentSamples必须等于创建VkRenderingInfo::pStencilAttachment->imageView的sample count
                                                                  （6）且含VkRenderingInfo::colorAttachmentCount大于0，如果当前的绑定的pipeline不以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且multisampledRenderToSingleSampled特性没有开启，则VkRenderingInfo::pColorAttachments中每个imageView不为VK_NULL_HANDLE的元素的imageView，其创建的sample count必须等于当前绑定的graphics pipeline的rasterizationSamples
                                                                  （7）如果当前的绑定的pipeline不以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且VkRenderingInfo::pDepthAttachment中的imageView不为VK_NULL_HANDLE，且multisampledRenderToSingleSampled特性没有开启，则当前pipeline的rasterizationSamples 必须等于创建VkRenderingInfo::pDepthAttachment->imageView的sample count
                                                                  （8）如果当前的绑定的pipeline不以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且VkRenderingInfo::pStencilAttachment中的imageView不为VK_NULL_HANDLE，且multisampledRenderToSingleSampled特性没有开启，则当前pipeline的rasterizationSamples 必须等于创建VkRenderingInfo::pStencilAttachment->imageView的sample count
                                                                  （9）当前绑定的pipeline必须VkGraphicsPipelineCreateInfo::renderPass为VK_NULL_HANDLE创建
                                                                  （10）如果绑定的pipeline的fragment shader静态写入一个color attachment，且color write mask不为0，启用了color writes，且该附件对应的VkRenderingInfo::pColorAttachments->imageView 不为VK_NULL_HANDLE，则对应的创建pipeline的VkPipelineRenderingCreateInfo::pColorAttachmentFormats中的元素不能为VK_FORMAT_UNDEFINED
                                                                  （11）如果绑定的pipeline启用了depth test，启用了depth writes，且VkRenderingInfo::pDepthAttachment->imageView 不为VK_NULL_HANDLE，则创建pipeline的VkPipelineRenderingCreateInfo::depthAttachmentFormat不能为VK_FORMAT_UNDEFINED
                                                                  （12）如果绑定的pipeline启用了stencil test，且VkRenderingInfo::pStencilAttachment->imageView 不为VK_NULL_HANDLE，则创建pipeline的VkPipelineRenderingCreateInfo::stencilAttachmentFormat不能为VK_FORMAT_UNDEFINED
    96.如果该命令在以vkCmdBeginRendering开始的render pass instance中调用，且VkRenderingInfo的pNext中包含一个multisampledRenderToSingleSampledEnable设为VK_TRUE的VkMultisampledRenderToSingleSampledInfoEXT，则当前绑定的graphics pipeline的rasterizationSamples必须等于VkMultisampledRenderToSingleSampledInfoEXT::rasterizationSamples
    97.如果primitivesGeneratedQueryWithRasterizerDiscard特性未开启，且VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query激活，则不能启用rasterization discard
    98.如果primitivesGeneratedQueryWithNonZeroStreams特性未开启，且VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query激活，则 绑定的graphics pipeline不能以VkPipelineRasterizationStateStreamCreateInfoEXT::rasterizationStream为非零值创建
    98.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_TESSELLATION_DOMAIN_ORIGIN_EXT动态state开启创建，则vkCmdSetTessellationDomainOriginEXT必须在该命令之前设置
                                    （2）以VK_DYNAMIC_STATE_DEPTH_CLAMP_ENABLE_EXT动态state开启创建，则vkCmdSetDepthClampEnableEXT必须在该命令之前设置
                                    （3）以VK_DYNAMIC_STATE_POLYGON_MODE_EXT动态state开启创建，则vkCmdSetPolygonModeEXT必须在该命令之前设置
                                    （4）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，则vkCmdSetRasterizationSamplesEXT必须在该命令之前设置
                                    （5）以VK_DYNAMIC_STATE_SAMPLE_MASK_EXT动态state开启创建，则vkCmdSetSampleMaskEXT必须在该命令之前设置
                                    （6）以VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT动态state开启创建，则vkCmdSetAlphaToCoverageEnableEXT必须在该命令之前设置
                                    （7）以VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT动态state开启创建，则最近的vkCmdSetAlphaToCoverageEnableEXT设置alphaToCoverageEnable为VK_TRUE，则Fragment Output Interface中 Index 0的Location 0必须有一个含alpha Component的变量
                                    （8）以VK_DYNAMIC_STATE_ALPHA_TO_ONE_ENABLE_EXT动态state开启创建，则vkCmdSetAlphaToOneEnableEXT必须在该命令之前设置
                                    （9）以VK_DYNAMIC_STATE_LOGIC_OP_ENABLE_EXT动态state开启创建，则vkCmdSetLogicOpEnableEXT必须在该命令之前设置
                                    （10）以VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态state开启创建，则vkCmdSetColorBlendEnableEXT必须在该命令之前设置
                                    （11）以VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT动态state开启创建，则vkCmdSetColorBlendEquationEXT必须在该命令之前设置
                                    （12）以VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT动态state开启创建，则vkCmdSetColorWriteMaskEXT必须在该命令之前设置
    
    99.如果一个shader object绑定到VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT stage，则vkCmdSetTessellationDomainOriginEXT必须在该命令之前设置
    100.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                                    （1）如果depthClamp特性启用，则vkCmdSetDepthClampEnableEXT必须在该命令之前设置
                                                    （2）则vkCmdSetPolygonModeEXT必须在该命令之前设置
                                                    （3）则vkCmdSetRasterizationSamplesEXT必须在该命令之前设置
                                                    （4）则vkCmdSetSampleMaskEXT必须在该命令之前设置
                                                    （5）则vkCmdSetAlphaToCoverageEnableEXT必须在该命令之前设置
                                                    （6）如果alphaToOne特性启用，则vkCmdSetAlphaToOneEnableEXT必须在该命令之前设置
    
    101.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetAlphaToCoverageEnableEXT设置alphaToCoverageEnable为VK_TRUE，则Fragment Output Interface中 Index 0的Location 0必须有一个含alpha Component的变量
    102.如果一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                        （1）如果logicOp特性开启 ,vkCmdSetLogicOpEnableEXT必须在该命令之前设置
                                        （2）如果绑定了color attachments，则vkCmdSetColorBlendEnableEXT必须在该命令之前设置
                                        （3）如果最近的vkCmdSetColorBlendEnableEXT设置任何附件在pColorBlendEnables中的值为VK_TRUE ，则vkCmdSetColorBlendEquationEXT必须在该命令之前设置
                                        （4）如果绑定了color attachments，则vkCmdSetColorWriteMaskEXT必须在该命令之前设置
    
    103.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT动态state开启创建，则vkCmdSetRasterizationStreamEXT必须在该命令之前设置
                                     （2）以VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT动态state开启创建，则vkCmdSetConservativeRasterizationModeEXT必须在该命令之前设置
                                     （3）以VK_DYNAMIC_STATE_EXTRA_PRIMITIVE_OVERESTIMATION_SIZE_EXT动态state开启创建，则vkCmdSetExtraPrimitiveOverestimationSizeEXT必须在该命令之前设置
                                     （4）以VK_DYNAMIC_STATE_DEPTH_CLIP_ENABLE_EXT动态state开启创建，则vkCmdSetDepthClipEnableEXT必须在该命令之前设置
                                     （5）以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT动态state开启创建，则vkCmdSetSampleLocationsEnableEXT必须在该命令之前设置
                                     （6）以VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT动态state开启创建，则vkCmdSetColorBlendAdvancedEXT必须在该命令之前设置
                                     （7）以VK_DYNAMIC_STATE_PROVOKING_VERTEX_MODE_EXT动态state开启创建，则vkCmdSetProvokingVertexModeEXT必须在该命令之前设置
                                     （8）以VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT动态state开启创建，则vkCmdSetLineRasterizationModeEXT必须在该命令之前设置
                                     （9）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT动态state开启创建，则vkCmdSetLineStippleEnableEXT必须在该命令之前设置
                                     （10）以VK_DYNAMIC_STATE_LINE_STIPPLE_KHR动态state开启创建，则vkCmdSetLineStippleKHR必须在该命令之前设置
                                     （11）以VK_DYNAMIC_STATE_DEPTH_CLIP_NEGATIVE_ONE_TO_ONE_EXT动态state开启创建，则vkCmdSetDepthClipNegativeOneToOneEXT必须在该命令之前设置
                                     （12）以VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_ENABLE_NV动态state开启创建，则vkCmdSetViewportWScalingEnableNV必须在该命令之前设置
                                     （13）以VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV动态state开启创建，则vkCmdSetViewportSwizzleNV必须在该命令之前设置
                                     （14）以VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV动态state开启创建，则vkCmdSetCoverageToColorEnableNV必须在该命令之前设置
                                     （15）以VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_LOCATION_NV动态state开启创建，则vkCmdSetCoverageToColorLocationNV必须在该命令之前设置
                                     （16）以VK_DYNAMIC_STATE_COVERAGE_MODULATION_MODE_NV动态state开启创建，则vkCmdSetCoverageModulationModeNV必须在该命令之前设置
                                     （17）以VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV动态state开启创建，则vkCmdSetCoverageModulationTableEnableNV必须在该命令之前设置
                                     （18）以VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_NV动态state开启创建，则vkCmdSetCoverageModulationTableNV必须在该命令之前设置
                                     （19）以VK_DYNAMIC_STATE_SHADING_RATE_IMAGE_ENABLE_NV动态state开启创建，则vkCmdSetShadingRateImageEnableNV必须在该命令之前设置
                                     （20）以VK_DYNAMIC_STATE_REPRESENTATIVE_FRAGMENT_TEST_ENABLE_NV动态state开启创建，则vkCmdSetRepresentativeFragmentTestEnableNV必须在该命令之前设置
                                     （21）以VK_DYNAMIC_STATE_COVERAGE_REDUCTION_MODE_NV动态state开启创建，则vkCmdSetCoverageReductionModeNV必须在该命令之前设置
    
    104.如果一个shader object绑定到VK_SHADER_STAGE_GEOMETRY_BIT stage，且如果geometryStreams 特性开启，则vkCmdSetRasterizationStreamEXT必须在该命令之前设置
    105.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                            （1）如果VK_EXT_conservative_rasterization 拓展开启，vkCmdSetConservativeRasterizationModeEXT必须在该命令之前设置
                            （2）如果VK_EXT_conservative_rasterization 拓展开启，且最近的vkCmdSetConservativeRasterizationModeEXT设置conservativeRasterizationMode为VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT，则vkCmdSetExtraPrimitiveOverestimationSizeEXT必须在该命令之前设置
                            （3）如果VK_EXT_sample_locations 拓展开启，则vkCmdSetSampleLocationsEnableEXT必须在该命令之前设置
    106.如果一个shader object绑定到任何graphics stage，且depthClipEnable 特性开启，则vkCmdSetDepthClipEnableEXT必须在该命令之前设置
    107.如果如果一个shader object绑定到任何VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且如果VK_EXT_blend_operation_advanced 拓展开启，则vkCmdSetColorBlendEquationEXT 和 vkCmdSetColorBlendAdvancedEXT中至少一个必须在该命令之前设置
    108.如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，如果VK_EXT_provoking_vertex拓展开启， 则vkCmdSetProvokingVertexModeEXT必须在该命令之前设置
    109.如果VK_KHR_line_rasterization 或者 VK_EXT_line_rasterization拓展开启，则（1）如果一个shader object绑定到任意一个graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetPolygonModeEXT设置polygonMode 为VK_POLYGON_MODE_LINE ，则vkCmdSetLineRasterizationModeEXT必须在该命令之前设置
                                                                                （2）如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetPrimitiveTopology设置primitiveTopology 为任何line topology ，则vkCmdSetLineRasterizationModeEXT必须在该命令之前设置
                                                                                （3）如果一个输出为line primitive的shader object绑定到VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或 VK_SHADER_STAGE_GEOMETRY_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则vkCmdSetLineRasterizationModeEXT必须在该命令之前设置
                                                                                （4）如果一个shader object绑定到任意一个graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetPolygonModeEXT设置polygonMode 为VK_POLYGON_MODE_LINE ，则vkCmdSetLineStippleEnableEXT必须在该命令之前设置
                                                                                （5）如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetPrimitiveTopology设置primitiveTopology 为任何line topology ，则vkCmdSetLineStippleEnableEXT必须在该命令之前设置
                                                                                （6）如果一个输出为line primitive的shader object绑定到VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或 VK_SHADER_STAGE_GEOMETRY_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则vkCmdSetLineStippleEnableEXT必须在该命令之前设置
                                                                                （7）如果一个shader object绑定到任意一个graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetLineStippleEnableEXT设置stippledLineEnable 为VK_TRUE ，则vkCmdSetLineStippleEXT必须在该命令之前设置
    110.如果一个shader object绑定到任何graphics stage，（1）如果depthClipControl 特性开启，则vkCmdSetDepthClipNegativeOneToOneEXT必须在该命令之前设置
                                                       （2）VK_NV_clip_space_w_scaling 拓展开启，则vkCmdSetViewportWScalingEnableNV必须在该命令之前设置
                                                       （3）VK_NV_viewport_swizzle 拓展开启，则vkCmdSetViewportSwizzleNV必须在该命令之前设置
    111.如果如果一个shader object绑定到任何VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                        （1）如果VK_NV_fragment_coverage_to_color 拓展开启，则vkCmdSetCoverageToColorEnableNV 必须在该命令之前设置
                        （2）如果VK_NV_fragment_coverage_to_color 拓展开启，且最近的vkCmdSetCoverageToColorEnableNV 设置coverageToColorEnable 为VK_TRUE，则vkCmdSetCoverageToColorLocationNV 必须在该命令之前设置
                        （3）如果pipelineFragmentShadingRate 特性开启，则vkCmdSetFragmentShadingRateKHR 必须在该命令之前设置
    112.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                （1）如果VK_NV_framebuffer_mixed_samples 拓展开启，则vkCmdSetCoverageModulationModeNV 必须在该命令之前设置
                                （2）如果VK_NV_framebuffer_mixed_samples 拓展开启，且最近的vkCmdSetCoverageModulationModeNV设置coverageModulationMode为任何除VK_COVERAGE_MODULATION_MODE_NONE_NV之外的值，则vkCmdSetCoverageModulationTableEnableNV 必须在该命令之前设置
                                （3）如果VK_NV_framebuffer_mixed_samples 拓展开启，最近的vkCmdSetCoverageModulationTableEnableNV设置coverageModulationTableEnable为VK_TRUE，则vkCmdSetCoverageModulationTableNV 必须在该命令之前设置
                                （4）如果shadingRateImage 特性开启，则vkCmdSetShadingRateImageEnableNV 必须在该命令之前设置
                                （5）如果representativeFragmentTest 特性开启，则vkCmdSetRepresentativeFragmentTestEnableNV 必须在该命令之前设置
                                （6）如果coverageReductionMode 特性开启，则vkCmdSetCoverageReductionModeNV 必须在该命令之前设置
    113.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态state开启创建，且最近的vkCmdSetColorBlendEnableEXT设置任何附件在pColorBlendEnables中的值为VK_TRUE 则subpas中这些附件对应的image view的format features中必须包含VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT
                                     （2）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，且当前subpass不使用任何color和/或者 depth/stencil attachments，则最后的vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples必须符合zero￾attachment subpass的规则
                                     （3）以VK_DYNAMIC_STATE_SAMPLE_MASK_EXT不以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT 动态state开启创建，则最后调用的vkCmdSetSampleMaskEXT中设置的samples参数必须大于等于创建该pipeline的VkPipelineMultisampleStateCreateInfo::rasterizationSamples
                                     （4）以VK_DYNAMIC_STATE_SAMPLE_MASK_EXT和 VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT 动态state开启创建，则最后调用的vkCmdSetSampleMaskEXT中设置的samples参数必须大于等于最后的vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples
                                     （5）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，且VK_AMD_mixed_attachment_samples和VK_NV_framebuffer_mixed_samples拓展都没有开启，则最后的vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples必须等于subpass中color和/或者 depth/stencil attachments使用的相同
                                     （6）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，或者一个shader object绑定到任意graphics stage，且当前的subpass包含一个multisampledRenderToSingleSampledEnable 为VK_TRUE的VkMultisampledRenderToSingleSampledInfoEXT，则最后的vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples必须等于该VkMultisampledRenderToSingleSampledInfoEXT中的对应成员
                                     （7）以VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态state开启创建，则vkCmdSetColorBlendEnableEXT 必须在该命令之前设置，且vkCmdSetColorBlendEnableEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定值
                                     （8）以VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT动态state开启创建，则vkCmdSetColorBlendEquationEXT 必须在该命令之前设置，且vkCmdSetColorBlendEquationEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定blend equations
                                     （9）以VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT动态state开启创建，则vkCmdSetColorWriteMaskEXT 必须在该命令之前设置，且vkCmdSetColorWriteMaskEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定color write mask
                                     （10）以VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT动态state开启创建，则vkCmdSetColorBlendAdvancedEXT 必须在该命令之前设置，且vkCmdSetColorBlendAdvancedEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活blend的color attachments指定advanced blend equations
                                     （11）以VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT和VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态state开启创建，且最后的vkCmdSetColorBlendEnableEXT和vkCmdSetColorBlendAdvancedEXT设置启用了advanced blending，则当前subpass中激活的color attachments的数量不能超过advancedBlendMaxColorAttachments
                                     （12）以VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT动态state开启创建，且如果primitivesGeneratedQueryWithNonZeroStreams特性未开启且VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query已经激活，则最后的vkCmdSetRasterizationStreamEXT必须设置rasterizationStream为0
                                     （13）以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT但不以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，则最后的vkCmdSetSampleLocationsEXT设置的pSampleLocationsInfo->sampleLocationsPerPixel必须等于创建pipeline的VkPipelineMultisampleStateCreateInfo::rasterizationSamples
                                     （14）以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT和VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，则最后的vkCmdSetSampleLocationsEXT设置的pSampleLocationsInfo->sampleLocationsPerPixel必须等于最后vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples
                                     （15）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT但不以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT动态state开启创建，且绑定的pipeline的VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable为VK_TRUE 或者以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT动态state开启，则sampleLocationsInfo.sampleLocationsPerPixel 必须等于最后vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples
                                     （16）以VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV动态state开启创建，且最后的vkCmdSetCoverageToColorEnableNV设置coverageToColorEnable为VK_TRUE，则当前subpass必须有color attachment，且该attachment的format必须为VK_FORMAT_R8_UINT, VK_FORMAT_R8_SINT, VK_FORMAT_R16_UINT, VK_FORMAT_R16_SINT, VK_FORMAT_R32_UINT, 或者 VK_FORMAT_R32_SINT，且该attachment的location 有最后的vkCmdSetCoverageToColorLocationNV设置的coverageToColorLocation决定
                                     （17）以VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV和VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT 动态state开启创建，且如果VK_NV_coverage_reduction_mode 拓展开启，则当前的 coverageReductionMode，rasterizationSamples 以及color 以及 depth/stencil attachments（如果subpass有）的sample count必须是有效的返回值vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV的值的组合
                                     （18）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT但不以VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV 动态state开启创建，则绑定的graphics pipeline的VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount 必须大于等于最后vkCmdSetViewportWithCount设置的viewportCount
                                     （19）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT和VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV 动态state开启创建，则最后vkCmdSetViewportSwizzleNV设置的viewportCount 必须大于等于最后vkCmdSetViewportWithCount设置的viewportCount
                                     （20）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT或者 VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT 动态state开启创建，如果当前的stippledLineEnable为VK_TRUE，且当前的lineRasterizationMode为VK_LINE_RASTERIZATION_MODE_RECTANGULAR_KHR，则stippledRectangularLines 特性必须开启
                                     （21）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT或者 VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT 动态state开启创建，如果当前的stippledLineEnable为VK_TRUE，且当前的lineRasterizationMode为VK_LINE_RASTERIZATION_MODE_BRESENHAM_KHR，则stippledBresenhamLines 特性必须开启
                                     （22）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT或者 VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT 动态state开启创建，如果当前的stippledLineEnable为VK_TRUE，且当前的lineRasterizationMode为VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_KHR，则stippledSmoothLines 特性必须开启
                                     （23）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT或者 VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT 动态state开启创建，如果当前的stippledLineEnable为VK_TRUE，且当前的lineRasterizationMode为VK_LINE_RASTERIZATION_MODE_DEFAULT_KHR，则stippledRectangularLines 特性必须开启且VkPhysicalDeviceLimits::strictLines 必须为VK_TRUE
                                     （24）以VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT 动态state开启创建，且conservativePointAndLineRasterization不支持，最后的 pre-rasterization shader stage输出的有效图元拓扑为点或者线，则最后vkCmdSetConservativeRasterizationModeEXT设置的conservativeRasterizationMode 必须为VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT
                                     （25）以VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT 动态state开启创建，则vkCmdSetAttachmentFeedbackLoopEnableEXT 必须在该命令之前调用
    114.如果一个shader object绑定到 VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                                                                        （1）则vkCmdSetColorBlendEnableEXT 必须在该命令之前设置，且vkCmdSetColorBlendEnableEXT指定的firstAttachment开始的attachmentCount的值必须为当前subpass所有激活的color attachments指定
                                                                                        （2）则vkCmdSetColorBlendEquationEXT 必须在该命令之前设置，且vkCmdSetColorBlendEquationEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定blend equations
                                                                                        （3）则vkCmdSetColorWriteMaskEXT 必须在该命令之前设置，且vkCmdSetColorWriteMaskEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定color write mask
                                                                                        （4）如果VK_NV_fragment_coverage_to_color拓展开启， 最后的vkCmdSetCoverageToColorEnableNV设置coverageToColorEnable为VK_TRUE，则当前subpass必须有color attachment，且该attachment的format必须为VK_FORMAT_R8_UINT, VK_FORMAT_R8_SINT, VK_FORMAT_R16_UINT, VK_FORMAT_R16_SINT, VK_FORMAT_R32_UINT, 或者 VK_FORMAT_R32_SINT，且该attachment的location 有最后的vkCmdSetCoverageToColorLocationNV设置的coverageToColorLocation决定
    115.如果一个shader object绑定到 VK_SHADER_STAGE_FRAGMENT_BIT stage，（1）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT动态state开启创建，且最近的vkCmdSetSampleLocationsEnableEXT设置sampleLocationsEnable为VK_TRUE，且该subpass含有depth/stencil attachment，则该附件必须以VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT创建
                                                                        （2）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT和VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT 动态state开启创建，且最近的vkCmdSetSampleLocationsEnableEXT设置sampleLocationsEnable为VK_TRUE，则 最后vkCmdSetSampleLocationsEXT设置的sampleLocationsInfo.sampleLocationGridSize.width以及height 必须等于被调用vkGetPhysicalDeviceMultisamplePropertiesEXT传入rasterizationSamples返回的VkMultisamplePropertiesEXT::sampleLocationGridSize.width以及height一一对应均匀整除
                                                                        （3）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT 动态state开启创建，且最近的vkCmdSetSampleLocationsEnableEXT设置sampleLocationsEnable为VK_TRUE，则fragment shader代码中不能静态使用扩展指令InterpolateAtSample
                                                                        （4）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT但不以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT 动态state开启创建，且绑定的pipeline的VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable为VK_TRUE 或者以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT动态state开启，则 最后vkCmdSetRasterizationSamplesEXT设置的sampleLocationsInfo.sampleLocationGridSize.width以及height 必须等于被调用vkGetPhysicalDeviceMultisamplePropertiesEXT传入和vkCmdSetRasterizationSamplesEXT设置的相同rasterizationSamples的samples返回的VkMultisamplePropertiesEXT::sampleLocationGridSize.width以及height一一对应均匀整除
    116.如果一个shader object绑定到任何graphics stage，（1）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV 动态state开启创建，且最近的vkCmdSetCoverageModulationTableEnableNV设置coverageModulationTableEnable为VK_TRUE，则最近的vkCmdSetCoverageModulationTableNV 设置的coverageModulationTableCount 必须等于当前rasterizationSamples除以当前subppas的color samples
                                                       （2）如果VK_NV_viewport_swizzle 拓展开启，则最后vkCmdSetViewportSwizzleNV设置的viewportCount 必须大于等于最后vkCmdSetViewportWithCount设置的viewportCount
    117.如果VK_NV_framebuffer_mixed_samples 拓展开启，且如果在绑定的graphics pipeline中当前subpass有一个depth/stencil attachment以及dep test, stencil test, 或depth bounds test 启用，则当前rasterizationSamples 必须等于depth/stencil attachment的sample count
    118.如果VK_NV_framebuffer_mixed_samples 拓展开启，且如果最后的vkCmdSetRasterizationSamplesEXT设置的当前subpass的任何color attachments的rasterizationSamples 都大于 color samples，则sampleShadingEnable 必须为VK_FALSE
    119.如果当前绑定的graphics pipeline以VkGraphicsPipelineCreateInfo::pStages中的元素的VkPipelineShaderStageCreateInfo::stage设置为VK_SHADER_STAGE_VERTEX_BIT, VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT, VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或者 VK_SHADER_STAGE_GEOMETRY_BIT创建，则Mesh Shader Queries 不能激活
    120.如果dynamic state继承自VkCommandBufferInheritanceViewportScissorInfoNV，则这些动态state的设置必须在该命令之前设置
    121.如果没有绑定graphics pipeline，则（1）vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_VERTEX_BIT
                                         （2）如果tessellationShader 特性开启，vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT，VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT
                                         （3）如果geometryShader 特性开启，vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_GEOMETRY_BIT
                                         （4）vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_FRAGMENT_BIT
                                         （5）如果taskShader 特性开启，vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_TASK_BIT_EXT
                                         （6）如果meshShader 特性开启，vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_MESH_BIT_EXT
                                         （8）如果至少taskShader 和 meshShader一个特性开启，VK_SHADER_STAGE_VERTEX_BIT 或者VK_SHADER_STAGE_MESH_BIT_EXT stages中的一个必须含有有效的VkShaderEXT绑定，另外一个则不含有VkShaderEXT绑定
                                         （9）如果taskShader 和 meshShader特性同时开启，且一个有效的VkShaderEXT 绑定到VK_SHADER_STAGE_MESH_BIT_EXT stage，且该VkShaderEXT不以VK_SHADER_CREATE_NO_TASK_SHADER_BIT_EXT 创建，则一个有效的VkShaderEXT必须绑定到VK_SHADER_STAGE_TASK_BIT_EXT stage
                                         （10）如果taskShader 和 meshShader特性同时开启，且一个有效的VkShaderEXT 绑定到VK_SHADER_STAGE_MESH_BIT_EXT stage，且该VkShaderEXT以VK_SHADER_CREATE_NO_TASK_SHADER_BIT_EXT 创建，则不能有VkShaderEXT绑定到VK_SHADER_STAGE_TASK_BIT_EXT stage
                                         （11）如果一个有效的VkShaderEXT 绑定到VK_SHADER_STAGE_VERTEX_BIT stage，则不能有VkShaderEXT绑定到VK_SHADER_STAGE_TASK_BIT_EXT stage或者VK_SHADER_STAGE_MESH_BIT_EXT stage中的一个
    122.如果任何绑定的graphics shader以VK_SHADER_CREATE_LINK_STAGE_BIT_EXT 创建，（1）所有在相同vkCreateShadersEXT中以VK_SHADER_CREATE_LINK_STAGE_BIT_EXT创建的shaders必须也要绑定
                                                                                 （2）任何相同vkCreateShadersEXT中不以VK_SHADER_CREATE_LINK_STAGE_BIT_EXT创建的shaders不能有任何VkShaderEXT绑定
    123.所有绑定的graphics shader objects 必须以相同或者相同定义的push constant ranges创建
    124.所有绑定的graphics shader objects 必须以相同或者相同定义的descriptor set layouts的数组创建
    125.如果当前的render pass instance以vkCmdBeginRendering开始，且VkRenderingInfo::colorAttachmentCount为1，且有一个resolve mode为 VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID 的color attachment，且绑定了fragment shader，则DepthReplacing 和 StencilRefReplacingEXT execution modes 不能声明
    126.如果一个shader object绑定到 VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则 （1）如果attachmentFeedbackLoopDynamicState 特性开启，则 vkCmdSetAttachmentFeedbackLoopEnableEXT 必须在该命令之前调用
    127.如果包含一个fragment shader stage的绑定的graphics pipeline，（1）且该pipeline以VkPipelineDynamicStateCreateInfo::pDynamicStates中设置有VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE创建，且该fragment shader声明了EarlyFragmentTests execution mode且使用了OpDepthAttachmentReadEXT，则最后vkCmdSetDepthWriteEnable 设置的 depthWriteEnable 必须为VK_FALSE
                                                                    （2）且该pipeline以VkPipelineDynamicStateCreateInfo::pDynamicStates中设置有VK_DYNAMIC_STATE_STENCIL_WRITE_MASK创建，且该fragment shader声明了EarlyFragmentTests execution mode且使用了OpStencilAttachmentReadEXT，则最后vkCmdSetStencilWriteMask 设置的 writeMask 必须为0
    128.如果一个shader object绑定到任何graphics stage 或者绑定的graphics pipeline 以VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT 动态state开启创建，且任何color attachment的format为VK_FORMAT_E5B9G9R9_UFLOAT_PACK32，则vkCmdSetColorWriteMaskEXT设置的pColorWriteMasks参数的对应元素必须包含VK_COLOR_COMPONENT_R_BIT, VK_COLOR_COMPONENT_G_BIT, 和 VK_COLOR_COMPONENT_B_BIT，或者都不包含
    129.如果任何附件开启了blending，且该附件的source 或者 destination blend factors使用第二个颜色输入，则该命令执行的Fragment Execution Model静态使用的任何输出output attachment的Location的最大值必须小于maxFragmentDualSrcAttachments
    130.如果当前的render pass instance以vkCmdBeginRendering开始，（1）如果没有任何shader object绑定到任何graphics stage，则vkCmdSetRenderingAttachmentLocationsKHR 设置的VkRenderingAttachmentLocationInfoKHR::pColorAttachmentLocations中的每个元素必须匹配设置在当前绑定的graphics pipeline中的对应元素
                                                                 （2）如果没有任何shader object绑定到任何graphics stage，绑定的graphics pipeline中的input attchment 索引中映射的附件必须匹配在当前render pass instance的VkRenderingInputAttachmentIndexInfoKHR中设置的
    131.如果当前的render pass instance以vkCmdBeginRendering开始且以VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT标志开始，则绑定的graphics pipeline必须以VK_PIPELINE_CREATE_2_ENABLE_LEGACY_DITHERING_BIT_EXT创建
    132.如果绑定的graphics pipeline以VK_PIPELINE_CREATE_2_ENABLE_LEGACY_DITHERING_BIT_EXT创建，则当前的render pass 必须以vkCmdBeginRendering开始且以VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT标志开始
    133.绑定的graphics pipeline不能以VkGraphicsPipelineCreateInfo::pStages中元素的VkPipelineShaderStageCreateInfo::stage设置为VK_SHADER_STAGE_VERTEX_BIT, VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT, VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或者 VK_SHADER_STAGE_GEOMETRY_BIT创建
    134.Transform Feedback Queries不能激活
    135.Primitives Generated Queries不能激活
    136.用于创建任何激活的Pipeline Statistics Query的pipelineStatistics 不能包含VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT,
                                                                                VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT,
                                                                                VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT,
                                                                                VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT,
                                                                                VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT,
                                                                                VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT,
                                                                                VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT,
                                                                                VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT, 或者
                                                                                VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT
    137.如果buffer是non-sparse，则它必须完全和连续地绑定到单个VkDeviceMemory对象
    138.buffer必须以VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT 标志创建
    139.offset必须是4的倍数
    140.commandBuffer必须不为protected command buffer
    141.如果multiDrawIndirect 特性未开启，drawCount 必须为0 或 1
    142.drawCount 必须小于等于VkPhysicalDeviceLimits::maxDrawIndirectCount\
    143.如果drawCount 大于1，则stride是4的倍数，并且必须大于或等于sizeof(VkDrawMeshTasksIndirectCommandNV)
    144.如果drawCount 为1，则(offset + sizeof(VkDrawMeshTasksIndirectCommandNV))必须小于等于buffer的大小
    145.如果drawCount 大于1，则(stride × (drawCount - 1) + offset + sizeof(VkDrawMeshTasksIndirectCommandNV))必须小于等于buffer的大小
    146.绑定到VK_PIPELINE_BIND_POINT_GRAPHICS绑定点的当前pipeline必须包含一个使用MeshNV Execution Model的shader stage
    
    */


    
    //记录一个绘制次数信息从buffer中获取的间接的mesh task 绘制命令    类似于 vkCmdDrawMeshTasksIndirectNV，只是绘制次数参数在countBuffer中指定,将从countBuffer中countOffset开始读取32-bit的无符号整数值作为绘制次数参数
    vkCmdDrawMeshTasksIndirectCountNV(commandBuffer, VkBuffer{/*假设这是一个有效的VkBuffer*/}/*buffer,包含绘制参数的的buffer.*/,0/*offset，为buffer中起始参数的字节偏移量.*/,
		VkBuffer{/*假设这是一个有效的VkBuffer*/ }/*countBuffer,包含绘制次数的buffer.*/, 0/*countOffset，为countBuffer中绘制次数参数的字节偏移量.*/, 
        1/*maxDrawCount，指明绘制的最大次数，实际的值为countBuffer中指定的和maxDrawCount的最小值.*/, sizeof(VkDrawMeshTasksIndirectCommandNV)/*stride,为buffer中两组连续参数之间的字节步长.*/);
    /*

     vkCmdDrawMeshTasksIndirectCountNV有效用法:
    1.如果一个VkSampler以其magFilter或者minFilter等于VK_FILTER_LINEAR创建，则（1）如果reductionMode为VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE，如果用于采样一个VkImageView作为该命令的结果的compareEnable为VK_FALSE，则该image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT
                                                                             （2）如果reductionMode为VK_SAMPLER_REDUCTION_MODE_MIN 或者VK_SAMPLER_REDUCTION_MODE_MAX之一 用于采样一个VkImageView作为该命令的结果，则该image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT
    2.如果一个VkSampler以其mipmapMode 等于VK_SAMPLER_MIPMAP_MODE_LINEAR创建，则（1）如果reductionMode为VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE，如果用于采样一个VkImageView作为该命令的结果的compareEnable为VK_FALSE，则该image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT
                                                                             （2）如果reductionMode为VK_SAMPLER_REDUCTION_MODE_MIN 或者VK_SAMPLER_REDUCTION_MODE_MAX之一 用于采样一个VkImageView作为该命令的结果，则该image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT
    3.如果一个VkSampler以其unnormalizedCoordinates等于VK_TRUE用于采样一个VkImageView作为该命令的结果创建，则（1）该image view的levelCount以及layerCount必须为1
                                                                                                            （2）该image view的viewType必须为VK_IMAGE_VIEW_TYPE_1D 或者 VK_IMAGE_VIEW_TYPE_2D
    4.如果一个VkImageView的采样带depth comparison操作，则image view的format features必须包含VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT
    5.如果一个VkImageView使用atomic operations作为该命令的结果进行访问，则image view的format features必须包含VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT
    6.如果一个VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER类型的 descriptor使用atomic operations作为该命令的结果进行访问，则storage texel buffer的format features必须包含VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT
    7.如果一个以VK_FILTER_CUBIC_EXT进行采样的VkImageView作为该命令的结果，则image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT
    8.如果VK_EXT_filter_cubic拓展没有开启，且有任何一个以VK_FILTER_CUBIC_EXT进行采样的VkImageView作为该命令的结果，则其VkImageViewType不能为VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, 或者 VK_IMAGE_VIEW_TYPE_CUBE_ARRAY
    9.任何一个以VK_FILTER_CUBIC_EXT进行采样的作为该命令的结果的VkImageView，其VkImageViewType和format 必须支持cubic filtering，参见vkGetPhysicalDeviceImageFormatProperties2返回的VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic
    10.任何一个以VK_FILTER_CUBIC_EXT进行采样且reduction mode为VK_SAMPLER_REDUCTION_MODE_MIN 或者 VK_SAMPLER_REDUCTION_MODE_MAX之一的作为该命令的结果的VkImageView，其VkImageViewType和format 必须支持带minmax filtering的cubic filtering，参见vkGetPhysicalDeviceImageFormatProperties2返回的VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax
    11.如果cubicRangeClamp特性没有开启，则有任何一个以VK_FILTER_CUBIC_EXT进行采样VkImageView的作为该命令的结果，VkSamplerReductionModeCreateInfo::reductionMode不能为VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM
    12.任何一个以VkSamplerReductionModeCreateInfo::reductionMode为VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM进行采样的作为该命令的结果的VkImageView必须以VK_FILTER_CUBIC_EXT进行采样
    13.如果selectableCubicWeights特性没有开启，则有任何一个以VK_FILTER_CUBIC_EXT进行采样VkImageView的作为该命令的结果，VkSamplerCubicWeightsCreateInfoQCOM::cubicWeights必须为VK_CUBIC_FILTER_WEIGHTS_CATMULL_ROM_QCOM
    14.任何一个以VkImageCreateInfo::flags含VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV创建的采样作为该命令结果的VkImage必须以VkSamplerAddressMode为VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE 进行采样
    15.对于任何作为storage image写入的VkImageView，且其OpTypeImage的format未知，则该image view的 format features必须包含VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT
    16.对于任何作为storage image读取的VkImageView，且其OpTypeImage的format未知，则该image view的 format features必须包含VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT
    17.对于任何作为storage storage texel buffer写入的VkBufferView，且其OpTypeImage的format未知，则该buffer view的 buffer features必须包含VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT
    18.对于任何作为storage storage texel buffer读取的VkBufferView，且其OpTypeImage的format未知，则该buffer view的 buffer features必须包含VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT
    19.对于每个在绑定的shader中静态使用的set n，一个descriptor set必须被绑定到相同pipeline bind point的set n处，该set n必须和创建当前VkPipeline的VkPipelineLayout或者和创建当前VkShaderEXT的VkDescriptorSetLayout 数组的set n处的布局兼容，参见Pipeline Layout Compatibility p1280
    20.对于每个在绑定的shader中静态使用的push constant，一个push constant值必须被绑定到相同pipeline bind point的对应处，该push constant必须和创建当前VkPipeline的VkPipelineLayout或者和创建当前VkShaderEXT的VkDescriptorSetLayout 数组中的对应处的布局兼容，参见Pipeline Layout Compatibility p1280
    21.如果maintenance4特性没有开启，则对于每个在绑定的shader中静态使用的push constant，一个push constant值必须被设置到相同pipeline bind point的对应处，该push constant必须和创建当前VkPipeline的VkPipelineLayout或者和创建当前VkShaderEXT的VkDescriptorSetLayout 数组中的对应处的布局兼容，参见Pipeline Layout Compatibility p1280
    22.每一个通过vkCmdBindDescriptorSets绑定的descriptor set的descriptors,如果是被不以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建的，且已经绑定到该命令使用的pipeline bind point的VkPipeline静态使用的，则这些descriptors必须是有效的，参见 descriptor validity p1328
    23.如果通过vkCmdBindDescriptorSets指定绑定到pipeline bind point的VkPipeline要使用的descriptors，则绑定的VkPipeline不能以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建
    24.在vkCmdSetDescriptorBufferOffsetsEXT中指定绑定的descriptor buffers的descriptors，则（1）如果绑定到pipeline bind point的该命令会使用的VkPipeline以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建，且这些descriptors是动态使用的，则这些descriptors必须是有效的
                                                                                          （2）如果绑定到pipeline bind point的对应stage的该命令会使用的VkShaderEXT，且这些descriptors是动态使用的，则这些descriptors必须是有效的
    25.在vkCmdSetDescriptorBufferOffsetsEXT中指定的descriptors在绑定到pipeline bind point的VkPipeline中使用，则VkPipeline必须以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建
    26.如果一个descriptor在以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建的VkPipeline中动态使用，则descriptor memory必须是驻留内存
    27.如果一个descriptor在以其VkDescriptorSetLayout以VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建的VkShaderEXT中动态使用，则descriptor memory必须是驻留内存
    28.如果shaderObject 特性没有开启，一个有效的pipeline必须绑定到这个命令使用的绑定到pipeline bind point上
    29.如果一个pipeline绑定到该命令使用的pipeline bind point上，则不能有任何动态state 设置命令设置任何该VkPipeline 中没有指定的动态 state
    30.如果一个VkPipeline绑定到该命令使用的pipeline bind point上 或者任何一个会访问一个使用unnormalized coordinates的VkSampler的 VkShaderEXT绑定到该命令使用的pipeline bind point上的pipeline的对应stage，则
                                                                                （1）在任何shader stage中，VkSampler不能用来采样任何类型为VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY 或者 VK_IMAGE_VIEW_TYPE_CUBE_ARRAY的VkImageView
                                                                                （2）在任何shader stage中，该VkSampler不能和任何带有名字中带有ImplicitLod，Dref 或者 Proj 的SPIR-V OpImageSample* 或者 OpImageSparseSample*指令一起使用
                                                                                （3）在任何shader stage中，该VkSampler不能和任何包含 LOD bias或者offset 值 的SPIR-V OpImageSample* or OpImageSparseSample*指令一起使用
    31.如果shaderObject开启，一个有效的pipeline必须绑定到该命令使用的pipeline bind point上或者一个有效的shader objects以及VK_NULL_HANDLE的组合必须绑定到该命令使用的pipeline bind point每一个支持的shader stage上
    32.如何绑定到该命令使用的pipeline bind point上的VkPipeline的任何stage会访问一个uniform buffer，且该stage对uniformBuffers不以启用VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT或者VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT 创建，且robustBufferAccess特性未开启，则该stage就不能访问绑定到相同pipeline bind point的descriptor set指定的buffer范围外的值
    33.如果robustBufferAccess特性未开启，且任何会访问uniform buffer的绑定到该命令使用的pipeline bind point上对应shader stage的VkShaderEXT，则其不能访问绑定到相同pipeline bind point的descriptor set指定的buffer范围外的值
    34.如何绑定到该命令使用的pipeline bind point上的VkPipeline的任何stage会访问一个storage buffer，且该stage对storageBuffers不以启用VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT或者VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT 创建，且robustBufferAccess特性未开启，则该stage就不能访问绑定到相同pipeline bind point的descriptor set指定的buffer范围外的值
    35.如果robustBufferAccess特性未开启，且任何会访问storage buffer的绑定到该命令使用的pipeline bind point上对应shader stage的VkShaderEXT，则其不能访问绑定到相同pipeline bind point的descriptor set指定的buffer范围外的值
    36.如果commandBuffer 是一个unprotected command buffer，且protectedNoFault 未支持，则任何绑定的shaders访问的资源不能是一个protected resource
    37.如果一个绑定的shader访问一个VkSampler 或者 VkImageView ，且启用了sampler Y′C BCR conversion，则只能使用OpImageSample* 或者 OpImageSparseSample*指令，不能使用ConstOffset 以及 Offset操作符
    38.如果一个VkImageView作为该命令的结果进行访问，则（1）image view 的viewType 必须匹配Instruction/Sampler/Image View Validation p1481中描述的OpTypeImage的Dim操作符
                                                      （2）image view 的foamrt的numeric type 必须匹配OpTypeImage的Sampled Type操作符
    39.如果一个VkImageView以一个不是VK_FORMAT_A8_UNORM_KHR的format创建且通过OpImageWrite作为该命令的结果进行访问，则该命令的Texel 操作符的Type必须至少包含和 image view的 format含有的components的个数相同的components个数
    40.如果一个VkImageView以VK_FORMAT_A8_UNORM_KHR的format创建且通过OpImageWrite作为该命令的结果进行访问，则该命令的Texel 操作符的Type必须包含4个components
    41.如果一个VkBufferView通过OpImageWrite作为该命令的结果进行访问，则该命令的Texel 操作符的Type必须至少包含和 buffer view的 format含有的components的个数相同的components个数
    42.如果一个带64-bit component的VkFormat的VkImageView作为该命令的结果进行访问，则该命令的OpTypeImage操作符的SampledType的宽度必须为64
    43.如果一个带少于64-bit component的VkFormat的VkImageView作为该命令的结果进行访问，则该命令的OpTypeImage操作符的SampledType的宽度必须为32
    44.如果一个带64-bit component的VkFormat的VkBufferView作为该命令的结果进行访问，则该命令的OpTypeImage操作符的SampledType的宽度必须为64位
    45.如果一个带少于64-bit component的VkFormat的VkBufferView作为该命令的结果进行访问，则该命令的OpTypeImage操作符的SampledType的宽度必须为32
    46.如果sparseImageInt64Atomics 特性未开启，则以VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT创建的VkImage对象不能被SampledType宽度为64位的OpTypeImage的atomic instructions访问
    47.如果sparseImageInt64Atomics 特性未开启，则以VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT创建的VkBuffer对象不能被SampledType宽度为64位的OpTypeImage的atomic instructions访问
    48.如果OpImageWeightedSampleQCOM用来采样一个作为该命令的结果的VkImageView，则该image view的format features必须包含VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM
    49.如果OpImageWeightedSampleQCOM用来采样一个作为该命令的结果的sample weight image的VkImageView，则该image view的format features必须包含VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM
    50.如果OpImageBoxFilterQCOM用来采样一个作为该命令的结果的VkImageView，则该image view的format features必须包含VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM
    51.如果OpImageBlockMatchSSDQCOM，或者 OpImageBlockMatchSADQCOM用来读取一个作为该命令的结果的VkImageView，则（1）该image view的format features必须包含VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM
                                                                                                               （2）如果是读取的reference image，指定的reference coordinates不能在integer texel coordinate validation 时候失败
    52.如果OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchWindowSSDQCOM, OpImageBlockMatchWindowSADQCOM, OpImageBlockMatchGatherSSDQCOM,
                                                OpImageBlockMatchGatherSADQCOM, OpImageBlockMatchSSDQCOM, 或者 OpImageBlockMatchSADQCOM用来采样一个作为该命令的结果的VkImageView，则该VkSampler必须以VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM创建
    53.如果任何除了OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchWindowSSDQCOM, OpImageBlockMatchWindowSADQCOM, OpImageBlockMatchGatherSSDQCOM, OpImageBlockMatchGatherSADQCOM, OpImageBlockMatchSSDQCOM, 或者 OpImageBlockMatchSADQCOM之外的指令使用VkSampler进行采样作为该命令的结果，则该sampler不能以VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM 创建
    54.如果OpImageBlockMatchWindow*QCOM or OpImageBlockMatchGather*QCOM指令用来读取VkImageView作为该命令的结果，则（1）VkImageView的format features必须包含VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM
                                                                                                                  （2）VkImageView的format必须只含有一个component
    55.如果OpImageBlockMatchWindow*QCOM or OpImageBlockMatchGather*QCOM指令用来读取一个引用的image作为该命令的结果，则指定的 reference coordinates不能在integer texel coordinate validation 时候失败
    56.任何该命令执行的shader invocation必须已经终止
    57.如果有一个类型位为VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM, VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, 或者 VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT中任意一个的descriptor作为该命令的结果进行访问，则该descriptor所指的image subresource的layout必须和该descriptor被写入时的layout相同。
    58.当前的 render pass  必须和绑定到VK_PIPELINE_BIND_POINT_GRAPHICS上的VkPipeline 创建时候的VkGraphicsPipelineCreateInfo中指定的renderPass兼容
    59.当前的 render pass  的subpass index必须和绑定到VK_PIPELINE_BIND_POINT_GRAPHICS上的VkPipeline 创建时候的VkGraphicsPipelineCreateInfo中指定的subpass相同
    60.如果任何shader静态访问一个input attachment，则有效的descriptor必须通过VkDescriptorSet被绑定到该pipeline中
    61.如果任何该pipeline执行shader以SubpassData的Dim操作符访问一个OpTypeImage变量，则该变量必须被一个对应当前subpass的input attachment的InputAttachmentIndex修饰
    62.在subpass中访问的Input attachment views必须以和该subpass相同定义的VkFormat创建，且必须以一个和当前绑定的VkFramebuffer的该附件引用的subpass的pInputAttachments[InputAttachmentIndex]附件兼容的VkImageView创建，参见Fragment Input Attachment Compatibility p1408
    63.在动态render pass中访问以VkRenderingInputAttachmentIndexInfoKHR的InputAttachmentIndex，或者VkRenderingInputAttachmentIndexInfoKHR:pDepthInputAttachmentIndex 或者 VkRenderingInputAttachmentIndexInfoKHR:pStencilInputAttachmentIndex为NULL情况下不指定InputAttachmentIndex的引用的Input attachment views，必须以和VkRenderingInfo中对应color, depth, 或者 stencil attachment兼容的VkImageView创建
    64.如果VkRenderingInputAttachmentIndexInfoKHR::pDepthInputAttachmentIndex 以及 VkRenderingInputAttachmentIndexInfoKHR::pStencilInputAttachmentIndex不为NULL，则在动态render pass中通过shader object访问Input attachment views必须指明InputAttachmentIndex
    65.如果在动态render pass中通过shader object访问Input attachment views指明了InputAttachmentIndex，则InputAttachmentIndex必须匹配VkRenderingInputAttachmentIndexInfoKHR中的index
    66.当前render pass所用的附件对应的image subresource底层内存的写入只能作为该命令的一个附件写入
    67.如果一个color attachment在之前的该subpass的命令中以load, store, 或者 resolve operations进行了写入，则其layout不为VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT，且有当前绑定的pipeline设有VK_PIPELINE_CREATE_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT，或者
                                    最后的vkCmdSetAttachmentFeedbackLoopEnableEXT调用包含VK_IMAGE_ASPECT_COLOR_BIT以及 没有绑定的pipeline 或者绑定的pipeline以VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT创建，则该附件只能以附件进行访问的，这两种情况中之一
    68.如果一个depth attachment在之前的该subpass的命令中以load, store, 或者 resolve operations进行了写入，则其layout不为VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT，且有当前绑定的pipeline设有VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT，或者
                                    最后的vkCmdSetAttachmentFeedbackLoopEnableEXT调用包含VK_IMAGE_ASPECT_DEPTH_BIT以及 没有绑定的pipeline 或者绑定的pipeline以VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT创建，则该附件只能以附件进行访问的，这两种情况中之一
    69.如果一个stencil attachment在之前的该subpass的命令中以load, store, 或者 resolve operations进行了写入，则其layout不为VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT，且有当前绑定的pipeline设有VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT，或者
                                    最后的vkCmdSetAttachmentFeedbackLoopEnableEXT调用包含VK_IMAGE_ASPECT_STENCIL_BIT以及 没有绑定的pipeline 或者绑定的pipeline以VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT创建，则该附件只能以附件进行访问的，这两种情况中之一
    70.如果一个attachment在之前的该subpass的命令中以load, store, 或者 resolve operations进行了写入,则该附件就不能再以除作为一个附件，storage image或者sampled image被该命令访问
    71.如果在之前的命令的subpass中以用作附件外的方式访问访问了一个当权subpass的附件所对的image subresource，则该命令就不能再将该image subresource用作附件进行写入
    72.如果当前render pass使用一个depth/stencil attachment，则（1）如果depth aspect的layout为read-only的layout，则不能启用depth writes
                                                              （2）如果stencil aspect的layout为read-only的layout，front 以及 back writeMask不为0，且stencil 测试开启，则所有stencil 操作必须为VK_STENCIL_OP_KEEP
    73.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_VIEWPORT动态state开启创建，则vkCmdSetViewport必须在该命令之前设置
                                    （2）以VK_DYNAMIC_STATE_SCISSOR动态state开启创建，则vkCmdSetScissor必须在该命令之前设置
                                    （3）以VK_DYNAMIC_STATE_LINE_WIDTH动态state开启创建，则vkCmdSetLineWidth必须在该命令之前设置
                                    （4）以VK_DYNAMIC_STATE_DEPTH_BIAS动态state开启创建，则vkCmdSetDepthBias或者vkCmdSetDepthBias2EXT 必须在该命令之前设置
                                    （5）以VK_DYNAMIC_STATE_BLEND_CONSTANTS动态state开启创建，则vkCmdSetBlendConstants 必须在该命令之前设置
                                    （6）以VK_DYNAMIC_STATE_DEPTH_BOUNDS动态state开启创建，且如果当前depthBoundsTestEnable为VK_TRUE， 则vkCmdSetDepthBounds 必须在该命令之前设置
                                    （7）以VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK动态state开启创建，且如果当前stencilTestEnable为VK_TRUE， 则vkCmdSetStencilCompareMask 必须在该命令之前设置
                                    （8）以VK_DYNAMIC_STATE_STENCIL_WRITE_MASK动态state开启创建，且如果当前stencilTestEnable为VK_TRUE， 则vkCmdSetStencilWriteMask 必须在该命令之前设置
                                    （9）以VK_DYNAMIC_STATE_STENCIL_REFERENCE动态state开启创建，且如果当前stencilTestEnable为VK_TRUE， 则vkCmdSetStencilReference 必须在该命令之前设置
                                    （10）以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT动态state开启创建， 则vkCmdSetSampleLocationsEXT 必须在该命令之前设置
                                    （11）以VK_DYNAMIC_STATE_CULL_MODE动态state开启创建， 则vkCmdSetCullMode 必须在该命令之前设置
                                    （12）以VK_DYNAMIC_STATE_FRONT_FACE动态state开启创建， 则vkCmdSetFrontFace 必须在该命令之前设置
                                    （13）以VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE动态state开启创建， 则vkCmdSetDepthTestEnable 必须在该命令之前设置
                                    （14）以VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE动态state开启创建， 则vkCmdSetDepthWriteEnable 必须在该命令之前设置
                                    （15）以VK_DYNAMIC_STATE_DEPTH_COMPARE_OP动态state开启创建， 则vkCmdSetDepthCompareOp 必须在该命令之前设置
                                    （16）以VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE动态state开启创建， 则vkCmdSetDepthBoundsTestEnable 必须在该命令之前设置
                                    （17）以VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE动态state开启创建， 则vkCmdSetStencilTestEnable 必须在该命令之前设置
                                    （18）以VK_DYNAMIC_STATE_STENCIL_OP动态state开启创建， 则vkCmdSetStencilOp 必须在该命令之前设置
                                    （19）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT但不以VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT 动态state开启创建， 则vkCmdSetViewportWithCount 必须在该命令之前设置，且vkCmdSetViewportWithCount设置的viewportCount必须匹配pipeline的VkPipelineViewportStateCreateInfo::scissorCount
                                    （20）以VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT但不以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT 动态state开启创建， 则vkCmdSetScissorWithCount 必须在该命令之前设置，且vkCmdSetScissorWithCount设置的scissorCount必须匹配pipeline的VkPipelineViewportStateCreateInfo::viewportCount
                                    （21）以VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT和VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT 动态state同时开启创建， 则vkCmdSetViewportWithCount以及vkCmdSetScissorWithCount 必须在该命令之前设置，且vkCmdSetViewportWithCount设置的viewportCount必须匹配vkCmdSetScissorWithCount设置的scissorCount
                                    （22）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT但不以VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV 动态state开启创建， 则绑定的pipeline必须以VkPipelineViewportWScalingStateCreateInfoNV::viewportCount 大于等于最近vkCmdSetViewportWithCount设置的viewportCount创建
                                    （23）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT和VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV 动态state开启创建， 则最近调用的vkCmdSetViewportWScalingNV设置的viewportCount 必须大于等于最近vkCmdSetViewportWithCount设置的viewportCount
                                    （24）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT但不以VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV 动态state开启创建， 则绑定的pipeline必须以VkPipelineViewportShadingRateImageStateCreateInfoNV::viewportCount 大于等于最近vkCmdSetViewportWithCount设置的viewportCount创建
                                    （25）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT和VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV 动态state开启创建， 则最近调用的vkCmdSetViewportShadingRatePaletteNV设置的viewportCount 必须大于等于最近vkCmdSetViewportWithCount设置的viewportCount
                                    （26）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT动态state开启且VkPipelineViewportStateCreateInfo的pNext中含有一个VkPipelineViewportSwizzleStateCreateInfoNV 创建， 则绑定的pipeline必须以VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount 大于等于最近vkCmdSetViewportWithCount设置的viewportCount创建
                                    （27）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT动态state开启且VkPipelineViewportStateCreateInfo的pNext中含有一个VkPipelineViewportExclusiveScissorStateCreateInfoNV 创建， 则绑定的pipeline必须以VkPipelineViewportExclusiveScissorStateCreateInfoNV::exclusiveScissorCount 大于等于最近vkCmdSetViewportWithCount设置的viewportCount创建
                                    （28）以VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_ENABLE_NV动态state开启创建， 则vkCmdSetExclusiveScissorEnableNV 必须在该命令之前设置
                                    （29）以VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV动态state开启创建， 则vkCmdSetExclusiveScissorNV 必须在该命令之前设置
                                    （30）以VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE动态state开启创建， 则vkCmdSetRasterizerDiscardEnable 必须在该命令之前设置
                                    （31）以VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE动态state开启创建， 则vkCmdSetDepthBiasEnable 必须在该命令之前设置
                                    （32）以VK_DYNAMIC_STATE_LOGIC_OP_EXT动态state开启创建， 则vkCmdSetLogicOpEXT 必须在该命令之前设置且参数logicOp必须是一个有效的VkLogicOp值
    74.如果一个shader object绑定到任何graphics stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                    （1）如果最靠近当前命令的vkCmdSetPolygonModeEXT设置polygonMode为VK_POLYGON_MODE_LINE或者是任何line topology，则vkCmdSetLineWidth必须在该命令之前设置
                                    （2）如果最靠近当前命令的vkCmdSetDepthBiasEnable设置depthBiasEnable为VK_TRUE，则vkCmdSetDepthBias 或者 vkCmdSetDepthBias2EXT必须在该命令之前设置
                                    （3）如果最靠近当前命令的vkCmdSetDepthBoundsTestEnable设置depthBoundsTestEnable为VK_TRUE，则vkCmdSetDepthBounds必须在该命令之前设置
                                    （4）如果最靠近当前命令的vkCmdSetStencilTestEnable设置stencilTestEnable为VK_TRUE，则vkCmdSetStencilCompareMask必须在该命令之前设置
                                    （5）如果最靠近当前命令的vkCmdSetStencilTestEnable设置stencilTestEnable为VK_TRUE，则vkCmdSetStencilWriteMask必须在该命令之前设置
                                    （6）如果最靠近当前命令的vkCmdSetStencilTestEnable设置stencilTestEnable为VK_TRUE，则vkCmdSetStencilReference必须在该命令之前设置
                                    （7）如果最靠近当前命令的vkCmdSetSampleLocationsEnableEXT设置sampleLocationsEnable为VK_TRUE，则vkCmdSetSampleLocationsEXT必须在该命令之前设置
                                    （8）则vkCmdSetCullMode必须在该命令之前设置
                                    （9）则vkCmdSetFrontFace必须在该命令之前设置
                                    （10）则vkCmdSetDepthTestEnable 必须在该命令之前设置
                                    （11）则vkCmdSetDepthWriteEnable 必须在该命令之前设置
                                    （12）如果最靠近当前命令的vkCmdSetDepthTestEnable设置depthTestEnable为VK_TRUE，则vkCmdSetDepthCompareOp 必须在该命令之前设置
                                    （13）则vkCmdSetDepthBoundsTestEnable 必须在该命令之前设置
                                    （14）则vkCmdSetStencilTestEnable 必须在该命令之前设置
                                    （15）如果最靠近当前命令的vkCmdSetStencilTestEnable设置stencilTestEnable为VK_TRUE，则vkCmdSetStencilOp 必须在该命令之前设置
                                    （16）
                                    （17）如果shadingRateImage特性开启，则vkCmdSetCoarseSampleOrderNV 必须在该命令之前设置
                                    （18）如果shadingRateImage特性开启，且最靠近当前命令的vkCmdSetShadingRateImageEnableNV设置shadingRateImageEnable为VK_TRUE，则vkCmdSetViewportShadingRatePaletteNV 必须在该命令之前设置
                                    （19）如果shadingRateImage特性开启，且最靠近当前命令的vkCmdSetShadingRateImageEnableNV设置shadingRateImageEnable为VK_TRUE，则最近的vkCmdSetViewportShadingRatePaletteNV设置的viewportCount 必须大于等于vkCmdSetViewportWithCount设置的viewportCount
                                    （20）则vkCmdSetDepthBiasEnable必须在该命令之前设置
    75.如果一个输出line primitives的shader object绑定到VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或者 VK_SHADER_STAGE_GEOMETRY_BIT，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则vkCmdSetLineWidth必须在该命令之前设置
    76.如果一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最靠近当前命令的vkCmdSetColorBlendEnableEXT设置pColorBlendEnables任何元素为VK_TRUE，且
                        最靠近当前命令的vkCmdSetColorBlendEquationEXT设置pColorBlendEquations相同元素的VkColorBlendEquationEXT的VkBlendFactor成员为VK_BLEND_FACTOR_CONSTANT_COLOR, VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR, VK_BLEND_FACTOR_CONSTANT_ALPHA, 或者 VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA，则vkCmdSetBlendConstants必须在该命令之前设置
    77.如果该命令记录在开启了multiview的render pass instance中，则最大的instance 索引必须小于等于VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex
    78.如果绑定的graphics pipeline以VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable设置为VK_TRUE创建且当前的subpass含有一个 depth/stencil attachment，则该attachment必须以VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT创建
    >>78.5  .如果一个shader object绑定到任何graphics stage，则（1）vkCmdSetViewportWithCount 和vkCmdSetScissorWithCount 必须同时在该命令之前设置，且vkCmdSetViewportWithCount设置的viewportCount必须匹配vkCmdSetScissorWithCount设置的scissorCount
                                                              （2）则vkCmdSetRasterizerDiscardEnable 必须在该命令之前设置
    79.如果VK_NV_clip_space_w_scaling拓展开启，且shader object绑定到任何graphics stage，且最近的vkCmdSetViewportWScalingEnableNV设置viewportWScalingEnable为VK_TRUE，则（1）vkCmdSetViewportWScalingNV必须在该命令前设置
                                                                                                                                                                       （2）最近vkCmdSetViewportWScalingNV设置的viewportCount必须大于等于vkCmdSetViewportWithCount设置的viewportCount
    80.如果exclusiveScissor 特性开启，且shader object绑定到任何graphics stage，，则（1）vkCmdSetExclusiveScissorEnableNV必须在该命令前设置
                                                                                   （2）最近的vkCmdSetExclusiveScissorEnableNV调用设置的pExclusiveScissorEnables中的任何元素为VK_TRUE,则vkCmdSetExclusiveScissorNV必须在该命令前设置
    81.如果一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最靠近当前命令的vkCmdSetLogicOpEnableEXT设置logicOpEnable任何元素为VK_TRUE，则vkCmdSetLogicOpEXT 必须在该命令之前设置且参数logicOp必须是一个有效的VkLogicOp值
    82.如果primitiveFragmentShadingRateWithMultipleViewports限制不支持，则（1）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT动态state开启创建，且任何该pipeline的shader stage会写入PrimitiveShadingRateKHR built-in修饰的变量，则vkCmdSetViewportWithCount 必须在该命令之前设置且参数viewportCount必须是1
                                                                          （2）任何绑定的graphics pipeline的shader stage会写入PrimitiveShadingRateKHR built-in修饰的变量，则vkCmdSetViewportWithCount 必须在该命令之前设置且参数viewportCount必须是1
    83.如果graphics pipeline中未开启rasterization，则对subpass中的每个color attachment，如果其对应的image view 的format features不包含VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT，则pColorBlendState中其对应pAttachments中元素的blendEnable必须为VK_FALSE
    84.如果一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则对于render pass中的每个color attachment，如果其对应的image view 的format features不包含VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT， 则最近的vkCmdSetColorBlendEnableEXT设置的pColorBlendEnables中该附件的对应元素必须为VK_FALSE
    85.如果graphics pipeline中未开启rasterization，有VK_AMD_mixed_attachment_samples拓展未开启，VK_NV_framebuffer_mixed_samples拓展未开启，multisampledRenderToSingleSampled特性未开启，则当前绑定的pipeline的rasterizationSamples必须和当前subpass的color 以及/或者 depth/stencil attachments的相同
    86.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且有VK_AMD_mixed_attachment_samples拓展未开启，VK_NV_framebuffer_mixed_samples拓展未开启，multisampledRenderToSingleSampled特性未开启，则最近vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples必须和当前subpass的color 以及/或者 depth/stencil attachments的相同
    87.如果一个shader object绑定到任何graphics stage，则当前的render pass instance必须以vkCmdBeginRendering开始
    88.如果当前的render pass instance以vkCmdBeginRendering开始，（1）如果pDepthAttachment的imageView不为VK_NULL_HANDLE，且pDepthAttachment的layout不为VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL，则该命令不能写入任何值到depth attachment
                                                                （2）如果pStencilAttachment的imageView不为VK_NULL_HANDLE，且pStencilAttachment的layout不为VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL，则该命令不能写入任何值到stencil attachment
                                                                （3）如果pDepthAttachment的imageView不为VK_NULL_HANDLE，且pDepthAttachment的layout为VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL，则该命令不能写入任何值到depth attachment
                                                                （4）如果pStencilAttachment的imageView不为VK_NULL_HANDLE，且pStencilAttachment的layout为VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL，则该命令不能写入任何值到stencil attachment
                                                                （5）如果pDepthAttachment的imageView不为VK_NULL_HANDLE，且pDepthAttachment的layout为VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL，则该命令不能写入任何值到depth attachment
                                                                （6）如果pStencilAttachment的imageView不为VK_NULL_HANDLE，且pStencilAttachment的layout为VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL，则该命令不能写入任何值到stencil attachment
                                                                （7）则当前绑定的graphics pipeline必须以含VkPipelineRenderingCreateInfo::viewMask等于VkRenderingInfo::viewMask创建
                                                                （8）如果带有VkRenderingInfo::colorAttachmentCount为1，则没有shader object绑定到任何graphics stage，且一个color attachment的 resolve mode为VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID，则VkRenderingInfo::pColorAttachments中每个resolveImageView不为VK_NULL_HANDLE的元素其对应image必须以和创建当前绑定的pipeline 相同的VkExternalFormatANDROID::externalFormat创建
                                                                （9）如果没有shader object绑定到任何graphics stage，如果绑定的graphics pipeline以一个非零值VkExternalFormatANDROID::externalFormat创建且启用VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态设置，则vkCmdSetColorBlendEnableEXT必须在该命令前设置blend enable为VK_FALSE
                                                                （10）如果没有shader object绑定到任何graphics stage，如果绑定的graphics pipeline以一个非零值VkExternalFormatANDROID::externalFormat创建且启用VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态设置，则vkCmdSetRasterizationSamplesEXT必须在该命令前设置rasterizationSamples为VK_SAMPLE_COUNT_1_BIT
                                                                （11）如果没有shader object绑定到任何graphics stage，如果绑定的graphics pipeline以一个非零值VkExternalFormatANDROID::externalFormat创建且启用VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR动态设置，则vkCmdSetFragmentShadingRateKHR必须在该命令前设置pFragmentSize->width为1，pFragmentSize->height为1
    89.如果dynamicRenderingUnusedAttachments特性未开启，且当前的render pass instance以vkCmdBeginRendering开始，则
                                                            （1）当前绑定的graphics pipeline必须以含VkPipelineRenderingCreateInfo::colorAttachmentCount等于VkRenderingInfo::colorAttachmentCount创建
                                                            （2）如果VkRenderingInfo::colorAttachmentCount大于0，则VkRenderingInfo::pColorAttachments 中每一个其imageView不为VK_NULL_HANDLE的元素的VkImageView必须以VkFormat对应绑定的graphics pipeline的VkPipelineRenderingCreateInfo::pColorAttachmentFormats指明的format创建
                                                            （3）如果VkRenderingInfo::colorAttachmentCount大于0，则VkRenderingInfo::pColorAttachments 中每一个其imageView为VK_NULL_HANDLE的元素对应绑定的graphics pipeline的VkPipelineRenderingCreateInfo::pColorAttachmentFormats指明的format必须为VK_FORMAT_UNDEFINED
                                                            （4）如果VkRenderingInfo::pDepthAttachment->imageView为VK_NULL_HANDLE，则创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::depthAttachmentFormat必须为VK_FORMAT_UNDEFINED
                                                            （5）如果VkRenderingInfo::pDepthAttachment->imageView不为VK_NULL_HANDLE，则创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::depthAttachmentFormat必须和创建VkRenderingInfo::pDepthAttachment->imageView的VkFormat相同
                                                            （6）如果VkRenderingInfo::pStencilAttachment->imageView为VK_NULL_HANDLE，则创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::stencilAttachmentFormat必须为VK_FORMAT_UNDEFINED
                                                            （7）如果VkRenderingInfo::pStencilAttachment->imageView不为VK_NULL_HANDLE，则创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::stencilAttachmentFormat必须和创建VkRenderingInfo::pStencilAttachment->imageView的VkFormat相同
    90.如果dynamicRenderingUnusedAttachments特性开启，且当前的render pass instance以vkCmdBeginRendering开始，则
                                                            （1）如果VkRenderingInfo::colorAttachmentCount大于0，则VkRenderingInfo::pColorAttachments 中每一个其imageView不为VK_NULL_HANDLE的元素的VkImageView必须以VkFormat对应绑定的graphics pipeline的VkPipelineRenderingCreateInfo::pColorAttachmentFormats指明的format创建，或者是对应元素为VK_FORMAT_UNDEFINED创建
                                                            （2）如果VkRenderingInfo::pDepthAttachment->imageView不为VK_NULL_HANDLE，且创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::depthAttachmentFormat和创建VkRenderingInfo::pDepthAttachment->imageView的VkFormat不同，则该format必须为VK_FORMAT_UNDEFINED
                                                            （3）如果VkRenderingInfo::pStencilAttachment->imageView不为VK_NULL_HANDLE，且创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::stencilAttachmentFormat和创建VkRenderingInfo::pStencilAttachment->imageView的VkFormat不同，则该format必须为VK_FORMAT_UNDEFINED
    91.如果没有shader object绑定到任何graphics stage，且当前的render pass instance以vkCmdBeginRendering开始且VkRenderingInfo::colorAttachmentCount为1，且一个color attachment的 resolve mode为VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID，则VkRenderingInfo::pColorAttachments中每个resolveImageView不为VK_NULL_HANDLE的元素其对应image必须以和创建当前绑定的pipeline 相同的VkExternalFormatANDROID::externalFormat创建
    92.如果有一个shader object绑定到任何graphics stage，且当前的render pass 包含一个使用VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID resolve mode的color attachment，则（1）vkCmdSetColorBlendEnableEXT必须在该命令前设置blend enable为VK_FALSE
                                                                                                                                                                             （2）则vkCmdSetRasterizationSamplesEXT必须在该命令前设置rasterizationSamples为VK_SAMPLE_COUNT_1_BIT
                                                                                                                                                                             （3）则vkCmdSetFragmentShadingRateKHR必须在该命令前设置pFragmentSize->width为1，pFragmentSize->height为1
    93.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT动态state开启创建， 则vkCmdSetColorWriteEnableEXT 必须在该命令之前设置，且设置的attachmentCount必须大于等于创建当前绑定的pipeline的VkPipelineColorBlendStateCreateInfo::attachmentCount
                                    （2）以VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT动态state开启创建， 则vkCmdSetDiscardRectangleEXT 必须在该命令之前为每个VkPipelineDiscardRectangleStateCreateInfoEXT::discardRectangleCount指明的discard rectangle 设置
                                    （3）以VK_DYNAMIC_STATE_DISCARD_RECTANGLE_ENABLE_EXT动态state开启创建， 则vkCmdSetDiscardRectangleEnableEXT 必须在该命令之前设置
                                    （4）以VK_DYNAMIC_STATE_DISCARD_RECTANGLE_MODE_EXT动态state开启创建， 则vkCmdSetDiscardRectangleModeEXT 必须在该命令之前设置
    94.如果有一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                    （1）如果colorWriteEnable特性在device上开启，则vkCmdSetColorWriteEnableEXT 必须在该命令之前设置，且设置的attachmentCount必须大于等于当前render pass instance的color attachment的数量
                                    （2）如果VK_EXT_discard_rectangles拓展开启，且最近的vkCmdSetDiscardRectangleEnableEXT设置discardRectangleEnable为VK_TRUE， 则vkCmdSetDiscardRectangleEXT 必须在该命令之前设置
                                    （3）如果VK_EXT_discard_rectangles拓展开启， 则vkCmdSetDiscardRectangleEnableEXT 必须在该命令之前设置
                                    （4）如果VK_EXT_discard_rectangles拓展开启， 则最近的vkCmdSetDiscardRectangleEnableEXT设置discardRectangleEnable为VK_TRUE，则vkCmdSetDiscardRectangleModeEXT 必须在该命令之前设置
    95.如果当前的render pass instance以vkCmdBeginRendering开始，则（1）如果VkRenderingFragmentShadingRateAttachmentInfoKHR::imageView不为VK_NULL_HANDLE，则当前绑定的graphics pipeline必须以VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR创建
                                                                  （2）如果VkRenderingFragmentDensityMapAttachmentInfoEXT::imageView不为VK_NULL_HANDLE，则当前绑定的graphics pipeline必须以VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT创建
                                                                  （3）且含VkRenderingInfo::colorAttachmentCount大于0，如果当前的绑定的pipeline以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，则VkRenderingInfo::pColorAttachments中每个imageView不为VK_NULL_HANDLE的元素的imageView，必须以当前pipeline的VkAttachmentSampleCountInfoAMD 或者 VkAttachmentSampleCountInfoNV中的pColorAttachmentSamples中对应元素的sample count进行创建
                                                                  （4）如果当前的绑定的pipeline以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且VkRenderingInfo::pDepthAttachment中的imageView不为VK_NULL_HANDLE，则当前pipeline的VkAttachmentSampleCountInfoAMD 或者 VkAttachmentSampleCountInfoNV中的depthStencilAttachmentSamples必须等于创建VkRenderingInfo::pDepthAttachment->imageView的sample count
                                                                  （5）如果当前的绑定的pipeline以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且VkRenderingInfo::pStencilAttachment中的imageView不为VK_NULL_HANDLE，则当前pipeline的VkAttachmentSampleCountInfoAMD 或者 VkAttachmentSampleCountInfoNV中的depthStencilAttachmentSamples必须等于创建VkRenderingInfo::pStencilAttachment->imageView的sample count
                                                                  （6）且含VkRenderingInfo::colorAttachmentCount大于0，如果当前的绑定的pipeline不以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且multisampledRenderToSingleSampled特性没有开启，则VkRenderingInfo::pColorAttachments中每个imageView不为VK_NULL_HANDLE的元素的imageView，其创建的sample count必须等于当前绑定的graphics pipeline的rasterizationSamples
                                                                  （7）如果当前的绑定的pipeline不以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且VkRenderingInfo::pDepthAttachment中的imageView不为VK_NULL_HANDLE，且multisampledRenderToSingleSampled特性没有开启，则当前pipeline的rasterizationSamples 必须等于创建VkRenderingInfo::pDepthAttachment->imageView的sample count
                                                                  （8）如果当前的绑定的pipeline不以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且VkRenderingInfo::pStencilAttachment中的imageView不为VK_NULL_HANDLE，且multisampledRenderToSingleSampled特性没有开启，则当前pipeline的rasterizationSamples 必须等于创建VkRenderingInfo::pStencilAttachment->imageView的sample count
                                                                  （9）当前绑定的pipeline必须VkGraphicsPipelineCreateInfo::renderPass为VK_NULL_HANDLE创建
                                                                  （10）如果绑定的pipeline的fragment shader静态写入一个color attachment，且color write mask不为0，启用了color writes，且该附件对应的VkRenderingInfo::pColorAttachments->imageView 不为VK_NULL_HANDLE，则对应的创建pipeline的VkPipelineRenderingCreateInfo::pColorAttachmentFormats中的元素不能为VK_FORMAT_UNDEFINED
                                                                  （11）如果绑定的pipeline启用了depth test，启用了depth writes，且VkRenderingInfo::pDepthAttachment->imageView 不为VK_NULL_HANDLE，则创建pipeline的VkPipelineRenderingCreateInfo::depthAttachmentFormat不能为VK_FORMAT_UNDEFINED
                                                                  （12）如果绑定的pipeline启用了stencil test，且VkRenderingInfo::pStencilAttachment->imageView 不为VK_NULL_HANDLE，则创建pipeline的VkPipelineRenderingCreateInfo::stencilAttachmentFormat不能为VK_FORMAT_UNDEFINED
    96.如果该命令在以vkCmdBeginRendering开始的render pass instance中调用，且VkRenderingInfo的pNext中包含一个multisampledRenderToSingleSampledEnable设为VK_TRUE的VkMultisampledRenderToSingleSampledInfoEXT，则当前绑定的graphics pipeline的rasterizationSamples必须等于VkMultisampledRenderToSingleSampledInfoEXT::rasterizationSamples
    97.如果primitivesGeneratedQueryWithRasterizerDiscard特性未开启，且VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query激活，则不能启用rasterization discard
    98.如果primitivesGeneratedQueryWithNonZeroStreams特性未开启，且VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query激活，则 绑定的graphics pipeline不能以VkPipelineRasterizationStateStreamCreateInfoEXT::rasterizationStream为非零值创建
    98.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_TESSELLATION_DOMAIN_ORIGIN_EXT动态state开启创建，则vkCmdSetTessellationDomainOriginEXT必须在该命令之前设置
                                    （2）以VK_DYNAMIC_STATE_DEPTH_CLAMP_ENABLE_EXT动态state开启创建，则vkCmdSetDepthClampEnableEXT必须在该命令之前设置
                                    （3）以VK_DYNAMIC_STATE_POLYGON_MODE_EXT动态state开启创建，则vkCmdSetPolygonModeEXT必须在该命令之前设置
                                    （4）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，则vkCmdSetRasterizationSamplesEXT必须在该命令之前设置
                                    （5）以VK_DYNAMIC_STATE_SAMPLE_MASK_EXT动态state开启创建，则vkCmdSetSampleMaskEXT必须在该命令之前设置
                                    （6）以VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT动态state开启创建，则vkCmdSetAlphaToCoverageEnableEXT必须在该命令之前设置
                                    （7）以VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT动态state开启创建，则最近的vkCmdSetAlphaToCoverageEnableEXT设置alphaToCoverageEnable为VK_TRUE，则Fragment Output Interface中 Index 0的Location 0必须有一个含alpha Component的变量
                                    （8）以VK_DYNAMIC_STATE_ALPHA_TO_ONE_ENABLE_EXT动态state开启创建，则vkCmdSetAlphaToOneEnableEXT必须在该命令之前设置
                                    （9）以VK_DYNAMIC_STATE_LOGIC_OP_ENABLE_EXT动态state开启创建，则vkCmdSetLogicOpEnableEXT必须在该命令之前设置
                                    （10）以VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态state开启创建，则vkCmdSetColorBlendEnableEXT必须在该命令之前设置
                                    （11）以VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT动态state开启创建，则vkCmdSetColorBlendEquationEXT必须在该命令之前设置
                                    （12）以VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT动态state开启创建，则vkCmdSetColorWriteMaskEXT必须在该命令之前设置
    
    99.如果一个shader object绑定到VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT stage，则vkCmdSetTessellationDomainOriginEXT必须在该命令之前设置
    100.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                                    （1）如果depthClamp特性启用，则vkCmdSetDepthClampEnableEXT必须在该命令之前设置
                                                    （2）则vkCmdSetPolygonModeEXT必须在该命令之前设置
                                                    （3）则vkCmdSetRasterizationSamplesEXT必须在该命令之前设置
                                                    （4）则vkCmdSetSampleMaskEXT必须在该命令之前设置
                                                    （5）则vkCmdSetAlphaToCoverageEnableEXT必须在该命令之前设置
                                                    （6）如果alphaToOne特性启用，则vkCmdSetAlphaToOneEnableEXT必须在该命令之前设置
    
    101.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetAlphaToCoverageEnableEXT设置alphaToCoverageEnable为VK_TRUE，则Fragment Output Interface中 Index 0的Location 0必须有一个含alpha Component的变量
    102.如果一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                        （1）如果logicOp特性开启 ,vkCmdSetLogicOpEnableEXT必须在该命令之前设置
                                        （2）如果绑定了color attachments，则vkCmdSetColorBlendEnableEXT必须在该命令之前设置
                                        （3）如果最近的vkCmdSetColorBlendEnableEXT设置任何附件在pColorBlendEnables中的值为VK_TRUE ，则vkCmdSetColorBlendEquationEXT必须在该命令之前设置
                                        （4）如果绑定了color attachments，则vkCmdSetColorWriteMaskEXT必须在该命令之前设置
    
    103.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT动态state开启创建，则vkCmdSetRasterizationStreamEXT必须在该命令之前设置
                                     （2）以VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT动态state开启创建，则vkCmdSetConservativeRasterizationModeEXT必须在该命令之前设置
                                     （3）以VK_DYNAMIC_STATE_EXTRA_PRIMITIVE_OVERESTIMATION_SIZE_EXT动态state开启创建，则vkCmdSetExtraPrimitiveOverestimationSizeEXT必须在该命令之前设置
                                     （4）以VK_DYNAMIC_STATE_DEPTH_CLIP_ENABLE_EXT动态state开启创建，则vkCmdSetDepthClipEnableEXT必须在该命令之前设置
                                     （5）以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT动态state开启创建，则vkCmdSetSampleLocationsEnableEXT必须在该命令之前设置
                                     （6）以VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT动态state开启创建，则vkCmdSetColorBlendAdvancedEXT必须在该命令之前设置
                                     （7）以VK_DYNAMIC_STATE_PROVOKING_VERTEX_MODE_EXT动态state开启创建，则vkCmdSetProvokingVertexModeEXT必须在该命令之前设置
                                     （8）以VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT动态state开启创建，则vkCmdSetLineRasterizationModeEXT必须在该命令之前设置
                                     （9）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT动态state开启创建，则vkCmdSetLineStippleEnableEXT必须在该命令之前设置
                                     （10）以VK_DYNAMIC_STATE_LINE_STIPPLE_KHR动态state开启创建，则vkCmdSetLineStippleKHR必须在该命令之前设置
                                     （11）以VK_DYNAMIC_STATE_DEPTH_CLIP_NEGATIVE_ONE_TO_ONE_EXT动态state开启创建，则vkCmdSetDepthClipNegativeOneToOneEXT必须在该命令之前设置
                                     （12）以VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_ENABLE_NV动态state开启创建，则vkCmdSetViewportWScalingEnableNV必须在该命令之前设置
                                     （13）以VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV动态state开启创建，则vkCmdSetViewportSwizzleNV必须在该命令之前设置
                                     （14）以VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV动态state开启创建，则vkCmdSetCoverageToColorEnableNV必须在该命令之前设置
                                     （15）以VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_LOCATION_NV动态state开启创建，则vkCmdSetCoverageToColorLocationNV必须在该命令之前设置
                                     （16）以VK_DYNAMIC_STATE_COVERAGE_MODULATION_MODE_NV动态state开启创建，则vkCmdSetCoverageModulationModeNV必须在该命令之前设置
                                     （17）以VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV动态state开启创建，则vkCmdSetCoverageModulationTableEnableNV必须在该命令之前设置
                                     （18）以VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_NV动态state开启创建，则vkCmdSetCoverageModulationTableNV必须在该命令之前设置
                                     （19）以VK_DYNAMIC_STATE_SHADING_RATE_IMAGE_ENABLE_NV动态state开启创建，则vkCmdSetShadingRateImageEnableNV必须在该命令之前设置
                                     （20）以VK_DYNAMIC_STATE_REPRESENTATIVE_FRAGMENT_TEST_ENABLE_NV动态state开启创建，则vkCmdSetRepresentativeFragmentTestEnableNV必须在该命令之前设置
                                     （21）以VK_DYNAMIC_STATE_COVERAGE_REDUCTION_MODE_NV动态state开启创建，则vkCmdSetCoverageReductionModeNV必须在该命令之前设置
    
    104.如果一个shader object绑定到VK_SHADER_STAGE_GEOMETRY_BIT stage，且如果geometryStreams 特性开启，则vkCmdSetRasterizationStreamEXT必须在该命令之前设置
    105.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                            （1）如果VK_EXT_conservative_rasterization 拓展开启，vkCmdSetConservativeRasterizationModeEXT必须在该命令之前设置
                            （2）如果VK_EXT_conservative_rasterization 拓展开启，且最近的vkCmdSetConservativeRasterizationModeEXT设置conservativeRasterizationMode为VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT，则vkCmdSetExtraPrimitiveOverestimationSizeEXT必须在该命令之前设置
                            （3）如果VK_EXT_sample_locations 拓展开启，则vkCmdSetSampleLocationsEnableEXT必须在该命令之前设置
    106.如果一个shader object绑定到任何graphics stage，且depthClipEnable 特性开启，则vkCmdSetDepthClipEnableEXT必须在该命令之前设置
    107.如果如果一个shader object绑定到任何VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且如果VK_EXT_blend_operation_advanced 拓展开启，则vkCmdSetColorBlendEquationEXT 和 vkCmdSetColorBlendAdvancedEXT中至少一个必须在该命令之前设置
    108.如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，如果VK_EXT_provoking_vertex拓展开启， 则vkCmdSetProvokingVertexModeEXT必须在该命令之前设置
    109.如果VK_KHR_line_rasterization 或者 VK_EXT_line_rasterization拓展开启，则（1）如果一个shader object绑定到任意一个graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetPolygonModeEXT设置polygonMode 为VK_POLYGON_MODE_LINE ，则vkCmdSetLineRasterizationModeEXT必须在该命令之前设置
                                                                                （2）如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetPrimitiveTopology设置primitiveTopology 为任何line topology ，则vkCmdSetLineRasterizationModeEXT必须在该命令之前设置
                                                                                （3）如果一个输出为line primitive的shader object绑定到VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或 VK_SHADER_STAGE_GEOMETRY_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则vkCmdSetLineRasterizationModeEXT必须在该命令之前设置
                                                                                （4）如果一个shader object绑定到任意一个graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetPolygonModeEXT设置polygonMode 为VK_POLYGON_MODE_LINE ，则vkCmdSetLineStippleEnableEXT必须在该命令之前设置
                                                                                （5）如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetPrimitiveTopology设置primitiveTopology 为任何line topology ，则vkCmdSetLineStippleEnableEXT必须在该命令之前设置
                                                                                （6）如果一个输出为line primitive的shader object绑定到VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或 VK_SHADER_STAGE_GEOMETRY_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则vkCmdSetLineStippleEnableEXT必须在该命令之前设置
                                                                                （7）如果一个shader object绑定到任意一个graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetLineStippleEnableEXT设置stippledLineEnable 为VK_TRUE ，则vkCmdSetLineStippleEXT必须在该命令之前设置
    110.如果一个shader object绑定到任何graphics stage，（1）如果depthClipControl 特性开启，则vkCmdSetDepthClipNegativeOneToOneEXT必须在该命令之前设置
                                                       （2）VK_NV_clip_space_w_scaling 拓展开启，则vkCmdSetViewportWScalingEnableNV必须在该命令之前设置
                                                       （3）VK_NV_viewport_swizzle 拓展开启，则vkCmdSetViewportSwizzleNV必须在该命令之前设置
    111.如果如果一个shader object绑定到任何VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                        （1）如果VK_NV_fragment_coverage_to_color 拓展开启，则vkCmdSetCoverageToColorEnableNV 必须在该命令之前设置
                        （2）如果VK_NV_fragment_coverage_to_color 拓展开启，且最近的vkCmdSetCoverageToColorEnableNV 设置coverageToColorEnable 为VK_TRUE，则vkCmdSetCoverageToColorLocationNV 必须在该命令之前设置
                        （3）如果pipelineFragmentShadingRate 特性开启，则vkCmdSetFragmentShadingRateKHR 必须在该命令之前设置
    112.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                （1）如果VK_NV_framebuffer_mixed_samples 拓展开启，则vkCmdSetCoverageModulationModeNV 必须在该命令之前设置
                                （2）如果VK_NV_framebuffer_mixed_samples 拓展开启，且最近的vkCmdSetCoverageModulationModeNV设置coverageModulationMode为任何除VK_COVERAGE_MODULATION_MODE_NONE_NV之外的值，则vkCmdSetCoverageModulationTableEnableNV 必须在该命令之前设置
                                （3）如果VK_NV_framebuffer_mixed_samples 拓展开启，最近的vkCmdSetCoverageModulationTableEnableNV设置coverageModulationTableEnable为VK_TRUE，则vkCmdSetCoverageModulationTableNV 必须在该命令之前设置
                                （4）如果shadingRateImage 特性开启，则vkCmdSetShadingRateImageEnableNV 必须在该命令之前设置
                                （5）如果representativeFragmentTest 特性开启，则vkCmdSetRepresentativeFragmentTestEnableNV 必须在该命令之前设置
                                （6）如果coverageReductionMode 特性开启，则vkCmdSetCoverageReductionModeNV 必须在该命令之前设置
    113.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态state开启创建，且最近的vkCmdSetColorBlendEnableEXT设置任何附件在pColorBlendEnables中的值为VK_TRUE 则subpas中这些附件对应的image view的format features中必须包含VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT
                                     （2）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，且当前subpass不使用任何color和/或者 depth/stencil attachments，则最后的vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples必须符合zero￾attachment subpass的规则
                                     （3）以VK_DYNAMIC_STATE_SAMPLE_MASK_EXT不以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT 动态state开启创建，则最后调用的vkCmdSetSampleMaskEXT中设置的samples参数必须大于等于创建该pipeline的VkPipelineMultisampleStateCreateInfo::rasterizationSamples
                                     （4）以VK_DYNAMIC_STATE_SAMPLE_MASK_EXT和 VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT 动态state开启创建，则最后调用的vkCmdSetSampleMaskEXT中设置的samples参数必须大于等于最后的vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples
                                     （5）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，且VK_AMD_mixed_attachment_samples和VK_NV_framebuffer_mixed_samples拓展都没有开启，则最后的vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples必须等于subpass中color和/或者 depth/stencil attachments使用的相同
                                     （6）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，或者一个shader object绑定到任意graphics stage，且当前的subpass包含一个multisampledRenderToSingleSampledEnable 为VK_TRUE的VkMultisampledRenderToSingleSampledInfoEXT，则最后的vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples必须等于该VkMultisampledRenderToSingleSampledInfoEXT中的对应成员
                                     （7）以VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态state开启创建，则vkCmdSetColorBlendEnableEXT 必须在该命令之前设置，且vkCmdSetColorBlendEnableEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定值
                                     （8）以VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT动态state开启创建，则vkCmdSetColorBlendEquationEXT 必须在该命令之前设置，且vkCmdSetColorBlendEquationEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定blend equations
                                     （9）以VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT动态state开启创建，则vkCmdSetColorWriteMaskEXT 必须在该命令之前设置，且vkCmdSetColorWriteMaskEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定color write mask
                                     （10）以VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT动态state开启创建，则vkCmdSetColorBlendAdvancedEXT 必须在该命令之前设置，且vkCmdSetColorBlendAdvancedEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活blend的color attachments指定advanced blend equations
                                     （11）以VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT和VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态state开启创建，且最后的vkCmdSetColorBlendEnableEXT和vkCmdSetColorBlendAdvancedEXT设置启用了advanced blending，则当前subpass中激活的color attachments的数量不能超过advancedBlendMaxColorAttachments
                                     （12）以VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT动态state开启创建，且如果primitivesGeneratedQueryWithNonZeroStreams特性未开启且VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query已经激活，则最后的vkCmdSetRasterizationStreamEXT必须设置rasterizationStream为0
                                     （13）以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT但不以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，则最后的vkCmdSetSampleLocationsEXT设置的pSampleLocationsInfo->sampleLocationsPerPixel必须等于创建pipeline的VkPipelineMultisampleStateCreateInfo::rasterizationSamples
                                     （14）以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT和VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，则最后的vkCmdSetSampleLocationsEXT设置的pSampleLocationsInfo->sampleLocationsPerPixel必须等于最后vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples
                                     （15）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT但不以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT动态state开启创建，且绑定的pipeline的VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable为VK_TRUE 或者以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT动态state开启，则sampleLocationsInfo.sampleLocationsPerPixel 必须等于最后vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples
                                     （16）以VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV动态state开启创建，且最后的vkCmdSetCoverageToColorEnableNV设置coverageToColorEnable为VK_TRUE，则当前subpass必须有color attachment，且该attachment的format必须为VK_FORMAT_R8_UINT, VK_FORMAT_R8_SINT, VK_FORMAT_R16_UINT, VK_FORMAT_R16_SINT, VK_FORMAT_R32_UINT, 或者 VK_FORMAT_R32_SINT，且该attachment的location 有最后的vkCmdSetCoverageToColorLocationNV设置的coverageToColorLocation决定
                                     （17）以VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV和VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT 动态state开启创建，且如果VK_NV_coverage_reduction_mode 拓展开启，则当前的 coverageReductionMode，rasterizationSamples 以及color 以及 depth/stencil attachments（如果subpass有）的sample count必须是有效的返回值vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV的值的组合
                                     （18）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT但不以VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV 动态state开启创建，则绑定的graphics pipeline的VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount 必须大于等于最后vkCmdSetViewportWithCount设置的viewportCount
                                     （19）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT和VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV 动态state开启创建，则最后vkCmdSetViewportSwizzleNV设置的viewportCount 必须大于等于最后vkCmdSetViewportWithCount设置的viewportCount
                                     （20）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT或者 VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT 动态state开启创建，如果当前的stippledLineEnable为VK_TRUE，且当前的lineRasterizationMode为VK_LINE_RASTERIZATION_MODE_RECTANGULAR_KHR，则stippledRectangularLines 特性必须开启
                                     （21）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT或者 VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT 动态state开启创建，如果当前的stippledLineEnable为VK_TRUE，且当前的lineRasterizationMode为VK_LINE_RASTERIZATION_MODE_BRESENHAM_KHR，则stippledBresenhamLines 特性必须开启
                                     （22）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT或者 VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT 动态state开启创建，如果当前的stippledLineEnable为VK_TRUE，且当前的lineRasterizationMode为VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_KHR，则stippledSmoothLines 特性必须开启
                                     （23）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT或者 VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT 动态state开启创建，如果当前的stippledLineEnable为VK_TRUE，且当前的lineRasterizationMode为VK_LINE_RASTERIZATION_MODE_DEFAULT_KHR，则stippledRectangularLines 特性必须开启且VkPhysicalDeviceLimits::strictLines 必须为VK_TRUE
                                     （24）以VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT 动态state开启创建，且conservativePointAndLineRasterization不支持，最后的 pre-rasterization shader stage输出的有效图元拓扑为点或者线，则最后vkCmdSetConservativeRasterizationModeEXT设置的conservativeRasterizationMode 必须为VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT
                                     （25）以VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT 动态state开启创建，则vkCmdSetAttachmentFeedbackLoopEnableEXT 必须在该命令之前调用
    114.如果一个shader object绑定到 VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                                                                        （1）则vkCmdSetColorBlendEnableEXT 必须在该命令之前设置，且vkCmdSetColorBlendEnableEXT指定的firstAttachment开始的attachmentCount的值必须为当前subpass所有激活的color attachments指定
                                                                                        （2）则vkCmdSetColorBlendEquationEXT 必须在该命令之前设置，且vkCmdSetColorBlendEquationEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定blend equations
                                                                                        （3）则vkCmdSetColorWriteMaskEXT 必须在该命令之前设置，且vkCmdSetColorWriteMaskEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定color write mask
                                                                                        （4）如果VK_NV_fragment_coverage_to_color拓展开启， 最后的vkCmdSetCoverageToColorEnableNV设置coverageToColorEnable为VK_TRUE，则当前subpass必须有color attachment，且该attachment的format必须为VK_FORMAT_R8_UINT, VK_FORMAT_R8_SINT, VK_FORMAT_R16_UINT, VK_FORMAT_R16_SINT, VK_FORMAT_R32_UINT, 或者 VK_FORMAT_R32_SINT，且该attachment的location 有最后的vkCmdSetCoverageToColorLocationNV设置的coverageToColorLocation决定
    115.如果一个shader object绑定到 VK_SHADER_STAGE_FRAGMENT_BIT stage，（1）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT动态state开启创建，且最近的vkCmdSetSampleLocationsEnableEXT设置sampleLocationsEnable为VK_TRUE，且该subpass含有depth/stencil attachment，则该附件必须以VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT创建
                                                                        （2）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT和VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT 动态state开启创建，且最近的vkCmdSetSampleLocationsEnableEXT设置sampleLocationsEnable为VK_TRUE，则 最后vkCmdSetSampleLocationsEXT设置的sampleLocationsInfo.sampleLocationGridSize.width以及height 必须等于被调用vkGetPhysicalDeviceMultisamplePropertiesEXT传入rasterizationSamples返回的VkMultisamplePropertiesEXT::sampleLocationGridSize.width以及height一一对应均匀整除
                                                                        （3）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT 动态state开启创建，且最近的vkCmdSetSampleLocationsEnableEXT设置sampleLocationsEnable为VK_TRUE，则fragment shader代码中不能静态使用扩展指令InterpolateAtSample
                                                                        （4）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT但不以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT 动态state开启创建，且绑定的pipeline的VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable为VK_TRUE 或者以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT动态state开启，则 最后vkCmdSetRasterizationSamplesEXT设置的sampleLocationsInfo.sampleLocationGridSize.width以及height 必须等于被调用vkGetPhysicalDeviceMultisamplePropertiesEXT传入和vkCmdSetRasterizationSamplesEXT设置的相同rasterizationSamples的samples返回的VkMultisamplePropertiesEXT::sampleLocationGridSize.width以及height一一对应均匀整除
    116.如果一个shader object绑定到任何graphics stage，（1）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV 动态state开启创建，且最近的vkCmdSetCoverageModulationTableEnableNV设置coverageModulationTableEnable为VK_TRUE，则最近的vkCmdSetCoverageModulationTableNV 设置的coverageModulationTableCount 必须等于当前rasterizationSamples除以当前subppas的color samples
                                                       （2）如果VK_NV_viewport_swizzle 拓展开启，则最后vkCmdSetViewportSwizzleNV设置的viewportCount 必须大于等于最后vkCmdSetViewportWithCount设置的viewportCount
    117.如果VK_NV_framebuffer_mixed_samples 拓展开启，且如果在绑定的graphics pipeline中当前subpass有一个depth/stencil attachment以及dep test, stencil test, 或depth bounds test 启用，则当前rasterizationSamples 必须等于depth/stencil attachment的sample count
    118.如果VK_NV_framebuffer_mixed_samples 拓展开启，且如果最后的vkCmdSetRasterizationSamplesEXT设置的当前subpass的任何color attachments的rasterizationSamples 都大于 color samples，则sampleShadingEnable 必须为VK_FALSE
    119.如果当前绑定的graphics pipeline以VkGraphicsPipelineCreateInfo::pStages中的元素的VkPipelineShaderStageCreateInfo::stage设置为VK_SHADER_STAGE_VERTEX_BIT, VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT, VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或者 VK_SHADER_STAGE_GEOMETRY_BIT创建，则Mesh Shader Queries 不能激活
    120.如果dynamic state继承自VkCommandBufferInheritanceViewportScissorInfoNV，则这些动态state的设置必须在该命令之前设置
    121.如果没有绑定graphics pipeline，则（1）vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_VERTEX_BIT
                                         （2）如果tessellationShader 特性开启，vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT，VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT
                                         （3）如果geometryShader 特性开启，vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_GEOMETRY_BIT
                                         （4）vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_FRAGMENT_BIT
                                         （5）如果taskShader 特性开启，vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_TASK_BIT_EXT
                                         （6）如果meshShader 特性开启，vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_MESH_BIT_EXT
                                         （8）如果至少taskShader 和 meshShader一个特性开启，VK_SHADER_STAGE_VERTEX_BIT 或者VK_SHADER_STAGE_MESH_BIT_EXT stages中的一个必须含有有效的VkShaderEXT绑定，另外一个则不含有VkShaderEXT绑定
                                         （9）如果taskShader 和 meshShader特性同时开启，且一个有效的VkShaderEXT 绑定到VK_SHADER_STAGE_MESH_BIT_EXT stage，且该VkShaderEXT不以VK_SHADER_CREATE_NO_TASK_SHADER_BIT_EXT 创建，则一个有效的VkShaderEXT必须绑定到VK_SHADER_STAGE_TASK_BIT_EXT stage
                                         （10）如果taskShader 和 meshShader特性同时开启，且一个有效的VkShaderEXT 绑定到VK_SHADER_STAGE_MESH_BIT_EXT stage，且该VkShaderEXT以VK_SHADER_CREATE_NO_TASK_SHADER_BIT_EXT 创建，则不能有VkShaderEXT绑定到VK_SHADER_STAGE_TASK_BIT_EXT stage
                                         （11）如果一个有效的VkShaderEXT 绑定到VK_SHADER_STAGE_VERTEX_BIT stage，则不能有VkShaderEXT绑定到VK_SHADER_STAGE_TASK_BIT_EXT stage或者VK_SHADER_STAGE_MESH_BIT_EXT stage中的一个
    122.如果任何绑定的graphics shader以VK_SHADER_CREATE_LINK_STAGE_BIT_EXT 创建，（1）所有在相同vkCreateShadersEXT中以VK_SHADER_CREATE_LINK_STAGE_BIT_EXT创建的shaders必须也要绑定
                                                                                 （2）任何相同vkCreateShadersEXT中不以VK_SHADER_CREATE_LINK_STAGE_BIT_EXT创建的shaders不能有任何VkShaderEXT绑定
    123.所有绑定的graphics shader objects 必须以相同或者相同定义的push constant ranges创建
    124.所有绑定的graphics shader objects 必须以相同或者相同定义的descriptor set layouts的数组创建
    125.如果当前的render pass instance以vkCmdBeginRendering开始，且VkRenderingInfo::colorAttachmentCount为1，且有一个resolve mode为 VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID 的color attachment，且绑定了fragment shader，则DepthReplacing 和 StencilRefReplacingEXT execution modes 不能声明
    126.如果一个shader object绑定到 VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则 （1）如果attachmentFeedbackLoopDynamicState 特性开启，则 vkCmdSetAttachmentFeedbackLoopEnableEXT 必须在该命令之前调用
    127.如果包含一个fragment shader stage的绑定的graphics pipeline，（1）且该pipeline以VkPipelineDynamicStateCreateInfo::pDynamicStates中设置有VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE创建，且该fragment shader声明了EarlyFragmentTests execution mode且使用了OpDepthAttachmentReadEXT，则最后vkCmdSetDepthWriteEnable 设置的 depthWriteEnable 必须为VK_FALSE
                                                                    （2）且该pipeline以VkPipelineDynamicStateCreateInfo::pDynamicStates中设置有VK_DYNAMIC_STATE_STENCIL_WRITE_MASK创建，且该fragment shader声明了EarlyFragmentTests execution mode且使用了OpStencilAttachmentReadEXT，则最后vkCmdSetStencilWriteMask 设置的 writeMask 必须为0
    128.如果一个shader object绑定到任何graphics stage 或者绑定的graphics pipeline 以VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT 动态state开启创建，且任何color attachment的format为VK_FORMAT_E5B9G9R9_UFLOAT_PACK32，则vkCmdSetColorWriteMaskEXT设置的pColorWriteMasks参数的对应元素必须包含VK_COLOR_COMPONENT_R_BIT, VK_COLOR_COMPONENT_G_BIT, 和 VK_COLOR_COMPONENT_B_BIT，或者都不包含
    129.如果任何附件开启了blending，且该附件的source 或者 destination blend factors使用第二个颜色输入，则该命令执行的Fragment Execution Model静态使用的任何输出output attachment的Location的最大值必须小于maxFragmentDualSrcAttachments
    130.如果当前的render pass instance以vkCmdBeginRendering开始，（1）如果没有任何shader object绑定到任何graphics stage，则vkCmdSetRenderingAttachmentLocationsKHR 设置的VkRenderingAttachmentLocationInfoKHR::pColorAttachmentLocations中的每个元素必须匹配设置在当前绑定的graphics pipeline中的对应元素
                                                                 （2）如果没有任何shader object绑定到任何graphics stage，绑定的graphics pipeline中的input attchment 索引中映射的附件必须匹配在当前render pass instance的VkRenderingInputAttachmentIndexInfoKHR中设置的
    131.如果当前的render pass instance以vkCmdBeginRendering开始且以VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT标志开始，则绑定的graphics pipeline必须以VK_PIPELINE_CREATE_2_ENABLE_LEGACY_DITHERING_BIT_EXT创建
    132.如果绑定的graphics pipeline以VK_PIPELINE_CREATE_2_ENABLE_LEGACY_DITHERING_BIT_EXT创建，则当前的render pass 必须以vkCmdBeginRendering开始且以VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT标志开始
    133.绑定的graphics pipeline不能以VkGraphicsPipelineCreateInfo::pStages中元素的VkPipelineShaderStageCreateInfo::stage设置为VK_SHADER_STAGE_VERTEX_BIT, VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT, VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或者 VK_SHADER_STAGE_GEOMETRY_BIT创建
    134.Transform Feedback Queries不能激活
    135.Primitives Generated Queries不能激活
    136.用于创建任何激活的Pipeline Statistics Query的pipelineStatistics 不能包含VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT,
                                                                                VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT,
                                                                                VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT,
                                                                                VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT,
                                                                                VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT,
                                                                                VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT,
                                                                                VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT,
                                                                                VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT, 或者
                                                                                VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT
    137.如果buffer是non-sparse，则它必须完全和连续地绑定到单个VkDeviceMemory对象
    138.buffer必须以VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT 标志创建
    139.offset必须是4的倍数
    140.commandBuffer必须不为protected command buffer
    141.如果multiDrawIndirect 特性未开启，drawCount 必须为0 或 1
    142.countBufferOffset 必须是4的倍数
    143.countBuffer中存储的绘制次数参数必须小于或等于VkPhysicalDeviceLimits::maxDrawIndirectCount
    144.(countBufferOffset + sizeof(uint32_t)) 必须小于等于countBuffer的大小
    145.stride必须是4的倍数且必须大于或等于sizeof(VkDrawMeshTasksIndirectCommandNV)
    146.如果maxDrawCount大于等于1，则(stride × (maxDrawCount - 1) + offset + sizeof(VkDrawMeshTasksIndirectCommandNV)) 必须小于等于buffer的大小
    147.如果countBuffer中存储的绘制次数参数 为1，则(offset + sizeof (VkDrawMeshTasksIndirectCommandNV))必须小于等于buffer的大小
    148.如果countBuffer中存储的绘制次数参数 大于1，则(stride × (drawCount - 1) + offset + sizeof(VkDrawMeshTasksIndirectCommandNV))必须小于等于buffer的大小
    149.绑定到VK_PIPELINE_BIND_POINT_GRAPHICS绑定点的当前pipeline必须包含一个使用MeshNV Execution Model的shader stage
    
    */
    /**/


    
    

    
    
	//记录一个mesh task 绘制命令     该命令执行时，由 groupCountX × groupCountY × groupCountZ组装成一个global workgroup，然后执行该global workgroup中的所有mesh task。
    vkCmdDrawMeshTasksEXT(commandBuffer, 1/*groupCountX，是X维度dispatch的 local workgroups 数量.*/, 1/* groupCountY，是Y维度dispatch的 local workgroups 数量.*/, 1/*groupCountZ, 是Z维度dispatch的 local workgroups 数量.*/);
    /*

     vkCmdDrawMeshTasksEXT有效用法:
    1.如果一个VkSampler以其magFilter或者minFilter等于VK_FILTER_LINEAR创建，则（1）如果reductionMode为VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE，如果用于采样一个VkImageView作为该命令的结果的compareEnable为VK_FALSE，则该image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT
                                                                             （2）如果reductionMode为VK_SAMPLER_REDUCTION_MODE_MIN 或者VK_SAMPLER_REDUCTION_MODE_MAX之一 用于采样一个VkImageView作为该命令的结果，则该image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT
    2.如果一个VkSampler以其mipmapMode 等于VK_SAMPLER_MIPMAP_MODE_LINEAR创建，则（1）如果reductionMode为VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE，如果用于采样一个VkImageView作为该命令的结果的compareEnable为VK_FALSE，则该image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT
                                                                             （2）如果reductionMode为VK_SAMPLER_REDUCTION_MODE_MIN 或者VK_SAMPLER_REDUCTION_MODE_MAX之一 用于采样一个VkImageView作为该命令的结果，则该image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT
    3.如果一个VkSampler以其unnormalizedCoordinates等于VK_TRUE用于采样一个VkImageView作为该命令的结果创建，则（1）该image view的levelCount以及layerCount必须为1
                                                                                                            （2）该image view的viewType必须为VK_IMAGE_VIEW_TYPE_1D 或者 VK_IMAGE_VIEW_TYPE_2D
    4.如果一个VkImageView的采样带depth comparison操作，则image view的format features必须包含VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT
    5.如果一个VkImageView使用atomic operations作为该命令的结果进行访问，则image view的format features必须包含VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT
    6.如果一个VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER类型的 descriptor使用atomic operations作为该命令的结果进行访问，则storage texel buffer的format features必须包含VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT
    7.如果一个以VK_FILTER_CUBIC_EXT进行采样的VkImageView作为该命令的结果，则image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT
    8.如果VK_EXT_filter_cubic拓展没有开启，且有任何一个以VK_FILTER_CUBIC_EXT进行采样的VkImageView作为该命令的结果，则其VkImageViewType不能为VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, 或者 VK_IMAGE_VIEW_TYPE_CUBE_ARRAY
    9.任何一个以VK_FILTER_CUBIC_EXT进行采样的作为该命令的结果的VkImageView，其VkImageViewType和format 必须支持cubic filtering，参见vkGetPhysicalDeviceImageFormatProperties2返回的VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic
    10.任何一个以VK_FILTER_CUBIC_EXT进行采样且reduction mode为VK_SAMPLER_REDUCTION_MODE_MIN 或者 VK_SAMPLER_REDUCTION_MODE_MAX之一的作为该命令的结果的VkImageView，其VkImageViewType和format 必须支持带minmax filtering的cubic filtering，参见vkGetPhysicalDeviceImageFormatProperties2返回的VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax
    11.如果cubicRangeClamp特性没有开启，则有任何一个以VK_FILTER_CUBIC_EXT进行采样VkImageView的作为该命令的结果，VkSamplerReductionModeCreateInfo::reductionMode不能为VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM
    12.任何一个以VkSamplerReductionModeCreateInfo::reductionMode为VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM进行采样的作为该命令的结果的VkImageView必须以VK_FILTER_CUBIC_EXT进行采样
    13.如果selectableCubicWeights特性没有开启，则有任何一个以VK_FILTER_CUBIC_EXT进行采样VkImageView的作为该命令的结果，VkSamplerCubicWeightsCreateInfoQCOM::cubicWeights必须为VK_CUBIC_FILTER_WEIGHTS_CATMULL_ROM_QCOM
    14.任何一个以VkImageCreateInfo::flags含VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV创建的采样作为该命令结果的VkImage必须以VkSamplerAddressMode为VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE 进行采样
    15.对于任何作为storage image写入的VkImageView，且其OpTypeImage的format未知，则该image view的 format features必须包含VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT
    16.对于任何作为storage image读取的VkImageView，且其OpTypeImage的format未知，则该image view的 format features必须包含VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT
    17.对于任何作为storage storage texel buffer写入的VkBufferView，且其OpTypeImage的format未知，则该buffer view的 buffer features必须包含VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT
    18.对于任何作为storage storage texel buffer读取的VkBufferView，且其OpTypeImage的format未知，则该buffer view的 buffer features必须包含VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT
    19.对于每个在绑定的shader中静态使用的set n，一个descriptor set必须被绑定到相同pipeline bind point的set n处，该set n必须和创建当前VkPipeline的VkPipelineLayout或者和创建当前VkShaderEXT的VkDescriptorSetLayout 数组的set n处的布局兼容，参见Pipeline Layout Compatibility p1280
    20.对于每个在绑定的shader中静态使用的push constant，一个push constant值必须被绑定到相同pipeline bind point的对应处，该push constant必须和创建当前VkPipeline的VkPipelineLayout或者和创建当前VkShaderEXT的VkDescriptorSetLayout 数组中的对应处的布局兼容，参见Pipeline Layout Compatibility p1280
    21.如果maintenance4特性没有开启，则对于每个在绑定的shader中静态使用的push constant，一个push constant值必须被设置到相同pipeline bind point的对应处，该push constant必须和创建当前VkPipeline的VkPipelineLayout或者和创建当前VkShaderEXT的VkDescriptorSetLayout 数组中的对应处的布局兼容，参见Pipeline Layout Compatibility p1280
    22.每一个通过vkCmdBindDescriptorSets绑定的descriptor set的descriptors,如果是被不以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建的，且已经绑定到该命令使用的pipeline bind point的VkPipeline静态使用的，则这些descriptors必须是有效的，参见 descriptor validity p1328
    23.如果通过vkCmdBindDescriptorSets指定绑定到pipeline bind point的VkPipeline要使用的descriptors，则绑定的VkPipeline不能以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建
    24.在vkCmdSetDescriptorBufferOffsetsEXT中指定绑定的descriptor buffers的descriptors，则（1）如果绑定到pipeline bind point的该命令会使用的VkPipeline以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建，且这些descriptors是动态使用的，则这些descriptors必须是有效的
                                                                                          （2）如果绑定到pipeline bind point的对应stage的该命令会使用的VkShaderEXT，且这些descriptors是动态使用的，则这些descriptors必须是有效的
    25.在vkCmdSetDescriptorBufferOffsetsEXT中指定的descriptors在绑定到pipeline bind point的VkPipeline中使用，则VkPipeline必须以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建
    26.如果一个descriptor在以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建的VkPipeline中动态使用，则descriptor memory必须是驻留内存
    27.如果一个descriptor在以其VkDescriptorSetLayout以VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建的VkShaderEXT中动态使用，则descriptor memory必须是驻留内存
    28.如果shaderObject 特性没有开启，一个有效的pipeline必须绑定到这个命令使用的绑定到pipeline bind point上
    29.如果一个pipeline绑定到该命令使用的pipeline bind point上，则不能有任何动态state 设置命令设置任何该VkPipeline 中没有指定的动态 state
    30.如果一个VkPipeline绑定到该命令使用的pipeline bind point上 或者任何一个会访问一个使用unnormalized coordinates的VkSampler的 VkShaderEXT绑定到该命令使用的pipeline bind point上的pipeline的对应stage，则
                                                                                （1）在任何shader stage中，VkSampler不能用来采样任何类型为VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY 或者 VK_IMAGE_VIEW_TYPE_CUBE_ARRAY的VkImageView
                                                                                （2）在任何shader stage中，该VkSampler不能和任何带有名字中带有ImplicitLod，Dref 或者 Proj 的SPIR-V OpImageSample* 或者 OpImageSparseSample*指令一起使用
                                                                                （3）在任何shader stage中，该VkSampler不能和任何包含 LOD bias或者offset 值 的SPIR-V OpImageSample* or OpImageSparseSample*指令一起使用
    31.如果shaderObject开启，一个有效的pipeline必须绑定到该命令使用的pipeline bind point上或者一个有效的shader objects以及VK_NULL_HANDLE的组合必须绑定到该命令使用的pipeline bind point每一个支持的shader stage上
    32.如何绑定到该命令使用的pipeline bind point上的VkPipeline的任何stage会访问一个uniform buffer，且该stage对uniformBuffers不以启用VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT或者VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT 创建，且robustBufferAccess特性未开启，则该stage就不能访问绑定到相同pipeline bind point的descriptor set指定的buffer范围外的值
    33.如果robustBufferAccess特性未开启，且任何会访问uniform buffer的绑定到该命令使用的pipeline bind point上对应shader stage的VkShaderEXT，则其不能访问绑定到相同pipeline bind point的descriptor set指定的buffer范围外的值
    34.如何绑定到该命令使用的pipeline bind point上的VkPipeline的任何stage会访问一个storage buffer，且该stage对storageBuffers不以启用VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT或者VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT 创建，且robustBufferAccess特性未开启，则该stage就不能访问绑定到相同pipeline bind point的descriptor set指定的buffer范围外的值
    35.如果robustBufferAccess特性未开启，且任何会访问storage buffer的绑定到该命令使用的pipeline bind point上对应shader stage的VkShaderEXT，则其不能访问绑定到相同pipeline bind point的descriptor set指定的buffer范围外的值
    36.如果commandBuffer 是一个unprotected command buffer，且protectedNoFault 未支持，则任何绑定的shaders访问的资源不能是一个protected resource
    37.如果一个绑定的shader访问一个VkSampler 或者 VkImageView ，且启用了sampler Y′C BCR conversion，则只能使用OpImageSample* 或者 OpImageSparseSample*指令，不能使用ConstOffset 以及 Offset操作符
    38.如果一个VkImageView作为该命令的结果进行访问，则（1）image view 的viewType 必须匹配Instruction/Sampler/Image View Validation p1481中描述的OpTypeImage的Dim操作符
                                                      （2）image view 的foamrt的numeric type 必须匹配OpTypeImage的Sampled Type操作符
    39.如果一个VkImageView以一个不是VK_FORMAT_A8_UNORM_KHR的format创建且通过OpImageWrite作为该命令的结果进行访问，则该命令的Texel 操作符的Type必须至少包含和 image view的 format含有的components的个数相同的components个数
    40.如果一个VkImageView以VK_FORMAT_A8_UNORM_KHR的format创建且通过OpImageWrite作为该命令的结果进行访问，则该命令的Texel 操作符的Type必须包含4个components
    41.如果一个VkBufferView通过OpImageWrite作为该命令的结果进行访问，则该命令的Texel 操作符的Type必须至少包含和 buffer view的 format含有的components的个数相同的components个数
    42.如果一个带64-bit component的VkFormat的VkImageView作为该命令的结果进行访问，则该命令的OpTypeImage操作符的SampledType的宽度必须为64
    43.如果一个带少于64-bit component的VkFormat的VkImageView作为该命令的结果进行访问，则该命令的OpTypeImage操作符的SampledType的宽度必须为32
    44.如果一个带64-bit component的VkFormat的VkBufferView作为该命令的结果进行访问，则该命令的OpTypeImage操作符的SampledType的宽度必须为64位
    45.如果一个带少于64-bit component的VkFormat的VkBufferView作为该命令的结果进行访问，则该命令的OpTypeImage操作符的SampledType的宽度必须为32
    46.如果sparseImageInt64Atomics 特性未开启，则以VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT创建的VkImage对象不能被SampledType宽度为64位的OpTypeImage的atomic instructions访问
    47.如果sparseImageInt64Atomics 特性未开启，则以VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT创建的VkBuffer对象不能被SampledType宽度为64位的OpTypeImage的atomic instructions访问
    48.如果OpImageWeightedSampleQCOM用来采样一个作为该命令的结果的VkImageView，则该image view的format features必须包含VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM
    49.如果OpImageWeightedSampleQCOM用来采样一个作为该命令的结果的sample weight image的VkImageView，则该image view的format features必须包含VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM
    50.如果OpImageBoxFilterQCOM用来采样一个作为该命令的结果的VkImageView，则该image view的format features必须包含VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM
    51.如果OpImageBlockMatchSSDQCOM，或者 OpImageBlockMatchSADQCOM用来读取一个作为该命令的结果的VkImageView，则（1）该image view的format features必须包含VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM
                                                                                                               （2）如果是读取的reference image，指定的reference coordinates不能在integer texel coordinate validation 时候失败
    52.如果OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchWindowSSDQCOM, OpImageBlockMatchWindowSADQCOM, OpImageBlockMatchGatherSSDQCOM,
                                                OpImageBlockMatchGatherSADQCOM, OpImageBlockMatchSSDQCOM, 或者 OpImageBlockMatchSADQCOM用来采样一个作为该命令的结果的VkImageView，则该VkSampler必须以VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM创建
    53.如果任何除了OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchWindowSSDQCOM, OpImageBlockMatchWindowSADQCOM, OpImageBlockMatchGatherSSDQCOM, OpImageBlockMatchGatherSADQCOM, OpImageBlockMatchSSDQCOM, 或者 OpImageBlockMatchSADQCOM之外的指令使用VkSampler进行采样作为该命令的结果，则该sampler不能以VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM 创建
    54.如果OpImageBlockMatchWindow*QCOM or OpImageBlockMatchGather*QCOM指令用来读取VkImageView作为该命令的结果，则（1）VkImageView的format features必须包含VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM
                                                                                                                  （2）VkImageView的format必须只含有一个component
    55.如果OpImageBlockMatchWindow*QCOM or OpImageBlockMatchGather*QCOM指令用来读取一个引用的image作为该命令的结果，则指定的 reference coordinates不能在integer texel coordinate validation 时候失败
    56.任何该命令执行的shader invocation必须已经终止
    57.如果有一个类型位为VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM, VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, 或者 VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT中任意一个的descriptor作为该命令的结果进行访问，则该descriptor所指的image subresource的layout必须和该descriptor被写入时的layout相同。
    58.当前的 render pass  必须和绑定到VK_PIPELINE_BIND_POINT_GRAPHICS上的VkPipeline 创建时候的VkGraphicsPipelineCreateInfo中指定的renderPass兼容
    59.当前的 render pass  的subpass index必须和绑定到VK_PIPELINE_BIND_POINT_GRAPHICS上的VkPipeline 创建时候的VkGraphicsPipelineCreateInfo中指定的subpass相同
    60.如果任何shader静态访问一个input attachment，则有效的descriptor必须通过VkDescriptorSet被绑定到该pipeline中
    61.如果任何该pipeline执行shader以SubpassData的Dim操作符访问一个OpTypeImage变量，则该变量必须被一个对应当前subpass的input attachment的InputAttachmentIndex修饰
    62.在subpass中访问的Input attachment views必须以和该subpass相同定义的VkFormat创建，且必须以一个和当前绑定的VkFramebuffer的该附件引用的subpass的pInputAttachments[InputAttachmentIndex]附件兼容的VkImageView创建，参见Fragment Input Attachment Compatibility p1408
    63.在动态render pass中访问以VkRenderingInputAttachmentIndexInfoKHR的InputAttachmentIndex，或者VkRenderingInputAttachmentIndexInfoKHR:pDepthInputAttachmentIndex 或者 VkRenderingInputAttachmentIndexInfoKHR:pStencilInputAttachmentIndex为NULL情况下不指定InputAttachmentIndex的引用的Input attachment views，必须以和VkRenderingInfo中对应color, depth, 或者 stencil attachment兼容的VkImageView创建
    64.如果VkRenderingInputAttachmentIndexInfoKHR::pDepthInputAttachmentIndex 以及 VkRenderingInputAttachmentIndexInfoKHR::pStencilInputAttachmentIndex不为NULL，则在动态render pass中通过shader object访问Input attachment views必须指明InputAttachmentIndex
    65.如果在动态render pass中通过shader object访问Input attachment views指明了InputAttachmentIndex，则InputAttachmentIndex必须匹配VkRenderingInputAttachmentIndexInfoKHR中的index
    66.当前render pass所用的附件对应的image subresource底层内存的写入只能作为该命令的一个附件写入
    67.如果一个color attachment在之前的该subpass的命令中以load, store, 或者 resolve operations进行了写入，则其layout不为VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT，且有当前绑定的pipeline设有VK_PIPELINE_CREATE_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT，或者
                                    最后的vkCmdSetAttachmentFeedbackLoopEnableEXT调用包含VK_IMAGE_ASPECT_COLOR_BIT以及 没有绑定的pipeline 或者绑定的pipeline以VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT创建，则该附件只能以附件进行访问的，这两种情况中之一
    68.如果一个depth attachment在之前的该subpass的命令中以load, store, 或者 resolve operations进行了写入，则其layout不为VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT，且有当前绑定的pipeline设有VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT，或者
                                    最后的vkCmdSetAttachmentFeedbackLoopEnableEXT调用包含VK_IMAGE_ASPECT_DEPTH_BIT以及 没有绑定的pipeline 或者绑定的pipeline以VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT创建，则该附件只能以附件进行访问的，这两种情况中之一
    69.如果一个stencil attachment在之前的该subpass的命令中以load, store, 或者 resolve operations进行了写入，则其layout不为VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT，且有当前绑定的pipeline设有VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT，或者
                                    最后的vkCmdSetAttachmentFeedbackLoopEnableEXT调用包含VK_IMAGE_ASPECT_STENCIL_BIT以及 没有绑定的pipeline 或者绑定的pipeline以VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT创建，则该附件只能以附件进行访问的，这两种情况中之一
    70.如果一个attachment在之前的该subpass的命令中以load, store, 或者 resolve operations进行了写入,则该附件就不能再以除作为一个附件，storage image或者sampled image被该命令访问
    71.如果在之前的命令的subpass中以用作附件外的方式访问访问了一个当权subpass的附件所对的image subresource，则该命令就不能再将该image subresource用作附件进行写入
    72.如果当前render pass使用一个depth/stencil attachment，则（1）如果depth aspect的layout为read-only的layout，则不能启用depth writes
                                                              （2）如果stencil aspect的layout为read-only的layout，front 以及 back writeMask不为0，且stencil 测试开启，则所有stencil 操作必须为VK_STENCIL_OP_KEEP
    73.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_VIEWPORT动态state开启创建，则vkCmdSetViewport必须在该命令之前设置
                                    （2）以VK_DYNAMIC_STATE_SCISSOR动态state开启创建，则vkCmdSetScissor必须在该命令之前设置
                                    （3）以VK_DYNAMIC_STATE_LINE_WIDTH动态state开启创建，则vkCmdSetLineWidth必须在该命令之前设置
                                    （4）以VK_DYNAMIC_STATE_DEPTH_BIAS动态state开启创建，则vkCmdSetDepthBias或者vkCmdSetDepthBias2EXT 必须在该命令之前设置
                                    （5）以VK_DYNAMIC_STATE_BLEND_CONSTANTS动态state开启创建，则vkCmdSetBlendConstants 必须在该命令之前设置
                                    （6）以VK_DYNAMIC_STATE_DEPTH_BOUNDS动态state开启创建，且如果当前depthBoundsTestEnable为VK_TRUE， 则vkCmdSetDepthBounds 必须在该命令之前设置
                                    （7）以VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK动态state开启创建，且如果当前stencilTestEnable为VK_TRUE， 则vkCmdSetStencilCompareMask 必须在该命令之前设置
                                    （8）以VK_DYNAMIC_STATE_STENCIL_WRITE_MASK动态state开启创建，且如果当前stencilTestEnable为VK_TRUE， 则vkCmdSetStencilWriteMask 必须在该命令之前设置
                                    （9）以VK_DYNAMIC_STATE_STENCIL_REFERENCE动态state开启创建，且如果当前stencilTestEnable为VK_TRUE， 则vkCmdSetStencilReference 必须在该命令之前设置
                                    （10）以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT动态state开启创建， 则vkCmdSetSampleLocationsEXT 必须在该命令之前设置
                                    （11）以VK_DYNAMIC_STATE_CULL_MODE动态state开启创建， 则vkCmdSetCullMode 必须在该命令之前设置
                                    （12）以VK_DYNAMIC_STATE_FRONT_FACE动态state开启创建， 则vkCmdSetFrontFace 必须在该命令之前设置
                                    （13）以VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE动态state开启创建， 则vkCmdSetDepthTestEnable 必须在该命令之前设置
                                    （14）以VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE动态state开启创建， 则vkCmdSetDepthWriteEnable 必须在该命令之前设置
                                    （15）以VK_DYNAMIC_STATE_DEPTH_COMPARE_OP动态state开启创建， 则vkCmdSetDepthCompareOp 必须在该命令之前设置
                                    （16）以VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE动态state开启创建， 则vkCmdSetDepthBoundsTestEnable 必须在该命令之前设置
                                    （17）以VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE动态state开启创建， 则vkCmdSetStencilTestEnable 必须在该命令之前设置
                                    （18）以VK_DYNAMIC_STATE_STENCIL_OP动态state开启创建， 则vkCmdSetStencilOp 必须在该命令之前设置
                                    （19）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT但不以VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT 动态state开启创建， 则vkCmdSetViewportWithCount 必须在该命令之前设置，且vkCmdSetViewportWithCount设置的viewportCount必须匹配pipeline的VkPipelineViewportStateCreateInfo::scissorCount
                                    （20）以VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT但不以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT 动态state开启创建， 则vkCmdSetScissorWithCount 必须在该命令之前设置，且vkCmdSetScissorWithCount设置的scissorCount必须匹配pipeline的VkPipelineViewportStateCreateInfo::viewportCount
                                    （21）以VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT和VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT 动态state同时开启创建， 则vkCmdSetViewportWithCount以及vkCmdSetScissorWithCount 必须在该命令之前设置，且vkCmdSetViewportWithCount设置的viewportCount必须匹配vkCmdSetScissorWithCount设置的scissorCount
                                    （22）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT但不以VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV 动态state开启创建， 则绑定的pipeline必须以VkPipelineViewportWScalingStateCreateInfoNV::viewportCount 大于等于最近vkCmdSetViewportWithCount设置的viewportCount创建
                                    （23）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT和VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV 动态state开启创建， 则最近调用的vkCmdSetViewportWScalingNV设置的viewportCount 必须大于等于最近vkCmdSetViewportWithCount设置的viewportCount
                                    （24）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT但不以VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV 动态state开启创建， 则绑定的pipeline必须以VkPipelineViewportShadingRateImageStateCreateInfoNV::viewportCount 大于等于最近vkCmdSetViewportWithCount设置的viewportCount创建
                                    （25）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT和VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV 动态state开启创建， 则最近调用的vkCmdSetViewportShadingRatePaletteNV设置的viewportCount 必须大于等于最近vkCmdSetViewportWithCount设置的viewportCount
                                    （26）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT动态state开启且VkPipelineViewportStateCreateInfo的pNext中含有一个VkPipelineViewportSwizzleStateCreateInfoNV 创建， 则绑定的pipeline必须以VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount 大于等于最近vkCmdSetViewportWithCount设置的viewportCount创建
                                    （27）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT动态state开启且VkPipelineViewportStateCreateInfo的pNext中含有一个VkPipelineViewportExclusiveScissorStateCreateInfoNV 创建， 则绑定的pipeline必须以VkPipelineViewportExclusiveScissorStateCreateInfoNV::exclusiveScissorCount 大于等于最近vkCmdSetViewportWithCount设置的viewportCount创建
                                    （28）以VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_ENABLE_NV动态state开启创建， 则vkCmdSetExclusiveScissorEnableNV 必须在该命令之前设置
                                    （29）以VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV动态state开启创建， 则vkCmdSetExclusiveScissorNV 必须在该命令之前设置
                                    （30）以VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE动态state开启创建， 则vkCmdSetRasterizerDiscardEnable 必须在该命令之前设置
                                    （31）以VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE动态state开启创建， 则vkCmdSetDepthBiasEnable 必须在该命令之前设置
                                    （32）以VK_DYNAMIC_STATE_LOGIC_OP_EXT动态state开启创建， 则vkCmdSetLogicOpEXT 必须在该命令之前设置且参数logicOp必须是一个有效的VkLogicOp值
    74.如果一个shader object绑定到任何graphics stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                    （1）如果最靠近当前命令的vkCmdSetPolygonModeEXT设置polygonMode为VK_POLYGON_MODE_LINE或者是任何line topology，则vkCmdSetLineWidth必须在该命令之前设置
                                    （2）如果最靠近当前命令的vkCmdSetDepthBiasEnable设置depthBiasEnable为VK_TRUE，则vkCmdSetDepthBias 或者 vkCmdSetDepthBias2EXT必须在该命令之前设置
                                    （3）如果最靠近当前命令的vkCmdSetDepthBoundsTestEnable设置depthBoundsTestEnable为VK_TRUE，则vkCmdSetDepthBounds必须在该命令之前设置
                                    （4）如果最靠近当前命令的vkCmdSetStencilTestEnable设置stencilTestEnable为VK_TRUE，则vkCmdSetStencilCompareMask必须在该命令之前设置
                                    （5）如果最靠近当前命令的vkCmdSetStencilTestEnable设置stencilTestEnable为VK_TRUE，则vkCmdSetStencilWriteMask必须在该命令之前设置
                                    （6）如果最靠近当前命令的vkCmdSetStencilTestEnable设置stencilTestEnable为VK_TRUE，则vkCmdSetStencilReference必须在该命令之前设置
                                    （7）如果最靠近当前命令的vkCmdSetSampleLocationsEnableEXT设置sampleLocationsEnable为VK_TRUE，则vkCmdSetSampleLocationsEXT必须在该命令之前设置
                                    （8）则vkCmdSetCullMode必须在该命令之前设置
                                    （9）则vkCmdSetFrontFace必须在该命令之前设置
                                    （10）则vkCmdSetDepthTestEnable 必须在该命令之前设置
                                    （11）则vkCmdSetDepthWriteEnable 必须在该命令之前设置
                                    （12）如果最靠近当前命令的vkCmdSetDepthTestEnable设置depthTestEnable为VK_TRUE，则vkCmdSetDepthCompareOp 必须在该命令之前设置
                                    （13）则vkCmdSetDepthBoundsTestEnable 必须在该命令之前设置
                                    （14）则vkCmdSetStencilTestEnable 必须在该命令之前设置
                                    （15）如果最靠近当前命令的vkCmdSetStencilTestEnable设置stencilTestEnable为VK_TRUE，则vkCmdSetStencilOp 必须在该命令之前设置
                                    （16）
                                    （17）如果shadingRateImage特性开启，则vkCmdSetCoarseSampleOrderNV 必须在该命令之前设置
                                    （18）如果shadingRateImage特性开启，且最靠近当前命令的vkCmdSetShadingRateImageEnableNV设置shadingRateImageEnable为VK_TRUE，则vkCmdSetViewportShadingRatePaletteNV 必须在该命令之前设置
                                    （19）如果shadingRateImage特性开启，且最靠近当前命令的vkCmdSetShadingRateImageEnableNV设置shadingRateImageEnable为VK_TRUE，则最近的vkCmdSetViewportShadingRatePaletteNV设置的viewportCount 必须大于等于vkCmdSetViewportWithCount设置的viewportCount
                                    （20）则vkCmdSetDepthBiasEnable必须在该命令之前设置
    75.如果一个输出line primitives的shader object绑定到VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或者 VK_SHADER_STAGE_GEOMETRY_BIT，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则vkCmdSetLineWidth必须在该命令之前设置
    76.如果一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最靠近当前命令的vkCmdSetColorBlendEnableEXT设置pColorBlendEnables任何元素为VK_TRUE，且
                        最靠近当前命令的vkCmdSetColorBlendEquationEXT设置pColorBlendEquations相同元素的VkColorBlendEquationEXT的VkBlendFactor成员为VK_BLEND_FACTOR_CONSTANT_COLOR, VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR, VK_BLEND_FACTOR_CONSTANT_ALPHA, 或者 VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA，则vkCmdSetBlendConstants必须在该命令之前设置
    77.如果该命令记录在开启了multiview的render pass instance中，则最大的instance 索引必须小于等于VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex
    78.如果绑定的graphics pipeline以VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable设置为VK_TRUE创建且当前的subpass含有一个 depth/stencil attachment，则该attachment必须以VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT创建
    >>78.5  .如果一个shader object绑定到任何graphics stage，则（1）vkCmdSetViewportWithCount 和vkCmdSetScissorWithCount 必须同时在该命令之前设置，且vkCmdSetViewportWithCount设置的viewportCount必须匹配vkCmdSetScissorWithCount设置的scissorCount
                                                              （2）则vkCmdSetRasterizerDiscardEnable 必须在该命令之前设置
    79.如果VK_NV_clip_space_w_scaling拓展开启，且shader object绑定到任何graphics stage，且最近的vkCmdSetViewportWScalingEnableNV设置viewportWScalingEnable为VK_TRUE，则（1）vkCmdSetViewportWScalingNV必须在该命令前设置
                                                                                                                                                                       （2）最近vkCmdSetViewportWScalingNV设置的viewportCount必须大于等于vkCmdSetViewportWithCount设置的viewportCount
    80.如果exclusiveScissor 特性开启，且shader object绑定到任何graphics stage，，则（1）vkCmdSetExclusiveScissorEnableNV必须在该命令前设置
                                                                                   （2）最近的vkCmdSetExclusiveScissorEnableNV调用设置的pExclusiveScissorEnables中的任何元素为VK_TRUE,则vkCmdSetExclusiveScissorNV必须在该命令前设置
    81.如果一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最靠近当前命令的vkCmdSetLogicOpEnableEXT设置logicOpEnable任何元素为VK_TRUE，则vkCmdSetLogicOpEXT 必须在该命令之前设置且参数logicOp必须是一个有效的VkLogicOp值
    82.如果primitiveFragmentShadingRateWithMultipleViewports限制不支持，则（1）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT动态state开启创建，且任何该pipeline的shader stage会写入PrimitiveShadingRateKHR built-in修饰的变量，则vkCmdSetViewportWithCount 必须在该命令之前设置且参数viewportCount必须是1
                                                                          （2）任何绑定的graphics pipeline的shader stage会写入PrimitiveShadingRateKHR built-in修饰的变量，则vkCmdSetViewportWithCount 必须在该命令之前设置且参数viewportCount必须是1
    83.如果graphics pipeline中未开启rasterization，则对subpass中的每个color attachment，如果其对应的image view 的format features不包含VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT，则pColorBlendState中其对应pAttachments中元素的blendEnable必须为VK_FALSE
    84.如果一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则对于render pass中的每个color attachment，如果其对应的image view 的format features不包含VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT， 则最近的vkCmdSetColorBlendEnableEXT设置的pColorBlendEnables中该附件的对应元素必须为VK_FALSE
    85.如果graphics pipeline中未开启rasterization，有VK_AMD_mixed_attachment_samples拓展未开启，VK_NV_framebuffer_mixed_samples拓展未开启，multisampledRenderToSingleSampled特性未开启，则当前绑定的pipeline的rasterizationSamples必须和当前subpass的color 以及/或者 depth/stencil attachments的相同
    86.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且有VK_AMD_mixed_attachment_samples拓展未开启，VK_NV_framebuffer_mixed_samples拓展未开启，multisampledRenderToSingleSampled特性未开启，则最近vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples必须和当前subpass的color 以及/或者 depth/stencil attachments的相同
    87.如果一个shader object绑定到任何graphics stage，则当前的render pass instance必须以vkCmdBeginRendering开始
    88.如果当前的render pass instance以vkCmdBeginRendering开始，（1）如果pDepthAttachment的imageView不为VK_NULL_HANDLE，且pDepthAttachment的layout不为VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL，则该命令不能写入任何值到depth attachment
                                                                （2）如果pStencilAttachment的imageView不为VK_NULL_HANDLE，且pStencilAttachment的layout不为VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL，则该命令不能写入任何值到stencil attachment
                                                                （3）如果pDepthAttachment的imageView不为VK_NULL_HANDLE，且pDepthAttachment的layout为VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL，则该命令不能写入任何值到depth attachment
                                                                （4）如果pStencilAttachment的imageView不为VK_NULL_HANDLE，且pStencilAttachment的layout为VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL，则该命令不能写入任何值到stencil attachment
                                                                （5）如果pDepthAttachment的imageView不为VK_NULL_HANDLE，且pDepthAttachment的layout为VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL，则该命令不能写入任何值到depth attachment
                                                                （6）如果pStencilAttachment的imageView不为VK_NULL_HANDLE，且pStencilAttachment的layout为VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL，则该命令不能写入任何值到stencil attachment
                                                                （7）则当前绑定的graphics pipeline必须以含VkPipelineRenderingCreateInfo::viewMask等于VkRenderingInfo::viewMask创建
                                                                （8）如果带有VkRenderingInfo::colorAttachmentCount为1，则没有shader object绑定到任何graphics stage，且一个color attachment的 resolve mode为VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID，则VkRenderingInfo::pColorAttachments中每个resolveImageView不为VK_NULL_HANDLE的元素其对应image必须以和创建当前绑定的pipeline 相同的VkExternalFormatANDROID::externalFormat创建
                                                                （9）如果没有shader object绑定到任何graphics stage，如果绑定的graphics pipeline以一个非零值VkExternalFormatANDROID::externalFormat创建且启用VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态设置，则vkCmdSetColorBlendEnableEXT必须在该命令前设置blend enable为VK_FALSE
                                                                （10）如果没有shader object绑定到任何graphics stage，如果绑定的graphics pipeline以一个非零值VkExternalFormatANDROID::externalFormat创建且启用VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态设置，则vkCmdSetRasterizationSamplesEXT必须在该命令前设置rasterizationSamples为VK_SAMPLE_COUNT_1_BIT
                                                                （11）如果没有shader object绑定到任何graphics stage，如果绑定的graphics pipeline以一个非零值VkExternalFormatANDROID::externalFormat创建且启用VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR动态设置，则vkCmdSetFragmentShadingRateKHR必须在该命令前设置pFragmentSize->width为1，pFragmentSize->height为1
    89.如果dynamicRenderingUnusedAttachments特性未开启，且当前的render pass instance以vkCmdBeginRendering开始，则
                                                            （1）当前绑定的graphics pipeline必须以含VkPipelineRenderingCreateInfo::colorAttachmentCount等于VkRenderingInfo::colorAttachmentCount创建
                                                            （2）如果VkRenderingInfo::colorAttachmentCount大于0，则VkRenderingInfo::pColorAttachments 中每一个其imageView不为VK_NULL_HANDLE的元素的VkImageView必须以VkFormat对应绑定的graphics pipeline的VkPipelineRenderingCreateInfo::pColorAttachmentFormats指明的format创建
                                                            （3）如果VkRenderingInfo::colorAttachmentCount大于0，则VkRenderingInfo::pColorAttachments 中每一个其imageView为VK_NULL_HANDLE的元素对应绑定的graphics pipeline的VkPipelineRenderingCreateInfo::pColorAttachmentFormats指明的format必须为VK_FORMAT_UNDEFINED
                                                            （4）如果VkRenderingInfo::pDepthAttachment->imageView为VK_NULL_HANDLE，则创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::depthAttachmentFormat必须为VK_FORMAT_UNDEFINED
                                                            （5）如果VkRenderingInfo::pDepthAttachment->imageView不为VK_NULL_HANDLE，则创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::depthAttachmentFormat必须和创建VkRenderingInfo::pDepthAttachment->imageView的VkFormat相同
                                                            （6）如果VkRenderingInfo::pStencilAttachment->imageView为VK_NULL_HANDLE，则创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::stencilAttachmentFormat必须为VK_FORMAT_UNDEFINED
                                                            （7）如果VkRenderingInfo::pStencilAttachment->imageView不为VK_NULL_HANDLE，则创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::stencilAttachmentFormat必须和创建VkRenderingInfo::pStencilAttachment->imageView的VkFormat相同
    90.如果dynamicRenderingUnusedAttachments特性开启，且当前的render pass instance以vkCmdBeginRendering开始，则
                                                            （1）如果VkRenderingInfo::colorAttachmentCount大于0，则VkRenderingInfo::pColorAttachments 中每一个其imageView不为VK_NULL_HANDLE的元素的VkImageView必须以VkFormat对应绑定的graphics pipeline的VkPipelineRenderingCreateInfo::pColorAttachmentFormats指明的format创建，或者是对应元素为VK_FORMAT_UNDEFINED创建
                                                            （2）如果VkRenderingInfo::pDepthAttachment->imageView不为VK_NULL_HANDLE，且创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::depthAttachmentFormat和创建VkRenderingInfo::pDepthAttachment->imageView的VkFormat不同，则该format必须为VK_FORMAT_UNDEFINED
                                                            （3）如果VkRenderingInfo::pStencilAttachment->imageView不为VK_NULL_HANDLE，且创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::stencilAttachmentFormat和创建VkRenderingInfo::pStencilAttachment->imageView的VkFormat不同，则该format必须为VK_FORMAT_UNDEFINED
    91.如果没有shader object绑定到任何graphics stage，且当前的render pass instance以vkCmdBeginRendering开始且VkRenderingInfo::colorAttachmentCount为1，且一个color attachment的 resolve mode为VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID，则VkRenderingInfo::pColorAttachments中每个resolveImageView不为VK_NULL_HANDLE的元素其对应image必须以和创建当前绑定的pipeline 相同的VkExternalFormatANDROID::externalFormat创建
    92.如果有一个shader object绑定到任何graphics stage，且当前的render pass 包含一个使用VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID resolve mode的color attachment，则（1）vkCmdSetColorBlendEnableEXT必须在该命令前设置blend enable为VK_FALSE
                                                                                                                                                                             （2）则vkCmdSetRasterizationSamplesEXT必须在该命令前设置rasterizationSamples为VK_SAMPLE_COUNT_1_BIT
                                                                                                                                                                             （3）则vkCmdSetFragmentShadingRateKHR必须在该命令前设置pFragmentSize->width为1，pFragmentSize->height为1
    93.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT动态state开启创建， 则vkCmdSetColorWriteEnableEXT 必须在该命令之前设置，且设置的attachmentCount必须大于等于创建当前绑定的pipeline的VkPipelineColorBlendStateCreateInfo::attachmentCount
                                    （2）以VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT动态state开启创建， 则vkCmdSetDiscardRectangleEXT 必须在该命令之前为每个VkPipelineDiscardRectangleStateCreateInfoEXT::discardRectangleCount指明的discard rectangle 设置
                                    （3）以VK_DYNAMIC_STATE_DISCARD_RECTANGLE_ENABLE_EXT动态state开启创建， 则vkCmdSetDiscardRectangleEnableEXT 必须在该命令之前设置
                                    （4）以VK_DYNAMIC_STATE_DISCARD_RECTANGLE_MODE_EXT动态state开启创建， 则vkCmdSetDiscardRectangleModeEXT 必须在该命令之前设置
    94.如果有一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                    （1）如果colorWriteEnable特性在device上开启，则vkCmdSetColorWriteEnableEXT 必须在该命令之前设置，且设置的attachmentCount必须大于等于当前render pass instance的color attachment的数量
                                    （2）如果VK_EXT_discard_rectangles拓展开启，且最近的vkCmdSetDiscardRectangleEnableEXT设置discardRectangleEnable为VK_TRUE， 则vkCmdSetDiscardRectangleEXT 必须在该命令之前设置
                                    （3）如果VK_EXT_discard_rectangles拓展开启， 则vkCmdSetDiscardRectangleEnableEXT 必须在该命令之前设置
                                    （4）如果VK_EXT_discard_rectangles拓展开启， 则最近的vkCmdSetDiscardRectangleEnableEXT设置discardRectangleEnable为VK_TRUE，则vkCmdSetDiscardRectangleModeEXT 必须在该命令之前设置
    95.如果当前的render pass instance以vkCmdBeginRendering开始，则（1）如果VkRenderingFragmentShadingRateAttachmentInfoKHR::imageView不为VK_NULL_HANDLE，则当前绑定的graphics pipeline必须以VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR创建
                                                                  （2）如果VkRenderingFragmentDensityMapAttachmentInfoEXT::imageView不为VK_NULL_HANDLE，则当前绑定的graphics pipeline必须以VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT创建
                                                                  （3）且含VkRenderingInfo::colorAttachmentCount大于0，如果当前的绑定的pipeline以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，则VkRenderingInfo::pColorAttachments中每个imageView不为VK_NULL_HANDLE的元素的imageView，必须以当前pipeline的VkAttachmentSampleCountInfoAMD 或者 VkAttachmentSampleCountInfoNV中的pColorAttachmentSamples中对应元素的sample count进行创建
                                                                  （4）如果当前的绑定的pipeline以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且VkRenderingInfo::pDepthAttachment中的imageView不为VK_NULL_HANDLE，则当前pipeline的VkAttachmentSampleCountInfoAMD 或者 VkAttachmentSampleCountInfoNV中的depthStencilAttachmentSamples必须等于创建VkRenderingInfo::pDepthAttachment->imageView的sample count
                                                                  （5）如果当前的绑定的pipeline以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且VkRenderingInfo::pStencilAttachment中的imageView不为VK_NULL_HANDLE，则当前pipeline的VkAttachmentSampleCountInfoAMD 或者 VkAttachmentSampleCountInfoNV中的depthStencilAttachmentSamples必须等于创建VkRenderingInfo::pStencilAttachment->imageView的sample count
                                                                  （6）且含VkRenderingInfo::colorAttachmentCount大于0，如果当前的绑定的pipeline不以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且multisampledRenderToSingleSampled特性没有开启，则VkRenderingInfo::pColorAttachments中每个imageView不为VK_NULL_HANDLE的元素的imageView，其创建的sample count必须等于当前绑定的graphics pipeline的rasterizationSamples
                                                                  （7）如果当前的绑定的pipeline不以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且VkRenderingInfo::pDepthAttachment中的imageView不为VK_NULL_HANDLE，且multisampledRenderToSingleSampled特性没有开启，则当前pipeline的rasterizationSamples 必须等于创建VkRenderingInfo::pDepthAttachment->imageView的sample count
                                                                  （8）如果当前的绑定的pipeline不以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且VkRenderingInfo::pStencilAttachment中的imageView不为VK_NULL_HANDLE，且multisampledRenderToSingleSampled特性没有开启，则当前pipeline的rasterizationSamples 必须等于创建VkRenderingInfo::pStencilAttachment->imageView的sample count
                                                                  （9）当前绑定的pipeline必须VkGraphicsPipelineCreateInfo::renderPass为VK_NULL_HANDLE创建
                                                                  （10）如果绑定的pipeline的fragment shader静态写入一个color attachment，且color write mask不为0，启用了color writes，且该附件对应的VkRenderingInfo::pColorAttachments->imageView 不为VK_NULL_HANDLE，则对应的创建pipeline的VkPipelineRenderingCreateInfo::pColorAttachmentFormats中的元素不能为VK_FORMAT_UNDEFINED
                                                                  （11）如果绑定的pipeline启用了depth test，启用了depth writes，且VkRenderingInfo::pDepthAttachment->imageView 不为VK_NULL_HANDLE，则创建pipeline的VkPipelineRenderingCreateInfo::depthAttachmentFormat不能为VK_FORMAT_UNDEFINED
                                                                  （12）如果绑定的pipeline启用了stencil test，且VkRenderingInfo::pStencilAttachment->imageView 不为VK_NULL_HANDLE，则创建pipeline的VkPipelineRenderingCreateInfo::stencilAttachmentFormat不能为VK_FORMAT_UNDEFINED
    96.如果该命令在以vkCmdBeginRendering开始的render pass instance中调用，且VkRenderingInfo的pNext中包含一个multisampledRenderToSingleSampledEnable设为VK_TRUE的VkMultisampledRenderToSingleSampledInfoEXT，则当前绑定的graphics pipeline的rasterizationSamples必须等于VkMultisampledRenderToSingleSampledInfoEXT::rasterizationSamples
    97.如果primitivesGeneratedQueryWithRasterizerDiscard特性未开启，且VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query激活，则不能启用rasterization discard
    98.如果primitivesGeneratedQueryWithNonZeroStreams特性未开启，且VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query激活，则 绑定的graphics pipeline不能以VkPipelineRasterizationStateStreamCreateInfoEXT::rasterizationStream为非零值创建
    98.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_TESSELLATION_DOMAIN_ORIGIN_EXT动态state开启创建，则vkCmdSetTessellationDomainOriginEXT必须在该命令之前设置
                                    （2）以VK_DYNAMIC_STATE_DEPTH_CLAMP_ENABLE_EXT动态state开启创建，则vkCmdSetDepthClampEnableEXT必须在该命令之前设置
                                    （3）以VK_DYNAMIC_STATE_POLYGON_MODE_EXT动态state开启创建，则vkCmdSetPolygonModeEXT必须在该命令之前设置
                                    （4）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，则vkCmdSetRasterizationSamplesEXT必须在该命令之前设置
                                    （5）以VK_DYNAMIC_STATE_SAMPLE_MASK_EXT动态state开启创建，则vkCmdSetSampleMaskEXT必须在该命令之前设置
                                    （6）以VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT动态state开启创建，则vkCmdSetAlphaToCoverageEnableEXT必须在该命令之前设置
                                    （7）以VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT动态state开启创建，则最近的vkCmdSetAlphaToCoverageEnableEXT设置alphaToCoverageEnable为VK_TRUE，则Fragment Output Interface中 Index 0的Location 0必须有一个含alpha Component的变量
                                    （8）以VK_DYNAMIC_STATE_ALPHA_TO_ONE_ENABLE_EXT动态state开启创建，则vkCmdSetAlphaToOneEnableEXT必须在该命令之前设置
                                    （9）以VK_DYNAMIC_STATE_LOGIC_OP_ENABLE_EXT动态state开启创建，则vkCmdSetLogicOpEnableEXT必须在该命令之前设置
                                    （10）以VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态state开启创建，则vkCmdSetColorBlendEnableEXT必须在该命令之前设置
                                    （11）以VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT动态state开启创建，则vkCmdSetColorBlendEquationEXT必须在该命令之前设置
                                    （12）以VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT动态state开启创建，则vkCmdSetColorWriteMaskEXT必须在该命令之前设置
    
    99.如果一个shader object绑定到VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT stage，则vkCmdSetTessellationDomainOriginEXT必须在该命令之前设置
    100.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                                    （1）如果depthClamp特性启用，则vkCmdSetDepthClampEnableEXT必须在该命令之前设置
                                                    （2）则vkCmdSetPolygonModeEXT必须在该命令之前设置
                                                    （3）则vkCmdSetRasterizationSamplesEXT必须在该命令之前设置
                                                    （4）则vkCmdSetSampleMaskEXT必须在该命令之前设置
                                                    （5）则vkCmdSetAlphaToCoverageEnableEXT必须在该命令之前设置
                                                    （6）如果alphaToOne特性启用，则vkCmdSetAlphaToOneEnableEXT必须在该命令之前设置
    
    101.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetAlphaToCoverageEnableEXT设置alphaToCoverageEnable为VK_TRUE，则Fragment Output Interface中 Index 0的Location 0必须有一个含alpha Component的变量
    102.如果一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                        （1）如果logicOp特性开启 ,vkCmdSetLogicOpEnableEXT必须在该命令之前设置
                                        （2）如果绑定了color attachments，则vkCmdSetColorBlendEnableEXT必须在该命令之前设置
                                        （3）如果最近的vkCmdSetColorBlendEnableEXT设置任何附件在pColorBlendEnables中的值为VK_TRUE ，则vkCmdSetColorBlendEquationEXT必须在该命令之前设置
                                        （4）如果绑定了color attachments，则vkCmdSetColorWriteMaskEXT必须在该命令之前设置
    
    103.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT动态state开启创建，则vkCmdSetRasterizationStreamEXT必须在该命令之前设置
                                     （2）以VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT动态state开启创建，则vkCmdSetConservativeRasterizationModeEXT必须在该命令之前设置
                                     （3）以VK_DYNAMIC_STATE_EXTRA_PRIMITIVE_OVERESTIMATION_SIZE_EXT动态state开启创建，则vkCmdSetExtraPrimitiveOverestimationSizeEXT必须在该命令之前设置
                                     （4）以VK_DYNAMIC_STATE_DEPTH_CLIP_ENABLE_EXT动态state开启创建，则vkCmdSetDepthClipEnableEXT必须在该命令之前设置
                                     （5）以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT动态state开启创建，则vkCmdSetSampleLocationsEnableEXT必须在该命令之前设置
                                     （6）以VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT动态state开启创建，则vkCmdSetColorBlendAdvancedEXT必须在该命令之前设置
                                     （7）以VK_DYNAMIC_STATE_PROVOKING_VERTEX_MODE_EXT动态state开启创建，则vkCmdSetProvokingVertexModeEXT必须在该命令之前设置
                                     （8）以VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT动态state开启创建，则vkCmdSetLineRasterizationModeEXT必须在该命令之前设置
                                     （9）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT动态state开启创建，则vkCmdSetLineStippleEnableEXT必须在该命令之前设置
                                     （10）以VK_DYNAMIC_STATE_LINE_STIPPLE_KHR动态state开启创建，则vkCmdSetLineStippleKHR必须在该命令之前设置
                                     （11）以VK_DYNAMIC_STATE_DEPTH_CLIP_NEGATIVE_ONE_TO_ONE_EXT动态state开启创建，则vkCmdSetDepthClipNegativeOneToOneEXT必须在该命令之前设置
                                     （12）以VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_ENABLE_NV动态state开启创建，则vkCmdSetViewportWScalingEnableNV必须在该命令之前设置
                                     （13）以VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV动态state开启创建，则vkCmdSetViewportSwizzleNV必须在该命令之前设置
                                     （14）以VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV动态state开启创建，则vkCmdSetCoverageToColorEnableNV必须在该命令之前设置
                                     （15）以VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_LOCATION_NV动态state开启创建，则vkCmdSetCoverageToColorLocationNV必须在该命令之前设置
                                     （16）以VK_DYNAMIC_STATE_COVERAGE_MODULATION_MODE_NV动态state开启创建，则vkCmdSetCoverageModulationModeNV必须在该命令之前设置
                                     （17）以VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV动态state开启创建，则vkCmdSetCoverageModulationTableEnableNV必须在该命令之前设置
                                     （18）以VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_NV动态state开启创建，则vkCmdSetCoverageModulationTableNV必须在该命令之前设置
                                     （19）以VK_DYNAMIC_STATE_SHADING_RATE_IMAGE_ENABLE_NV动态state开启创建，则vkCmdSetShadingRateImageEnableNV必须在该命令之前设置
                                     （20）以VK_DYNAMIC_STATE_REPRESENTATIVE_FRAGMENT_TEST_ENABLE_NV动态state开启创建，则vkCmdSetRepresentativeFragmentTestEnableNV必须在该命令之前设置
                                     （21）以VK_DYNAMIC_STATE_COVERAGE_REDUCTION_MODE_NV动态state开启创建，则vkCmdSetCoverageReductionModeNV必须在该命令之前设置
    
    104.如果一个shader object绑定到VK_SHADER_STAGE_GEOMETRY_BIT stage，且如果geometryStreams 特性开启，则vkCmdSetRasterizationStreamEXT必须在该命令之前设置
    105.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                            （1）如果VK_EXT_conservative_rasterization 拓展开启，vkCmdSetConservativeRasterizationModeEXT必须在该命令之前设置
                            （2）如果VK_EXT_conservative_rasterization 拓展开启，且最近的vkCmdSetConservativeRasterizationModeEXT设置conservativeRasterizationMode为VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT，则vkCmdSetExtraPrimitiveOverestimationSizeEXT必须在该命令之前设置
                            （3）如果VK_EXT_sample_locations 拓展开启，则vkCmdSetSampleLocationsEnableEXT必须在该命令之前设置
    106.如果一个shader object绑定到任何graphics stage，且depthClipEnable 特性开启，则vkCmdSetDepthClipEnableEXT必须在该命令之前设置
    107.如果如果一个shader object绑定到任何VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且如果VK_EXT_blend_operation_advanced 拓展开启，则vkCmdSetColorBlendEquationEXT 和 vkCmdSetColorBlendAdvancedEXT中至少一个必须在该命令之前设置
    108.如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，如果VK_EXT_provoking_vertex拓展开启， 则vkCmdSetProvokingVertexModeEXT必须在该命令之前设置
    109.如果VK_KHR_line_rasterization 或者 VK_EXT_line_rasterization拓展开启，则（1）如果一个shader object绑定到任意一个graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetPolygonModeEXT设置polygonMode 为VK_POLYGON_MODE_LINE ，则vkCmdSetLineRasterizationModeEXT必须在该命令之前设置
                                                                                （2）如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetPrimitiveTopology设置primitiveTopology 为任何line topology ，则vkCmdSetLineRasterizationModeEXT必须在该命令之前设置
                                                                                （3）如果一个输出为line primitive的shader object绑定到VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或 VK_SHADER_STAGE_GEOMETRY_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则vkCmdSetLineRasterizationModeEXT必须在该命令之前设置
                                                                                （4）如果一个shader object绑定到任意一个graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetPolygonModeEXT设置polygonMode 为VK_POLYGON_MODE_LINE ，则vkCmdSetLineStippleEnableEXT必须在该命令之前设置
                                                                                （5）如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetPrimitiveTopology设置primitiveTopology 为任何line topology ，则vkCmdSetLineStippleEnableEXT必须在该命令之前设置
                                                                                （6）如果一个输出为line primitive的shader object绑定到VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或 VK_SHADER_STAGE_GEOMETRY_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则vkCmdSetLineStippleEnableEXT必须在该命令之前设置
                                                                                （7）如果一个shader object绑定到任意一个graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetLineStippleEnableEXT设置stippledLineEnable 为VK_TRUE ，则vkCmdSetLineStippleEXT必须在该命令之前设置
    110.如果一个shader object绑定到任何graphics stage，（1）如果depthClipControl 特性开启，则vkCmdSetDepthClipNegativeOneToOneEXT必须在该命令之前设置
                                                       （2）VK_NV_clip_space_w_scaling 拓展开启，则vkCmdSetViewportWScalingEnableNV必须在该命令之前设置
                                                       （3）VK_NV_viewport_swizzle 拓展开启，则vkCmdSetViewportSwizzleNV必须在该命令之前设置
    111.如果如果一个shader object绑定到任何VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                        （1）如果VK_NV_fragment_coverage_to_color 拓展开启，则vkCmdSetCoverageToColorEnableNV 必须在该命令之前设置
                        （2）如果VK_NV_fragment_coverage_to_color 拓展开启，且最近的vkCmdSetCoverageToColorEnableNV 设置coverageToColorEnable 为VK_TRUE，则vkCmdSetCoverageToColorLocationNV 必须在该命令之前设置
                        （3）如果pipelineFragmentShadingRate 特性开启，则vkCmdSetFragmentShadingRateKHR 必须在该命令之前设置
    112.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                （1）如果VK_NV_framebuffer_mixed_samples 拓展开启，则vkCmdSetCoverageModulationModeNV 必须在该命令之前设置
                                （2）如果VK_NV_framebuffer_mixed_samples 拓展开启，且最近的vkCmdSetCoverageModulationModeNV设置coverageModulationMode为任何除VK_COVERAGE_MODULATION_MODE_NONE_NV之外的值，则vkCmdSetCoverageModulationTableEnableNV 必须在该命令之前设置
                                （3）如果VK_NV_framebuffer_mixed_samples 拓展开启，最近的vkCmdSetCoverageModulationTableEnableNV设置coverageModulationTableEnable为VK_TRUE，则vkCmdSetCoverageModulationTableNV 必须在该命令之前设置
                                （4）如果shadingRateImage 特性开启，则vkCmdSetShadingRateImageEnableNV 必须在该命令之前设置
                                （5）如果representativeFragmentTest 特性开启，则vkCmdSetRepresentativeFragmentTestEnableNV 必须在该命令之前设置
                                （6）如果coverageReductionMode 特性开启，则vkCmdSetCoverageReductionModeNV 必须在该命令之前设置
    113.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态state开启创建，且最近的vkCmdSetColorBlendEnableEXT设置任何附件在pColorBlendEnables中的值为VK_TRUE 则subpas中这些附件对应的image view的format features中必须包含VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT
                                     （2）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，且当前subpass不使用任何color和/或者 depth/stencil attachments，则最后的vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples必须符合zero￾attachment subpass的规则
                                     （3）以VK_DYNAMIC_STATE_SAMPLE_MASK_EXT不以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT 动态state开启创建，则最后调用的vkCmdSetSampleMaskEXT中设置的samples参数必须大于等于创建该pipeline的VkPipelineMultisampleStateCreateInfo::rasterizationSamples
                                     （4）以VK_DYNAMIC_STATE_SAMPLE_MASK_EXT和 VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT 动态state开启创建，则最后调用的vkCmdSetSampleMaskEXT中设置的samples参数必须大于等于最后的vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples
                                     （5）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，且VK_AMD_mixed_attachment_samples和VK_NV_framebuffer_mixed_samples拓展都没有开启，则最后的vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples必须等于subpass中color和/或者 depth/stencil attachments使用的相同
                                     （6）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，或者一个shader object绑定到任意graphics stage，且当前的subpass包含一个multisampledRenderToSingleSampledEnable 为VK_TRUE的VkMultisampledRenderToSingleSampledInfoEXT，则最后的vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples必须等于该VkMultisampledRenderToSingleSampledInfoEXT中的对应成员
                                     （7）以VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态state开启创建，则vkCmdSetColorBlendEnableEXT 必须在该命令之前设置，且vkCmdSetColorBlendEnableEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定值
                                     （8）以VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT动态state开启创建，则vkCmdSetColorBlendEquationEXT 必须在该命令之前设置，且vkCmdSetColorBlendEquationEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定blend equations
                                     （9）以VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT动态state开启创建，则vkCmdSetColorWriteMaskEXT 必须在该命令之前设置，且vkCmdSetColorWriteMaskEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定color write mask
                                     （10）以VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT动态state开启创建，则vkCmdSetColorBlendAdvancedEXT 必须在该命令之前设置，且vkCmdSetColorBlendAdvancedEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活blend的color attachments指定advanced blend equations
                                     （11）以VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT和VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态state开启创建，且最后的vkCmdSetColorBlendEnableEXT和vkCmdSetColorBlendAdvancedEXT设置启用了advanced blending，则当前subpass中激活的color attachments的数量不能超过advancedBlendMaxColorAttachments
                                     （12）以VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT动态state开启创建，且如果primitivesGeneratedQueryWithNonZeroStreams特性未开启且VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query已经激活，则最后的vkCmdSetRasterizationStreamEXT必须设置rasterizationStream为0
                                     （13）以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT但不以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，则最后的vkCmdSetSampleLocationsEXT设置的pSampleLocationsInfo->sampleLocationsPerPixel必须等于创建pipeline的VkPipelineMultisampleStateCreateInfo::rasterizationSamples
                                     （14）以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT和VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，则最后的vkCmdSetSampleLocationsEXT设置的pSampleLocationsInfo->sampleLocationsPerPixel必须等于最后vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples
                                     （15）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT但不以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT动态state开启创建，且绑定的pipeline的VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable为VK_TRUE 或者以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT动态state开启，则sampleLocationsInfo.sampleLocationsPerPixel 必须等于最后vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples
                                     （16）以VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV动态state开启创建，且最后的vkCmdSetCoverageToColorEnableNV设置coverageToColorEnable为VK_TRUE，则当前subpass必须有color attachment，且该attachment的format必须为VK_FORMAT_R8_UINT, VK_FORMAT_R8_SINT, VK_FORMAT_R16_UINT, VK_FORMAT_R16_SINT, VK_FORMAT_R32_UINT, 或者 VK_FORMAT_R32_SINT，且该attachment的location 有最后的vkCmdSetCoverageToColorLocationNV设置的coverageToColorLocation决定
                                     （17）以VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV和VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT 动态state开启创建，且如果VK_NV_coverage_reduction_mode 拓展开启，则当前的 coverageReductionMode，rasterizationSamples 以及color 以及 depth/stencil attachments（如果subpass有）的sample count必须是有效的返回值vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV的值的组合
                                     （18）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT但不以VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV 动态state开启创建，则绑定的graphics pipeline的VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount 必须大于等于最后vkCmdSetViewportWithCount设置的viewportCount
                                     （19）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT和VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV 动态state开启创建，则最后vkCmdSetViewportSwizzleNV设置的viewportCount 必须大于等于最后vkCmdSetViewportWithCount设置的viewportCount
                                     （20）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT或者 VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT 动态state开启创建，如果当前的stippledLineEnable为VK_TRUE，且当前的lineRasterizationMode为VK_LINE_RASTERIZATION_MODE_RECTANGULAR_KHR，则stippledRectangularLines 特性必须开启
                                     （21）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT或者 VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT 动态state开启创建，如果当前的stippledLineEnable为VK_TRUE，且当前的lineRasterizationMode为VK_LINE_RASTERIZATION_MODE_BRESENHAM_KHR，则stippledBresenhamLines 特性必须开启
                                     （22）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT或者 VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT 动态state开启创建，如果当前的stippledLineEnable为VK_TRUE，且当前的lineRasterizationMode为VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_KHR，则stippledSmoothLines 特性必须开启
                                     （23）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT或者 VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT 动态state开启创建，如果当前的stippledLineEnable为VK_TRUE，且当前的lineRasterizationMode为VK_LINE_RASTERIZATION_MODE_DEFAULT_KHR，则stippledRectangularLines 特性必须开启且VkPhysicalDeviceLimits::strictLines 必须为VK_TRUE
                                     （24）以VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT 动态state开启创建，且conservativePointAndLineRasterization不支持，最后的 pre-rasterization shader stage输出的有效图元拓扑为点或者线，则最后vkCmdSetConservativeRasterizationModeEXT设置的conservativeRasterizationMode 必须为VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT
                                     （25）以VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT 动态state开启创建，则vkCmdSetAttachmentFeedbackLoopEnableEXT 必须在该命令之前调用
    114.如果一个shader object绑定到 VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                                                                        （1）则vkCmdSetColorBlendEnableEXT 必须在该命令之前设置，且vkCmdSetColorBlendEnableEXT指定的firstAttachment开始的attachmentCount的值必须为当前subpass所有激活的color attachments指定
                                                                                        （2）则vkCmdSetColorBlendEquationEXT 必须在该命令之前设置，且vkCmdSetColorBlendEquationEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定blend equations
                                                                                        （3）则vkCmdSetColorWriteMaskEXT 必须在该命令之前设置，且vkCmdSetColorWriteMaskEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定color write mask
                                                                                        （4）如果VK_NV_fragment_coverage_to_color拓展开启， 最后的vkCmdSetCoverageToColorEnableNV设置coverageToColorEnable为VK_TRUE，则当前subpass必须有color attachment，且该attachment的format必须为VK_FORMAT_R8_UINT, VK_FORMAT_R8_SINT, VK_FORMAT_R16_UINT, VK_FORMAT_R16_SINT, VK_FORMAT_R32_UINT, 或者 VK_FORMAT_R32_SINT，且该attachment的location 有最后的vkCmdSetCoverageToColorLocationNV设置的coverageToColorLocation决定
    115.如果一个shader object绑定到 VK_SHADER_STAGE_FRAGMENT_BIT stage，（1）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT动态state开启创建，且最近的vkCmdSetSampleLocationsEnableEXT设置sampleLocationsEnable为VK_TRUE，且该subpass含有depth/stencil attachment，则该附件必须以VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT创建
                                                                        （2）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT和VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT 动态state开启创建，且最近的vkCmdSetSampleLocationsEnableEXT设置sampleLocationsEnable为VK_TRUE，则 最后vkCmdSetSampleLocationsEXT设置的sampleLocationsInfo.sampleLocationGridSize.width以及height 必须等于被调用vkGetPhysicalDeviceMultisamplePropertiesEXT传入rasterizationSamples返回的VkMultisamplePropertiesEXT::sampleLocationGridSize.width以及height一一对应均匀整除
                                                                        （3）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT 动态state开启创建，且最近的vkCmdSetSampleLocationsEnableEXT设置sampleLocationsEnable为VK_TRUE，则fragment shader代码中不能静态使用扩展指令InterpolateAtSample
                                                                        （4）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT但不以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT 动态state开启创建，且绑定的pipeline的VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable为VK_TRUE 或者以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT动态state开启，则 最后vkCmdSetRasterizationSamplesEXT设置的sampleLocationsInfo.sampleLocationGridSize.width以及height 必须等于被调用vkGetPhysicalDeviceMultisamplePropertiesEXT传入和vkCmdSetRasterizationSamplesEXT设置的相同rasterizationSamples的samples返回的VkMultisamplePropertiesEXT::sampleLocationGridSize.width以及height一一对应均匀整除
    116.如果一个shader object绑定到任何graphics stage，（1）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV 动态state开启创建，且最近的vkCmdSetCoverageModulationTableEnableNV设置coverageModulationTableEnable为VK_TRUE，则最近的vkCmdSetCoverageModulationTableNV 设置的coverageModulationTableCount 必须等于当前rasterizationSamples除以当前subppas的color samples
                                                       （2）如果VK_NV_viewport_swizzle 拓展开启，则最后vkCmdSetViewportSwizzleNV设置的viewportCount 必须大于等于最后vkCmdSetViewportWithCount设置的viewportCount
    117.如果VK_NV_framebuffer_mixed_samples 拓展开启，且如果在绑定的graphics pipeline中当前subpass有一个depth/stencil attachment以及dep test, stencil test, 或depth bounds test 启用，则当前rasterizationSamples 必须等于depth/stencil attachment的sample count
    118.如果VK_NV_framebuffer_mixed_samples 拓展开启，且如果最后的vkCmdSetRasterizationSamplesEXT设置的当前subpass的任何color attachments的rasterizationSamples 都大于 color samples，则sampleShadingEnable 必须为VK_FALSE
    119.如果当前绑定的graphics pipeline以VkGraphicsPipelineCreateInfo::pStages中的元素的VkPipelineShaderStageCreateInfo::stage设置为VK_SHADER_STAGE_VERTEX_BIT, VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT, VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或者 VK_SHADER_STAGE_GEOMETRY_BIT创建，则Mesh Shader Queries 不能激活
    120.如果dynamic state继承自VkCommandBufferInheritanceViewportScissorInfoNV，则这些动态state的设置必须在该命令之前设置
    121.如果没有绑定graphics pipeline，则（1）vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_VERTEX_BIT
                                         （2）如果tessellationShader 特性开启，vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT，VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT
                                         （3）如果geometryShader 特性开启，vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_GEOMETRY_BIT
                                         （4）vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_FRAGMENT_BIT
                                         （5）如果taskShader 特性开启，vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_TASK_BIT_EXT
                                         （6）如果meshShader 特性开启，vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_MESH_BIT_EXT
                                         （8）如果至少taskShader 和 meshShader一个特性开启，VK_SHADER_STAGE_VERTEX_BIT 或者VK_SHADER_STAGE_MESH_BIT_EXT stages中的一个必须含有有效的VkShaderEXT绑定，另外一个则不含有VkShaderEXT绑定
                                         （9）如果taskShader 和 meshShader特性同时开启，且一个有效的VkShaderEXT 绑定到VK_SHADER_STAGE_MESH_BIT_EXT stage，且该VkShaderEXT不以VK_SHADER_CREATE_NO_TASK_SHADER_BIT_EXT 创建，则一个有效的VkShaderEXT必须绑定到VK_SHADER_STAGE_TASK_BIT_EXT stage
                                         （10）如果taskShader 和 meshShader特性同时开启，且一个有效的VkShaderEXT 绑定到VK_SHADER_STAGE_MESH_BIT_EXT stage，且该VkShaderEXT以VK_SHADER_CREATE_NO_TASK_SHADER_BIT_EXT 创建，则不能有VkShaderEXT绑定到VK_SHADER_STAGE_TASK_BIT_EXT stage
                                         （11）如果一个有效的VkShaderEXT 绑定到VK_SHADER_STAGE_VERTEX_BIT stage，则不能有VkShaderEXT绑定到VK_SHADER_STAGE_TASK_BIT_EXT stage或者VK_SHADER_STAGE_MESH_BIT_EXT stage中的一个
    122.如果任何绑定的graphics shader以VK_SHADER_CREATE_LINK_STAGE_BIT_EXT 创建，（1）所有在相同vkCreateShadersEXT中以VK_SHADER_CREATE_LINK_STAGE_BIT_EXT创建的shaders必须也要绑定
                                                                                 （2）任何相同vkCreateShadersEXT中不以VK_SHADER_CREATE_LINK_STAGE_BIT_EXT创建的shaders不能有任何VkShaderEXT绑定
    123.所有绑定的graphics shader objects 必须以相同或者相同定义的push constant ranges创建
    124.所有绑定的graphics shader objects 必须以相同或者相同定义的descriptor set layouts的数组创建
    125.如果当前的render pass instance以vkCmdBeginRendering开始，且VkRenderingInfo::colorAttachmentCount为1，且有一个resolve mode为 VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID 的color attachment，且绑定了fragment shader，则DepthReplacing 和 StencilRefReplacingEXT execution modes 不能声明
    126.如果一个shader object绑定到 VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则 （1）如果attachmentFeedbackLoopDynamicState 特性开启，则 vkCmdSetAttachmentFeedbackLoopEnableEXT 必须在该命令之前调用
    127.如果包含一个fragment shader stage的绑定的graphics pipeline，（1）且该pipeline以VkPipelineDynamicStateCreateInfo::pDynamicStates中设置有VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE创建，且该fragment shader声明了EarlyFragmentTests execution mode且使用了OpDepthAttachmentReadEXT，则最后vkCmdSetDepthWriteEnable 设置的 depthWriteEnable 必须为VK_FALSE
                                                                    （2）且该pipeline以VkPipelineDynamicStateCreateInfo::pDynamicStates中设置有VK_DYNAMIC_STATE_STENCIL_WRITE_MASK创建，且该fragment shader声明了EarlyFragmentTests execution mode且使用了OpStencilAttachmentReadEXT，则最后vkCmdSetStencilWriteMask 设置的 writeMask 必须为0
    128.如果一个shader object绑定到任何graphics stage 或者绑定的graphics pipeline 以VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT 动态state开启创建，且任何color attachment的format为VK_FORMAT_E5B9G9R9_UFLOAT_PACK32，则vkCmdSetColorWriteMaskEXT设置的pColorWriteMasks参数的对应元素必须包含VK_COLOR_COMPONENT_R_BIT, VK_COLOR_COMPONENT_G_BIT, 和 VK_COLOR_COMPONENT_B_BIT，或者都不包含
    129.如果任何附件开启了blending，且该附件的source 或者 destination blend factors使用第二个颜色输入，则该命令执行的Fragment Execution Model静态使用的任何输出output attachment的Location的最大值必须小于maxFragmentDualSrcAttachments
    130.如果当前的render pass instance以vkCmdBeginRendering开始，（1）如果没有任何shader object绑定到任何graphics stage，则vkCmdSetRenderingAttachmentLocationsKHR 设置的VkRenderingAttachmentLocationInfoKHR::pColorAttachmentLocations中的每个元素必须匹配设置在当前绑定的graphics pipeline中的对应元素
                                                                 （2）如果没有任何shader object绑定到任何graphics stage，绑定的graphics pipeline中的input attchment 索引中映射的附件必须匹配在当前render pass instance的VkRenderingInputAttachmentIndexInfoKHR中设置的
    131.如果当前的render pass instance以vkCmdBeginRendering开始且以VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT标志开始，则绑定的graphics pipeline必须以VK_PIPELINE_CREATE_2_ENABLE_LEGACY_DITHERING_BIT_EXT创建
    132.如果绑定的graphics pipeline以VK_PIPELINE_CREATE_2_ENABLE_LEGACY_DITHERING_BIT_EXT创建，则当前的render pass 必须以vkCmdBeginRendering开始且以VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT标志开始
    133.绑定的graphics pipeline不能以VkGraphicsPipelineCreateInfo::pStages中元素的VkPipelineShaderStageCreateInfo::stage设置为VK_SHADER_STAGE_VERTEX_BIT, VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT, VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或者 VK_SHADER_STAGE_GEOMETRY_BIT创建
    134.Transform Feedback Queries不能激活
    135.Primitives Generated Queries不能激活
    136.用于创建任何激活的Pipeline Statistics Query的pipelineStatistics 不能包含VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT,
                                                                                VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT,
                                                                                VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT,
                                                                                VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT,
                                                                                VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT,
                                                                                VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT,
                                                                                VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT,
                                                                                VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT, 或者
                                                                                VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT
    137.如果绑定到VK_PIPELINE_BIND_POINT_GRAPHICS绑定点的当前pipeline，（1）如果该pipeline包含一个使用TaskEXT Execution Model的shader stage，则groupCountX, groupCountY, groupCountZ必须一一小于等于VkPhysicalDeviceMeshShaderPropertiesEXT::maxTaskWorkGroupCount[0], VkPhysicalDeviceMeshShaderPropertiesEXT::maxTaskWorkGroupCount[1], VkPhysicalDeviceMeshShaderPropertiesEXT::maxTaskWorkGroupCount[2]
    																   （2）如果该pipeline包含一个使用TaskEXT Execution Model的shader stage， 则groupCountX *  groupCountY * groupCountZ 必须小于等于VkPhysicalDeviceMeshShaderPropertiesEXT::maxTaskWorkGroupTotalCount
    																   （3）如果该pipeline不包含一个使用TaskEXT Execution Model的shader stage，则groupCountX, groupCountY, groupCountZ必须一一小于等于VkPhysicalDeviceMeshShaderPropertiesEXT::maxMeshWorkGroupCount[0], VkPhysicalDeviceMeshShaderPropertiesEXT::maxMeshWorkGroupCount[1], VkPhysicalDeviceMeshShaderPropertiesEXT::maxMeshWorkGroupCount[2]
                                                                       （4）如果该pipeline不包含一个使用TaskEXT Execution Model的shader stage，则groupCountX *  groupCountY * groupCountZ 必须小于等于VkPhysicalDeviceMeshShaderPropertiesEXT::maxMeshWorkGroupTotalCount
                                                                       
    138.绑定到VK_PIPELINE_BIND_POINT_GRAPHICS绑定点的当前pipeline必须包含一个使用MeshEXT Execution Model的shader stage
    
    */


    VkDrawMeshTasksIndirectCommandEXT drawMeshTasksIndirectCommandEXT{};//和vkCmdDrawMeshTasksEXT 对应参数等效
    drawMeshTasksIndirectCommandEXT.groupCountX = 1;//是X维度dispatch的 local workgroups 数量
	drawMeshTasksIndirectCommandEXT.groupCountY = 1;//是Y维度dispatch的 local workgroups 数量
	drawMeshTasksIndirectCommandEXT.groupCountZ = 1;//是Z维度dispatch的 local workgroups 数量
    /*
    VkDrawMeshTasksIndirectCommandEXT有效用法:
    1.如果绑定到VK_PIPELINE_BIND_POINT_GRAPHICS绑定点的当前pipeline，（1）如果该pipeline包含一个使用TaskEXT Execution Model的shader stage，则groupCountX, groupCountY, groupCountZ必须一一小于等于VkPhysicalDeviceMeshShaderPropertiesEXT::maxTaskWorkGroupCount[0], VkPhysicalDeviceMeshShaderPropertiesEXT::maxTaskWorkGroupCount[1], VkPhysicalDeviceMeshShaderPropertiesEXT::maxTaskWorkGroupCount[2]
                                                                     （2）如果该pipeline包含一个使用TaskEXT Execution Model的shader stage， 则groupCountX *  groupCountY * groupCountZ 必须小于等于VkPhysicalDeviceMeshShaderPropertiesEXT::maxTaskWorkGroupTotalCount
                                                                     （3）如果该pipeline不包含一个使用TaskEXT Execution Model的shader stage，则groupCountX, groupCountY, groupCountZ必须一一小于等于VkPhysicalDeviceMeshShaderPropertiesEXT::maxMeshWorkGroupCount[0], VkPhysicalDeviceMeshShaderPropertiesEXT::maxMeshWorkGroupCount[1], VkPhysicalDeviceMeshShaderPropertiesEXT::maxMeshWorkGroupCount[2]
                                                                     （4）如果该pipeline不包含一个使用TaskEXT Execution Model的shader stage，则groupCountX *  groupCountY * groupCountZ 必须小于等于VkPhysicalDeviceMeshShaderPropertiesEXT::maxMeshWorkGroupTotalCount
    
    */

    //记录一个间接的mesh task 绘制命令   类似于vkCmdDrawMeshTasksEXT，只不过参数由buffer给出，buffer中从offset开始，每stride的字节表示一组绘制参数 ，如果drawCount为0，则忽略stride
    vkCmdDrawMeshTasksIndirectEXT(commandBuffer, VkBuffer{/*假设这是一个有效的VkBuffer*/ }/*buffer,包含绘制参数的的buffer.*/, 0/*offset，为buffer中起始参数的字节偏移量.*/,
    1/*drawCount，是buffer中的绘制参数个数 ，指明绘制个数，可以为0.*/, sizeof(VkDrawMeshTasksIndirectCommandEXT)/*stride,为buffer中两组连续参数之间的字节步长.*/);
    /*

      vkCmdDrawMeshTasksIndirectEXT有效用法:
     1.如果一个VkSampler以其magFilter或者minFilter等于VK_FILTER_LINEAR创建，则（1）如果reductionMode为VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE，如果用于采样一个VkImageView作为该命令的结果的compareEnable为VK_FALSE，则该image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT
                                                                              （2）如果reductionMode为VK_SAMPLER_REDUCTION_MODE_MIN 或者VK_SAMPLER_REDUCTION_MODE_MAX之一 用于采样一个VkImageView作为该命令的结果，则该image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT
     2.如果一个VkSampler以其mipmapMode 等于VK_SAMPLER_MIPMAP_MODE_LINEAR创建，则（1）如果reductionMode为VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE，如果用于采样一个VkImageView作为该命令的结果的compareEnable为VK_FALSE，则该image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT
                                                                              （2）如果reductionMode为VK_SAMPLER_REDUCTION_MODE_MIN 或者VK_SAMPLER_REDUCTION_MODE_MAX之一 用于采样一个VkImageView作为该命令的结果，则该image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT
     3.如果一个VkSampler以其unnormalizedCoordinates等于VK_TRUE用于采样一个VkImageView作为该命令的结果创建，则（1）该image view的levelCount以及layerCount必须为1
                                                                                                             （2）该image view的viewType必须为VK_IMAGE_VIEW_TYPE_1D 或者 VK_IMAGE_VIEW_TYPE_2D
     4.如果一个VkImageView的采样带depth comparison操作，则image view的format features必须包含VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT
     5.如果一个VkImageView使用atomic operations作为该命令的结果进行访问，则image view的format features必须包含VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT
     6.如果一个VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER类型的 descriptor使用atomic operations作为该命令的结果进行访问，则storage texel buffer的format features必须包含VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT
     7.如果一个以VK_FILTER_CUBIC_EXT进行采样的VkImageView作为该命令的结果，则image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT
     8.如果VK_EXT_filter_cubic拓展没有开启，且有任何一个以VK_FILTER_CUBIC_EXT进行采样的VkImageView作为该命令的结果，则其VkImageViewType不能为VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, 或者 VK_IMAGE_VIEW_TYPE_CUBE_ARRAY
     9.任何一个以VK_FILTER_CUBIC_EXT进行采样的作为该命令的结果的VkImageView，其VkImageViewType和format 必须支持cubic filtering，参见vkGetPhysicalDeviceImageFormatProperties2返回的VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic
     10.任何一个以VK_FILTER_CUBIC_EXT进行采样且reduction mode为VK_SAMPLER_REDUCTION_MODE_MIN 或者 VK_SAMPLER_REDUCTION_MODE_MAX之一的作为该命令的结果的VkImageView，其VkImageViewType和format 必须支持带minmax filtering的cubic filtering，参见vkGetPhysicalDeviceImageFormatProperties2返回的VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax
     11.如果cubicRangeClamp特性没有开启，则有任何一个以VK_FILTER_CUBIC_EXT进行采样VkImageView的作为该命令的结果，VkSamplerReductionModeCreateInfo::reductionMode不能为VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM
     12.任何一个以VkSamplerReductionModeCreateInfo::reductionMode为VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM进行采样的作为该命令的结果的VkImageView必须以VK_FILTER_CUBIC_EXT进行采样
     13.如果selectableCubicWeights特性没有开启，则有任何一个以VK_FILTER_CUBIC_EXT进行采样VkImageView的作为该命令的结果，VkSamplerCubicWeightsCreateInfoQCOM::cubicWeights必须为VK_CUBIC_FILTER_WEIGHTS_CATMULL_ROM_QCOM
     14.任何一个以VkImageCreateInfo::flags含VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV创建的采样作为该命令结果的VkImage必须以VkSamplerAddressMode为VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE 进行采样
     15.对于任何作为storage image写入的VkImageView，且其OpTypeImage的format未知，则该image view的 format features必须包含VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT
     16.对于任何作为storage image读取的VkImageView，且其OpTypeImage的format未知，则该image view的 format features必须包含VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT
     17.对于任何作为storage storage texel buffer写入的VkBufferView，且其OpTypeImage的format未知，则该buffer view的 buffer features必须包含VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT
     18.对于任何作为storage storage texel buffer读取的VkBufferView，且其OpTypeImage的format未知，则该buffer view的 buffer features必须包含VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT
     19.对于每个在绑定的shader中静态使用的set n，一个descriptor set必须被绑定到相同pipeline bind point的set n处，该set n必须和创建当前VkPipeline的VkPipelineLayout或者和创建当前VkShaderEXT的VkDescriptorSetLayout 数组的set n处的布局兼容，参见Pipeline Layout Compatibility p1280
     20.对于每个在绑定的shader中静态使用的push constant，一个push constant值必须被绑定到相同pipeline bind point的对应处，该push constant必须和创建当前VkPipeline的VkPipelineLayout或者和创建当前VkShaderEXT的VkDescriptorSetLayout 数组中的对应处的布局兼容，参见Pipeline Layout Compatibility p1280
     21.如果maintenance4特性没有开启，则对于每个在绑定的shader中静态使用的push constant，一个push constant值必须被设置到相同pipeline bind point的对应处，该push constant必须和创建当前VkPipeline的VkPipelineLayout或者和创建当前VkShaderEXT的VkDescriptorSetLayout 数组中的对应处的布局兼容，参见Pipeline Layout Compatibility p1280
     22.每一个通过vkCmdBindDescriptorSets绑定的descriptor set的descriptors,如果是被不以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建的，且已经绑定到该命令使用的pipeline bind point的VkPipeline静态使用的，则这些descriptors必须是有效的，参见 descriptor validity p1328
     23.如果通过vkCmdBindDescriptorSets指定绑定到pipeline bind point的VkPipeline要使用的descriptors，则绑定的VkPipeline不能以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建
     24.在vkCmdSetDescriptorBufferOffsetsEXT中指定绑定的descriptor buffers的descriptors，则（1）如果绑定到pipeline bind point的该命令会使用的VkPipeline以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建，且这些descriptors是动态使用的，则这些descriptors必须是有效的
                                                                                           （2）如果绑定到pipeline bind point的对应stage的该命令会使用的VkShaderEXT，且这些descriptors是动态使用的，则这些descriptors必须是有效的
     25.在vkCmdSetDescriptorBufferOffsetsEXT中指定的descriptors在绑定到pipeline bind point的VkPipeline中使用，则VkPipeline必须以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建
     26.如果一个descriptor在以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建的VkPipeline中动态使用，则descriptor memory必须是驻留内存
     27.如果一个descriptor在以其VkDescriptorSetLayout以VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建的VkShaderEXT中动态使用，则descriptor memory必须是驻留内存
     28.如果shaderObject 特性没有开启，一个有效的pipeline必须绑定到这个命令使用的绑定到pipeline bind point上
     29.如果一个pipeline绑定到该命令使用的pipeline bind point上，则不能有任何动态state 设置命令设置任何该VkPipeline 中没有指定的动态 state
     30.如果一个VkPipeline绑定到该命令使用的pipeline bind point上 或者任何一个会访问一个使用unnormalized coordinates的VkSampler的 VkShaderEXT绑定到该命令使用的pipeline bind point上的pipeline的对应stage，则
                                                                                 （1）在任何shader stage中，VkSampler不能用来采样任何类型为VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY 或者 VK_IMAGE_VIEW_TYPE_CUBE_ARRAY的VkImageView
                                                                                 （2）在任何shader stage中，该VkSampler不能和任何带有名字中带有ImplicitLod，Dref 或者 Proj 的SPIR-V OpImageSample* 或者 OpImageSparseSample*指令一起使用
                                                                                 （3）在任何shader stage中，该VkSampler不能和任何包含 LOD bias或者offset 值 的SPIR-V OpImageSample* or OpImageSparseSample*指令一起使用
     31.如果shaderObject开启，一个有效的pipeline必须绑定到该命令使用的pipeline bind point上或者一个有效的shader objects以及VK_NULL_HANDLE的组合必须绑定到该命令使用的pipeline bind point每一个支持的shader stage上
     32.如何绑定到该命令使用的pipeline bind point上的VkPipeline的任何stage会访问一个uniform buffer，且该stage对uniformBuffers不以启用VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT或者VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT 创建，且robustBufferAccess特性未开启，则该stage就不能访问绑定到相同pipeline bind point的descriptor set指定的buffer范围外的值
     33.如果robustBufferAccess特性未开启，且任何会访问uniform buffer的绑定到该命令使用的pipeline bind point上对应shader stage的VkShaderEXT，则其不能访问绑定到相同pipeline bind point的descriptor set指定的buffer范围外的值
     34.如何绑定到该命令使用的pipeline bind point上的VkPipeline的任何stage会访问一个storage buffer，且该stage对storageBuffers不以启用VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT或者VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT 创建，且robustBufferAccess特性未开启，则该stage就不能访问绑定到相同pipeline bind point的descriptor set指定的buffer范围外的值
     35.如果robustBufferAccess特性未开启，且任何会访问storage buffer的绑定到该命令使用的pipeline bind point上对应shader stage的VkShaderEXT，则其不能访问绑定到相同pipeline bind point的descriptor set指定的buffer范围外的值
     36.如果commandBuffer 是一个unprotected command buffer，且protectedNoFault 未支持，则任何绑定的shaders访问的资源不能是一个protected resource
     37.如果一个绑定的shader访问一个VkSampler 或者 VkImageView ，且启用了sampler Y′C BCR conversion，则只能使用OpImageSample* 或者 OpImageSparseSample*指令，不能使用ConstOffset 以及 Offset操作符
     38.如果一个VkImageView作为该命令的结果进行访问，则（1）image view 的viewType 必须匹配Instruction/Sampler/Image View Validation p1481中描述的OpTypeImage的Dim操作符
                                                       （2）image view 的foamrt的numeric type 必须匹配OpTypeImage的Sampled Type操作符
     39.如果一个VkImageView以一个不是VK_FORMAT_A8_UNORM_KHR的format创建且通过OpImageWrite作为该命令的结果进行访问，则该命令的Texel 操作符的Type必须至少包含和 image view的 format含有的components的个数相同的components个数
     40.如果一个VkImageView以VK_FORMAT_A8_UNORM_KHR的format创建且通过OpImageWrite作为该命令的结果进行访问，则该命令的Texel 操作符的Type必须包含4个components
     41.如果一个VkBufferView通过OpImageWrite作为该命令的结果进行访问，则该命令的Texel 操作符的Type必须至少包含和 buffer view的 format含有的components的个数相同的components个数
     42.如果一个带64-bit component的VkFormat的VkImageView作为该命令的结果进行访问，则该命令的OpTypeImage操作符的SampledType的宽度必须为64
     43.如果一个带少于64-bit component的VkFormat的VkImageView作为该命令的结果进行访问，则该命令的OpTypeImage操作符的SampledType的宽度必须为32
     44.如果一个带64-bit component的VkFormat的VkBufferView作为该命令的结果进行访问，则该命令的OpTypeImage操作符的SampledType的宽度必须为64位
     45.如果一个带少于64-bit component的VkFormat的VkBufferView作为该命令的结果进行访问，则该命令的OpTypeImage操作符的SampledType的宽度必须为32
     46.如果sparseImageInt64Atomics 特性未开启，则以VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT创建的VkImage对象不能被SampledType宽度为64位的OpTypeImage的atomic instructions访问
     47.如果sparseImageInt64Atomics 特性未开启，则以VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT创建的VkBuffer对象不能被SampledType宽度为64位的OpTypeImage的atomic instructions访问
     48.如果OpImageWeightedSampleQCOM用来采样一个作为该命令的结果的VkImageView，则该image view的format features必须包含VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM
     49.如果OpImageWeightedSampleQCOM用来采样一个作为该命令的结果的sample weight image的VkImageView，则该image view的format features必须包含VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM
     50.如果OpImageBoxFilterQCOM用来采样一个作为该命令的结果的VkImageView，则该image view的format features必须包含VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM
     51.如果OpImageBlockMatchSSDQCOM，或者 OpImageBlockMatchSADQCOM用来读取一个作为该命令的结果的VkImageView，则（1）该image view的format features必须包含VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM
                                                                                                                （2）如果是读取的reference image，指定的reference coordinates不能在integer texel coordinate validation 时候失败
     52.如果OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchWindowSSDQCOM, OpImageBlockMatchWindowSADQCOM, OpImageBlockMatchGatherSSDQCOM,
                                                 OpImageBlockMatchGatherSADQCOM, OpImageBlockMatchSSDQCOM, 或者 OpImageBlockMatchSADQCOM用来采样一个作为该命令的结果的VkImageView，则该VkSampler必须以VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM创建
     53.如果任何除了OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchWindowSSDQCOM, OpImageBlockMatchWindowSADQCOM, OpImageBlockMatchGatherSSDQCOM, OpImageBlockMatchGatherSADQCOM, OpImageBlockMatchSSDQCOM, 或者 OpImageBlockMatchSADQCOM之外的指令使用VkSampler进行采样作为该命令的结果，则该sampler不能以VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM 创建
     54.如果OpImageBlockMatchWindow*QCOM or OpImageBlockMatchGather*QCOM指令用来读取VkImageView作为该命令的结果，则（1）VkImageView的format features必须包含VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM
                                                                                                                   （2）VkImageView的format必须只含有一个component
     55.如果OpImageBlockMatchWindow*QCOM or OpImageBlockMatchGather*QCOM指令用来读取一个引用的image作为该命令的结果，则指定的 reference coordinates不能在integer texel coordinate validation 时候失败
     56.任何该命令执行的shader invocation必须已经终止
     57.如果有一个类型位为VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM, VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, 或者 VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT中任意一个的descriptor作为该命令的结果进行访问，则该descriptor所指的image subresource的layout必须和该descriptor被写入时的layout相同。
     58.当前的 render pass  必须和绑定到VK_PIPELINE_BIND_POINT_GRAPHICS上的VkPipeline 创建时候的VkGraphicsPipelineCreateInfo中指定的renderPass兼容
     59.当前的 render pass  的subpass index必须和绑定到VK_PIPELINE_BIND_POINT_GRAPHICS上的VkPipeline 创建时候的VkGraphicsPipelineCreateInfo中指定的subpass相同
     60.如果任何shader静态访问一个input attachment，则有效的descriptor必须通过VkDescriptorSet被绑定到该pipeline中
     61.如果任何该pipeline执行shader以SubpassData的Dim操作符访问一个OpTypeImage变量，则该变量必须被一个对应当前subpass的input attachment的InputAttachmentIndex修饰
     62.在subpass中访问的Input attachment views必须以和该subpass相同定义的VkFormat创建，且必须以一个和当前绑定的VkFramebuffer的该附件引用的subpass的pInputAttachments[InputAttachmentIndex]附件兼容的VkImageView创建，参见Fragment Input Attachment Compatibility p1408
     63.在动态render pass中访问以VkRenderingInputAttachmentIndexInfoKHR的InputAttachmentIndex，或者VkRenderingInputAttachmentIndexInfoKHR:pDepthInputAttachmentIndex 或者 VkRenderingInputAttachmentIndexInfoKHR:pStencilInputAttachmentIndex为NULL情况下不指定InputAttachmentIndex的引用的Input attachment views，必须以和VkRenderingInfo中对应color, depth, 或者 stencil attachment兼容的VkImageView创建
     64.如果VkRenderingInputAttachmentIndexInfoKHR::pDepthInputAttachmentIndex 以及 VkRenderingInputAttachmentIndexInfoKHR::pStencilInputAttachmentIndex不为NULL，则在动态render pass中通过shader object访问Input attachment views必须指明InputAttachmentIndex
     65.如果在动态render pass中通过shader object访问Input attachment views指明了InputAttachmentIndex，则InputAttachmentIndex必须匹配VkRenderingInputAttachmentIndexInfoKHR中的index
     66.当前render pass所用的附件对应的image subresource底层内存的写入只能作为该命令的一个附件写入
     67.如果一个color attachment在之前的该subpass的命令中以load, store, 或者 resolve operations进行了写入，则其layout不为VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT，且有当前绑定的pipeline设有VK_PIPELINE_CREATE_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT，或者
                                     最后的vkCmdSetAttachmentFeedbackLoopEnableEXT调用包含VK_IMAGE_ASPECT_COLOR_BIT以及 没有绑定的pipeline 或者绑定的pipeline以VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT创建，则该附件只能以附件进行访问的，这两种情况中之一
     68.如果一个depth attachment在之前的该subpass的命令中以load, store, 或者 resolve operations进行了写入，则其layout不为VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT，且有当前绑定的pipeline设有VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT，或者
                                     最后的vkCmdSetAttachmentFeedbackLoopEnableEXT调用包含VK_IMAGE_ASPECT_DEPTH_BIT以及 没有绑定的pipeline 或者绑定的pipeline以VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT创建，则该附件只能以附件进行访问的，这两种情况中之一
     69.如果一个stencil attachment在之前的该subpass的命令中以load, store, 或者 resolve operations进行了写入，则其layout不为VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT，且有当前绑定的pipeline设有VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT，或者
                                     最后的vkCmdSetAttachmentFeedbackLoopEnableEXT调用包含VK_IMAGE_ASPECT_STENCIL_BIT以及 没有绑定的pipeline 或者绑定的pipeline以VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT创建，则该附件只能以附件进行访问的，这两种情况中之一
     70.如果一个attachment在之前的该subpass的命令中以load, store, 或者 resolve operations进行了写入,则该附件就不能再以除作为一个附件，storage image或者sampled image被该命令访问
     71.如果在之前的命令的subpass中以用作附件外的方式访问访问了一个当权subpass的附件所对的image subresource，则该命令就不能再将该image subresource用作附件进行写入
     72.如果当前render pass使用一个depth/stencil attachment，则（1）如果depth aspect的layout为read-only的layout，则不能启用depth writes
                                                               （2）如果stencil aspect的layout为read-only的layout，front 以及 back writeMask不为0，且stencil 测试开启，则所有stencil 操作必须为VK_STENCIL_OP_KEEP
     73.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_VIEWPORT动态state开启创建，则vkCmdSetViewport必须在该命令之前设置
                                     （2）以VK_DYNAMIC_STATE_SCISSOR动态state开启创建，则vkCmdSetScissor必须在该命令之前设置
                                     （3）以VK_DYNAMIC_STATE_LINE_WIDTH动态state开启创建，则vkCmdSetLineWidth必须在该命令之前设置
                                     （4）以VK_DYNAMIC_STATE_DEPTH_BIAS动态state开启创建，则vkCmdSetDepthBias或者vkCmdSetDepthBias2EXT 必须在该命令之前设置
                                     （5）以VK_DYNAMIC_STATE_BLEND_CONSTANTS动态state开启创建，则vkCmdSetBlendConstants 必须在该命令之前设置
                                     （6）以VK_DYNAMIC_STATE_DEPTH_BOUNDS动态state开启创建，且如果当前depthBoundsTestEnable为VK_TRUE， 则vkCmdSetDepthBounds 必须在该命令之前设置
                                     （7）以VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK动态state开启创建，且如果当前stencilTestEnable为VK_TRUE， 则vkCmdSetStencilCompareMask 必须在该命令之前设置
                                     （8）以VK_DYNAMIC_STATE_STENCIL_WRITE_MASK动态state开启创建，且如果当前stencilTestEnable为VK_TRUE， 则vkCmdSetStencilWriteMask 必须在该命令之前设置
                                     （9）以VK_DYNAMIC_STATE_STENCIL_REFERENCE动态state开启创建，且如果当前stencilTestEnable为VK_TRUE， 则vkCmdSetStencilReference 必须在该命令之前设置
                                     （10）以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT动态state开启创建， 则vkCmdSetSampleLocationsEXT 必须在该命令之前设置
                                     （11）以VK_DYNAMIC_STATE_CULL_MODE动态state开启创建， 则vkCmdSetCullMode 必须在该命令之前设置
                                     （12）以VK_DYNAMIC_STATE_FRONT_FACE动态state开启创建， 则vkCmdSetFrontFace 必须在该命令之前设置
                                     （13）以VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE动态state开启创建， 则vkCmdSetDepthTestEnable 必须在该命令之前设置
                                     （14）以VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE动态state开启创建， 则vkCmdSetDepthWriteEnable 必须在该命令之前设置
                                     （15）以VK_DYNAMIC_STATE_DEPTH_COMPARE_OP动态state开启创建， 则vkCmdSetDepthCompareOp 必须在该命令之前设置
                                     （16）以VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE动态state开启创建， 则vkCmdSetDepthBoundsTestEnable 必须在该命令之前设置
                                     （17）以VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE动态state开启创建， 则vkCmdSetStencilTestEnable 必须在该命令之前设置
                                     （18）以VK_DYNAMIC_STATE_STENCIL_OP动态state开启创建， 则vkCmdSetStencilOp 必须在该命令之前设置
                                     （19）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT但不以VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT 动态state开启创建， 则vkCmdSetViewportWithCount 必须在该命令之前设置，且vkCmdSetViewportWithCount设置的viewportCount必须匹配pipeline的VkPipelineViewportStateCreateInfo::scissorCount
                                     （20）以VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT但不以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT 动态state开启创建， 则vkCmdSetScissorWithCount 必须在该命令之前设置，且vkCmdSetScissorWithCount设置的scissorCount必须匹配pipeline的VkPipelineViewportStateCreateInfo::viewportCount
                                     （21）以VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT和VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT 动态state同时开启创建， 则vkCmdSetViewportWithCount以及vkCmdSetScissorWithCount 必须在该命令之前设置，且vkCmdSetViewportWithCount设置的viewportCount必须匹配vkCmdSetScissorWithCount设置的scissorCount
                                     （22）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT但不以VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV 动态state开启创建， 则绑定的pipeline必须以VkPipelineViewportWScalingStateCreateInfoNV::viewportCount 大于等于最近vkCmdSetViewportWithCount设置的viewportCount创建
                                     （23）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT和VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV 动态state开启创建， 则最近调用的vkCmdSetViewportWScalingNV设置的viewportCount 必须大于等于最近vkCmdSetViewportWithCount设置的viewportCount
                                     （24）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT但不以VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV 动态state开启创建， 则绑定的pipeline必须以VkPipelineViewportShadingRateImageStateCreateInfoNV::viewportCount 大于等于最近vkCmdSetViewportWithCount设置的viewportCount创建
                                     （25）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT和VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV 动态state开启创建， 则最近调用的vkCmdSetViewportShadingRatePaletteNV设置的viewportCount 必须大于等于最近vkCmdSetViewportWithCount设置的viewportCount
                                     （26）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT动态state开启且VkPipelineViewportStateCreateInfo的pNext中含有一个VkPipelineViewportSwizzleStateCreateInfoNV 创建， 则绑定的pipeline必须以VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount 大于等于最近vkCmdSetViewportWithCount设置的viewportCount创建
                                     （27）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT动态state开启且VkPipelineViewportStateCreateInfo的pNext中含有一个VkPipelineViewportExclusiveScissorStateCreateInfoNV 创建， 则绑定的pipeline必须以VkPipelineViewportExclusiveScissorStateCreateInfoNV::exclusiveScissorCount 大于等于最近vkCmdSetViewportWithCount设置的viewportCount创建
                                     （28）以VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_ENABLE_NV动态state开启创建， 则vkCmdSetExclusiveScissorEnableNV 必须在该命令之前设置
                                     （29）以VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV动态state开启创建， 则vkCmdSetExclusiveScissorNV 必须在该命令之前设置
                                     （30）以VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE动态state开启创建， 则vkCmdSetRasterizerDiscardEnable 必须在该命令之前设置
                                     （31）以VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE动态state开启创建， 则vkCmdSetDepthBiasEnable 必须在该命令之前设置
                                     （32）以VK_DYNAMIC_STATE_LOGIC_OP_EXT动态state开启创建， 则vkCmdSetLogicOpEXT 必须在该命令之前设置且参数logicOp必须是一个有效的VkLogicOp值
     74.如果一个shader object绑定到任何graphics stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                     （1）如果最靠近当前命令的vkCmdSetPolygonModeEXT设置polygonMode为VK_POLYGON_MODE_LINE或者是任何line topology，则vkCmdSetLineWidth必须在该命令之前设置
                                     （2）如果最靠近当前命令的vkCmdSetDepthBiasEnable设置depthBiasEnable为VK_TRUE，则vkCmdSetDepthBias 或者 vkCmdSetDepthBias2EXT必须在该命令之前设置
                                     （3）如果最靠近当前命令的vkCmdSetDepthBoundsTestEnable设置depthBoundsTestEnable为VK_TRUE，则vkCmdSetDepthBounds必须在该命令之前设置
                                     （4）如果最靠近当前命令的vkCmdSetStencilTestEnable设置stencilTestEnable为VK_TRUE，则vkCmdSetStencilCompareMask必须在该命令之前设置
                                     （5）如果最靠近当前命令的vkCmdSetStencilTestEnable设置stencilTestEnable为VK_TRUE，则vkCmdSetStencilWriteMask必须在该命令之前设置
                                     （6）如果最靠近当前命令的vkCmdSetStencilTestEnable设置stencilTestEnable为VK_TRUE，则vkCmdSetStencilReference必须在该命令之前设置
                                     （7）如果最靠近当前命令的vkCmdSetSampleLocationsEnableEXT设置sampleLocationsEnable为VK_TRUE，则vkCmdSetSampleLocationsEXT必须在该命令之前设置
                                     （8）则vkCmdSetCullMode必须在该命令之前设置
                                     （9）则vkCmdSetFrontFace必须在该命令之前设置
                                     （10）则vkCmdSetDepthTestEnable 必须在该命令之前设置
                                     （11）则vkCmdSetDepthWriteEnable 必须在该命令之前设置
                                     （12）如果最靠近当前命令的vkCmdSetDepthTestEnable设置depthTestEnable为VK_TRUE，则vkCmdSetDepthCompareOp 必须在该命令之前设置
                                     （13）则vkCmdSetDepthBoundsTestEnable 必须在该命令之前设置
                                     （14）则vkCmdSetStencilTestEnable 必须在该命令之前设置
                                     （15）如果最靠近当前命令的vkCmdSetStencilTestEnable设置stencilTestEnable为VK_TRUE，则vkCmdSetStencilOp 必须在该命令之前设置
                                     （16）
                                     （17）如果shadingRateImage特性开启，则vkCmdSetCoarseSampleOrderNV 必须在该命令之前设置
                                     （18）如果shadingRateImage特性开启，且最靠近当前命令的vkCmdSetShadingRateImageEnableNV设置shadingRateImageEnable为VK_TRUE，则vkCmdSetViewportShadingRatePaletteNV 必须在该命令之前设置
                                     （19）如果shadingRateImage特性开启，且最靠近当前命令的vkCmdSetShadingRateImageEnableNV设置shadingRateImageEnable为VK_TRUE，则最近的vkCmdSetViewportShadingRatePaletteNV设置的viewportCount 必须大于等于vkCmdSetViewportWithCount设置的viewportCount
                                     （20）则vkCmdSetDepthBiasEnable必须在该命令之前设置
     75.如果一个输出line primitives的shader object绑定到VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或者 VK_SHADER_STAGE_GEOMETRY_BIT，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则vkCmdSetLineWidth必须在该命令之前设置
     76.如果一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最靠近当前命令的vkCmdSetColorBlendEnableEXT设置pColorBlendEnables任何元素为VK_TRUE，且
                         最靠近当前命令的vkCmdSetColorBlendEquationEXT设置pColorBlendEquations相同元素的VkColorBlendEquationEXT的VkBlendFactor成员为VK_BLEND_FACTOR_CONSTANT_COLOR, VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR, VK_BLEND_FACTOR_CONSTANT_ALPHA, 或者 VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA，则vkCmdSetBlendConstants必须在该命令之前设置
     77.如果该命令记录在开启了multiview的render pass instance中，则最大的instance 索引必须小于等于VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex
     78.如果绑定的graphics pipeline以VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable设置为VK_TRUE创建且当前的subpass含有一个 depth/stencil attachment，则该attachment必须以VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT创建
     >>78.5  .如果一个shader object绑定到任何graphics stage，则（1）vkCmdSetViewportWithCount 和vkCmdSetScissorWithCount 必须同时在该命令之前设置，且vkCmdSetViewportWithCount设置的viewportCount必须匹配vkCmdSetScissorWithCount设置的scissorCount
                                                               （2）则vkCmdSetRasterizerDiscardEnable 必须在该命令之前设置
     79.如果VK_NV_clip_space_w_scaling拓展开启，且shader object绑定到任何graphics stage，且最近的vkCmdSetViewportWScalingEnableNV设置viewportWScalingEnable为VK_TRUE，则（1）vkCmdSetViewportWScalingNV必须在该命令前设置
                                                                                                                                                                        （2）最近vkCmdSetViewportWScalingNV设置的viewportCount必须大于等于vkCmdSetViewportWithCount设置的viewportCount
     80.如果exclusiveScissor 特性开启，且shader object绑定到任何graphics stage，，则（1）vkCmdSetExclusiveScissorEnableNV必须在该命令前设置
                                                                                    （2）最近的vkCmdSetExclusiveScissorEnableNV调用设置的pExclusiveScissorEnables中的任何元素为VK_TRUE,则vkCmdSetExclusiveScissorNV必须在该命令前设置
     81.如果一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最靠近当前命令的vkCmdSetLogicOpEnableEXT设置logicOpEnable任何元素为VK_TRUE，则vkCmdSetLogicOpEXT 必须在该命令之前设置且参数logicOp必须是一个有效的VkLogicOp值
     82.如果primitiveFragmentShadingRateWithMultipleViewports限制不支持，则（1）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT动态state开启创建，且任何该pipeline的shader stage会写入PrimitiveShadingRateKHR built-in修饰的变量，则vkCmdSetViewportWithCount 必须在该命令之前设置且参数viewportCount必须是1
                                                                           （2）任何绑定的graphics pipeline的shader stage会写入PrimitiveShadingRateKHR built-in修饰的变量，则vkCmdSetViewportWithCount 必须在该命令之前设置且参数viewportCount必须是1
     83.如果graphics pipeline中未开启rasterization，则对subpass中的每个color attachment，如果其对应的image view 的format features不包含VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT，则pColorBlendState中其对应pAttachments中元素的blendEnable必须为VK_FALSE
     84.如果一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则对于render pass中的每个color attachment，如果其对应的image view 的format features不包含VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT， 则最近的vkCmdSetColorBlendEnableEXT设置的pColorBlendEnables中该附件的对应元素必须为VK_FALSE
     85.如果graphics pipeline中未开启rasterization，有VK_AMD_mixed_attachment_samples拓展未开启，VK_NV_framebuffer_mixed_samples拓展未开启，multisampledRenderToSingleSampled特性未开启，则当前绑定的pipeline的rasterizationSamples必须和当前subpass的color 以及/或者 depth/stencil attachments的相同
     86.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且有VK_AMD_mixed_attachment_samples拓展未开启，VK_NV_framebuffer_mixed_samples拓展未开启，multisampledRenderToSingleSampled特性未开启，则最近vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples必须和当前subpass的color 以及/或者 depth/stencil attachments的相同
     87.如果一个shader object绑定到任何graphics stage，则当前的render pass instance必须以vkCmdBeginRendering开始
     88.如果当前的render pass instance以vkCmdBeginRendering开始，（1）如果pDepthAttachment的imageView不为VK_NULL_HANDLE，且pDepthAttachment的layout不为VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL，则该命令不能写入任何值到depth attachment
                                                                 （2）如果pStencilAttachment的imageView不为VK_NULL_HANDLE，且pStencilAttachment的layout不为VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL，则该命令不能写入任何值到stencil attachment
                                                                 （3）如果pDepthAttachment的imageView不为VK_NULL_HANDLE，且pDepthAttachment的layout为VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL，则该命令不能写入任何值到depth attachment
                                                                 （4）如果pStencilAttachment的imageView不为VK_NULL_HANDLE，且pStencilAttachment的layout为VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL，则该命令不能写入任何值到stencil attachment
                                                                 （5）如果pDepthAttachment的imageView不为VK_NULL_HANDLE，且pDepthAttachment的layout为VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL，则该命令不能写入任何值到depth attachment
                                                                 （6）如果pStencilAttachment的imageView不为VK_NULL_HANDLE，且pStencilAttachment的layout为VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL，则该命令不能写入任何值到stencil attachment
                                                                 （7）则当前绑定的graphics pipeline必须以含VkPipelineRenderingCreateInfo::viewMask等于VkRenderingInfo::viewMask创建
                                                                 （8）如果带有VkRenderingInfo::colorAttachmentCount为1，则没有shader object绑定到任何graphics stage，且一个color attachment的 resolve mode为VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID，则VkRenderingInfo::pColorAttachments中每个resolveImageView不为VK_NULL_HANDLE的元素其对应image必须以和创建当前绑定的pipeline 相同的VkExternalFormatANDROID::externalFormat创建
                                                                 （9）如果没有shader object绑定到任何graphics stage，如果绑定的graphics pipeline以一个非零值VkExternalFormatANDROID::externalFormat创建且启用VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态设置，则vkCmdSetColorBlendEnableEXT必须在该命令前设置blend enable为VK_FALSE
                                                                 （10）如果没有shader object绑定到任何graphics stage，如果绑定的graphics pipeline以一个非零值VkExternalFormatANDROID::externalFormat创建且启用VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态设置，则vkCmdSetRasterizationSamplesEXT必须在该命令前设置rasterizationSamples为VK_SAMPLE_COUNT_1_BIT
                                                                 （11）如果没有shader object绑定到任何graphics stage，如果绑定的graphics pipeline以一个非零值VkExternalFormatANDROID::externalFormat创建且启用VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR动态设置，则vkCmdSetFragmentShadingRateKHR必须在该命令前设置pFragmentSize->width为1，pFragmentSize->height为1
     89.如果dynamicRenderingUnusedAttachments特性未开启，且当前的render pass instance以vkCmdBeginRendering开始，则
                                                             （1）当前绑定的graphics pipeline必须以含VkPipelineRenderingCreateInfo::colorAttachmentCount等于VkRenderingInfo::colorAttachmentCount创建
                                                             （2）如果VkRenderingInfo::colorAttachmentCount大于0，则VkRenderingInfo::pColorAttachments 中每一个其imageView不为VK_NULL_HANDLE的元素的VkImageView必须以VkFormat对应绑定的graphics pipeline的VkPipelineRenderingCreateInfo::pColorAttachmentFormats指明的format创建
                                                             （3）如果VkRenderingInfo::colorAttachmentCount大于0，则VkRenderingInfo::pColorAttachments 中每一个其imageView为VK_NULL_HANDLE的元素对应绑定的graphics pipeline的VkPipelineRenderingCreateInfo::pColorAttachmentFormats指明的format必须为VK_FORMAT_UNDEFINED
                                                             （4）如果VkRenderingInfo::pDepthAttachment->imageView为VK_NULL_HANDLE，则创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::depthAttachmentFormat必须为VK_FORMAT_UNDEFINED
                                                             （5）如果VkRenderingInfo::pDepthAttachment->imageView不为VK_NULL_HANDLE，则创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::depthAttachmentFormat必须和创建VkRenderingInfo::pDepthAttachment->imageView的VkFormat相同
                                                             （6）如果VkRenderingInfo::pStencilAttachment->imageView为VK_NULL_HANDLE，则创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::stencilAttachmentFormat必须为VK_FORMAT_UNDEFINED
                                                             （7）如果VkRenderingInfo::pStencilAttachment->imageView不为VK_NULL_HANDLE，则创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::stencilAttachmentFormat必须和创建VkRenderingInfo::pStencilAttachment->imageView的VkFormat相同
     90.如果dynamicRenderingUnusedAttachments特性开启，且当前的render pass instance以vkCmdBeginRendering开始，则
                                                             （1）如果VkRenderingInfo::colorAttachmentCount大于0，则VkRenderingInfo::pColorAttachments 中每一个其imageView不为VK_NULL_HANDLE的元素的VkImageView必须以VkFormat对应绑定的graphics pipeline的VkPipelineRenderingCreateInfo::pColorAttachmentFormats指明的format创建，或者是对应元素为VK_FORMAT_UNDEFINED创建
                                                             （2）如果VkRenderingInfo::pDepthAttachment->imageView不为VK_NULL_HANDLE，且创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::depthAttachmentFormat和创建VkRenderingInfo::pDepthAttachment->imageView的VkFormat不同，则该format必须为VK_FORMAT_UNDEFINED
                                                             （3）如果VkRenderingInfo::pStencilAttachment->imageView不为VK_NULL_HANDLE，且创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::stencilAttachmentFormat和创建VkRenderingInfo::pStencilAttachment->imageView的VkFormat不同，则该format必须为VK_FORMAT_UNDEFINED
     91.如果没有shader object绑定到任何graphics stage，且当前的render pass instance以vkCmdBeginRendering开始且VkRenderingInfo::colorAttachmentCount为1，且一个color attachment的 resolve mode为VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID，则VkRenderingInfo::pColorAttachments中每个resolveImageView不为VK_NULL_HANDLE的元素其对应image必须以和创建当前绑定的pipeline 相同的VkExternalFormatANDROID::externalFormat创建
     92.如果有一个shader object绑定到任何graphics stage，且当前的render pass 包含一个使用VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID resolve mode的color attachment，则（1）vkCmdSetColorBlendEnableEXT必须在该命令前设置blend enable为VK_FALSE
                                                                                                                                                                              （2）则vkCmdSetRasterizationSamplesEXT必须在该命令前设置rasterizationSamples为VK_SAMPLE_COUNT_1_BIT
                                                                                                                                                                              （3）则vkCmdSetFragmentShadingRateKHR必须在该命令前设置pFragmentSize->width为1，pFragmentSize->height为1
     93.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT动态state开启创建， 则vkCmdSetColorWriteEnableEXT 必须在该命令之前设置，且设置的attachmentCount必须大于等于创建当前绑定的pipeline的VkPipelineColorBlendStateCreateInfo::attachmentCount
                                     （2）以VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT动态state开启创建， 则vkCmdSetDiscardRectangleEXT 必须在该命令之前为每个VkPipelineDiscardRectangleStateCreateInfoEXT::discardRectangleCount指明的discard rectangle 设置
                                     （3）以VK_DYNAMIC_STATE_DISCARD_RECTANGLE_ENABLE_EXT动态state开启创建， 则vkCmdSetDiscardRectangleEnableEXT 必须在该命令之前设置
                                     （4）以VK_DYNAMIC_STATE_DISCARD_RECTANGLE_MODE_EXT动态state开启创建， 则vkCmdSetDiscardRectangleModeEXT 必须在该命令之前设置
     94.如果有一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                     （1）如果colorWriteEnable特性在device上开启，则vkCmdSetColorWriteEnableEXT 必须在该命令之前设置，且设置的attachmentCount必须大于等于当前render pass instance的color attachment的数量
                                     （2）如果VK_EXT_discard_rectangles拓展开启，且最近的vkCmdSetDiscardRectangleEnableEXT设置discardRectangleEnable为VK_TRUE， 则vkCmdSetDiscardRectangleEXT 必须在该命令之前设置
                                     （3）如果VK_EXT_discard_rectangles拓展开启， 则vkCmdSetDiscardRectangleEnableEXT 必须在该命令之前设置
                                     （4）如果VK_EXT_discard_rectangles拓展开启， 则最近的vkCmdSetDiscardRectangleEnableEXT设置discardRectangleEnable为VK_TRUE，则vkCmdSetDiscardRectangleModeEXT 必须在该命令之前设置
     95.如果当前的render pass instance以vkCmdBeginRendering开始，则（1）如果VkRenderingFragmentShadingRateAttachmentInfoKHR::imageView不为VK_NULL_HANDLE，则当前绑定的graphics pipeline必须以VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR创建
                                                                   （2）如果VkRenderingFragmentDensityMapAttachmentInfoEXT::imageView不为VK_NULL_HANDLE，则当前绑定的graphics pipeline必须以VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT创建
                                                                   （3）且含VkRenderingInfo::colorAttachmentCount大于0，如果当前的绑定的pipeline以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，则VkRenderingInfo::pColorAttachments中每个imageView不为VK_NULL_HANDLE的元素的imageView，必须以当前pipeline的VkAttachmentSampleCountInfoAMD 或者 VkAttachmentSampleCountInfoNV中的pColorAttachmentSamples中对应元素的sample count进行创建
                                                                   （4）如果当前的绑定的pipeline以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且VkRenderingInfo::pDepthAttachment中的imageView不为VK_NULL_HANDLE，则当前pipeline的VkAttachmentSampleCountInfoAMD 或者 VkAttachmentSampleCountInfoNV中的depthStencilAttachmentSamples必须等于创建VkRenderingInfo::pDepthAttachment->imageView的sample count
                                                                   （5）如果当前的绑定的pipeline以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且VkRenderingInfo::pStencilAttachment中的imageView不为VK_NULL_HANDLE，则当前pipeline的VkAttachmentSampleCountInfoAMD 或者 VkAttachmentSampleCountInfoNV中的depthStencilAttachmentSamples必须等于创建VkRenderingInfo::pStencilAttachment->imageView的sample count
                                                                   （6）且含VkRenderingInfo::colorAttachmentCount大于0，如果当前的绑定的pipeline不以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且multisampledRenderToSingleSampled特性没有开启，则VkRenderingInfo::pColorAttachments中每个imageView不为VK_NULL_HANDLE的元素的imageView，其创建的sample count必须等于当前绑定的graphics pipeline的rasterizationSamples
                                                                   （7）如果当前的绑定的pipeline不以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且VkRenderingInfo::pDepthAttachment中的imageView不为VK_NULL_HANDLE，且multisampledRenderToSingleSampled特性没有开启，则当前pipeline的rasterizationSamples 必须等于创建VkRenderingInfo::pDepthAttachment->imageView的sample count
                                                                   （8）如果当前的绑定的pipeline不以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且VkRenderingInfo::pStencilAttachment中的imageView不为VK_NULL_HANDLE，且multisampledRenderToSingleSampled特性没有开启，则当前pipeline的rasterizationSamples 必须等于创建VkRenderingInfo::pStencilAttachment->imageView的sample count
                                                                   （9）当前绑定的pipeline必须VkGraphicsPipelineCreateInfo::renderPass为VK_NULL_HANDLE创建
                                                                   （10）如果绑定的pipeline的fragment shader静态写入一个color attachment，且color write mask不为0，启用了color writes，且该附件对应的VkRenderingInfo::pColorAttachments->imageView 不为VK_NULL_HANDLE，则对应的创建pipeline的VkPipelineRenderingCreateInfo::pColorAttachmentFormats中的元素不能为VK_FORMAT_UNDEFINED
                                                                   （11）如果绑定的pipeline启用了depth test，启用了depth writes，且VkRenderingInfo::pDepthAttachment->imageView 不为VK_NULL_HANDLE，则创建pipeline的VkPipelineRenderingCreateInfo::depthAttachmentFormat不能为VK_FORMAT_UNDEFINED
                                                                   （12）如果绑定的pipeline启用了stencil test，且VkRenderingInfo::pStencilAttachment->imageView 不为VK_NULL_HANDLE，则创建pipeline的VkPipelineRenderingCreateInfo::stencilAttachmentFormat不能为VK_FORMAT_UNDEFINED
     96.如果该命令在以vkCmdBeginRendering开始的render pass instance中调用，且VkRenderingInfo的pNext中包含一个multisampledRenderToSingleSampledEnable设为VK_TRUE的VkMultisampledRenderToSingleSampledInfoEXT，则当前绑定的graphics pipeline的rasterizationSamples必须等于VkMultisampledRenderToSingleSampledInfoEXT::rasterizationSamples
     97.如果primitivesGeneratedQueryWithRasterizerDiscard特性未开启，且VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query激活，则不能启用rasterization discard
     98.如果primitivesGeneratedQueryWithNonZeroStreams特性未开启，且VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query激活，则 绑定的graphics pipeline不能以VkPipelineRasterizationStateStreamCreateInfoEXT::rasterizationStream为非零值创建
     98.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_TESSELLATION_DOMAIN_ORIGIN_EXT动态state开启创建，则vkCmdSetTessellationDomainOriginEXT必须在该命令之前设置
                                     （2）以VK_DYNAMIC_STATE_DEPTH_CLAMP_ENABLE_EXT动态state开启创建，则vkCmdSetDepthClampEnableEXT必须在该命令之前设置
                                     （3）以VK_DYNAMIC_STATE_POLYGON_MODE_EXT动态state开启创建，则vkCmdSetPolygonModeEXT必须在该命令之前设置
                                     （4）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，则vkCmdSetRasterizationSamplesEXT必须在该命令之前设置
                                     （5）以VK_DYNAMIC_STATE_SAMPLE_MASK_EXT动态state开启创建，则vkCmdSetSampleMaskEXT必须在该命令之前设置
                                     （6）以VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT动态state开启创建，则vkCmdSetAlphaToCoverageEnableEXT必须在该命令之前设置
                                     （7）以VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT动态state开启创建，则最近的vkCmdSetAlphaToCoverageEnableEXT设置alphaToCoverageEnable为VK_TRUE，则Fragment Output Interface中 Index 0的Location 0必须有一个含alpha Component的变量
                                     （8）以VK_DYNAMIC_STATE_ALPHA_TO_ONE_ENABLE_EXT动态state开启创建，则vkCmdSetAlphaToOneEnableEXT必须在该命令之前设置
                                     （9）以VK_DYNAMIC_STATE_LOGIC_OP_ENABLE_EXT动态state开启创建，则vkCmdSetLogicOpEnableEXT必须在该命令之前设置
                                     （10）以VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态state开启创建，则vkCmdSetColorBlendEnableEXT必须在该命令之前设置
                                     （11）以VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT动态state开启创建，则vkCmdSetColorBlendEquationEXT必须在该命令之前设置
                                     （12）以VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT动态state开启创建，则vkCmdSetColorWriteMaskEXT必须在该命令之前设置
    
     99.如果一个shader object绑定到VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT stage，则vkCmdSetTessellationDomainOriginEXT必须在该命令之前设置
     100.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                                     （1）如果depthClamp特性启用，则vkCmdSetDepthClampEnableEXT必须在该命令之前设置
                                                     （2）则vkCmdSetPolygonModeEXT必须在该命令之前设置
                                                     （3）则vkCmdSetRasterizationSamplesEXT必须在该命令之前设置
                                                     （4）则vkCmdSetSampleMaskEXT必须在该命令之前设置
                                                     （5）则vkCmdSetAlphaToCoverageEnableEXT必须在该命令之前设置
                                                     （6）如果alphaToOne特性启用，则vkCmdSetAlphaToOneEnableEXT必须在该命令之前设置
    
     101.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetAlphaToCoverageEnableEXT设置alphaToCoverageEnable为VK_TRUE，则Fragment Output Interface中 Index 0的Location 0必须有一个含alpha Component的变量
     102.如果一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                         （1）如果logicOp特性开启 ,vkCmdSetLogicOpEnableEXT必须在该命令之前设置
                                         （2）如果绑定了color attachments，则vkCmdSetColorBlendEnableEXT必须在该命令之前设置
                                         （3）如果最近的vkCmdSetColorBlendEnableEXT设置任何附件在pColorBlendEnables中的值为VK_TRUE ，则vkCmdSetColorBlendEquationEXT必须在该命令之前设置
                                         （4）如果绑定了color attachments，则vkCmdSetColorWriteMaskEXT必须在该命令之前设置
    
     103.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT动态state开启创建，则vkCmdSetRasterizationStreamEXT必须在该命令之前设置
                                      （2）以VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT动态state开启创建，则vkCmdSetConservativeRasterizationModeEXT必须在该命令之前设置
                                      （3）以VK_DYNAMIC_STATE_EXTRA_PRIMITIVE_OVERESTIMATION_SIZE_EXT动态state开启创建，则vkCmdSetExtraPrimitiveOverestimationSizeEXT必须在该命令之前设置
                                      （4）以VK_DYNAMIC_STATE_DEPTH_CLIP_ENABLE_EXT动态state开启创建，则vkCmdSetDepthClipEnableEXT必须在该命令之前设置
                                      （5）以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT动态state开启创建，则vkCmdSetSampleLocationsEnableEXT必须在该命令之前设置
                                      （6）以VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT动态state开启创建，则vkCmdSetColorBlendAdvancedEXT必须在该命令之前设置
                                      （7）以VK_DYNAMIC_STATE_PROVOKING_VERTEX_MODE_EXT动态state开启创建，则vkCmdSetProvokingVertexModeEXT必须在该命令之前设置
                                      （8）以VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT动态state开启创建，则vkCmdSetLineRasterizationModeEXT必须在该命令之前设置
                                      （9）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT动态state开启创建，则vkCmdSetLineStippleEnableEXT必须在该命令之前设置
                                      （10）以VK_DYNAMIC_STATE_LINE_STIPPLE_KHR动态state开启创建，则vkCmdSetLineStippleKHR必须在该命令之前设置
                                      （11）以VK_DYNAMIC_STATE_DEPTH_CLIP_NEGATIVE_ONE_TO_ONE_EXT动态state开启创建，则vkCmdSetDepthClipNegativeOneToOneEXT必须在该命令之前设置
                                      （12）以VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_ENABLE_NV动态state开启创建，则vkCmdSetViewportWScalingEnableNV必须在该命令之前设置
                                      （13）以VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV动态state开启创建，则vkCmdSetViewportSwizzleNV必须在该命令之前设置
                                      （14）以VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV动态state开启创建，则vkCmdSetCoverageToColorEnableNV必须在该命令之前设置
                                      （15）以VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_LOCATION_NV动态state开启创建，则vkCmdSetCoverageToColorLocationNV必须在该命令之前设置
                                      （16）以VK_DYNAMIC_STATE_COVERAGE_MODULATION_MODE_NV动态state开启创建，则vkCmdSetCoverageModulationModeNV必须在该命令之前设置
                                      （17）以VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV动态state开启创建，则vkCmdSetCoverageModulationTableEnableNV必须在该命令之前设置
                                      （18）以VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_NV动态state开启创建，则vkCmdSetCoverageModulationTableNV必须在该命令之前设置
                                      （19）以VK_DYNAMIC_STATE_SHADING_RATE_IMAGE_ENABLE_NV动态state开启创建，则vkCmdSetShadingRateImageEnableNV必须在该命令之前设置
                                      （20）以VK_DYNAMIC_STATE_REPRESENTATIVE_FRAGMENT_TEST_ENABLE_NV动态state开启创建，则vkCmdSetRepresentativeFragmentTestEnableNV必须在该命令之前设置
                                      （21）以VK_DYNAMIC_STATE_COVERAGE_REDUCTION_MODE_NV动态state开启创建，则vkCmdSetCoverageReductionModeNV必须在该命令之前设置
    
     104.如果一个shader object绑定到VK_SHADER_STAGE_GEOMETRY_BIT stage，且如果geometryStreams 特性开启，则vkCmdSetRasterizationStreamEXT必须在该命令之前设置
     105.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                             （1）如果VK_EXT_conservative_rasterization 拓展开启，vkCmdSetConservativeRasterizationModeEXT必须在该命令之前设置
                             （2）如果VK_EXT_conservative_rasterization 拓展开启，且最近的vkCmdSetConservativeRasterizationModeEXT设置conservativeRasterizationMode为VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT，则vkCmdSetExtraPrimitiveOverestimationSizeEXT必须在该命令之前设置
                             （3）如果VK_EXT_sample_locations 拓展开启，则vkCmdSetSampleLocationsEnableEXT必须在该命令之前设置
     106.如果一个shader object绑定到任何graphics stage，且depthClipEnable 特性开启，则vkCmdSetDepthClipEnableEXT必须在该命令之前设置
     107.如果如果一个shader object绑定到任何VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且如果VK_EXT_blend_operation_advanced 拓展开启，则vkCmdSetColorBlendEquationEXT 和 vkCmdSetColorBlendAdvancedEXT中至少一个必须在该命令之前设置
     108.如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，如果VK_EXT_provoking_vertex拓展开启， 则vkCmdSetProvokingVertexModeEXT必须在该命令之前设置
     109.如果VK_KHR_line_rasterization 或者 VK_EXT_line_rasterization拓展开启，则（1）如果一个shader object绑定到任意一个graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetPolygonModeEXT设置polygonMode 为VK_POLYGON_MODE_LINE ，则vkCmdSetLineRasterizationModeEXT必须在该命令之前设置
                                                                                 （2）如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetPrimitiveTopology设置primitiveTopology 为任何line topology ，则vkCmdSetLineRasterizationModeEXT必须在该命令之前设置
                                                                                 （3）如果一个输出为line primitive的shader object绑定到VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或 VK_SHADER_STAGE_GEOMETRY_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则vkCmdSetLineRasterizationModeEXT必须在该命令之前设置
                                                                                 （4）如果一个shader object绑定到任意一个graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetPolygonModeEXT设置polygonMode 为VK_POLYGON_MODE_LINE ，则vkCmdSetLineStippleEnableEXT必须在该命令之前设置
                                                                                 （5）如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetPrimitiveTopology设置primitiveTopology 为任何line topology ，则vkCmdSetLineStippleEnableEXT必须在该命令之前设置
                                                                                 （6）如果一个输出为line primitive的shader object绑定到VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或 VK_SHADER_STAGE_GEOMETRY_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则vkCmdSetLineStippleEnableEXT必须在该命令之前设置
                                                                                 （7）如果一个shader object绑定到任意一个graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetLineStippleEnableEXT设置stippledLineEnable 为VK_TRUE ，则vkCmdSetLineStippleEXT必须在该命令之前设置
     110.如果一个shader object绑定到任何graphics stage，（1）如果depthClipControl 特性开启，则vkCmdSetDepthClipNegativeOneToOneEXT必须在该命令之前设置
                                                        （2）VK_NV_clip_space_w_scaling 拓展开启，则vkCmdSetViewportWScalingEnableNV必须在该命令之前设置
                                                        （3）VK_NV_viewport_swizzle 拓展开启，则vkCmdSetViewportSwizzleNV必须在该命令之前设置
     111.如果如果一个shader object绑定到任何VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                         （1）如果VK_NV_fragment_coverage_to_color 拓展开启，则vkCmdSetCoverageToColorEnableNV 必须在该命令之前设置
                         （2）如果VK_NV_fragment_coverage_to_color 拓展开启，且最近的vkCmdSetCoverageToColorEnableNV 设置coverageToColorEnable 为VK_TRUE，则vkCmdSetCoverageToColorLocationNV 必须在该命令之前设置
                         （3）如果pipelineFragmentShadingRate 特性开启，则vkCmdSetFragmentShadingRateKHR 必须在该命令之前设置
     112.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                 （1）如果VK_NV_framebuffer_mixed_samples 拓展开启，则vkCmdSetCoverageModulationModeNV 必须在该命令之前设置
                                 （2）如果VK_NV_framebuffer_mixed_samples 拓展开启，且最近的vkCmdSetCoverageModulationModeNV设置coverageModulationMode为任何除VK_COVERAGE_MODULATION_MODE_NONE_NV之外的值，则vkCmdSetCoverageModulationTableEnableNV 必须在该命令之前设置
                                 （3）如果VK_NV_framebuffer_mixed_samples 拓展开启，最近的vkCmdSetCoverageModulationTableEnableNV设置coverageModulationTableEnable为VK_TRUE，则vkCmdSetCoverageModulationTableNV 必须在该命令之前设置
                                 （4）如果shadingRateImage 特性开启，则vkCmdSetShadingRateImageEnableNV 必须在该命令之前设置
                                 （5）如果representativeFragmentTest 特性开启，则vkCmdSetRepresentativeFragmentTestEnableNV 必须在该命令之前设置
                                 （6）如果coverageReductionMode 特性开启，则vkCmdSetCoverageReductionModeNV 必须在该命令之前设置
     113.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态state开启创建，且最近的vkCmdSetColorBlendEnableEXT设置任何附件在pColorBlendEnables中的值为VK_TRUE 则subpas中这些附件对应的image view的format features中必须包含VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT
                                      （2）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，且当前subpass不使用任何color和/或者 depth/stencil attachments，则最后的vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples必须符合zero￾attachment subpass的规则
                                      （3）以VK_DYNAMIC_STATE_SAMPLE_MASK_EXT不以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT 动态state开启创建，则最后调用的vkCmdSetSampleMaskEXT中设置的samples参数必须大于等于创建该pipeline的VkPipelineMultisampleStateCreateInfo::rasterizationSamples
                                      （4）以VK_DYNAMIC_STATE_SAMPLE_MASK_EXT和 VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT 动态state开启创建，则最后调用的vkCmdSetSampleMaskEXT中设置的samples参数必须大于等于最后的vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples
                                      （5）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，且VK_AMD_mixed_attachment_samples和VK_NV_framebuffer_mixed_samples拓展都没有开启，则最后的vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples必须等于subpass中color和/或者 depth/stencil attachments使用的相同
                                      （6）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，或者一个shader object绑定到任意graphics stage，且当前的subpass包含一个multisampledRenderToSingleSampledEnable 为VK_TRUE的VkMultisampledRenderToSingleSampledInfoEXT，则最后的vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples必须等于该VkMultisampledRenderToSingleSampledInfoEXT中的对应成员
                                      （7）以VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态state开启创建，则vkCmdSetColorBlendEnableEXT 必须在该命令之前设置，且vkCmdSetColorBlendEnableEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定值
                                      （8）以VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT动态state开启创建，则vkCmdSetColorBlendEquationEXT 必须在该命令之前设置，且vkCmdSetColorBlendEquationEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定blend equations
                                      （9）以VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT动态state开启创建，则vkCmdSetColorWriteMaskEXT 必须在该命令之前设置，且vkCmdSetColorWriteMaskEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定color write mask
                                      （10）以VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT动态state开启创建，则vkCmdSetColorBlendAdvancedEXT 必须在该命令之前设置，且vkCmdSetColorBlendAdvancedEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活blend的color attachments指定advanced blend equations
                                      （11）以VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT和VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态state开启创建，且最后的vkCmdSetColorBlendEnableEXT和vkCmdSetColorBlendAdvancedEXT设置启用了advanced blending，则当前subpass中激活的color attachments的数量不能超过advancedBlendMaxColorAttachments
                                      （12）以VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT动态state开启创建，且如果primitivesGeneratedQueryWithNonZeroStreams特性未开启且VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query已经激活，则最后的vkCmdSetRasterizationStreamEXT必须设置rasterizationStream为0
                                      （13）以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT但不以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，则最后的vkCmdSetSampleLocationsEXT设置的pSampleLocationsInfo->sampleLocationsPerPixel必须等于创建pipeline的VkPipelineMultisampleStateCreateInfo::rasterizationSamples
                                      （14）以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT和VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，则最后的vkCmdSetSampleLocationsEXT设置的pSampleLocationsInfo->sampleLocationsPerPixel必须等于最后vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples
                                      （15）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT但不以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT动态state开启创建，且绑定的pipeline的VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable为VK_TRUE 或者以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT动态state开启，则sampleLocationsInfo.sampleLocationsPerPixel 必须等于最后vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples
                                      （16）以VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV动态state开启创建，且最后的vkCmdSetCoverageToColorEnableNV设置coverageToColorEnable为VK_TRUE，则当前subpass必须有color attachment，且该attachment的format必须为VK_FORMAT_R8_UINT, VK_FORMAT_R8_SINT, VK_FORMAT_R16_UINT, VK_FORMAT_R16_SINT, VK_FORMAT_R32_UINT, 或者 VK_FORMAT_R32_SINT，且该attachment的location 有最后的vkCmdSetCoverageToColorLocationNV设置的coverageToColorLocation决定
                                      （17）以VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV和VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT 动态state开启创建，且如果VK_NV_coverage_reduction_mode 拓展开启，则当前的 coverageReductionMode，rasterizationSamples 以及color 以及 depth/stencil attachments（如果subpass有）的sample count必须是有效的返回值vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV的值的组合
                                      （18）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT但不以VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV 动态state开启创建，则绑定的graphics pipeline的VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount 必须大于等于最后vkCmdSetViewportWithCount设置的viewportCount
                                      （19）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT和VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV 动态state开启创建，则最后vkCmdSetViewportSwizzleNV设置的viewportCount 必须大于等于最后vkCmdSetViewportWithCount设置的viewportCount
                                      （20）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT或者 VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT 动态state开启创建，如果当前的stippledLineEnable为VK_TRUE，且当前的lineRasterizationMode为VK_LINE_RASTERIZATION_MODE_RECTANGULAR_KHR，则stippledRectangularLines 特性必须开启
                                      （21）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT或者 VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT 动态state开启创建，如果当前的stippledLineEnable为VK_TRUE，且当前的lineRasterizationMode为VK_LINE_RASTERIZATION_MODE_BRESENHAM_KHR，则stippledBresenhamLines 特性必须开启
                                      （22）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT或者 VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT 动态state开启创建，如果当前的stippledLineEnable为VK_TRUE，且当前的lineRasterizationMode为VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_KHR，则stippledSmoothLines 特性必须开启
                                      （23）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT或者 VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT 动态state开启创建，如果当前的stippledLineEnable为VK_TRUE，且当前的lineRasterizationMode为VK_LINE_RASTERIZATION_MODE_DEFAULT_KHR，则stippledRectangularLines 特性必须开启且VkPhysicalDeviceLimits::strictLines 必须为VK_TRUE
                                      （24）以VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT 动态state开启创建，且conservativePointAndLineRasterization不支持，最后的 pre-rasterization shader stage输出的有效图元拓扑为点或者线，则最后vkCmdSetConservativeRasterizationModeEXT设置的conservativeRasterizationMode 必须为VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT
                                      （25）以VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT 动态state开启创建，则vkCmdSetAttachmentFeedbackLoopEnableEXT 必须在该命令之前调用
     114.如果一个shader object绑定到 VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                                                                         （1）则vkCmdSetColorBlendEnableEXT 必须在该命令之前设置，且vkCmdSetColorBlendEnableEXT指定的firstAttachment开始的attachmentCount的值必须为当前subpass所有激活的color attachments指定
                                                                                         （2）则vkCmdSetColorBlendEquationEXT 必须在该命令之前设置，且vkCmdSetColorBlendEquationEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定blend equations
                                                                                         （3）则vkCmdSetColorWriteMaskEXT 必须在该命令之前设置，且vkCmdSetColorWriteMaskEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定color write mask
                                                                                         （4）如果VK_NV_fragment_coverage_to_color拓展开启， 最后的vkCmdSetCoverageToColorEnableNV设置coverageToColorEnable为VK_TRUE，则当前subpass必须有color attachment，且该attachment的format必须为VK_FORMAT_R8_UINT, VK_FORMAT_R8_SINT, VK_FORMAT_R16_UINT, VK_FORMAT_R16_SINT, VK_FORMAT_R32_UINT, 或者 VK_FORMAT_R32_SINT，且该attachment的location 有最后的vkCmdSetCoverageToColorLocationNV设置的coverageToColorLocation决定
     115.如果一个shader object绑定到 VK_SHADER_STAGE_FRAGMENT_BIT stage，（1）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT动态state开启创建，且最近的vkCmdSetSampleLocationsEnableEXT设置sampleLocationsEnable为VK_TRUE，且该subpass含有depth/stencil attachment，则该附件必须以VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT创建
                                                                         （2）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT和VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT 动态state开启创建，且最近的vkCmdSetSampleLocationsEnableEXT设置sampleLocationsEnable为VK_TRUE，则 最后vkCmdSetSampleLocationsEXT设置的sampleLocationsInfo.sampleLocationGridSize.width以及height 必须等于被调用vkGetPhysicalDeviceMultisamplePropertiesEXT传入rasterizationSamples返回的VkMultisamplePropertiesEXT::sampleLocationGridSize.width以及height一一对应均匀整除
                                                                         （3）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT 动态state开启创建，且最近的vkCmdSetSampleLocationsEnableEXT设置sampleLocationsEnable为VK_TRUE，则fragment shader代码中不能静态使用扩展指令InterpolateAtSample
                                                                         （4）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT但不以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT 动态state开启创建，且绑定的pipeline的VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable为VK_TRUE 或者以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT动态state开启，则 最后vkCmdSetRasterizationSamplesEXT设置的sampleLocationsInfo.sampleLocationGridSize.width以及height 必须等于被调用vkGetPhysicalDeviceMultisamplePropertiesEXT传入和vkCmdSetRasterizationSamplesEXT设置的相同rasterizationSamples的samples返回的VkMultisamplePropertiesEXT::sampleLocationGridSize.width以及height一一对应均匀整除
     116.如果一个shader object绑定到任何graphics stage，（1）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV 动态state开启创建，且最近的vkCmdSetCoverageModulationTableEnableNV设置coverageModulationTableEnable为VK_TRUE，则最近的vkCmdSetCoverageModulationTableNV 设置的coverageModulationTableCount 必须等于当前rasterizationSamples除以当前subppas的color samples
                                                        （2）如果VK_NV_viewport_swizzle 拓展开启，则最后vkCmdSetViewportSwizzleNV设置的viewportCount 必须大于等于最后vkCmdSetViewportWithCount设置的viewportCount
     117.如果VK_NV_framebuffer_mixed_samples 拓展开启，且如果在绑定的graphics pipeline中当前subpass有一个depth/stencil attachment以及dep test, stencil test, 或depth bounds test 启用，则当前rasterizationSamples 必须等于depth/stencil attachment的sample count
     118.如果VK_NV_framebuffer_mixed_samples 拓展开启，且如果最后的vkCmdSetRasterizationSamplesEXT设置的当前subpass的任何color attachments的rasterizationSamples 都大于 color samples，则sampleShadingEnable 必须为VK_FALSE
     119.如果当前绑定的graphics pipeline以VkGraphicsPipelineCreateInfo::pStages中的元素的VkPipelineShaderStageCreateInfo::stage设置为VK_SHADER_STAGE_VERTEX_BIT, VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT, VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或者 VK_SHADER_STAGE_GEOMETRY_BIT创建，则Mesh Shader Queries 不能激活
     120.如果dynamic state继承自VkCommandBufferInheritanceViewportScissorInfoNV，则这些动态state的设置必须在该命令之前设置
     121.如果没有绑定graphics pipeline，则（1）vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_VERTEX_BIT
                                          （2）如果tessellationShader 特性开启，vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT，VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT
                                          （3）如果geometryShader 特性开启，vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_GEOMETRY_BIT
                                          （4）vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_FRAGMENT_BIT
                                          （5）如果taskShader 特性开启，vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_TASK_BIT_EXT
                                          （6）如果meshShader 特性开启，vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_MESH_BIT_EXT
                                          （8）如果至少taskShader 和 meshShader一个特性开启，VK_SHADER_STAGE_VERTEX_BIT 或者VK_SHADER_STAGE_MESH_BIT_EXT stages中的一个必须含有有效的VkShaderEXT绑定，另外一个则不含有VkShaderEXT绑定
                                          （9）如果taskShader 和 meshShader特性同时开启，且一个有效的VkShaderEXT 绑定到VK_SHADER_STAGE_MESH_BIT_EXT stage，且该VkShaderEXT不以VK_SHADER_CREATE_NO_TASK_SHADER_BIT_EXT 创建，则一个有效的VkShaderEXT必须绑定到VK_SHADER_STAGE_TASK_BIT_EXT stage
                                          （10）如果taskShader 和 meshShader特性同时开启，且一个有效的VkShaderEXT 绑定到VK_SHADER_STAGE_MESH_BIT_EXT stage，且该VkShaderEXT以VK_SHADER_CREATE_NO_TASK_SHADER_BIT_EXT 创建，则不能有VkShaderEXT绑定到VK_SHADER_STAGE_TASK_BIT_EXT stage
                                          （11）如果一个有效的VkShaderEXT 绑定到VK_SHADER_STAGE_VERTEX_BIT stage，则不能有VkShaderEXT绑定到VK_SHADER_STAGE_TASK_BIT_EXT stage或者VK_SHADER_STAGE_MESH_BIT_EXT stage中的一个
     122.如果任何绑定的graphics shader以VK_SHADER_CREATE_LINK_STAGE_BIT_EXT 创建，（1）所有在相同vkCreateShadersEXT中以VK_SHADER_CREATE_LINK_STAGE_BIT_EXT创建的shaders必须也要绑定
                                                                                  （2）任何相同vkCreateShadersEXT中不以VK_SHADER_CREATE_LINK_STAGE_BIT_EXT创建的shaders不能有任何VkShaderEXT绑定
     123.所有绑定的graphics shader objects 必须以相同或者相同定义的push constant ranges创建
     124.所有绑定的graphics shader objects 必须以相同或者相同定义的descriptor set layouts的数组创建
     125.如果当前的render pass instance以vkCmdBeginRendering开始，且VkRenderingInfo::colorAttachmentCount为1，且有一个resolve mode为 VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID 的color attachment，且绑定了fragment shader，则DepthReplacing 和 StencilRefReplacingEXT execution modes 不能声明
     126.如果一个shader object绑定到 VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则 （1）如果attachmentFeedbackLoopDynamicState 特性开启，则 vkCmdSetAttachmentFeedbackLoopEnableEXT 必须在该命令之前调用
     127.如果包含一个fragment shader stage的绑定的graphics pipeline，（1）且该pipeline以VkPipelineDynamicStateCreateInfo::pDynamicStates中设置有VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE创建，且该fragment shader声明了EarlyFragmentTests execution mode且使用了OpDepthAttachmentReadEXT，则最后vkCmdSetDepthWriteEnable 设置的 depthWriteEnable 必须为VK_FALSE
                                                                     （2）且该pipeline以VkPipelineDynamicStateCreateInfo::pDynamicStates中设置有VK_DYNAMIC_STATE_STENCIL_WRITE_MASK创建，且该fragment shader声明了EarlyFragmentTests execution mode且使用了OpStencilAttachmentReadEXT，则最后vkCmdSetStencilWriteMask 设置的 writeMask 必须为0
     128.如果一个shader object绑定到任何graphics stage 或者绑定的graphics pipeline 以VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT 动态state开启创建，且任何color attachment的format为VK_FORMAT_E5B9G9R9_UFLOAT_PACK32，则vkCmdSetColorWriteMaskEXT设置的pColorWriteMasks参数的对应元素必须包含VK_COLOR_COMPONENT_R_BIT, VK_COLOR_COMPONENT_G_BIT, 和 VK_COLOR_COMPONENT_B_BIT，或者都不包含
     129.如果任何附件开启了blending，且该附件的source 或者 destination blend factors使用第二个颜色输入，则该命令执行的Fragment Execution Model静态使用的任何输出output attachment的Location的最大值必须小于maxFragmentDualSrcAttachments
     130.如果当前的render pass instance以vkCmdBeginRendering开始，（1）如果没有任何shader object绑定到任何graphics stage，则vkCmdSetRenderingAttachmentLocationsKHR 设置的VkRenderingAttachmentLocationInfoKHR::pColorAttachmentLocations中的每个元素必须匹配设置在当前绑定的graphics pipeline中的对应元素
                                                                  （2）如果没有任何shader object绑定到任何graphics stage，绑定的graphics pipeline中的input attchment 索引中映射的附件必须匹配在当前render pass instance的VkRenderingInputAttachmentIndexInfoKHR中设置的
     131.如果当前的render pass instance以vkCmdBeginRendering开始且以VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT标志开始，则绑定的graphics pipeline必须以VK_PIPELINE_CREATE_2_ENABLE_LEGACY_DITHERING_BIT_EXT创建
     132.如果绑定的graphics pipeline以VK_PIPELINE_CREATE_2_ENABLE_LEGACY_DITHERING_BIT_EXT创建，则当前的render pass 必须以vkCmdBeginRendering开始且以VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT标志开始
     133.绑定的graphics pipeline不能以VkGraphicsPipelineCreateInfo::pStages中元素的VkPipelineShaderStageCreateInfo::stage设置为VK_SHADER_STAGE_VERTEX_BIT, VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT, VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或者 VK_SHADER_STAGE_GEOMETRY_BIT创建
     134.Transform Feedback Queries不能激活
     135.Primitives Generated Queries不能激活
     136.用于创建任何激活的Pipeline Statistics Query的pipelineStatistics 不能包含VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT,
                                                                                 VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT,
                                                                                 VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT,
                                                                                 VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT,
                                                                                 VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT,
                                                                                 VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT,
                                                                                 VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT,
                                                                                 VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT, 或者
                                                                                 VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT
     137.如果buffer是non-sparse，则它必须完全和连续地绑定到单个VkDeviceMemory对象
     138.buffer必须以VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT 标志创建
     139.offset必须是4的倍数
     140.commandBuffer必须不为protected command buffer
     141.如果multiDrawIndirect 特性未开启，drawCount 必须为0 或 1
     142.drawCount 必须小于等于VkPhysicalDeviceLimits::maxDrawIndirectCount
     143.如果drawCount 大于1，则stride是4的倍数，并且必须大于或等于sizeof(VkDrawMeshTasksIndirectCommandEXT)
     144.如果drawCount 为1，则(offset + sizeof(VkDrawMeshTasksIndirectCommandEXT))必须小于等于buffer的大小
     145.如果drawCount 大于1，则(stride × (drawCount - 1) + offset + sizeof(VkDrawMeshTasksIndirectCommandEXT))必须小于等于buffer的大小
     146.绑定到VK_PIPELINE_BIND_POINT_GRAPHICS绑定点的当前pipeline必须包含一个使用MeshEXT Execution Model的shader stage
    
     */



     //记录一个绘制次数信息从buffer中获取的间接的mesh task 绘制命令    类似于 vkCmdDrawMeshTasksIndirectEXT，只是绘制次数参数在countBuffer中指定,将从countBuffer中countOffset开始读取32-bit的无符号整数值作为绘制次数参数
    vkCmdDrawMeshTasksIndirectCountEXT(commandBuffer, VkBuffer{/*假设这是一个有效的VkBuffer*/ }/*buffer,包含绘制参数的的buffer.*/, 0/*offset，为buffer中起始参数的字节偏移量.*/,
        VkBuffer{/*假设这是一个有效的VkBuffer*/ }/*countBuffer,包含绘制次数的buffer.*/, 0/*countOffset，为countBuffer中绘制次数参数的字节偏移量.*/,
        1/*maxDrawCount，指明绘制的最大次数，实际的值为countBuffer中指定的和maxDrawCount的最小值.*/, sizeof(VkDrawMeshTasksIndirectCommandEXT)/*stride,为buffer中两组连续参数之间的字节步长.*/);
    /*
    
     vkCmdDrawMeshTasksIndirectCountEXT有效用法:
    1.如果一个VkSampler以其magFilter或者minFilter等于VK_FILTER_LINEAR创建，则（1）如果reductionMode为VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE，如果用于采样一个VkImageView作为该命令的结果的compareEnable为VK_FALSE，则该image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT
                                                                             （2）如果reductionMode为VK_SAMPLER_REDUCTION_MODE_MIN 或者VK_SAMPLER_REDUCTION_MODE_MAX之一 用于采样一个VkImageView作为该命令的结果，则该image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT
    2.如果一个VkSampler以其mipmapMode 等于VK_SAMPLER_MIPMAP_MODE_LINEAR创建，则（1）如果reductionMode为VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE，如果用于采样一个VkImageView作为该命令的结果的compareEnable为VK_FALSE，则该image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT
                                                                             （2）如果reductionMode为VK_SAMPLER_REDUCTION_MODE_MIN 或者VK_SAMPLER_REDUCTION_MODE_MAX之一 用于采样一个VkImageView作为该命令的结果，则该image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT
    3.如果一个VkSampler以其unnormalizedCoordinates等于VK_TRUE用于采样一个VkImageView作为该命令的结果创建，则（1）该image view的levelCount以及layerCount必须为1
                                                                                                            （2）该image view的viewType必须为VK_IMAGE_VIEW_TYPE_1D 或者 VK_IMAGE_VIEW_TYPE_2D
    4.如果一个VkImageView的采样带depth comparison操作，则image view的format features必须包含VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT
    5.如果一个VkImageView使用atomic operations作为该命令的结果进行访问，则image view的format features必须包含VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT
    6.如果一个VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER类型的 descriptor使用atomic operations作为该命令的结果进行访问，则storage texel buffer的format features必须包含VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT
    7.如果一个以VK_FILTER_CUBIC_EXT进行采样的VkImageView作为该命令的结果，则image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT
    8.如果VK_EXT_filter_cubic拓展没有开启，且有任何一个以VK_FILTER_CUBIC_EXT进行采样的VkImageView作为该命令的结果，则其VkImageViewType不能为VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, 或者 VK_IMAGE_VIEW_TYPE_CUBE_ARRAY
    9.任何一个以VK_FILTER_CUBIC_EXT进行采样的作为该命令的结果的VkImageView，其VkImageViewType和format 必须支持cubic filtering，参见vkGetPhysicalDeviceImageFormatProperties2返回的VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic
    10.任何一个以VK_FILTER_CUBIC_EXT进行采样且reduction mode为VK_SAMPLER_REDUCTION_MODE_MIN 或者 VK_SAMPLER_REDUCTION_MODE_MAX之一的作为该命令的结果的VkImageView，其VkImageViewType和format 必须支持带minmax filtering的cubic filtering，参见vkGetPhysicalDeviceImageFormatProperties2返回的VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax
    11.如果cubicRangeClamp特性没有开启，则有任何一个以VK_FILTER_CUBIC_EXT进行采样VkImageView的作为该命令的结果，VkSamplerReductionModeCreateInfo::reductionMode不能为VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM
    12.任何一个以VkSamplerReductionModeCreateInfo::reductionMode为VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM进行采样的作为该命令的结果的VkImageView必须以VK_FILTER_CUBIC_EXT进行采样
    13.如果selectableCubicWeights特性没有开启，则有任何一个以VK_FILTER_CUBIC_EXT进行采样VkImageView的作为该命令的结果，VkSamplerCubicWeightsCreateInfoQCOM::cubicWeights必须为VK_CUBIC_FILTER_WEIGHTS_CATMULL_ROM_QCOM
    14.任何一个以VkImageCreateInfo::flags含VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV创建的采样作为该命令结果的VkImage必须以VkSamplerAddressMode为VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE 进行采样
    15.对于任何作为storage image写入的VkImageView，且其OpTypeImage的format未知，则该image view的 format features必须包含VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT
    16.对于任何作为storage image读取的VkImageView，且其OpTypeImage的format未知，则该image view的 format features必须包含VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT
    17.对于任何作为storage storage texel buffer写入的VkBufferView，且其OpTypeImage的format未知，则该buffer view的 buffer features必须包含VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT
    18.对于任何作为storage storage texel buffer读取的VkBufferView，且其OpTypeImage的format未知，则该buffer view的 buffer features必须包含VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT
    19.对于每个在绑定的shader中静态使用的set n，一个descriptor set必须被绑定到相同pipeline bind point的set n处，该set n必须和创建当前VkPipeline的VkPipelineLayout或者和创建当前VkShaderEXT的VkDescriptorSetLayout 数组的set n处的布局兼容，参见Pipeline Layout Compatibility p1280
    20.对于每个在绑定的shader中静态使用的push constant，一个push constant值必须被绑定到相同pipeline bind point的对应处，该push constant必须和创建当前VkPipeline的VkPipelineLayout或者和创建当前VkShaderEXT的VkDescriptorSetLayout 数组中的对应处的布局兼容，参见Pipeline Layout Compatibility p1280
    21.如果maintenance4特性没有开启，则对于每个在绑定的shader中静态使用的push constant，一个push constant值必须被设置到相同pipeline bind point的对应处，该push constant必须和创建当前VkPipeline的VkPipelineLayout或者和创建当前VkShaderEXT的VkDescriptorSetLayout 数组中的对应处的布局兼容，参见Pipeline Layout Compatibility p1280
    22.每一个通过vkCmdBindDescriptorSets绑定的descriptor set的descriptors,如果是被不以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建的，且已经绑定到该命令使用的pipeline bind point的VkPipeline静态使用的，则这些descriptors必须是有效的，参见 descriptor validity p1328
    23.如果通过vkCmdBindDescriptorSets指定绑定到pipeline bind point的VkPipeline要使用的descriptors，则绑定的VkPipeline不能以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建
    24.在vkCmdSetDescriptorBufferOffsetsEXT中指定绑定的descriptor buffers的descriptors，则（1）如果绑定到pipeline bind point的该命令会使用的VkPipeline以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建，且这些descriptors是动态使用的，则这些descriptors必须是有效的
                                                                                          （2）如果绑定到pipeline bind point的对应stage的该命令会使用的VkShaderEXT，且这些descriptors是动态使用的，则这些descriptors必须是有效的
    25.在vkCmdSetDescriptorBufferOffsetsEXT中指定的descriptors在绑定到pipeline bind point的VkPipeline中使用，则VkPipeline必须以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建
    26.如果一个descriptor在以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建的VkPipeline中动态使用，则descriptor memory必须是驻留内存
    27.如果一个descriptor在以其VkDescriptorSetLayout以VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建的VkShaderEXT中动态使用，则descriptor memory必须是驻留内存
    28.如果shaderObject 特性没有开启，一个有效的pipeline必须绑定到这个命令使用的绑定到pipeline bind point上
    29.如果一个pipeline绑定到该命令使用的pipeline bind point上，则不能有任何动态state 设置命令设置任何该VkPipeline 中没有指定的动态 state
    30.如果一个VkPipeline绑定到该命令使用的pipeline bind point上 或者任何一个会访问一个使用unnormalized coordinates的VkSampler的 VkShaderEXT绑定到该命令使用的pipeline bind point上的pipeline的对应stage，则
                                                                                （1）在任何shader stage中，VkSampler不能用来采样任何类型为VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY 或者 VK_IMAGE_VIEW_TYPE_CUBE_ARRAY的VkImageView
                                                                                （2）在任何shader stage中，该VkSampler不能和任何带有名字中带有ImplicitLod，Dref 或者 Proj 的SPIR-V OpImageSample* 或者 OpImageSparseSample*指令一起使用
                                                                                （3）在任何shader stage中，该VkSampler不能和任何包含 LOD bias或者offset 值 的SPIR-V OpImageSample* or OpImageSparseSample*指令一起使用
    31.如果shaderObject开启，一个有效的pipeline必须绑定到该命令使用的pipeline bind point上或者一个有效的shader objects以及VK_NULL_HANDLE的组合必须绑定到该命令使用的pipeline bind point每一个支持的shader stage上
    32.如何绑定到该命令使用的pipeline bind point上的VkPipeline的任何stage会访问一个uniform buffer，且该stage对uniformBuffers不以启用VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT或者VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT 创建，且robustBufferAccess特性未开启，则该stage就不能访问绑定到相同pipeline bind point的descriptor set指定的buffer范围外的值
    33.如果robustBufferAccess特性未开启，且任何会访问uniform buffer的绑定到该命令使用的pipeline bind point上对应shader stage的VkShaderEXT，则其不能访问绑定到相同pipeline bind point的descriptor set指定的buffer范围外的值
    34.如何绑定到该命令使用的pipeline bind point上的VkPipeline的任何stage会访问一个storage buffer，且该stage对storageBuffers不以启用VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT或者VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT 创建，且robustBufferAccess特性未开启，则该stage就不能访问绑定到相同pipeline bind point的descriptor set指定的buffer范围外的值
    35.如果robustBufferAccess特性未开启，且任何会访问storage buffer的绑定到该命令使用的pipeline bind point上对应shader stage的VkShaderEXT，则其不能访问绑定到相同pipeline bind point的descriptor set指定的buffer范围外的值
    36.如果commandBuffer 是一个unprotected command buffer，且protectedNoFault 未支持，则任何绑定的shaders访问的资源不能是一个protected resource
    37.如果一个绑定的shader访问一个VkSampler 或者 VkImageView ，且启用了sampler Y′C BCR conversion，则只能使用OpImageSample* 或者 OpImageSparseSample*指令，不能使用ConstOffset 以及 Offset操作符
    38.如果一个VkImageView作为该命令的结果进行访问，则（1）image view 的viewType 必须匹配Instruction/Sampler/Image View Validation p1481中描述的OpTypeImage的Dim操作符
                                                      （2）image view 的foamrt的numeric type 必须匹配OpTypeImage的Sampled Type操作符
    39.如果一个VkImageView以一个不是VK_FORMAT_A8_UNORM_KHR的format创建且通过OpImageWrite作为该命令的结果进行访问，则该命令的Texel 操作符的Type必须至少包含和 image view的 format含有的components的个数相同的components个数
    40.如果一个VkImageView以VK_FORMAT_A8_UNORM_KHR的format创建且通过OpImageWrite作为该命令的结果进行访问，则该命令的Texel 操作符的Type必须包含4个components
    41.如果一个VkBufferView通过OpImageWrite作为该命令的结果进行访问，则该命令的Texel 操作符的Type必须至少包含和 buffer view的 format含有的components的个数相同的components个数
    42.如果一个带64-bit component的VkFormat的VkImageView作为该命令的结果进行访问，则该命令的OpTypeImage操作符的SampledType的宽度必须为64
    43.如果一个带少于64-bit component的VkFormat的VkImageView作为该命令的结果进行访问，则该命令的OpTypeImage操作符的SampledType的宽度必须为32
    44.如果一个带64-bit component的VkFormat的VkBufferView作为该命令的结果进行访问，则该命令的OpTypeImage操作符的SampledType的宽度必须为64位
    45.如果一个带少于64-bit component的VkFormat的VkBufferView作为该命令的结果进行访问，则该命令的OpTypeImage操作符的SampledType的宽度必须为32
    46.如果sparseImageInt64Atomics 特性未开启，则以VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT创建的VkImage对象不能被SampledType宽度为64位的OpTypeImage的atomic instructions访问
    47.如果sparseImageInt64Atomics 特性未开启，则以VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT创建的VkBuffer对象不能被SampledType宽度为64位的OpTypeImage的atomic instructions访问
    48.如果OpImageWeightedSampleQCOM用来采样一个作为该命令的结果的VkImageView，则该image view的format features必须包含VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM
    49.如果OpImageWeightedSampleQCOM用来采样一个作为该命令的结果的sample weight image的VkImageView，则该image view的format features必须包含VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM
    50.如果OpImageBoxFilterQCOM用来采样一个作为该命令的结果的VkImageView，则该image view的format features必须包含VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM
    51.如果OpImageBlockMatchSSDQCOM，或者 OpImageBlockMatchSADQCOM用来读取一个作为该命令的结果的VkImageView，则（1）该image view的format features必须包含VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM
                                                                                                               （2）如果是读取的reference image，指定的reference coordinates不能在integer texel coordinate validation 时候失败
    52.如果OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchWindowSSDQCOM, OpImageBlockMatchWindowSADQCOM, OpImageBlockMatchGatherSSDQCOM,
                                                OpImageBlockMatchGatherSADQCOM, OpImageBlockMatchSSDQCOM, 或者 OpImageBlockMatchSADQCOM用来采样一个作为该命令的结果的VkImageView，则该VkSampler必须以VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM创建
    53.如果任何除了OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchWindowSSDQCOM, OpImageBlockMatchWindowSADQCOM, OpImageBlockMatchGatherSSDQCOM, OpImageBlockMatchGatherSADQCOM, OpImageBlockMatchSSDQCOM, 或者 OpImageBlockMatchSADQCOM之外的指令使用VkSampler进行采样作为该命令的结果，则该sampler不能以VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM 创建
    54.如果OpImageBlockMatchWindow*QCOM or OpImageBlockMatchGather*QCOM指令用来读取VkImageView作为该命令的结果，则（1）VkImageView的format features必须包含VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM
                                                                                                                  （2）VkImageView的format必须只含有一个component
    55.如果OpImageBlockMatchWindow*QCOM or OpImageBlockMatchGather*QCOM指令用来读取一个引用的image作为该命令的结果，则指定的 reference coordinates不能在integer texel coordinate validation 时候失败
    56.任何该命令执行的shader invocation必须已经终止
    57.如果有一个类型位为VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM, VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, 或者 VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT中任意一个的descriptor作为该命令的结果进行访问，则该descriptor所指的image subresource的layout必须和该descriptor被写入时的layout相同。
    58.当前的 render pass  必须和绑定到VK_PIPELINE_BIND_POINT_GRAPHICS上的VkPipeline 创建时候的VkGraphicsPipelineCreateInfo中指定的renderPass兼容
    59.当前的 render pass  的subpass index必须和绑定到VK_PIPELINE_BIND_POINT_GRAPHICS上的VkPipeline 创建时候的VkGraphicsPipelineCreateInfo中指定的subpass相同
    60.如果任何shader静态访问一个input attachment，则有效的descriptor必须通过VkDescriptorSet被绑定到该pipeline中
    61.如果任何该pipeline执行shader以SubpassData的Dim操作符访问一个OpTypeImage变量，则该变量必须被一个对应当前subpass的input attachment的InputAttachmentIndex修饰
    62.在subpass中访问的Input attachment views必须以和该subpass相同定义的VkFormat创建，且必须以一个和当前绑定的VkFramebuffer的该附件引用的subpass的pInputAttachments[InputAttachmentIndex]附件兼容的VkImageView创建，参见Fragment Input Attachment Compatibility p1408
    63.在动态render pass中访问以VkRenderingInputAttachmentIndexInfoKHR的InputAttachmentIndex，或者VkRenderingInputAttachmentIndexInfoKHR:pDepthInputAttachmentIndex 或者 VkRenderingInputAttachmentIndexInfoKHR:pStencilInputAttachmentIndex为NULL情况下不指定InputAttachmentIndex的引用的Input attachment views，必须以和VkRenderingInfo中对应color, depth, 或者 stencil attachment兼容的VkImageView创建
    64.如果VkRenderingInputAttachmentIndexInfoKHR::pDepthInputAttachmentIndex 以及 VkRenderingInputAttachmentIndexInfoKHR::pStencilInputAttachmentIndex不为NULL，则在动态render pass中通过shader object访问Input attachment views必须指明InputAttachmentIndex
    65.如果在动态render pass中通过shader object访问Input attachment views指明了InputAttachmentIndex，则InputAttachmentIndex必须匹配VkRenderingInputAttachmentIndexInfoKHR中的index
    66.当前render pass所用的附件对应的image subresource底层内存的写入只能作为该命令的一个附件写入
    67.如果一个color attachment在之前的该subpass的命令中以load, store, 或者 resolve operations进行了写入，则其layout不为VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT，且有当前绑定的pipeline设有VK_PIPELINE_CREATE_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT，或者
                                    最后的vkCmdSetAttachmentFeedbackLoopEnableEXT调用包含VK_IMAGE_ASPECT_COLOR_BIT以及 没有绑定的pipeline 或者绑定的pipeline以VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT创建，则该附件只能以附件进行访问的，这两种情况中之一
    68.如果一个depth attachment在之前的该subpass的命令中以load, store, 或者 resolve operations进行了写入，则其layout不为VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT，且有当前绑定的pipeline设有VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT，或者
                                    最后的vkCmdSetAttachmentFeedbackLoopEnableEXT调用包含VK_IMAGE_ASPECT_DEPTH_BIT以及 没有绑定的pipeline 或者绑定的pipeline以VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT创建，则该附件只能以附件进行访问的，这两种情况中之一
    69.如果一个stencil attachment在之前的该subpass的命令中以load, store, 或者 resolve operations进行了写入，则其layout不为VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT，且有当前绑定的pipeline设有VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT，或者
                                    最后的vkCmdSetAttachmentFeedbackLoopEnableEXT调用包含VK_IMAGE_ASPECT_STENCIL_BIT以及 没有绑定的pipeline 或者绑定的pipeline以VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT创建，则该附件只能以附件进行访问的，这两种情况中之一
    70.如果一个attachment在之前的该subpass的命令中以load, store, 或者 resolve operations进行了写入,则该附件就不能再以除作为一个附件，storage image或者sampled image被该命令访问
    71.如果在之前的命令的subpass中以用作附件外的方式访问访问了一个当权subpass的附件所对的image subresource，则该命令就不能再将该image subresource用作附件进行写入
    72.如果当前render pass使用一个depth/stencil attachment，则（1）如果depth aspect的layout为read-only的layout，则不能启用depth writes
                                                              （2）如果stencil aspect的layout为read-only的layout，front 以及 back writeMask不为0，且stencil 测试开启，则所有stencil 操作必须为VK_STENCIL_OP_KEEP
    73.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_VIEWPORT动态state开启创建，则vkCmdSetViewport必须在该命令之前设置
                                    （2）以VK_DYNAMIC_STATE_SCISSOR动态state开启创建，则vkCmdSetScissor必须在该命令之前设置
                                    （3）以VK_DYNAMIC_STATE_LINE_WIDTH动态state开启创建，则vkCmdSetLineWidth必须在该命令之前设置
                                    （4）以VK_DYNAMIC_STATE_DEPTH_BIAS动态state开启创建，则vkCmdSetDepthBias或者vkCmdSetDepthBias2EXT 必须在该命令之前设置
                                    （5）以VK_DYNAMIC_STATE_BLEND_CONSTANTS动态state开启创建，则vkCmdSetBlendConstants 必须在该命令之前设置
                                    （6）以VK_DYNAMIC_STATE_DEPTH_BOUNDS动态state开启创建，且如果当前depthBoundsTestEnable为VK_TRUE， 则vkCmdSetDepthBounds 必须在该命令之前设置
                                    （7）以VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK动态state开启创建，且如果当前stencilTestEnable为VK_TRUE， 则vkCmdSetStencilCompareMask 必须在该命令之前设置
                                    （8）以VK_DYNAMIC_STATE_STENCIL_WRITE_MASK动态state开启创建，且如果当前stencilTestEnable为VK_TRUE， 则vkCmdSetStencilWriteMask 必须在该命令之前设置
                                    （9）以VK_DYNAMIC_STATE_STENCIL_REFERENCE动态state开启创建，且如果当前stencilTestEnable为VK_TRUE， 则vkCmdSetStencilReference 必须在该命令之前设置
                                    （10）以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT动态state开启创建， 则vkCmdSetSampleLocationsEXT 必须在该命令之前设置
                                    （11）以VK_DYNAMIC_STATE_CULL_MODE动态state开启创建， 则vkCmdSetCullMode 必须在该命令之前设置
                                    （12）以VK_DYNAMIC_STATE_FRONT_FACE动态state开启创建， 则vkCmdSetFrontFace 必须在该命令之前设置
                                    （13）以VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE动态state开启创建， 则vkCmdSetDepthTestEnable 必须在该命令之前设置
                                    （14）以VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE动态state开启创建， 则vkCmdSetDepthWriteEnable 必须在该命令之前设置
                                    （15）以VK_DYNAMIC_STATE_DEPTH_COMPARE_OP动态state开启创建， 则vkCmdSetDepthCompareOp 必须在该命令之前设置
                                    （16）以VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE动态state开启创建， 则vkCmdSetDepthBoundsTestEnable 必须在该命令之前设置
                                    （17）以VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE动态state开启创建， 则vkCmdSetStencilTestEnable 必须在该命令之前设置
                                    （18）以VK_DYNAMIC_STATE_STENCIL_OP动态state开启创建， 则vkCmdSetStencilOp 必须在该命令之前设置
                                    （19）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT但不以VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT 动态state开启创建， 则vkCmdSetViewportWithCount 必须在该命令之前设置，且vkCmdSetViewportWithCount设置的viewportCount必须匹配pipeline的VkPipelineViewportStateCreateInfo::scissorCount
                                    （20）以VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT但不以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT 动态state开启创建， 则vkCmdSetScissorWithCount 必须在该命令之前设置，且vkCmdSetScissorWithCount设置的scissorCount必须匹配pipeline的VkPipelineViewportStateCreateInfo::viewportCount
                                    （21）以VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT和VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT 动态state同时开启创建， 则vkCmdSetViewportWithCount以及vkCmdSetScissorWithCount 必须在该命令之前设置，且vkCmdSetViewportWithCount设置的viewportCount必须匹配vkCmdSetScissorWithCount设置的scissorCount
                                    （22）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT但不以VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV 动态state开启创建， 则绑定的pipeline必须以VkPipelineViewportWScalingStateCreateInfoNV::viewportCount 大于等于最近vkCmdSetViewportWithCount设置的viewportCount创建
                                    （23）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT和VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV 动态state开启创建， 则最近调用的vkCmdSetViewportWScalingNV设置的viewportCount 必须大于等于最近vkCmdSetViewportWithCount设置的viewportCount
                                    （24）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT但不以VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV 动态state开启创建， 则绑定的pipeline必须以VkPipelineViewportShadingRateImageStateCreateInfoNV::viewportCount 大于等于最近vkCmdSetViewportWithCount设置的viewportCount创建
                                    （25）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT和VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV 动态state开启创建， 则最近调用的vkCmdSetViewportShadingRatePaletteNV设置的viewportCount 必须大于等于最近vkCmdSetViewportWithCount设置的viewportCount
                                    （26）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT动态state开启且VkPipelineViewportStateCreateInfo的pNext中含有一个VkPipelineViewportSwizzleStateCreateInfoNV 创建， 则绑定的pipeline必须以VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount 大于等于最近vkCmdSetViewportWithCount设置的viewportCount创建
                                    （27）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT动态state开启且VkPipelineViewportStateCreateInfo的pNext中含有一个VkPipelineViewportExclusiveScissorStateCreateInfoNV 创建， 则绑定的pipeline必须以VkPipelineViewportExclusiveScissorStateCreateInfoNV::exclusiveScissorCount 大于等于最近vkCmdSetViewportWithCount设置的viewportCount创建
                                    （28）以VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_ENABLE_NV动态state开启创建， 则vkCmdSetExclusiveScissorEnableNV 必须在该命令之前设置
                                    （29）以VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV动态state开启创建， 则vkCmdSetExclusiveScissorNV 必须在该命令之前设置
                                    （30）以VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE动态state开启创建， 则vkCmdSetRasterizerDiscardEnable 必须在该命令之前设置
                                    （31）以VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE动态state开启创建， 则vkCmdSetDepthBiasEnable 必须在该命令之前设置
                                    （32）以VK_DYNAMIC_STATE_LOGIC_OP_EXT动态state开启创建， 则vkCmdSetLogicOpEXT 必须在该命令之前设置且参数logicOp必须是一个有效的VkLogicOp值
    74.如果一个shader object绑定到任何graphics stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                    （1）如果最靠近当前命令的vkCmdSetPolygonModeEXT设置polygonMode为VK_POLYGON_MODE_LINE或者是任何line topology，则vkCmdSetLineWidth必须在该命令之前设置
                                    （2）如果最靠近当前命令的vkCmdSetDepthBiasEnable设置depthBiasEnable为VK_TRUE，则vkCmdSetDepthBias 或者 vkCmdSetDepthBias2EXT必须在该命令之前设置
                                    （3）如果最靠近当前命令的vkCmdSetDepthBoundsTestEnable设置depthBoundsTestEnable为VK_TRUE，则vkCmdSetDepthBounds必须在该命令之前设置
                                    （4）如果最靠近当前命令的vkCmdSetStencilTestEnable设置stencilTestEnable为VK_TRUE，则vkCmdSetStencilCompareMask必须在该命令之前设置
                                    （5）如果最靠近当前命令的vkCmdSetStencilTestEnable设置stencilTestEnable为VK_TRUE，则vkCmdSetStencilWriteMask必须在该命令之前设置
                                    （6）如果最靠近当前命令的vkCmdSetStencilTestEnable设置stencilTestEnable为VK_TRUE，则vkCmdSetStencilReference必须在该命令之前设置
                                    （7）如果最靠近当前命令的vkCmdSetSampleLocationsEnableEXT设置sampleLocationsEnable为VK_TRUE，则vkCmdSetSampleLocationsEXT必须在该命令之前设置
                                    （8）则vkCmdSetCullMode必须在该命令之前设置
                                    （9）则vkCmdSetFrontFace必须在该命令之前设置
                                    （10）则vkCmdSetDepthTestEnable 必须在该命令之前设置
                                    （11）则vkCmdSetDepthWriteEnable 必须在该命令之前设置
                                    （12）如果最靠近当前命令的vkCmdSetDepthTestEnable设置depthTestEnable为VK_TRUE，则vkCmdSetDepthCompareOp 必须在该命令之前设置
                                    （13）则vkCmdSetDepthBoundsTestEnable 必须在该命令之前设置
                                    （14）则vkCmdSetStencilTestEnable 必须在该命令之前设置
                                    （15）如果最靠近当前命令的vkCmdSetStencilTestEnable设置stencilTestEnable为VK_TRUE，则vkCmdSetStencilOp 必须在该命令之前设置
                                    （16）
                                    （17）如果shadingRateImage特性开启，则vkCmdSetCoarseSampleOrderNV 必须在该命令之前设置
                                    （18）如果shadingRateImage特性开启，且最靠近当前命令的vkCmdSetShadingRateImageEnableNV设置shadingRateImageEnable为VK_TRUE，则vkCmdSetViewportShadingRatePaletteNV 必须在该命令之前设置
                                    （19）如果shadingRateImage特性开启，且最靠近当前命令的vkCmdSetShadingRateImageEnableNV设置shadingRateImageEnable为VK_TRUE，则最近的vkCmdSetViewportShadingRatePaletteNV设置的viewportCount 必须大于等于vkCmdSetViewportWithCount设置的viewportCount
                                    （20）则vkCmdSetDepthBiasEnable必须在该命令之前设置
    75.如果一个输出line primitives的shader object绑定到VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或者 VK_SHADER_STAGE_GEOMETRY_BIT，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则vkCmdSetLineWidth必须在该命令之前设置
    76.如果一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最靠近当前命令的vkCmdSetColorBlendEnableEXT设置pColorBlendEnables任何元素为VK_TRUE，且
                        最靠近当前命令的vkCmdSetColorBlendEquationEXT设置pColorBlendEquations相同元素的VkColorBlendEquationEXT的VkBlendFactor成员为VK_BLEND_FACTOR_CONSTANT_COLOR, VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR, VK_BLEND_FACTOR_CONSTANT_ALPHA, 或者 VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA，则vkCmdSetBlendConstants必须在该命令之前设置
    77.如果该命令记录在开启了multiview的render pass instance中，则最大的instance 索引必须小于等于VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex
    78.如果绑定的graphics pipeline以VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable设置为VK_TRUE创建且当前的subpass含有一个 depth/stencil attachment，则该attachment必须以VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT创建
    >>78.5  .如果一个shader object绑定到任何graphics stage，则（1）vkCmdSetViewportWithCount 和vkCmdSetScissorWithCount 必须同时在该命令之前设置，且vkCmdSetViewportWithCount设置的viewportCount必须匹配vkCmdSetScissorWithCount设置的scissorCount
                                                              （2）则vkCmdSetRasterizerDiscardEnable 必须在该命令之前设置
    79.如果VK_NV_clip_space_w_scaling拓展开启，且shader object绑定到任何graphics stage，且最近的vkCmdSetViewportWScalingEnableNV设置viewportWScalingEnable为VK_TRUE，则（1）vkCmdSetViewportWScalingNV必须在该命令前设置
                                                                                                                                                                       （2）最近vkCmdSetViewportWScalingNV设置的viewportCount必须大于等于vkCmdSetViewportWithCount设置的viewportCount
    80.如果exclusiveScissor 特性开启，且shader object绑定到任何graphics stage，，则（1）vkCmdSetExclusiveScissorEnableNV必须在该命令前设置
                                                                                   （2）最近的vkCmdSetExclusiveScissorEnableNV调用设置的pExclusiveScissorEnables中的任何元素为VK_TRUE,则vkCmdSetExclusiveScissorNV必须在该命令前设置
    81.如果一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最靠近当前命令的vkCmdSetLogicOpEnableEXT设置logicOpEnable任何元素为VK_TRUE，则vkCmdSetLogicOpEXT 必须在该命令之前设置且参数logicOp必须是一个有效的VkLogicOp值
    82.如果primitiveFragmentShadingRateWithMultipleViewports限制不支持，则（1）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT动态state开启创建，且任何该pipeline的shader stage会写入PrimitiveShadingRateKHR built-in修饰的变量，则vkCmdSetViewportWithCount 必须在该命令之前设置且参数viewportCount必须是1
                                                                          （2）任何绑定的graphics pipeline的shader stage会写入PrimitiveShadingRateKHR built-in修饰的变量，则vkCmdSetViewportWithCount 必须在该命令之前设置且参数viewportCount必须是1
    83.如果graphics pipeline中未开启rasterization，则对subpass中的每个color attachment，如果其对应的image view 的format features不包含VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT，则pColorBlendState中其对应pAttachments中元素的blendEnable必须为VK_FALSE
    84.如果一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则对于render pass中的每个color attachment，如果其对应的image view 的format features不包含VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT， 则最近的vkCmdSetColorBlendEnableEXT设置的pColorBlendEnables中该附件的对应元素必须为VK_FALSE
    85.如果graphics pipeline中未开启rasterization，有VK_AMD_mixed_attachment_samples拓展未开启，VK_NV_framebuffer_mixed_samples拓展未开启，multisampledRenderToSingleSampled特性未开启，则当前绑定的pipeline的rasterizationSamples必须和当前subpass的color 以及/或者 depth/stencil attachments的相同
    86.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且有VK_AMD_mixed_attachment_samples拓展未开启，VK_NV_framebuffer_mixed_samples拓展未开启，multisampledRenderToSingleSampled特性未开启，则最近vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples必须和当前subpass的color 以及/或者 depth/stencil attachments的相同
    87.如果一个shader object绑定到任何graphics stage，则当前的render pass instance必须以vkCmdBeginRendering开始
    88.如果当前的render pass instance以vkCmdBeginRendering开始，（1）如果pDepthAttachment的imageView不为VK_NULL_HANDLE，且pDepthAttachment的layout不为VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL，则该命令不能写入任何值到depth attachment
                                                                （2）如果pStencilAttachment的imageView不为VK_NULL_HANDLE，且pStencilAttachment的layout不为VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL，则该命令不能写入任何值到stencil attachment
                                                                （3）如果pDepthAttachment的imageView不为VK_NULL_HANDLE，且pDepthAttachment的layout为VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL，则该命令不能写入任何值到depth attachment
                                                                （4）如果pStencilAttachment的imageView不为VK_NULL_HANDLE，且pStencilAttachment的layout为VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL，则该命令不能写入任何值到stencil attachment
                                                                （5）如果pDepthAttachment的imageView不为VK_NULL_HANDLE，且pDepthAttachment的layout为VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL，则该命令不能写入任何值到depth attachment
                                                                （6）如果pStencilAttachment的imageView不为VK_NULL_HANDLE，且pStencilAttachment的layout为VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL，则该命令不能写入任何值到stencil attachment
                                                                （7）则当前绑定的graphics pipeline必须以含VkPipelineRenderingCreateInfo::viewMask等于VkRenderingInfo::viewMask创建
                                                                （8）如果带有VkRenderingInfo::colorAttachmentCount为1，则没有shader object绑定到任何graphics stage，且一个color attachment的 resolve mode为VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID，则VkRenderingInfo::pColorAttachments中每个resolveImageView不为VK_NULL_HANDLE的元素其对应image必须以和创建当前绑定的pipeline 相同的VkExternalFormatANDROID::externalFormat创建
                                                                （9）如果没有shader object绑定到任何graphics stage，如果绑定的graphics pipeline以一个非零值VkExternalFormatANDROID::externalFormat创建且启用VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态设置，则vkCmdSetColorBlendEnableEXT必须在该命令前设置blend enable为VK_FALSE
                                                                （10）如果没有shader object绑定到任何graphics stage，如果绑定的graphics pipeline以一个非零值VkExternalFormatANDROID::externalFormat创建且启用VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态设置，则vkCmdSetRasterizationSamplesEXT必须在该命令前设置rasterizationSamples为VK_SAMPLE_COUNT_1_BIT
                                                                （11）如果没有shader object绑定到任何graphics stage，如果绑定的graphics pipeline以一个非零值VkExternalFormatANDROID::externalFormat创建且启用VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR动态设置，则vkCmdSetFragmentShadingRateKHR必须在该命令前设置pFragmentSize->width为1，pFragmentSize->height为1
    89.如果dynamicRenderingUnusedAttachments特性未开启，且当前的render pass instance以vkCmdBeginRendering开始，则
                                                            （1）当前绑定的graphics pipeline必须以含VkPipelineRenderingCreateInfo::colorAttachmentCount等于VkRenderingInfo::colorAttachmentCount创建
                                                            （2）如果VkRenderingInfo::colorAttachmentCount大于0，则VkRenderingInfo::pColorAttachments 中每一个其imageView不为VK_NULL_HANDLE的元素的VkImageView必须以VkFormat对应绑定的graphics pipeline的VkPipelineRenderingCreateInfo::pColorAttachmentFormats指明的format创建
                                                            （3）如果VkRenderingInfo::colorAttachmentCount大于0，则VkRenderingInfo::pColorAttachments 中每一个其imageView为VK_NULL_HANDLE的元素对应绑定的graphics pipeline的VkPipelineRenderingCreateInfo::pColorAttachmentFormats指明的format必须为VK_FORMAT_UNDEFINED
                                                            （4）如果VkRenderingInfo::pDepthAttachment->imageView为VK_NULL_HANDLE，则创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::depthAttachmentFormat必须为VK_FORMAT_UNDEFINED
                                                            （5）如果VkRenderingInfo::pDepthAttachment->imageView不为VK_NULL_HANDLE，则创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::depthAttachmentFormat必须和创建VkRenderingInfo::pDepthAttachment->imageView的VkFormat相同
                                                            （6）如果VkRenderingInfo::pStencilAttachment->imageView为VK_NULL_HANDLE，则创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::stencilAttachmentFormat必须为VK_FORMAT_UNDEFINED
                                                            （7）如果VkRenderingInfo::pStencilAttachment->imageView不为VK_NULL_HANDLE，则创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::stencilAttachmentFormat必须和创建VkRenderingInfo::pStencilAttachment->imageView的VkFormat相同
    90.如果dynamicRenderingUnusedAttachments特性开启，且当前的render pass instance以vkCmdBeginRendering开始，则
                                                            （1）如果VkRenderingInfo::colorAttachmentCount大于0，则VkRenderingInfo::pColorAttachments 中每一个其imageView不为VK_NULL_HANDLE的元素的VkImageView必须以VkFormat对应绑定的graphics pipeline的VkPipelineRenderingCreateInfo::pColorAttachmentFormats指明的format创建，或者是对应元素为VK_FORMAT_UNDEFINED创建
                                                            （2）如果VkRenderingInfo::pDepthAttachment->imageView不为VK_NULL_HANDLE，且创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::depthAttachmentFormat和创建VkRenderingInfo::pDepthAttachment->imageView的VkFormat不同，则该format必须为VK_FORMAT_UNDEFINED
                                                            （3）如果VkRenderingInfo::pStencilAttachment->imageView不为VK_NULL_HANDLE，且创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::stencilAttachmentFormat和创建VkRenderingInfo::pStencilAttachment->imageView的VkFormat不同，则该format必须为VK_FORMAT_UNDEFINED
    91.如果没有shader object绑定到任何graphics stage，且当前的render pass instance以vkCmdBeginRendering开始且VkRenderingInfo::colorAttachmentCount为1，且一个color attachment的 resolve mode为VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID，则VkRenderingInfo::pColorAttachments中每个resolveImageView不为VK_NULL_HANDLE的元素其对应image必须以和创建当前绑定的pipeline 相同的VkExternalFormatANDROID::externalFormat创建
    92.如果有一个shader object绑定到任何graphics stage，且当前的render pass 包含一个使用VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID resolve mode的color attachment，则（1）vkCmdSetColorBlendEnableEXT必须在该命令前设置blend enable为VK_FALSE
                                                                                                                                                                             （2）则vkCmdSetRasterizationSamplesEXT必须在该命令前设置rasterizationSamples为VK_SAMPLE_COUNT_1_BIT
                                                                                                                                                                             （3）则vkCmdSetFragmentShadingRateKHR必须在该命令前设置pFragmentSize->width为1，pFragmentSize->height为1
    93.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT动态state开启创建， 则vkCmdSetColorWriteEnableEXT 必须在该命令之前设置，且设置的attachmentCount必须大于等于创建当前绑定的pipeline的VkPipelineColorBlendStateCreateInfo::attachmentCount
                                    （2）以VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT动态state开启创建， 则vkCmdSetDiscardRectangleEXT 必须在该命令之前为每个VkPipelineDiscardRectangleStateCreateInfoEXT::discardRectangleCount指明的discard rectangle 设置
                                    （3）以VK_DYNAMIC_STATE_DISCARD_RECTANGLE_ENABLE_EXT动态state开启创建， 则vkCmdSetDiscardRectangleEnableEXT 必须在该命令之前设置
                                    （4）以VK_DYNAMIC_STATE_DISCARD_RECTANGLE_MODE_EXT动态state开启创建， 则vkCmdSetDiscardRectangleModeEXT 必须在该命令之前设置
    94.如果有一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                    （1）如果colorWriteEnable特性在device上开启，则vkCmdSetColorWriteEnableEXT 必须在该命令之前设置，且设置的attachmentCount必须大于等于当前render pass instance的color attachment的数量
                                    （2）如果VK_EXT_discard_rectangles拓展开启，且最近的vkCmdSetDiscardRectangleEnableEXT设置discardRectangleEnable为VK_TRUE， 则vkCmdSetDiscardRectangleEXT 必须在该命令之前设置
                                    （3）如果VK_EXT_discard_rectangles拓展开启， 则vkCmdSetDiscardRectangleEnableEXT 必须在该命令之前设置
                                    （4）如果VK_EXT_discard_rectangles拓展开启， 则最近的vkCmdSetDiscardRectangleEnableEXT设置discardRectangleEnable为VK_TRUE，则vkCmdSetDiscardRectangleModeEXT 必须在该命令之前设置
    95.如果当前的render pass instance以vkCmdBeginRendering开始，则（1）如果VkRenderingFragmentShadingRateAttachmentInfoKHR::imageView不为VK_NULL_HANDLE，则当前绑定的graphics pipeline必须以VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR创建
                                                                  （2）如果VkRenderingFragmentDensityMapAttachmentInfoEXT::imageView不为VK_NULL_HANDLE，则当前绑定的graphics pipeline必须以VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT创建
                                                                  （3）且含VkRenderingInfo::colorAttachmentCount大于0，如果当前的绑定的pipeline以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，则VkRenderingInfo::pColorAttachments中每个imageView不为VK_NULL_HANDLE的元素的imageView，必须以当前pipeline的VkAttachmentSampleCountInfoAMD 或者 VkAttachmentSampleCountInfoNV中的pColorAttachmentSamples中对应元素的sample count进行创建
                                                                  （4）如果当前的绑定的pipeline以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且VkRenderingInfo::pDepthAttachment中的imageView不为VK_NULL_HANDLE，则当前pipeline的VkAttachmentSampleCountInfoAMD 或者 VkAttachmentSampleCountInfoNV中的depthStencilAttachmentSamples必须等于创建VkRenderingInfo::pDepthAttachment->imageView的sample count
                                                                  （5）如果当前的绑定的pipeline以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且VkRenderingInfo::pStencilAttachment中的imageView不为VK_NULL_HANDLE，则当前pipeline的VkAttachmentSampleCountInfoAMD 或者 VkAttachmentSampleCountInfoNV中的depthStencilAttachmentSamples必须等于创建VkRenderingInfo::pStencilAttachment->imageView的sample count
                                                                  （6）且含VkRenderingInfo::colorAttachmentCount大于0，如果当前的绑定的pipeline不以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且multisampledRenderToSingleSampled特性没有开启，则VkRenderingInfo::pColorAttachments中每个imageView不为VK_NULL_HANDLE的元素的imageView，其创建的sample count必须等于当前绑定的graphics pipeline的rasterizationSamples
                                                                  （7）如果当前的绑定的pipeline不以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且VkRenderingInfo::pDepthAttachment中的imageView不为VK_NULL_HANDLE，且multisampledRenderToSingleSampled特性没有开启，则当前pipeline的rasterizationSamples 必须等于创建VkRenderingInfo::pDepthAttachment->imageView的sample count
                                                                  （8）如果当前的绑定的pipeline不以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且VkRenderingInfo::pStencilAttachment中的imageView不为VK_NULL_HANDLE，且multisampledRenderToSingleSampled特性没有开启，则当前pipeline的rasterizationSamples 必须等于创建VkRenderingInfo::pStencilAttachment->imageView的sample count
                                                                  （9）当前绑定的pipeline必须VkGraphicsPipelineCreateInfo::renderPass为VK_NULL_HANDLE创建
                                                                  （10）如果绑定的pipeline的fragment shader静态写入一个color attachment，且color write mask不为0，启用了color writes，且该附件对应的VkRenderingInfo::pColorAttachments->imageView 不为VK_NULL_HANDLE，则对应的创建pipeline的VkPipelineRenderingCreateInfo::pColorAttachmentFormats中的元素不能为VK_FORMAT_UNDEFINED
                                                                  （11）如果绑定的pipeline启用了depth test，启用了depth writes，且VkRenderingInfo::pDepthAttachment->imageView 不为VK_NULL_HANDLE，则创建pipeline的VkPipelineRenderingCreateInfo::depthAttachmentFormat不能为VK_FORMAT_UNDEFINED
                                                                  （12）如果绑定的pipeline启用了stencil test，且VkRenderingInfo::pStencilAttachment->imageView 不为VK_NULL_HANDLE，则创建pipeline的VkPipelineRenderingCreateInfo::stencilAttachmentFormat不能为VK_FORMAT_UNDEFINED
    96.如果该命令在以vkCmdBeginRendering开始的render pass instance中调用，且VkRenderingInfo的pNext中包含一个multisampledRenderToSingleSampledEnable设为VK_TRUE的VkMultisampledRenderToSingleSampledInfoEXT，则当前绑定的graphics pipeline的rasterizationSamples必须等于VkMultisampledRenderToSingleSampledInfoEXT::rasterizationSamples
    97.如果primitivesGeneratedQueryWithRasterizerDiscard特性未开启，且VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query激活，则不能启用rasterization discard
    98.如果primitivesGeneratedQueryWithNonZeroStreams特性未开启，且VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query激活，则 绑定的graphics pipeline不能以VkPipelineRasterizationStateStreamCreateInfoEXT::rasterizationStream为非零值创建
    98.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_TESSELLATION_DOMAIN_ORIGIN_EXT动态state开启创建，则vkCmdSetTessellationDomainOriginEXT必须在该命令之前设置
                                    （2）以VK_DYNAMIC_STATE_DEPTH_CLAMP_ENABLE_EXT动态state开启创建，则vkCmdSetDepthClampEnableEXT必须在该命令之前设置
                                    （3）以VK_DYNAMIC_STATE_POLYGON_MODE_EXT动态state开启创建，则vkCmdSetPolygonModeEXT必须在该命令之前设置
                                    （4）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，则vkCmdSetRasterizationSamplesEXT必须在该命令之前设置
                                    （5）以VK_DYNAMIC_STATE_SAMPLE_MASK_EXT动态state开启创建，则vkCmdSetSampleMaskEXT必须在该命令之前设置
                                    （6）以VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT动态state开启创建，则vkCmdSetAlphaToCoverageEnableEXT必须在该命令之前设置
                                    （7）以VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT动态state开启创建，则最近的vkCmdSetAlphaToCoverageEnableEXT设置alphaToCoverageEnable为VK_TRUE，则Fragment Output Interface中 Index 0的Location 0必须有一个含alpha Component的变量
                                    （8）以VK_DYNAMIC_STATE_ALPHA_TO_ONE_ENABLE_EXT动态state开启创建，则vkCmdSetAlphaToOneEnableEXT必须在该命令之前设置
                                    （9）以VK_DYNAMIC_STATE_LOGIC_OP_ENABLE_EXT动态state开启创建，则vkCmdSetLogicOpEnableEXT必须在该命令之前设置
                                    （10）以VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态state开启创建，则vkCmdSetColorBlendEnableEXT必须在该命令之前设置
                                    （11）以VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT动态state开启创建，则vkCmdSetColorBlendEquationEXT必须在该命令之前设置
                                    （12）以VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT动态state开启创建，则vkCmdSetColorWriteMaskEXT必须在该命令之前设置
    
    99.如果一个shader object绑定到VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT stage，则vkCmdSetTessellationDomainOriginEXT必须在该命令之前设置
    100.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                                    （1）如果depthClamp特性启用，则vkCmdSetDepthClampEnableEXT必须在该命令之前设置
                                                    （2）则vkCmdSetPolygonModeEXT必须在该命令之前设置
                                                    （3）则vkCmdSetRasterizationSamplesEXT必须在该命令之前设置
                                                    （4）则vkCmdSetSampleMaskEXT必须在该命令之前设置
                                                    （5）则vkCmdSetAlphaToCoverageEnableEXT必须在该命令之前设置
                                                    （6）如果alphaToOne特性启用，则vkCmdSetAlphaToOneEnableEXT必须在该命令之前设置
    
    101.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetAlphaToCoverageEnableEXT设置alphaToCoverageEnable为VK_TRUE，则Fragment Output Interface中 Index 0的Location 0必须有一个含alpha Component的变量
    102.如果一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                        （1）如果logicOp特性开启 ,vkCmdSetLogicOpEnableEXT必须在该命令之前设置
                                        （2）如果绑定了color attachments，则vkCmdSetColorBlendEnableEXT必须在该命令之前设置
                                        （3）如果最近的vkCmdSetColorBlendEnableEXT设置任何附件在pColorBlendEnables中的值为VK_TRUE ，则vkCmdSetColorBlendEquationEXT必须在该命令之前设置
                                        （4）如果绑定了color attachments，则vkCmdSetColorWriteMaskEXT必须在该命令之前设置
    
    103.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT动态state开启创建，则vkCmdSetRasterizationStreamEXT必须在该命令之前设置
                                     （2）以VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT动态state开启创建，则vkCmdSetConservativeRasterizationModeEXT必须在该命令之前设置
                                     （3）以VK_DYNAMIC_STATE_EXTRA_PRIMITIVE_OVERESTIMATION_SIZE_EXT动态state开启创建，则vkCmdSetExtraPrimitiveOverestimationSizeEXT必须在该命令之前设置
                                     （4）以VK_DYNAMIC_STATE_DEPTH_CLIP_ENABLE_EXT动态state开启创建，则vkCmdSetDepthClipEnableEXT必须在该命令之前设置
                                     （5）以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT动态state开启创建，则vkCmdSetSampleLocationsEnableEXT必须在该命令之前设置
                                     （6）以VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT动态state开启创建，则vkCmdSetColorBlendAdvancedEXT必须在该命令之前设置
                                     （7）以VK_DYNAMIC_STATE_PROVOKING_VERTEX_MODE_EXT动态state开启创建，则vkCmdSetProvokingVertexModeEXT必须在该命令之前设置
                                     （8）以VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT动态state开启创建，则vkCmdSetLineRasterizationModeEXT必须在该命令之前设置
                                     （9）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT动态state开启创建，则vkCmdSetLineStippleEnableEXT必须在该命令之前设置
                                     （10）以VK_DYNAMIC_STATE_LINE_STIPPLE_KHR动态state开启创建，则vkCmdSetLineStippleKHR必须在该命令之前设置
                                     （11）以VK_DYNAMIC_STATE_DEPTH_CLIP_NEGATIVE_ONE_TO_ONE_EXT动态state开启创建，则vkCmdSetDepthClipNegativeOneToOneEXT必须在该命令之前设置
                                     （12）以VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_ENABLE_NV动态state开启创建，则vkCmdSetViewportWScalingEnableNV必须在该命令之前设置
                                     （13）以VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV动态state开启创建，则vkCmdSetViewportSwizzleNV必须在该命令之前设置
                                     （14）以VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV动态state开启创建，则vkCmdSetCoverageToColorEnableNV必须在该命令之前设置
                                     （15）以VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_LOCATION_NV动态state开启创建，则vkCmdSetCoverageToColorLocationNV必须在该命令之前设置
                                     （16）以VK_DYNAMIC_STATE_COVERAGE_MODULATION_MODE_NV动态state开启创建，则vkCmdSetCoverageModulationModeNV必须在该命令之前设置
                                     （17）以VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV动态state开启创建，则vkCmdSetCoverageModulationTableEnableNV必须在该命令之前设置
                                     （18）以VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_NV动态state开启创建，则vkCmdSetCoverageModulationTableNV必须在该命令之前设置
                                     （19）以VK_DYNAMIC_STATE_SHADING_RATE_IMAGE_ENABLE_NV动态state开启创建，则vkCmdSetShadingRateImageEnableNV必须在该命令之前设置
                                     （20）以VK_DYNAMIC_STATE_REPRESENTATIVE_FRAGMENT_TEST_ENABLE_NV动态state开启创建，则vkCmdSetRepresentativeFragmentTestEnableNV必须在该命令之前设置
                                     （21）以VK_DYNAMIC_STATE_COVERAGE_REDUCTION_MODE_NV动态state开启创建，则vkCmdSetCoverageReductionModeNV必须在该命令之前设置
    
    104.如果一个shader object绑定到VK_SHADER_STAGE_GEOMETRY_BIT stage，且如果geometryStreams 特性开启，则vkCmdSetRasterizationStreamEXT必须在该命令之前设置
    105.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                            （1）如果VK_EXT_conservative_rasterization 拓展开启，vkCmdSetConservativeRasterizationModeEXT必须在该命令之前设置
                            （2）如果VK_EXT_conservative_rasterization 拓展开启，且最近的vkCmdSetConservativeRasterizationModeEXT设置conservativeRasterizationMode为VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT，则vkCmdSetExtraPrimitiveOverestimationSizeEXT必须在该命令之前设置
                            （3）如果VK_EXT_sample_locations 拓展开启，则vkCmdSetSampleLocationsEnableEXT必须在该命令之前设置
    106.如果一个shader object绑定到任何graphics stage，且depthClipEnable 特性开启，则vkCmdSetDepthClipEnableEXT必须在该命令之前设置
    107.如果如果一个shader object绑定到任何VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且如果VK_EXT_blend_operation_advanced 拓展开启，则vkCmdSetColorBlendEquationEXT 和 vkCmdSetColorBlendAdvancedEXT中至少一个必须在该命令之前设置
    108.如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，如果VK_EXT_provoking_vertex拓展开启， 则vkCmdSetProvokingVertexModeEXT必须在该命令之前设置
    109.如果VK_KHR_line_rasterization 或者 VK_EXT_line_rasterization拓展开启，则（1）如果一个shader object绑定到任意一个graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetPolygonModeEXT设置polygonMode 为VK_POLYGON_MODE_LINE ，则vkCmdSetLineRasterizationModeEXT必须在该命令之前设置
                                                                                （2）如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetPrimitiveTopology设置primitiveTopology 为任何line topology ，则vkCmdSetLineRasterizationModeEXT必须在该命令之前设置
                                                                                （3）如果一个输出为line primitive的shader object绑定到VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或 VK_SHADER_STAGE_GEOMETRY_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则vkCmdSetLineRasterizationModeEXT必须在该命令之前设置
                                                                                （4）如果一个shader object绑定到任意一个graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetPolygonModeEXT设置polygonMode 为VK_POLYGON_MODE_LINE ，则vkCmdSetLineStippleEnableEXT必须在该命令之前设置
                                                                                （5）如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetPrimitiveTopology设置primitiveTopology 为任何line topology ，则vkCmdSetLineStippleEnableEXT必须在该命令之前设置
                                                                                （6）如果一个输出为line primitive的shader object绑定到VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或 VK_SHADER_STAGE_GEOMETRY_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则vkCmdSetLineStippleEnableEXT必须在该命令之前设置
                                                                                （7）如果一个shader object绑定到任意一个graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetLineStippleEnableEXT设置stippledLineEnable 为VK_TRUE ，则vkCmdSetLineStippleEXT必须在该命令之前设置
    110.如果一个shader object绑定到任何graphics stage，（1）如果depthClipControl 特性开启，则vkCmdSetDepthClipNegativeOneToOneEXT必须在该命令之前设置
                                                       （2）VK_NV_clip_space_w_scaling 拓展开启，则vkCmdSetViewportWScalingEnableNV必须在该命令之前设置
                                                       （3）VK_NV_viewport_swizzle 拓展开启，则vkCmdSetViewportSwizzleNV必须在该命令之前设置
    111.如果如果一个shader object绑定到任何VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                        （1）如果VK_NV_fragment_coverage_to_color 拓展开启，则vkCmdSetCoverageToColorEnableNV 必须在该命令之前设置
                        （2）如果VK_NV_fragment_coverage_to_color 拓展开启，且最近的vkCmdSetCoverageToColorEnableNV 设置coverageToColorEnable 为VK_TRUE，则vkCmdSetCoverageToColorLocationNV 必须在该命令之前设置
                        （3）如果pipelineFragmentShadingRate 特性开启，则vkCmdSetFragmentShadingRateKHR 必须在该命令之前设置
    112.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                （1）如果VK_NV_framebuffer_mixed_samples 拓展开启，则vkCmdSetCoverageModulationModeNV 必须在该命令之前设置
                                （2）如果VK_NV_framebuffer_mixed_samples 拓展开启，且最近的vkCmdSetCoverageModulationModeNV设置coverageModulationMode为任何除VK_COVERAGE_MODULATION_MODE_NONE_NV之外的值，则vkCmdSetCoverageModulationTableEnableNV 必须在该命令之前设置
                                （3）如果VK_NV_framebuffer_mixed_samples 拓展开启，最近的vkCmdSetCoverageModulationTableEnableNV设置coverageModulationTableEnable为VK_TRUE，则vkCmdSetCoverageModulationTableNV 必须在该命令之前设置
                                （4）如果shadingRateImage 特性开启，则vkCmdSetShadingRateImageEnableNV 必须在该命令之前设置
                                （5）如果representativeFragmentTest 特性开启，则vkCmdSetRepresentativeFragmentTestEnableNV 必须在该命令之前设置
                                （6）如果coverageReductionMode 特性开启，则vkCmdSetCoverageReductionModeNV 必须在该命令之前设置
    113.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态state开启创建，且最近的vkCmdSetColorBlendEnableEXT设置任何附件在pColorBlendEnables中的值为VK_TRUE 则subpas中这些附件对应的image view的format features中必须包含VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT
                                     （2）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，且当前subpass不使用任何color和/或者 depth/stencil attachments，则最后的vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples必须符合zero￾attachment subpass的规则
                                     （3）以VK_DYNAMIC_STATE_SAMPLE_MASK_EXT不以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT 动态state开启创建，则最后调用的vkCmdSetSampleMaskEXT中设置的samples参数必须大于等于创建该pipeline的VkPipelineMultisampleStateCreateInfo::rasterizationSamples
                                     （4）以VK_DYNAMIC_STATE_SAMPLE_MASK_EXT和 VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT 动态state开启创建，则最后调用的vkCmdSetSampleMaskEXT中设置的samples参数必须大于等于最后的vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples
                                     （5）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，且VK_AMD_mixed_attachment_samples和VK_NV_framebuffer_mixed_samples拓展都没有开启，则最后的vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples必须等于subpass中color和/或者 depth/stencil attachments使用的相同
                                     （6）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，或者一个shader object绑定到任意graphics stage，且当前的subpass包含一个multisampledRenderToSingleSampledEnable 为VK_TRUE的VkMultisampledRenderToSingleSampledInfoEXT，则最后的vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples必须等于该VkMultisampledRenderToSingleSampledInfoEXT中的对应成员
                                     （7）以VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态state开启创建，则vkCmdSetColorBlendEnableEXT 必须在该命令之前设置，且vkCmdSetColorBlendEnableEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定值
                                     （8）以VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT动态state开启创建，则vkCmdSetColorBlendEquationEXT 必须在该命令之前设置，且vkCmdSetColorBlendEquationEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定blend equations
                                     （9）以VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT动态state开启创建，则vkCmdSetColorWriteMaskEXT 必须在该命令之前设置，且vkCmdSetColorWriteMaskEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定color write mask
                                     （10）以VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT动态state开启创建，则vkCmdSetColorBlendAdvancedEXT 必须在该命令之前设置，且vkCmdSetColorBlendAdvancedEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活blend的color attachments指定advanced blend equations
                                     （11）以VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT和VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态state开启创建，且最后的vkCmdSetColorBlendEnableEXT和vkCmdSetColorBlendAdvancedEXT设置启用了advanced blending，则当前subpass中激活的color attachments的数量不能超过advancedBlendMaxColorAttachments
                                     （12）以VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT动态state开启创建，且如果primitivesGeneratedQueryWithNonZeroStreams特性未开启且VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query已经激活，则最后的vkCmdSetRasterizationStreamEXT必须设置rasterizationStream为0
                                     （13）以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT但不以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，则最后的vkCmdSetSampleLocationsEXT设置的pSampleLocationsInfo->sampleLocationsPerPixel必须等于创建pipeline的VkPipelineMultisampleStateCreateInfo::rasterizationSamples
                                     （14）以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT和VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，则最后的vkCmdSetSampleLocationsEXT设置的pSampleLocationsInfo->sampleLocationsPerPixel必须等于最后vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples
                                     （15）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT但不以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT动态state开启创建，且绑定的pipeline的VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable为VK_TRUE 或者以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT动态state开启，则sampleLocationsInfo.sampleLocationsPerPixel 必须等于最后vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples
                                     （16）以VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV动态state开启创建，且最后的vkCmdSetCoverageToColorEnableNV设置coverageToColorEnable为VK_TRUE，则当前subpass必须有color attachment，且该attachment的format必须为VK_FORMAT_R8_UINT, VK_FORMAT_R8_SINT, VK_FORMAT_R16_UINT, VK_FORMAT_R16_SINT, VK_FORMAT_R32_UINT, 或者 VK_FORMAT_R32_SINT，且该attachment的location 有最后的vkCmdSetCoverageToColorLocationNV设置的coverageToColorLocation决定
                                     （17）以VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV和VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT 动态state开启创建，且如果VK_NV_coverage_reduction_mode 拓展开启，则当前的 coverageReductionMode，rasterizationSamples 以及color 以及 depth/stencil attachments（如果subpass有）的sample count必须是有效的返回值vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV的值的组合
                                     （18）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT但不以VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV 动态state开启创建，则绑定的graphics pipeline的VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount 必须大于等于最后vkCmdSetViewportWithCount设置的viewportCount
                                     （19）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT和VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV 动态state开启创建，则最后vkCmdSetViewportSwizzleNV设置的viewportCount 必须大于等于最后vkCmdSetViewportWithCount设置的viewportCount
                                     （20）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT或者 VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT 动态state开启创建，如果当前的stippledLineEnable为VK_TRUE，且当前的lineRasterizationMode为VK_LINE_RASTERIZATION_MODE_RECTANGULAR_KHR，则stippledRectangularLines 特性必须开启
                                     （21）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT或者 VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT 动态state开启创建，如果当前的stippledLineEnable为VK_TRUE，且当前的lineRasterizationMode为VK_LINE_RASTERIZATION_MODE_BRESENHAM_KHR，则stippledBresenhamLines 特性必须开启
                                     （22）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT或者 VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT 动态state开启创建，如果当前的stippledLineEnable为VK_TRUE，且当前的lineRasterizationMode为VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_KHR，则stippledSmoothLines 特性必须开启
                                     （23）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT或者 VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT 动态state开启创建，如果当前的stippledLineEnable为VK_TRUE，且当前的lineRasterizationMode为VK_LINE_RASTERIZATION_MODE_DEFAULT_KHR，则stippledRectangularLines 特性必须开启且VkPhysicalDeviceLimits::strictLines 必须为VK_TRUE
                                     （24）以VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT 动态state开启创建，且conservativePointAndLineRasterization不支持，最后的 pre-rasterization shader stage输出的有效图元拓扑为点或者线，则最后vkCmdSetConservativeRasterizationModeEXT设置的conservativeRasterizationMode 必须为VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT
                                     （25）以VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT 动态state开启创建，则vkCmdSetAttachmentFeedbackLoopEnableEXT 必须在该命令之前调用
    114.如果一个shader object绑定到 VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                                                                        （1）则vkCmdSetColorBlendEnableEXT 必须在该命令之前设置，且vkCmdSetColorBlendEnableEXT指定的firstAttachment开始的attachmentCount的值必须为当前subpass所有激活的color attachments指定
                                                                                        （2）则vkCmdSetColorBlendEquationEXT 必须在该命令之前设置，且vkCmdSetColorBlendEquationEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定blend equations
                                                                                        （3）则vkCmdSetColorWriteMaskEXT 必须在该命令之前设置，且vkCmdSetColorWriteMaskEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定color write mask
                                                                                        （4）如果VK_NV_fragment_coverage_to_color拓展开启， 最后的vkCmdSetCoverageToColorEnableNV设置coverageToColorEnable为VK_TRUE，则当前subpass必须有color attachment，且该attachment的format必须为VK_FORMAT_R8_UINT, VK_FORMAT_R8_SINT, VK_FORMAT_R16_UINT, VK_FORMAT_R16_SINT, VK_FORMAT_R32_UINT, 或者 VK_FORMAT_R32_SINT，且该attachment的location 有最后的vkCmdSetCoverageToColorLocationNV设置的coverageToColorLocation决定
    115.如果一个shader object绑定到 VK_SHADER_STAGE_FRAGMENT_BIT stage，（1）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT动态state开启创建，且最近的vkCmdSetSampleLocationsEnableEXT设置sampleLocationsEnable为VK_TRUE，且该subpass含有depth/stencil attachment，则该附件必须以VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT创建
                                                                        （2）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT和VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT 动态state开启创建，且最近的vkCmdSetSampleLocationsEnableEXT设置sampleLocationsEnable为VK_TRUE，则 最后vkCmdSetSampleLocationsEXT设置的sampleLocationsInfo.sampleLocationGridSize.width以及height 必须等于被调用vkGetPhysicalDeviceMultisamplePropertiesEXT传入rasterizationSamples返回的VkMultisamplePropertiesEXT::sampleLocationGridSize.width以及height一一对应均匀整除
                                                                        （3）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT 动态state开启创建，且最近的vkCmdSetSampleLocationsEnableEXT设置sampleLocationsEnable为VK_TRUE，则fragment shader代码中不能静态使用扩展指令InterpolateAtSample
                                                                        （4）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT但不以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT 动态state开启创建，且绑定的pipeline的VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable为VK_TRUE 或者以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT动态state开启，则 最后vkCmdSetRasterizationSamplesEXT设置的sampleLocationsInfo.sampleLocationGridSize.width以及height 必须等于被调用vkGetPhysicalDeviceMultisamplePropertiesEXT传入和vkCmdSetRasterizationSamplesEXT设置的相同rasterizationSamples的samples返回的VkMultisamplePropertiesEXT::sampleLocationGridSize.width以及height一一对应均匀整除
    116.如果一个shader object绑定到任何graphics stage，（1）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV 动态state开启创建，且最近的vkCmdSetCoverageModulationTableEnableNV设置coverageModulationTableEnable为VK_TRUE，则最近的vkCmdSetCoverageModulationTableNV 设置的coverageModulationTableCount 必须等于当前rasterizationSamples除以当前subppas的color samples
                                                       （2）如果VK_NV_viewport_swizzle 拓展开启，则最后vkCmdSetViewportSwizzleNV设置的viewportCount 必须大于等于最后vkCmdSetViewportWithCount设置的viewportCount
    117.如果VK_NV_framebuffer_mixed_samples 拓展开启，且如果在绑定的graphics pipeline中当前subpass有一个depth/stencil attachment以及dep test, stencil test, 或depth bounds test 启用，则当前rasterizationSamples 必须等于depth/stencil attachment的sample count
    118.如果VK_NV_framebuffer_mixed_samples 拓展开启，且如果最后的vkCmdSetRasterizationSamplesEXT设置的当前subpass的任何color attachments的rasterizationSamples 都大于 color samples，则sampleShadingEnable 必须为VK_FALSE
    119.如果当前绑定的graphics pipeline以VkGraphicsPipelineCreateInfo::pStages中的元素的VkPipelineShaderStageCreateInfo::stage设置为VK_SHADER_STAGE_VERTEX_BIT, VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT, VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或者 VK_SHADER_STAGE_GEOMETRY_BIT创建，则Mesh Shader Queries 不能激活
    120.如果dynamic state继承自VkCommandBufferInheritanceViewportScissorInfoNV，则这些动态state的设置必须在该命令之前设置
    121.如果没有绑定graphics pipeline，则（1）vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_VERTEX_BIT
                                         （2）如果tessellationShader 特性开启，vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT，VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT
                                         （3）如果geometryShader 特性开启，vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_GEOMETRY_BIT
                                         （4）vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_FRAGMENT_BIT
                                         （5）如果taskShader 特性开启，vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_TASK_BIT_EXT
                                         （6）如果meshShader 特性开启，vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_MESH_BIT_EXT
                                         （8）如果至少taskShader 和 meshShader一个特性开启，VK_SHADER_STAGE_VERTEX_BIT 或者VK_SHADER_STAGE_MESH_BIT_EXT stages中的一个必须含有有效的VkShaderEXT绑定，另外一个则不含有VkShaderEXT绑定
                                         （9）如果taskShader 和 meshShader特性同时开启，且一个有效的VkShaderEXT 绑定到VK_SHADER_STAGE_MESH_BIT_EXT stage，且该VkShaderEXT不以VK_SHADER_CREATE_NO_TASK_SHADER_BIT_EXT 创建，则一个有效的VkShaderEXT必须绑定到VK_SHADER_STAGE_TASK_BIT_EXT stage
                                         （10）如果taskShader 和 meshShader特性同时开启，且一个有效的VkShaderEXT 绑定到VK_SHADER_STAGE_MESH_BIT_EXT stage，且该VkShaderEXT以VK_SHADER_CREATE_NO_TASK_SHADER_BIT_EXT 创建，则不能有VkShaderEXT绑定到VK_SHADER_STAGE_TASK_BIT_EXT stage
                                         （11）如果一个有效的VkShaderEXT 绑定到VK_SHADER_STAGE_VERTEX_BIT stage，则不能有VkShaderEXT绑定到VK_SHADER_STAGE_TASK_BIT_EXT stage或者VK_SHADER_STAGE_MESH_BIT_EXT stage中的一个
    122.如果任何绑定的graphics shader以VK_SHADER_CREATE_LINK_STAGE_BIT_EXT 创建，（1）所有在相同vkCreateShadersEXT中以VK_SHADER_CREATE_LINK_STAGE_BIT_EXT创建的shaders必须也要绑定
                                                                                 （2）任何相同vkCreateShadersEXT中不以VK_SHADER_CREATE_LINK_STAGE_BIT_EXT创建的shaders不能有任何VkShaderEXT绑定
    123.所有绑定的graphics shader objects 必须以相同或者相同定义的push constant ranges创建
    124.所有绑定的graphics shader objects 必须以相同或者相同定义的descriptor set layouts的数组创建
    125.如果当前的render pass instance以vkCmdBeginRendering开始，且VkRenderingInfo::colorAttachmentCount为1，且有一个resolve mode为 VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID 的color attachment，且绑定了fragment shader，则DepthReplacing 和 StencilRefReplacingEXT execution modes 不能声明
    126.如果一个shader object绑定到 VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则 （1）如果attachmentFeedbackLoopDynamicState 特性开启，则 vkCmdSetAttachmentFeedbackLoopEnableEXT 必须在该命令之前调用
    127.如果包含一个fragment shader stage的绑定的graphics pipeline，（1）且该pipeline以VkPipelineDynamicStateCreateInfo::pDynamicStates中设置有VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE创建，且该fragment shader声明了EarlyFragmentTests execution mode且使用了OpDepthAttachmentReadEXT，则最后vkCmdSetDepthWriteEnable 设置的 depthWriteEnable 必须为VK_FALSE
                                                                    （2）且该pipeline以VkPipelineDynamicStateCreateInfo::pDynamicStates中设置有VK_DYNAMIC_STATE_STENCIL_WRITE_MASK创建，且该fragment shader声明了EarlyFragmentTests execution mode且使用了OpStencilAttachmentReadEXT，则最后vkCmdSetStencilWriteMask 设置的 writeMask 必须为0
    128.如果一个shader object绑定到任何graphics stage 或者绑定的graphics pipeline 以VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT 动态state开启创建，且任何color attachment的format为VK_FORMAT_E5B9G9R9_UFLOAT_PACK32，则vkCmdSetColorWriteMaskEXT设置的pColorWriteMasks参数的对应元素必须包含VK_COLOR_COMPONENT_R_BIT, VK_COLOR_COMPONENT_G_BIT, 和 VK_COLOR_COMPONENT_B_BIT，或者都不包含
    129.如果任何附件开启了blending，且该附件的source 或者 destination blend factors使用第二个颜色输入，则该命令执行的Fragment Execution Model静态使用的任何输出output attachment的Location的最大值必须小于maxFragmentDualSrcAttachments
    130.如果当前的render pass instance以vkCmdBeginRendering开始，（1）如果没有任何shader object绑定到任何graphics stage，则vkCmdSetRenderingAttachmentLocationsKHR 设置的VkRenderingAttachmentLocationInfoKHR::pColorAttachmentLocations中的每个元素必须匹配设置在当前绑定的graphics pipeline中的对应元素
                                                                 （2）如果没有任何shader object绑定到任何graphics stage，绑定的graphics pipeline中的input attchment 索引中映射的附件必须匹配在当前render pass instance的VkRenderingInputAttachmentIndexInfoKHR中设置的
    131.如果当前的render pass instance以vkCmdBeginRendering开始且以VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT标志开始，则绑定的graphics pipeline必须以VK_PIPELINE_CREATE_2_ENABLE_LEGACY_DITHERING_BIT_EXT创建
    132.如果绑定的graphics pipeline以VK_PIPELINE_CREATE_2_ENABLE_LEGACY_DITHERING_BIT_EXT创建，则当前的render pass 必须以vkCmdBeginRendering开始且以VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT标志开始
    133.绑定的graphics pipeline不能以VkGraphicsPipelineCreateInfo::pStages中元素的VkPipelineShaderStageCreateInfo::stage设置为VK_SHADER_STAGE_VERTEX_BIT, VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT, VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或者 VK_SHADER_STAGE_GEOMETRY_BIT创建
    134.Transform Feedback Queries不能激活
    135.Primitives Generated Queries不能激活
    136.用于创建任何激活的Pipeline Statistics Query的pipelineStatistics 不能包含VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT,
                                                                                VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT,
                                                                                VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT,
                                                                                VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT,
                                                                                VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT,
                                                                                VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT,
                                                                                VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT,
                                                                                VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT, 或者
                                                                                VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT
    137.如果buffer是non-sparse，则它必须完全和连续地绑定到单个VkDeviceMemory对象
    138.buffer必须以VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT 标志创建
    139.offset必须是4的倍数
    140.commandBuffer必须不为protected command buffer
    141.如果multiDrawIndirect 特性未开启，drawCount 必须为0 或 1
    142.countBufferOffset 必须是4的倍数
    143.countBuffer中存储的绘制次数参数必须小于或等于VkPhysicalDeviceLimits::maxDrawIndirectCount
    144.(countBufferOffset + sizeof(uint32_t)) 必须小于等于countBuffer的大小
    145.stride必须是4的倍数且必须大于或等于sizeof(VkDrawMeshTasksIndirectCommandEXT)
    146.如果maxDrawCount大于等于1，则(stride × (maxDrawCount - 1) + offset + sizeof(VkDrawMeshTasksIndirectCommandEXT)) 必须小于等于buffer的大小
    147.如果countBuffer中存储的绘制次数参数 为1，则(offset + sizeof (VkDrawMeshTasksIndirectCommandEXT))必须小于等于buffer的大小
    148.如果countBuffer中存储的绘制次数参数 大于1，则(stride × (drawCount - 1) + offset + sizeof(VkDrawMeshTasksIndirectCommandEXT))必须小于等于buffer的大小
    149.绑定到VK_PIPELINE_BIND_POINT_GRAPHICS绑定点的当前pipeline必须包含一个使用MeshEXT Execution Model的shader stage
    
    */
    /**/
}

void DrawingCommandsTest::ClusterCullingShadingTest()
{
    //图元可以从cluster culling shader stage生成并进行绘制，cluster culling shading类似于 dispatching compute因为shader使用了workgroups
    //cluster culling shading pipline只接受命令vkCmdDrawClusterHUAWEI 以及 vkCmdDrawClusterIndirectHUAWEI作为绘制命令

    VkCommandBuffer commandBuffer{/*假设这是一个有效的VkCommandBuffer*/ };
    
    //记录一个cluster culling 绘制命令     该命令执行时，由 groupCountX × groupCountY × groupCountZ组装成一个global workgroup。
    vkCmdDrawClusterHUAWEI(commandBuffer, 1/*groupCountX，是X维度dispatch的 local workgroups 数量.*/, 1/* groupCountY，是Y维度dispatch的 local workgroups 数量.*/, 1/*groupCountZ, 是Z维度dispatch的 local workgroups 数量.*/);
    /*

     vkCmdDrawClusterHUAWEI有效用法:
    1.如果一个VkSampler以其magFilter或者minFilter等于VK_FILTER_LINEAR创建，则（1）如果reductionMode为VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE，如果用于采样一个VkImageView作为该命令的结果的compareEnable为VK_FALSE，则该image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT
                                                                             （2）如果reductionMode为VK_SAMPLER_REDUCTION_MODE_MIN 或者VK_SAMPLER_REDUCTION_MODE_MAX之一 用于采样一个VkImageView作为该命令的结果，则该image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT
    2.如果一个VkSampler以其mipmapMode 等于VK_SAMPLER_MIPMAP_MODE_LINEAR创建，则（1）如果reductionMode为VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE，如果用于采样一个VkImageView作为该命令的结果的compareEnable为VK_FALSE，则该image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT
                                                                             （2）如果reductionMode为VK_SAMPLER_REDUCTION_MODE_MIN 或者VK_SAMPLER_REDUCTION_MODE_MAX之一 用于采样一个VkImageView作为该命令的结果，则该image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT
    3.如果一个VkSampler以其unnormalizedCoordinates等于VK_TRUE用于采样一个VkImageView作为该命令的结果创建，则（1）该image view的levelCount以及layerCount必须为1
                                                                                                            （2）该image view的viewType必须为VK_IMAGE_VIEW_TYPE_1D 或者 VK_IMAGE_VIEW_TYPE_2D
    4.如果一个VkImageView的采样带depth comparison操作，则image view的format features必须包含VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT
    5.如果一个VkImageView使用atomic operations作为该命令的结果进行访问，则image view的format features必须包含VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT
    6.如果一个VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER类型的 descriptor使用atomic operations作为该命令的结果进行访问，则storage texel buffer的format features必须包含VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT
    7.如果一个以VK_FILTER_CUBIC_EXT进行采样的VkImageView作为该命令的结果，则image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT
    8.如果VK_EXT_filter_cubic拓展没有开启，且有任何一个以VK_FILTER_CUBIC_EXT进行采样的VkImageView作为该命令的结果，则其VkImageViewType不能为VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, 或者 VK_IMAGE_VIEW_TYPE_CUBE_ARRAY
    9.任何一个以VK_FILTER_CUBIC_EXT进行采样的作为该命令的结果的VkImageView，其VkImageViewType和format 必须支持cubic filtering，参见vkGetPhysicalDeviceImageFormatProperties2返回的VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic
    10.任何一个以VK_FILTER_CUBIC_EXT进行采样且reduction mode为VK_SAMPLER_REDUCTION_MODE_MIN 或者 VK_SAMPLER_REDUCTION_MODE_MAX之一的作为该命令的结果的VkImageView，其VkImageViewType和format 必须支持带minmax filtering的cubic filtering，参见vkGetPhysicalDeviceImageFormatProperties2返回的VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax
    11.如果cubicRangeClamp特性没有开启，则有任何一个以VK_FILTER_CUBIC_EXT进行采样VkImageView的作为该命令的结果，VkSamplerReductionModeCreateInfo::reductionMode不能为VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM
    12.任何一个以VkSamplerReductionModeCreateInfo::reductionMode为VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM进行采样的作为该命令的结果的VkImageView必须以VK_FILTER_CUBIC_EXT进行采样
    13.如果selectableCubicWeights特性没有开启，则有任何一个以VK_FILTER_CUBIC_EXT进行采样VkImageView的作为该命令的结果，VkSamplerCubicWeightsCreateInfoQCOM::cubicWeights必须为VK_CUBIC_FILTER_WEIGHTS_CATMULL_ROM_QCOM
    14.任何一个以VkImageCreateInfo::flags含VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV创建的采样作为该命令结果的VkImage必须以VkSamplerAddressMode为VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE 进行采样
    15.对于任何作为storage image写入的VkImageView，且其OpTypeImage的format未知，则该image view的 format features必须包含VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT
    16.对于任何作为storage image读取的VkImageView，且其OpTypeImage的format未知，则该image view的 format features必须包含VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT
    17.对于任何作为storage storage texel buffer写入的VkBufferView，且其OpTypeImage的format未知，则该buffer view的 buffer features必须包含VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT
    18.对于任何作为storage storage texel buffer读取的VkBufferView，且其OpTypeImage的format未知，则该buffer view的 buffer features必须包含VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT
    19.对于每个在绑定的shader中静态使用的set n，一个descriptor set必须被绑定到相同pipeline bind point的set n处，该set n必须和创建当前VkPipeline的VkPipelineLayout或者和创建当前VkShaderEXT的VkDescriptorSetLayout 数组的set n处的布局兼容，参见Pipeline Layout Compatibility p1280
    20.对于每个在绑定的shader中静态使用的push constant，一个push constant值必须被绑定到相同pipeline bind point的对应处，该push constant必须和创建当前VkPipeline的VkPipelineLayout或者和创建当前VkShaderEXT的VkDescriptorSetLayout 数组中的对应处的布局兼容，参见Pipeline Layout Compatibility p1280
    21.如果maintenance4特性没有开启，则对于每个在绑定的shader中静态使用的push constant，一个push constant值必须被设置到相同pipeline bind point的对应处，该push constant必须和创建当前VkPipeline的VkPipelineLayout或者和创建当前VkShaderEXT的VkDescriptorSetLayout 数组中的对应处的布局兼容，参见Pipeline Layout Compatibility p1280
    22.每一个通过vkCmdBindDescriptorSets绑定的descriptor set的descriptors,如果是被不以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建的，且已经绑定到该命令使用的pipeline bind point的VkPipeline静态使用的，则这些descriptors必须是有效的，参见 descriptor validity p1328
    23.如果通过vkCmdBindDescriptorSets指定绑定到pipeline bind point的VkPipeline要使用的descriptors，则绑定的VkPipeline不能以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建
    24.在vkCmdSetDescriptorBufferOffsetsEXT中指定绑定的descriptor buffers的descriptors，则（1）如果绑定到pipeline bind point的该命令会使用的VkPipeline以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建，且这些descriptors是动态使用的，则这些descriptors必须是有效的
                                                                                          （2）如果绑定到pipeline bind point的对应stage的该命令会使用的VkShaderEXT，且这些descriptors是动态使用的，则这些descriptors必须是有效的
    25.在vkCmdSetDescriptorBufferOffsetsEXT中指定的descriptors在绑定到pipeline bind point的VkPipeline中使用，则VkPipeline必须以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建
    26.如果一个descriptor在以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建的VkPipeline中动态使用，则descriptor memory必须是驻留内存
    27.如果一个descriptor在以其VkDescriptorSetLayout以VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建的VkShaderEXT中动态使用，则descriptor memory必须是驻留内存
    28.如果shaderObject 特性没有开启，一个有效的pipeline必须绑定到这个命令使用的绑定到pipeline bind point上
    29.如果一个pipeline绑定到该命令使用的pipeline bind point上，则不能有任何动态state 设置命令设置任何该VkPipeline 中没有指定的动态 state
    30.如果一个VkPipeline绑定到该命令使用的pipeline bind point上 或者任何一个会访问一个使用unnormalized coordinates的VkSampler的 VkShaderEXT绑定到该命令使用的pipeline bind point上的pipeline的对应stage，则
                                                                                （1）在任何shader stage中，VkSampler不能用来采样任何类型为VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY 或者 VK_IMAGE_VIEW_TYPE_CUBE_ARRAY的VkImageView
                                                                                （2）在任何shader stage中，该VkSampler不能和任何带有名字中带有ImplicitLod，Dref 或者 Proj 的SPIR-V OpImageSample* 或者 OpImageSparseSample*指令一起使用
                                                                                （3）在任何shader stage中，该VkSampler不能和任何包含 LOD bias或者offset 值 的SPIR-V OpImageSample* or OpImageSparseSample*指令一起使用
    31.如果shaderObject开启，一个有效的pipeline必须绑定到该命令使用的pipeline bind point上或者一个有效的shader objects以及VK_NULL_HANDLE的组合必须绑定到该命令使用的pipeline bind point每一个支持的shader stage上
    32.如何绑定到该命令使用的pipeline bind point上的VkPipeline的任何stage会访问一个uniform buffer，且该stage对uniformBuffers不以启用VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT或者VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT 创建，且robustBufferAccess特性未开启，则该stage就不能访问绑定到相同pipeline bind point的descriptor set指定的buffer范围外的值
    33.如果robustBufferAccess特性未开启，且任何会访问uniform buffer的绑定到该命令使用的pipeline bind point上对应shader stage的VkShaderEXT，则其不能访问绑定到相同pipeline bind point的descriptor set指定的buffer范围外的值
    34.如何绑定到该命令使用的pipeline bind point上的VkPipeline的任何stage会访问一个storage buffer，且该stage对storageBuffers不以启用VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT或者VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT 创建，且robustBufferAccess特性未开启，则该stage就不能访问绑定到相同pipeline bind point的descriptor set指定的buffer范围外的值
    35.如果robustBufferAccess特性未开启，且任何会访问storage buffer的绑定到该命令使用的pipeline bind point上对应shader stage的VkShaderEXT，则其不能访问绑定到相同pipeline bind point的descriptor set指定的buffer范围外的值
    36.如果commandBuffer 是一个unprotected command buffer，且protectedNoFault 未支持，则任何绑定的shaders访问的资源不能是一个protected resource
    37.如果一个绑定的shader访问一个VkSampler 或者 VkImageView ，且启用了sampler Y′C BCR conversion，则只能使用OpImageSample* 或者 OpImageSparseSample*指令，不能使用ConstOffset 以及 Offset操作符
    38.如果一个VkImageView作为该命令的结果进行访问，则（1）image view 的viewType 必须匹配Instruction/Sampler/Image View Validation p1481中描述的OpTypeImage的Dim操作符
                                                      （2）image view 的foamrt的numeric type 必须匹配OpTypeImage的Sampled Type操作符
    39.如果一个VkImageView以一个不是VK_FORMAT_A8_UNORM_KHR的format创建且通过OpImageWrite作为该命令的结果进行访问，则该命令的Texel 操作符的Type必须至少包含和 image view的 format含有的components的个数相同的components个数
    40.如果一个VkImageView以VK_FORMAT_A8_UNORM_KHR的format创建且通过OpImageWrite作为该命令的结果进行访问，则该命令的Texel 操作符的Type必须包含4个components
    41.如果一个VkBufferView通过OpImageWrite作为该命令的结果进行访问，则该命令的Texel 操作符的Type必须至少包含和 buffer view的 format含有的components的个数相同的components个数
    42.如果一个带64-bit component的VkFormat的VkImageView作为该命令的结果进行访问，则该命令的OpTypeImage操作符的SampledType的宽度必须为64
    43.如果一个带少于64-bit component的VkFormat的VkImageView作为该命令的结果进行访问，则该命令的OpTypeImage操作符的SampledType的宽度必须为32
    44.如果一个带64-bit component的VkFormat的VkBufferView作为该命令的结果进行访问，则该命令的OpTypeImage操作符的SampledType的宽度必须为64位
    45.如果一个带少于64-bit component的VkFormat的VkBufferView作为该命令的结果进行访问，则该命令的OpTypeImage操作符的SampledType的宽度必须为32
    46.如果sparseImageInt64Atomics 特性未开启，则以VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT创建的VkImage对象不能被SampledType宽度为64位的OpTypeImage的atomic instructions访问
    47.如果sparseImageInt64Atomics 特性未开启，则以VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT创建的VkBuffer对象不能被SampledType宽度为64位的OpTypeImage的atomic instructions访问
    48.如果OpImageWeightedSampleQCOM用来采样一个作为该命令的结果的VkImageView，则该image view的format features必须包含VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM
    49.如果OpImageWeightedSampleQCOM用来采样一个作为该命令的结果的sample weight image的VkImageView，则该image view的format features必须包含VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM
    50.如果OpImageBoxFilterQCOM用来采样一个作为该命令的结果的VkImageView，则该image view的format features必须包含VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM
    51.如果OpImageBlockMatchSSDQCOM，或者 OpImageBlockMatchSADQCOM用来读取一个作为该命令的结果的VkImageView，则（1）该image view的format features必须包含VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM
                                                                                                               （2）如果是读取的reference image，指定的reference coordinates不能在integer texel coordinate validation 时候失败
    52.如果OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchWindowSSDQCOM, OpImageBlockMatchWindowSADQCOM, OpImageBlockMatchGatherSSDQCOM,
                                                OpImageBlockMatchGatherSADQCOM, OpImageBlockMatchSSDQCOM, 或者 OpImageBlockMatchSADQCOM用来采样一个作为该命令的结果的VkImageView，则该VkSampler必须以VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM创建
    53.如果任何除了OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchWindowSSDQCOM, OpImageBlockMatchWindowSADQCOM, OpImageBlockMatchGatherSSDQCOM, OpImageBlockMatchGatherSADQCOM, OpImageBlockMatchSSDQCOM, 或者 OpImageBlockMatchSADQCOM之外的指令使用VkSampler进行采样作为该命令的结果，则该sampler不能以VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM 创建
    54.如果OpImageBlockMatchWindow*QCOM or OpImageBlockMatchGather*QCOM指令用来读取VkImageView作为该命令的结果，则（1）VkImageView的format features必须包含VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM
                                                                                                                  （2）VkImageView的format必须只含有一个component
    55.如果OpImageBlockMatchWindow*QCOM or OpImageBlockMatchGather*QCOM指令用来读取一个引用的image作为该命令的结果，则指定的 reference coordinates不能在integer texel coordinate validation 时候失败
    56.任何该命令执行的shader invocation必须已经终止
    57.如果有一个类型位为VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM, VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, 或者 VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT中任意一个的descriptor作为该命令的结果进行访问，则该descriptor所指的image subresource的layout必须和该descriptor被写入时的layout相同。
    58.当前的 render pass  必须和绑定到VK_PIPELINE_BIND_POINT_GRAPHICS上的VkPipeline 创建时候的VkGraphicsPipelineCreateInfo中指定的renderPass兼容
    59.当前的 render pass  的subpass index必须和绑定到VK_PIPELINE_BIND_POINT_GRAPHICS上的VkPipeline 创建时候的VkGraphicsPipelineCreateInfo中指定的subpass相同
    60.如果任何shader静态访问一个input attachment，则有效的descriptor必须通过VkDescriptorSet被绑定到该pipeline中
    61.如果任何该pipeline执行shader以SubpassData的Dim操作符访问一个OpTypeImage变量，则该变量必须被一个对应当前subpass的input attachment的InputAttachmentIndex修饰
    62.在subpass中访问的Input attachment views必须以和该subpass相同定义的VkFormat创建，且必须以一个和当前绑定的VkFramebuffer的该附件引用的subpass的pInputAttachments[InputAttachmentIndex]附件兼容的VkImageView创建，参见Fragment Input Attachment Compatibility p1408
    63.在动态render pass中访问以VkRenderingInputAttachmentIndexInfoKHR的InputAttachmentIndex，或者VkRenderingInputAttachmentIndexInfoKHR:pDepthInputAttachmentIndex 或者 VkRenderingInputAttachmentIndexInfoKHR:pStencilInputAttachmentIndex为NULL情况下不指定InputAttachmentIndex的引用的Input attachment views，必须以和VkRenderingInfo中对应color, depth, 或者 stencil attachment兼容的VkImageView创建
    64.如果VkRenderingInputAttachmentIndexInfoKHR::pDepthInputAttachmentIndex 以及 VkRenderingInputAttachmentIndexInfoKHR::pStencilInputAttachmentIndex不为NULL，则在动态render pass中通过shader object访问Input attachment views必须指明InputAttachmentIndex
    65.如果在动态render pass中通过shader object访问Input attachment views指明了InputAttachmentIndex，则InputAttachmentIndex必须匹配VkRenderingInputAttachmentIndexInfoKHR中的index
    66.当前render pass所用的附件对应的image subresource底层内存的写入只能作为该命令的一个附件写入
    67.如果一个color attachment在之前的该subpass的命令中以load, store, 或者 resolve operations进行了写入，则其layout不为VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT，且有当前绑定的pipeline设有VK_PIPELINE_CREATE_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT，或者
                                    最后的vkCmdSetAttachmentFeedbackLoopEnableEXT调用包含VK_IMAGE_ASPECT_COLOR_BIT以及 没有绑定的pipeline 或者绑定的pipeline以VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT创建，则该附件只能以附件进行访问的，这两种情况中之一
    68.如果一个depth attachment在之前的该subpass的命令中以load, store, 或者 resolve operations进行了写入，则其layout不为VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT，且有当前绑定的pipeline设有VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT，或者
                                    最后的vkCmdSetAttachmentFeedbackLoopEnableEXT调用包含VK_IMAGE_ASPECT_DEPTH_BIT以及 没有绑定的pipeline 或者绑定的pipeline以VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT创建，则该附件只能以附件进行访问的，这两种情况中之一
    69.如果一个stencil attachment在之前的该subpass的命令中以load, store, 或者 resolve operations进行了写入，则其layout不为VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT，且有当前绑定的pipeline设有VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT，或者
                                    最后的vkCmdSetAttachmentFeedbackLoopEnableEXT调用包含VK_IMAGE_ASPECT_STENCIL_BIT以及 没有绑定的pipeline 或者绑定的pipeline以VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT创建，则该附件只能以附件进行访问的，这两种情况中之一
    70.如果一个attachment在之前的该subpass的命令中以load, store, 或者 resolve operations进行了写入,则该附件就不能再以除作为一个附件，storage image或者sampled image被该命令访问
    71.如果在之前的命令的subpass中以用作附件外的方式访问访问了一个当权subpass的附件所对的image subresource，则该命令就不能再将该image subresource用作附件进行写入
    72.如果当前render pass使用一个depth/stencil attachment，则（1）如果depth aspect的layout为read-only的layout，则不能启用depth writes
                                                              （2）如果stencil aspect的layout为read-only的layout，front 以及 back writeMask不为0，且stencil 测试开启，则所有stencil 操作必须为VK_STENCIL_OP_KEEP
    73.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_VIEWPORT动态state开启创建，则vkCmdSetViewport必须在该命令之前设置
                                    （2）以VK_DYNAMIC_STATE_SCISSOR动态state开启创建，则vkCmdSetScissor必须在该命令之前设置
                                    （3）以VK_DYNAMIC_STATE_LINE_WIDTH动态state开启创建，则vkCmdSetLineWidth必须在该命令之前设置
                                    （4）以VK_DYNAMIC_STATE_DEPTH_BIAS动态state开启创建，则vkCmdSetDepthBias或者vkCmdSetDepthBias2EXT 必须在该命令之前设置
                                    （5）以VK_DYNAMIC_STATE_BLEND_CONSTANTS动态state开启创建，则vkCmdSetBlendConstants 必须在该命令之前设置
                                    （6）以VK_DYNAMIC_STATE_DEPTH_BOUNDS动态state开启创建，且如果当前depthBoundsTestEnable为VK_TRUE， 则vkCmdSetDepthBounds 必须在该命令之前设置
                                    （7）以VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK动态state开启创建，且如果当前stencilTestEnable为VK_TRUE， 则vkCmdSetStencilCompareMask 必须在该命令之前设置
                                    （8）以VK_DYNAMIC_STATE_STENCIL_WRITE_MASK动态state开启创建，且如果当前stencilTestEnable为VK_TRUE， 则vkCmdSetStencilWriteMask 必须在该命令之前设置
                                    （9）以VK_DYNAMIC_STATE_STENCIL_REFERENCE动态state开启创建，且如果当前stencilTestEnable为VK_TRUE， 则vkCmdSetStencilReference 必须在该命令之前设置
                                    （10）以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT动态state开启创建， 则vkCmdSetSampleLocationsEXT 必须在该命令之前设置
                                    （11）以VK_DYNAMIC_STATE_CULL_MODE动态state开启创建， 则vkCmdSetCullMode 必须在该命令之前设置
                                    （12）以VK_DYNAMIC_STATE_FRONT_FACE动态state开启创建， 则vkCmdSetFrontFace 必须在该命令之前设置
                                    （13）以VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE动态state开启创建， 则vkCmdSetDepthTestEnable 必须在该命令之前设置
                                    （14）以VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE动态state开启创建， 则vkCmdSetDepthWriteEnable 必须在该命令之前设置
                                    （15）以VK_DYNAMIC_STATE_DEPTH_COMPARE_OP动态state开启创建， 则vkCmdSetDepthCompareOp 必须在该命令之前设置
                                    （16）以VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE动态state开启创建， 则vkCmdSetDepthBoundsTestEnable 必须在该命令之前设置
                                    （17）以VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE动态state开启创建， 则vkCmdSetStencilTestEnable 必须在该命令之前设置
                                    （18）以VK_DYNAMIC_STATE_STENCIL_OP动态state开启创建， 则vkCmdSetStencilOp 必须在该命令之前设置
                                    （19）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT但不以VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT 动态state开启创建， 则vkCmdSetViewportWithCount 必须在该命令之前设置，且vkCmdSetViewportWithCount设置的viewportCount必须匹配pipeline的VkPipelineViewportStateCreateInfo::scissorCount
                                    （20）以VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT但不以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT 动态state开启创建， 则vkCmdSetScissorWithCount 必须在该命令之前设置，且vkCmdSetScissorWithCount设置的scissorCount必须匹配pipeline的VkPipelineViewportStateCreateInfo::viewportCount
                                    （21）以VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT和VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT 动态state同时开启创建， 则vkCmdSetViewportWithCount以及vkCmdSetScissorWithCount 必须在该命令之前设置，且vkCmdSetViewportWithCount设置的viewportCount必须匹配vkCmdSetScissorWithCount设置的scissorCount
                                    （22）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT但不以VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV 动态state开启创建， 则绑定的pipeline必须以VkPipelineViewportWScalingStateCreateInfoNV::viewportCount 大于等于最近vkCmdSetViewportWithCount设置的viewportCount创建
                                    （23）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT和VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV 动态state开启创建， 则最近调用的vkCmdSetViewportWScalingNV设置的viewportCount 必须大于等于最近vkCmdSetViewportWithCount设置的viewportCount
                                    （24）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT但不以VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV 动态state开启创建， 则绑定的pipeline必须以VkPipelineViewportShadingRateImageStateCreateInfoNV::viewportCount 大于等于最近vkCmdSetViewportWithCount设置的viewportCount创建
                                    （25）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT和VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV 动态state开启创建， 则最近调用的vkCmdSetViewportShadingRatePaletteNV设置的viewportCount 必须大于等于最近vkCmdSetViewportWithCount设置的viewportCount
                                    （26）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT动态state开启且VkPipelineViewportStateCreateInfo的pNext中含有一个VkPipelineViewportSwizzleStateCreateInfoNV 创建， 则绑定的pipeline必须以VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount 大于等于最近vkCmdSetViewportWithCount设置的viewportCount创建
                                    （27）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT动态state开启且VkPipelineViewportStateCreateInfo的pNext中含有一个VkPipelineViewportExclusiveScissorStateCreateInfoNV 创建， 则绑定的pipeline必须以VkPipelineViewportExclusiveScissorStateCreateInfoNV::exclusiveScissorCount 大于等于最近vkCmdSetViewportWithCount设置的viewportCount创建
                                    （28）以VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_ENABLE_NV动态state开启创建， 则vkCmdSetExclusiveScissorEnableNV 必须在该命令之前设置
                                    （29）以VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV动态state开启创建， 则vkCmdSetExclusiveScissorNV 必须在该命令之前设置
                                    （30）以VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE动态state开启创建， 则vkCmdSetRasterizerDiscardEnable 必须在该命令之前设置
                                    （31）以VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE动态state开启创建， 则vkCmdSetDepthBiasEnable 必须在该命令之前设置
                                    （32）以VK_DYNAMIC_STATE_LOGIC_OP_EXT动态state开启创建， 则vkCmdSetLogicOpEXT 必须在该命令之前设置且参数logicOp必须是一个有效的VkLogicOp值
    74.如果一个shader object绑定到任何graphics stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                    （1）如果最靠近当前命令的vkCmdSetPolygonModeEXT设置polygonMode为VK_POLYGON_MODE_LINE或者是任何line topology，则vkCmdSetLineWidth必须在该命令之前设置
                                    （2）如果最靠近当前命令的vkCmdSetDepthBiasEnable设置depthBiasEnable为VK_TRUE，则vkCmdSetDepthBias 或者 vkCmdSetDepthBias2EXT必须在该命令之前设置
                                    （3）如果最靠近当前命令的vkCmdSetDepthBoundsTestEnable设置depthBoundsTestEnable为VK_TRUE，则vkCmdSetDepthBounds必须在该命令之前设置
                                    （4）如果最靠近当前命令的vkCmdSetStencilTestEnable设置stencilTestEnable为VK_TRUE，则vkCmdSetStencilCompareMask必须在该命令之前设置
                                    （5）如果最靠近当前命令的vkCmdSetStencilTestEnable设置stencilTestEnable为VK_TRUE，则vkCmdSetStencilWriteMask必须在该命令之前设置
                                    （6）如果最靠近当前命令的vkCmdSetStencilTestEnable设置stencilTestEnable为VK_TRUE，则vkCmdSetStencilReference必须在该命令之前设置
                                    （7）如果最靠近当前命令的vkCmdSetSampleLocationsEnableEXT设置sampleLocationsEnable为VK_TRUE，则vkCmdSetSampleLocationsEXT必须在该命令之前设置
                                    （8）则vkCmdSetCullMode必须在该命令之前设置
                                    （9）则vkCmdSetFrontFace必须在该命令之前设置
                                    （10）则vkCmdSetDepthTestEnable 必须在该命令之前设置
                                    （11）则vkCmdSetDepthWriteEnable 必须在该命令之前设置
                                    （12）如果最靠近当前命令的vkCmdSetDepthTestEnable设置depthTestEnable为VK_TRUE，则vkCmdSetDepthCompareOp 必须在该命令之前设置
                                    （13）则vkCmdSetDepthBoundsTestEnable 必须在该命令之前设置
                                    （14）则vkCmdSetStencilTestEnable 必须在该命令之前设置
                                    （15）如果最靠近当前命令的vkCmdSetStencilTestEnable设置stencilTestEnable为VK_TRUE，则vkCmdSetStencilOp 必须在该命令之前设置
                                    （16）
                                    （17）如果shadingRateImage特性开启，则vkCmdSetCoarseSampleOrderNV 必须在该命令之前设置
                                    （18）如果shadingRateImage特性开启，且最靠近当前命令的vkCmdSetShadingRateImageEnableNV设置shadingRateImageEnable为VK_TRUE，则vkCmdSetViewportShadingRatePaletteNV 必须在该命令之前设置
                                    （19）如果shadingRateImage特性开启，且最靠近当前命令的vkCmdSetShadingRateImageEnableNV设置shadingRateImageEnable为VK_TRUE，则最近的vkCmdSetViewportShadingRatePaletteNV设置的viewportCount 必须大于等于vkCmdSetViewportWithCount设置的viewportCount
                                    （20）则vkCmdSetDepthBiasEnable必须在该命令之前设置
    75.如果一个输出line primitives的shader object绑定到VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或者 VK_SHADER_STAGE_GEOMETRY_BIT，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则vkCmdSetLineWidth必须在该命令之前设置
    76.如果一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最靠近当前命令的vkCmdSetColorBlendEnableEXT设置pColorBlendEnables任何元素为VK_TRUE，且
                        最靠近当前命令的vkCmdSetColorBlendEquationEXT设置pColorBlendEquations相同元素的VkColorBlendEquationEXT的VkBlendFactor成员为VK_BLEND_FACTOR_CONSTANT_COLOR, VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR, VK_BLEND_FACTOR_CONSTANT_ALPHA, 或者 VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA，则vkCmdSetBlendConstants必须在该命令之前设置
    77.如果该命令记录在开启了multiview的render pass instance中，则最大的instance 索引必须小于等于VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex
    78.如果绑定的graphics pipeline以VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable设置为VK_TRUE创建且当前的subpass含有一个 depth/stencil attachment，则该attachment必须以VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT创建
    >>78.5  .如果一个shader object绑定到任何graphics stage，则（1）vkCmdSetViewportWithCount 和vkCmdSetScissorWithCount 必须同时在该命令之前设置，且vkCmdSetViewportWithCount设置的viewportCount必须匹配vkCmdSetScissorWithCount设置的scissorCount
                                                              （2）则vkCmdSetRasterizerDiscardEnable 必须在该命令之前设置
    79.如果VK_NV_clip_space_w_scaling拓展开启，且shader object绑定到任何graphics stage，且最近的vkCmdSetViewportWScalingEnableNV设置viewportWScalingEnable为VK_TRUE，则（1）vkCmdSetViewportWScalingNV必须在该命令前设置
                                                                                                                                                                       （2）最近vkCmdSetViewportWScalingNV设置的viewportCount必须大于等于vkCmdSetViewportWithCount设置的viewportCount
    80.如果exclusiveScissor 特性开启，且shader object绑定到任何graphics stage，，则（1）vkCmdSetExclusiveScissorEnableNV必须在该命令前设置
                                                                                   （2）最近的vkCmdSetExclusiveScissorEnableNV调用设置的pExclusiveScissorEnables中的任何元素为VK_TRUE,则vkCmdSetExclusiveScissorNV必须在该命令前设置
    81.如果一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最靠近当前命令的vkCmdSetLogicOpEnableEXT设置logicOpEnable任何元素为VK_TRUE，则vkCmdSetLogicOpEXT 必须在该命令之前设置且参数logicOp必须是一个有效的VkLogicOp值
    82.如果primitiveFragmentShadingRateWithMultipleViewports限制不支持，则（1）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT动态state开启创建，且任何该pipeline的shader stage会写入PrimitiveShadingRateKHR built-in修饰的变量，则vkCmdSetViewportWithCount 必须在该命令之前设置且参数viewportCount必须是1
                                                                          （2）任何绑定的graphics pipeline的shader stage会写入PrimitiveShadingRateKHR built-in修饰的变量，则vkCmdSetViewportWithCount 必须在该命令之前设置且参数viewportCount必须是1
    83.如果graphics pipeline中未开启rasterization，则对subpass中的每个color attachment，如果其对应的image view 的format features不包含VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT，则pColorBlendState中其对应pAttachments中元素的blendEnable必须为VK_FALSE
    84.如果一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则对于render pass中的每个color attachment，如果其对应的image view 的format features不包含VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT， 则最近的vkCmdSetColorBlendEnableEXT设置的pColorBlendEnables中该附件的对应元素必须为VK_FALSE
    85.如果graphics pipeline中未开启rasterization，有VK_AMD_mixed_attachment_samples拓展未开启，VK_NV_framebuffer_mixed_samples拓展未开启，multisampledRenderToSingleSampled特性未开启，则当前绑定的pipeline的rasterizationSamples必须和当前subpass的color 以及/或者 depth/stencil attachments的相同
    86.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且有VK_AMD_mixed_attachment_samples拓展未开启，VK_NV_framebuffer_mixed_samples拓展未开启，multisampledRenderToSingleSampled特性未开启，则最近vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples必须和当前subpass的color 以及/或者 depth/stencil attachments的相同
    87.如果一个shader object绑定到任何graphics stage，则当前的render pass instance必须以vkCmdBeginRendering开始
    88.如果当前的render pass instance以vkCmdBeginRendering开始，（1）如果pDepthAttachment的imageView不为VK_NULL_HANDLE，且pDepthAttachment的layout不为VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL，则该命令不能写入任何值到depth attachment
                                                                （2）如果pStencilAttachment的imageView不为VK_NULL_HANDLE，且pStencilAttachment的layout不为VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL，则该命令不能写入任何值到stencil attachment
                                                                （3）如果pDepthAttachment的imageView不为VK_NULL_HANDLE，且pDepthAttachment的layout为VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL，则该命令不能写入任何值到depth attachment
                                                                （4）如果pStencilAttachment的imageView不为VK_NULL_HANDLE，且pStencilAttachment的layout为VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL，则该命令不能写入任何值到stencil attachment
                                                                （5）如果pDepthAttachment的imageView不为VK_NULL_HANDLE，且pDepthAttachment的layout为VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL，则该命令不能写入任何值到depth attachment
                                                                （6）如果pStencilAttachment的imageView不为VK_NULL_HANDLE，且pStencilAttachment的layout为VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL，则该命令不能写入任何值到stencil attachment
                                                                （7）则当前绑定的graphics pipeline必须以含VkPipelineRenderingCreateInfo::viewMask等于VkRenderingInfo::viewMask创建
                                                                （8）如果带有VkRenderingInfo::colorAttachmentCount为1，则没有shader object绑定到任何graphics stage，且一个color attachment的 resolve mode为VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID，则VkRenderingInfo::pColorAttachments中每个resolveImageView不为VK_NULL_HANDLE的元素其对应image必须以和创建当前绑定的pipeline 相同的VkExternalFormatANDROID::externalFormat创建
                                                                （9）如果没有shader object绑定到任何graphics stage，如果绑定的graphics pipeline以一个非零值VkExternalFormatANDROID::externalFormat创建且启用VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态设置，则vkCmdSetColorBlendEnableEXT必须在该命令前设置blend enable为VK_FALSE
                                                                （10）如果没有shader object绑定到任何graphics stage，如果绑定的graphics pipeline以一个非零值VkExternalFormatANDROID::externalFormat创建且启用VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态设置，则vkCmdSetRasterizationSamplesEXT必须在该命令前设置rasterizationSamples为VK_SAMPLE_COUNT_1_BIT
                                                                （11）如果没有shader object绑定到任何graphics stage，如果绑定的graphics pipeline以一个非零值VkExternalFormatANDROID::externalFormat创建且启用VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR动态设置，则vkCmdSetFragmentShadingRateKHR必须在该命令前设置pFragmentSize->width为1，pFragmentSize->height为1
    89.如果dynamicRenderingUnusedAttachments特性未开启，且当前的render pass instance以vkCmdBeginRendering开始，则
                                                            （1）当前绑定的graphics pipeline必须以含VkPipelineRenderingCreateInfo::colorAttachmentCount等于VkRenderingInfo::colorAttachmentCount创建
                                                            （2）如果VkRenderingInfo::colorAttachmentCount大于0，则VkRenderingInfo::pColorAttachments 中每一个其imageView不为VK_NULL_HANDLE的元素的VkImageView必须以VkFormat对应绑定的graphics pipeline的VkPipelineRenderingCreateInfo::pColorAttachmentFormats指明的format创建
                                                            （3）如果VkRenderingInfo::colorAttachmentCount大于0，则VkRenderingInfo::pColorAttachments 中每一个其imageView为VK_NULL_HANDLE的元素对应绑定的graphics pipeline的VkPipelineRenderingCreateInfo::pColorAttachmentFormats指明的format必须为VK_FORMAT_UNDEFINED
                                                            （4）如果VkRenderingInfo::pDepthAttachment->imageView为VK_NULL_HANDLE，则创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::depthAttachmentFormat必须为VK_FORMAT_UNDEFINED
                                                            （5）如果VkRenderingInfo::pDepthAttachment->imageView不为VK_NULL_HANDLE，则创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::depthAttachmentFormat必须和创建VkRenderingInfo::pDepthAttachment->imageView的VkFormat相同
                                                            （6）如果VkRenderingInfo::pStencilAttachment->imageView为VK_NULL_HANDLE，则创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::stencilAttachmentFormat必须为VK_FORMAT_UNDEFINED
                                                            （7）如果VkRenderingInfo::pStencilAttachment->imageView不为VK_NULL_HANDLE，则创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::stencilAttachmentFormat必须和创建VkRenderingInfo::pStencilAttachment->imageView的VkFormat相同
    90.如果dynamicRenderingUnusedAttachments特性开启，且当前的render pass instance以vkCmdBeginRendering开始，则
                                                            （1）如果VkRenderingInfo::colorAttachmentCount大于0，则VkRenderingInfo::pColorAttachments 中每一个其imageView不为VK_NULL_HANDLE的元素的VkImageView必须以VkFormat对应绑定的graphics pipeline的VkPipelineRenderingCreateInfo::pColorAttachmentFormats指明的format创建，或者是对应元素为VK_FORMAT_UNDEFINED创建
                                                            （2）如果VkRenderingInfo::pDepthAttachment->imageView不为VK_NULL_HANDLE，且创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::depthAttachmentFormat和创建VkRenderingInfo::pDepthAttachment->imageView的VkFormat不同，则该format必须为VK_FORMAT_UNDEFINED
                                                            （3）如果VkRenderingInfo::pStencilAttachment->imageView不为VK_NULL_HANDLE，且创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::stencilAttachmentFormat和创建VkRenderingInfo::pStencilAttachment->imageView的VkFormat不同，则该format必须为VK_FORMAT_UNDEFINED
    91.如果没有shader object绑定到任何graphics stage，且当前的render pass instance以vkCmdBeginRendering开始且VkRenderingInfo::colorAttachmentCount为1，且一个color attachment的 resolve mode为VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID，则VkRenderingInfo::pColorAttachments中每个resolveImageView不为VK_NULL_HANDLE的元素其对应image必须以和创建当前绑定的pipeline 相同的VkExternalFormatANDROID::externalFormat创建
    92.如果有一个shader object绑定到任何graphics stage，且当前的render pass 包含一个使用VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID resolve mode的color attachment，则（1）vkCmdSetColorBlendEnableEXT必须在该命令前设置blend enable为VK_FALSE
                                                                                                                                                                             （2）则vkCmdSetRasterizationSamplesEXT必须在该命令前设置rasterizationSamples为VK_SAMPLE_COUNT_1_BIT
                                                                                                                                                                             （3）则vkCmdSetFragmentShadingRateKHR必须在该命令前设置pFragmentSize->width为1，pFragmentSize->height为1
    93.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT动态state开启创建， 则vkCmdSetColorWriteEnableEXT 必须在该命令之前设置，且设置的attachmentCount必须大于等于创建当前绑定的pipeline的VkPipelineColorBlendStateCreateInfo::attachmentCount
                                    （2）以VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT动态state开启创建， 则vkCmdSetDiscardRectangleEXT 必须在该命令之前为每个VkPipelineDiscardRectangleStateCreateInfoEXT::discardRectangleCount指明的discard rectangle 设置
                                    （3）以VK_DYNAMIC_STATE_DISCARD_RECTANGLE_ENABLE_EXT动态state开启创建， 则vkCmdSetDiscardRectangleEnableEXT 必须在该命令之前设置
                                    （4）以VK_DYNAMIC_STATE_DISCARD_RECTANGLE_MODE_EXT动态state开启创建， 则vkCmdSetDiscardRectangleModeEXT 必须在该命令之前设置
    94.如果有一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                    （1）如果colorWriteEnable特性在device上开启，则vkCmdSetColorWriteEnableEXT 必须在该命令之前设置，且设置的attachmentCount必须大于等于当前render pass instance的color attachment的数量
                                    （2）如果VK_EXT_discard_rectangles拓展开启，且最近的vkCmdSetDiscardRectangleEnableEXT设置discardRectangleEnable为VK_TRUE， 则vkCmdSetDiscardRectangleEXT 必须在该命令之前设置
                                    （3）如果VK_EXT_discard_rectangles拓展开启， 则vkCmdSetDiscardRectangleEnableEXT 必须在该命令之前设置
                                    （4）如果VK_EXT_discard_rectangles拓展开启， 则最近的vkCmdSetDiscardRectangleEnableEXT设置discardRectangleEnable为VK_TRUE，则vkCmdSetDiscardRectangleModeEXT 必须在该命令之前设置
    95.如果当前的render pass instance以vkCmdBeginRendering开始，则（1）如果VkRenderingFragmentShadingRateAttachmentInfoKHR::imageView不为VK_NULL_HANDLE，则当前绑定的graphics pipeline必须以VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR创建
                                                                  （2）如果VkRenderingFragmentDensityMapAttachmentInfoEXT::imageView不为VK_NULL_HANDLE，则当前绑定的graphics pipeline必须以VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT创建
                                                                  （3）且含VkRenderingInfo::colorAttachmentCount大于0，如果当前的绑定的pipeline以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，则VkRenderingInfo::pColorAttachments中每个imageView不为VK_NULL_HANDLE的元素的imageView，必须以当前pipeline的VkAttachmentSampleCountInfoAMD 或者 VkAttachmentSampleCountInfoNV中的pColorAttachmentSamples中对应元素的sample count进行创建
                                                                  （4）如果当前的绑定的pipeline以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且VkRenderingInfo::pDepthAttachment中的imageView不为VK_NULL_HANDLE，则当前pipeline的VkAttachmentSampleCountInfoAMD 或者 VkAttachmentSampleCountInfoNV中的depthStencilAttachmentSamples必须等于创建VkRenderingInfo::pDepthAttachment->imageView的sample count
                                                                  （5）如果当前的绑定的pipeline以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且VkRenderingInfo::pStencilAttachment中的imageView不为VK_NULL_HANDLE，则当前pipeline的VkAttachmentSampleCountInfoAMD 或者 VkAttachmentSampleCountInfoNV中的depthStencilAttachmentSamples必须等于创建VkRenderingInfo::pStencilAttachment->imageView的sample count
                                                                  （6）且含VkRenderingInfo::colorAttachmentCount大于0，如果当前的绑定的pipeline不以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且multisampledRenderToSingleSampled特性没有开启，则VkRenderingInfo::pColorAttachments中每个imageView不为VK_NULL_HANDLE的元素的imageView，其创建的sample count必须等于当前绑定的graphics pipeline的rasterizationSamples
                                                                  （7）如果当前的绑定的pipeline不以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且VkRenderingInfo::pDepthAttachment中的imageView不为VK_NULL_HANDLE，且multisampledRenderToSingleSampled特性没有开启，则当前pipeline的rasterizationSamples 必须等于创建VkRenderingInfo::pDepthAttachment->imageView的sample count
                                                                  （8）如果当前的绑定的pipeline不以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且VkRenderingInfo::pStencilAttachment中的imageView不为VK_NULL_HANDLE，且multisampledRenderToSingleSampled特性没有开启，则当前pipeline的rasterizationSamples 必须等于创建VkRenderingInfo::pStencilAttachment->imageView的sample count
                                                                  （9）当前绑定的pipeline必须VkGraphicsPipelineCreateInfo::renderPass为VK_NULL_HANDLE创建
                                                                  （10）如果绑定的pipeline的fragment shader静态写入一个color attachment，且color write mask不为0，启用了color writes，且该附件对应的VkRenderingInfo::pColorAttachments->imageView 不为VK_NULL_HANDLE，则对应的创建pipeline的VkPipelineRenderingCreateInfo::pColorAttachmentFormats中的元素不能为VK_FORMAT_UNDEFINED
                                                                  （11）如果绑定的pipeline启用了depth test，启用了depth writes，且VkRenderingInfo::pDepthAttachment->imageView 不为VK_NULL_HANDLE，则创建pipeline的VkPipelineRenderingCreateInfo::depthAttachmentFormat不能为VK_FORMAT_UNDEFINED
                                                                  （12）如果绑定的pipeline启用了stencil test，且VkRenderingInfo::pStencilAttachment->imageView 不为VK_NULL_HANDLE，则创建pipeline的VkPipelineRenderingCreateInfo::stencilAttachmentFormat不能为VK_FORMAT_UNDEFINED
    96.如果该命令在以vkCmdBeginRendering开始的render pass instance中调用，且VkRenderingInfo的pNext中包含一个multisampledRenderToSingleSampledEnable设为VK_TRUE的VkMultisampledRenderToSingleSampledInfoEXT，则当前绑定的graphics pipeline的rasterizationSamples必须等于VkMultisampledRenderToSingleSampledInfoEXT::rasterizationSamples
    97.如果primitivesGeneratedQueryWithRasterizerDiscard特性未开启，且VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query激活，则不能启用rasterization discard
    98.如果primitivesGeneratedQueryWithNonZeroStreams特性未开启，且VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query激活，则 绑定的graphics pipeline不能以VkPipelineRasterizationStateStreamCreateInfoEXT::rasterizationStream为非零值创建
    98.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_TESSELLATION_DOMAIN_ORIGIN_EXT动态state开启创建，则vkCmdSetTessellationDomainOriginEXT必须在该命令之前设置
                                    （2）以VK_DYNAMIC_STATE_DEPTH_CLAMP_ENABLE_EXT动态state开启创建，则vkCmdSetDepthClampEnableEXT必须在该命令之前设置
                                    （3）以VK_DYNAMIC_STATE_POLYGON_MODE_EXT动态state开启创建，则vkCmdSetPolygonModeEXT必须在该命令之前设置
                                    （4）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，则vkCmdSetRasterizationSamplesEXT必须在该命令之前设置
                                    （5）以VK_DYNAMIC_STATE_SAMPLE_MASK_EXT动态state开启创建，则vkCmdSetSampleMaskEXT必须在该命令之前设置
                                    （6）以VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT动态state开启创建，则vkCmdSetAlphaToCoverageEnableEXT必须在该命令之前设置
                                    （7）以VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT动态state开启创建，则最近的vkCmdSetAlphaToCoverageEnableEXT设置alphaToCoverageEnable为VK_TRUE，则Fragment Output Interface中 Index 0的Location 0必须有一个含alpha Component的变量
                                    （8）以VK_DYNAMIC_STATE_ALPHA_TO_ONE_ENABLE_EXT动态state开启创建，则vkCmdSetAlphaToOneEnableEXT必须在该命令之前设置
                                    （9）以VK_DYNAMIC_STATE_LOGIC_OP_ENABLE_EXT动态state开启创建，则vkCmdSetLogicOpEnableEXT必须在该命令之前设置
                                    （10）以VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态state开启创建，则vkCmdSetColorBlendEnableEXT必须在该命令之前设置
                                    （11）以VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT动态state开启创建，则vkCmdSetColorBlendEquationEXT必须在该命令之前设置
                                    （12）以VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT动态state开启创建，则vkCmdSetColorWriteMaskEXT必须在该命令之前设置

    99.如果一个shader object绑定到VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT stage，则vkCmdSetTessellationDomainOriginEXT必须在该命令之前设置
    100.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                                    （1）如果depthClamp特性启用，则vkCmdSetDepthClampEnableEXT必须在该命令之前设置
                                                    （2）则vkCmdSetPolygonModeEXT必须在该命令之前设置
                                                    （3）则vkCmdSetRasterizationSamplesEXT必须在该命令之前设置
                                                    （4）则vkCmdSetSampleMaskEXT必须在该命令之前设置
                                                    （5）则vkCmdSetAlphaToCoverageEnableEXT必须在该命令之前设置
                                                    （6）如果alphaToOne特性启用，则vkCmdSetAlphaToOneEnableEXT必须在该命令之前设置

    101.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetAlphaToCoverageEnableEXT设置alphaToCoverageEnable为VK_TRUE，则Fragment Output Interface中 Index 0的Location 0必须有一个含alpha Component的变量
    102.如果一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                        （1）如果logicOp特性开启 ,vkCmdSetLogicOpEnableEXT必须在该命令之前设置
                                        （2）如果绑定了color attachments，则vkCmdSetColorBlendEnableEXT必须在该命令之前设置
                                        （3）如果最近的vkCmdSetColorBlendEnableEXT设置任何附件在pColorBlendEnables中的值为VK_TRUE ，则vkCmdSetColorBlendEquationEXT必须在该命令之前设置
                                        （4）如果绑定了color attachments，则vkCmdSetColorWriteMaskEXT必须在该命令之前设置

    103.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT动态state开启创建，则vkCmdSetRasterizationStreamEXT必须在该命令之前设置
                                     （2）以VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT动态state开启创建，则vkCmdSetConservativeRasterizationModeEXT必须在该命令之前设置
                                     （3）以VK_DYNAMIC_STATE_EXTRA_PRIMITIVE_OVERESTIMATION_SIZE_EXT动态state开启创建，则vkCmdSetExtraPrimitiveOverestimationSizeEXT必须在该命令之前设置
                                     （4）以VK_DYNAMIC_STATE_DEPTH_CLIP_ENABLE_EXT动态state开启创建，则vkCmdSetDepthClipEnableEXT必须在该命令之前设置
                                     （5）以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT动态state开启创建，则vkCmdSetSampleLocationsEnableEXT必须在该命令之前设置
                                     （6）以VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT动态state开启创建，则vkCmdSetColorBlendAdvancedEXT必须在该命令之前设置
                                     （7）以VK_DYNAMIC_STATE_PROVOKING_VERTEX_MODE_EXT动态state开启创建，则vkCmdSetProvokingVertexModeEXT必须在该命令之前设置
                                     （8）以VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT动态state开启创建，则vkCmdSetLineRasterizationModeEXT必须在该命令之前设置
                                     （9）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT动态state开启创建，则vkCmdSetLineStippleEnableEXT必须在该命令之前设置
                                     （10）以VK_DYNAMIC_STATE_LINE_STIPPLE_KHR动态state开启创建，则vkCmdSetLineStippleKHR必须在该命令之前设置
                                     （11）以VK_DYNAMIC_STATE_DEPTH_CLIP_NEGATIVE_ONE_TO_ONE_EXT动态state开启创建，则vkCmdSetDepthClipNegativeOneToOneEXT必须在该命令之前设置
                                     （12）以VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_ENABLE_NV动态state开启创建，则vkCmdSetViewportWScalingEnableNV必须在该命令之前设置
                                     （13）以VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV动态state开启创建，则vkCmdSetViewportSwizzleNV必须在该命令之前设置
                                     （14）以VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV动态state开启创建，则vkCmdSetCoverageToColorEnableNV必须在该命令之前设置
                                     （15）以VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_LOCATION_NV动态state开启创建，则vkCmdSetCoverageToColorLocationNV必须在该命令之前设置
                                     （16）以VK_DYNAMIC_STATE_COVERAGE_MODULATION_MODE_NV动态state开启创建，则vkCmdSetCoverageModulationModeNV必须在该命令之前设置
                                     （17）以VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV动态state开启创建，则vkCmdSetCoverageModulationTableEnableNV必须在该命令之前设置
                                     （18）以VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_NV动态state开启创建，则vkCmdSetCoverageModulationTableNV必须在该命令之前设置
                                     （19）以VK_DYNAMIC_STATE_SHADING_RATE_IMAGE_ENABLE_NV动态state开启创建，则vkCmdSetShadingRateImageEnableNV必须在该命令之前设置
                                     （20）以VK_DYNAMIC_STATE_REPRESENTATIVE_FRAGMENT_TEST_ENABLE_NV动态state开启创建，则vkCmdSetRepresentativeFragmentTestEnableNV必须在该命令之前设置
                                     （21）以VK_DYNAMIC_STATE_COVERAGE_REDUCTION_MODE_NV动态state开启创建，则vkCmdSetCoverageReductionModeNV必须在该命令之前设置

    104.如果一个shader object绑定到VK_SHADER_STAGE_GEOMETRY_BIT stage，且如果geometryStreams 特性开启，则vkCmdSetRasterizationStreamEXT必须在该命令之前设置
    105.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                            （1）如果VK_EXT_conservative_rasterization 拓展开启，vkCmdSetConservativeRasterizationModeEXT必须在该命令之前设置
                            （2）如果VK_EXT_conservative_rasterization 拓展开启，且最近的vkCmdSetConservativeRasterizationModeEXT设置conservativeRasterizationMode为VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT，则vkCmdSetExtraPrimitiveOverestimationSizeEXT必须在该命令之前设置
                            （3）如果VK_EXT_sample_locations 拓展开启，则vkCmdSetSampleLocationsEnableEXT必须在该命令之前设置
    106.如果一个shader object绑定到任何graphics stage，且depthClipEnable 特性开启，则vkCmdSetDepthClipEnableEXT必须在该命令之前设置
    107.如果如果一个shader object绑定到任何VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且如果VK_EXT_blend_operation_advanced 拓展开启，则vkCmdSetColorBlendEquationEXT 和 vkCmdSetColorBlendAdvancedEXT中至少一个必须在该命令之前设置
    108.如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，如果VK_EXT_provoking_vertex拓展开启， 则vkCmdSetProvokingVertexModeEXT必须在该命令之前设置
    109.如果VK_KHR_line_rasterization 或者 VK_EXT_line_rasterization拓展开启，则（1）如果一个shader object绑定到任意一个graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetPolygonModeEXT设置polygonMode 为VK_POLYGON_MODE_LINE ，则vkCmdSetLineRasterizationModeEXT必须在该命令之前设置
                                                                                （2）如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetPrimitiveTopology设置primitiveTopology 为任何line topology ，则vkCmdSetLineRasterizationModeEXT必须在该命令之前设置
                                                                                （3）如果一个输出为line primitive的shader object绑定到VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或 VK_SHADER_STAGE_GEOMETRY_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则vkCmdSetLineRasterizationModeEXT必须在该命令之前设置
                                                                                （4）如果一个shader object绑定到任意一个graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetPolygonModeEXT设置polygonMode 为VK_POLYGON_MODE_LINE ，则vkCmdSetLineStippleEnableEXT必须在该命令之前设置
                                                                                （5）如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetPrimitiveTopology设置primitiveTopology 为任何line topology ，则vkCmdSetLineStippleEnableEXT必须在该命令之前设置
                                                                                （6）如果一个输出为line primitive的shader object绑定到VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或 VK_SHADER_STAGE_GEOMETRY_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则vkCmdSetLineStippleEnableEXT必须在该命令之前设置
                                                                                （7）如果一个shader object绑定到任意一个graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetLineStippleEnableEXT设置stippledLineEnable 为VK_TRUE ，则vkCmdSetLineStippleEXT必须在该命令之前设置
    110.如果一个shader object绑定到任何graphics stage，（1）如果depthClipControl 特性开启，则vkCmdSetDepthClipNegativeOneToOneEXT必须在该命令之前设置
                                                       （2）VK_NV_clip_space_w_scaling 拓展开启，则vkCmdSetViewportWScalingEnableNV必须在该命令之前设置
                                                       （3）VK_NV_viewport_swizzle 拓展开启，则vkCmdSetViewportSwizzleNV必须在该命令之前设置
    111.如果如果一个shader object绑定到任何VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                        （1）如果VK_NV_fragment_coverage_to_color 拓展开启，则vkCmdSetCoverageToColorEnableNV 必须在该命令之前设置
                        （2）如果VK_NV_fragment_coverage_to_color 拓展开启，且最近的vkCmdSetCoverageToColorEnableNV 设置coverageToColorEnable 为VK_TRUE，则vkCmdSetCoverageToColorLocationNV 必须在该命令之前设置
                        （3）如果pipelineFragmentShadingRate 特性开启，则vkCmdSetFragmentShadingRateKHR 必须在该命令之前设置
    112.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                （1）如果VK_NV_framebuffer_mixed_samples 拓展开启，则vkCmdSetCoverageModulationModeNV 必须在该命令之前设置
                                （2）如果VK_NV_framebuffer_mixed_samples 拓展开启，且最近的vkCmdSetCoverageModulationModeNV设置coverageModulationMode为任何除VK_COVERAGE_MODULATION_MODE_NONE_NV之外的值，则vkCmdSetCoverageModulationTableEnableNV 必须在该命令之前设置
                                （3）如果VK_NV_framebuffer_mixed_samples 拓展开启，最近的vkCmdSetCoverageModulationTableEnableNV设置coverageModulationTableEnable为VK_TRUE，则vkCmdSetCoverageModulationTableNV 必须在该命令之前设置
                                （4）如果shadingRateImage 特性开启，则vkCmdSetShadingRateImageEnableNV 必须在该命令之前设置
                                （5）如果representativeFragmentTest 特性开启，则vkCmdSetRepresentativeFragmentTestEnableNV 必须在该命令之前设置
                                （6）如果coverageReductionMode 特性开启，则vkCmdSetCoverageReductionModeNV 必须在该命令之前设置
    113.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态state开启创建，且最近的vkCmdSetColorBlendEnableEXT设置任何附件在pColorBlendEnables中的值为VK_TRUE 则subpas中这些附件对应的image view的format features中必须包含VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT
                                     （2）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，且当前subpass不使用任何color和/或者 depth/stencil attachments，则最后的vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples必须符合zero￾attachment subpass的规则
                                     （3）以VK_DYNAMIC_STATE_SAMPLE_MASK_EXT不以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT 动态state开启创建，则最后调用的vkCmdSetSampleMaskEXT中设置的samples参数必须大于等于创建该pipeline的VkPipelineMultisampleStateCreateInfo::rasterizationSamples
                                     （4）以VK_DYNAMIC_STATE_SAMPLE_MASK_EXT和 VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT 动态state开启创建，则最后调用的vkCmdSetSampleMaskEXT中设置的samples参数必须大于等于最后的vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples
                                     （5）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，且VK_AMD_mixed_attachment_samples和VK_NV_framebuffer_mixed_samples拓展都没有开启，则最后的vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples必须等于subpass中color和/或者 depth/stencil attachments使用的相同
                                     （6）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，或者一个shader object绑定到任意graphics stage，且当前的subpass包含一个multisampledRenderToSingleSampledEnable 为VK_TRUE的VkMultisampledRenderToSingleSampledInfoEXT，则最后的vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples必须等于该VkMultisampledRenderToSingleSampledInfoEXT中的对应成员
                                     （7）以VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态state开启创建，则vkCmdSetColorBlendEnableEXT 必须在该命令之前设置，且vkCmdSetColorBlendEnableEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定值
                                     （8）以VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT动态state开启创建，则vkCmdSetColorBlendEquationEXT 必须在该命令之前设置，且vkCmdSetColorBlendEquationEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定blend equations
                                     （9）以VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT动态state开启创建，则vkCmdSetColorWriteMaskEXT 必须在该命令之前设置，且vkCmdSetColorWriteMaskEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定color write mask
                                     （10）以VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT动态state开启创建，则vkCmdSetColorBlendAdvancedEXT 必须在该命令之前设置，且vkCmdSetColorBlendAdvancedEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活blend的color attachments指定advanced blend equations
                                     （11）以VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT和VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态state开启创建，且最后的vkCmdSetColorBlendEnableEXT和vkCmdSetColorBlendAdvancedEXT设置启用了advanced blending，则当前subpass中激活的color attachments的数量不能超过advancedBlendMaxColorAttachments
                                     （12）以VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT动态state开启创建，且如果primitivesGeneratedQueryWithNonZeroStreams特性未开启且VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query已经激活，则最后的vkCmdSetRasterizationStreamEXT必须设置rasterizationStream为0
                                     （13）以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT但不以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，则最后的vkCmdSetSampleLocationsEXT设置的pSampleLocationsInfo->sampleLocationsPerPixel必须等于创建pipeline的VkPipelineMultisampleStateCreateInfo::rasterizationSamples
                                     （14）以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT和VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，则最后的vkCmdSetSampleLocationsEXT设置的pSampleLocationsInfo->sampleLocationsPerPixel必须等于最后vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples
                                     （15）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT但不以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT动态state开启创建，且绑定的pipeline的VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable为VK_TRUE 或者以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT动态state开启，则sampleLocationsInfo.sampleLocationsPerPixel 必须等于最后vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples
                                     （16）以VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV动态state开启创建，且最后的vkCmdSetCoverageToColorEnableNV设置coverageToColorEnable为VK_TRUE，则当前subpass必须有color attachment，且该attachment的format必须为VK_FORMAT_R8_UINT, VK_FORMAT_R8_SINT, VK_FORMAT_R16_UINT, VK_FORMAT_R16_SINT, VK_FORMAT_R32_UINT, 或者 VK_FORMAT_R32_SINT，且该attachment的location 有最后的vkCmdSetCoverageToColorLocationNV设置的coverageToColorLocation决定
                                     （17）以VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV和VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT 动态state开启创建，且如果VK_NV_coverage_reduction_mode 拓展开启，则当前的 coverageReductionMode，rasterizationSamples 以及color 以及 depth/stencil attachments（如果subpass有）的sample count必须是有效的返回值vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV的值的组合
                                     （18）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT但不以VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV 动态state开启创建，则绑定的graphics pipeline的VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount 必须大于等于最后vkCmdSetViewportWithCount设置的viewportCount
                                     （19）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT和VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV 动态state开启创建，则最后vkCmdSetViewportSwizzleNV设置的viewportCount 必须大于等于最后vkCmdSetViewportWithCount设置的viewportCount
                                     （20）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT或者 VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT 动态state开启创建，如果当前的stippledLineEnable为VK_TRUE，且当前的lineRasterizationMode为VK_LINE_RASTERIZATION_MODE_RECTANGULAR_KHR，则stippledRectangularLines 特性必须开启
                                     （21）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT或者 VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT 动态state开启创建，如果当前的stippledLineEnable为VK_TRUE，且当前的lineRasterizationMode为VK_LINE_RASTERIZATION_MODE_BRESENHAM_KHR，则stippledBresenhamLines 特性必须开启
                                     （22）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT或者 VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT 动态state开启创建，如果当前的stippledLineEnable为VK_TRUE，且当前的lineRasterizationMode为VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_KHR，则stippledSmoothLines 特性必须开启
                                     （23）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT或者 VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT 动态state开启创建，如果当前的stippledLineEnable为VK_TRUE，且当前的lineRasterizationMode为VK_LINE_RASTERIZATION_MODE_DEFAULT_KHR，则stippledRectangularLines 特性必须开启且VkPhysicalDeviceLimits::strictLines 必须为VK_TRUE
                                     （24）以VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT 动态state开启创建，且conservativePointAndLineRasterization不支持，最后的 pre-rasterization shader stage输出的有效图元拓扑为点或者线，则最后vkCmdSetConservativeRasterizationModeEXT设置的conservativeRasterizationMode 必须为VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT
                                     （25）以VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT 动态state开启创建，则vkCmdSetAttachmentFeedbackLoopEnableEXT 必须在该命令之前调用
    114.如果一个shader object绑定到 VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                                                                        （1）则vkCmdSetColorBlendEnableEXT 必须在该命令之前设置，且vkCmdSetColorBlendEnableEXT指定的firstAttachment开始的attachmentCount的值必须为当前subpass所有激活的color attachments指定
                                                                                        （2）则vkCmdSetColorBlendEquationEXT 必须在该命令之前设置，且vkCmdSetColorBlendEquationEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定blend equations
                                                                                        （3）则vkCmdSetColorWriteMaskEXT 必须在该命令之前设置，且vkCmdSetColorWriteMaskEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定color write mask
                                                                                        （4）如果VK_NV_fragment_coverage_to_color拓展开启， 最后的vkCmdSetCoverageToColorEnableNV设置coverageToColorEnable为VK_TRUE，则当前subpass必须有color attachment，且该attachment的format必须为VK_FORMAT_R8_UINT, VK_FORMAT_R8_SINT, VK_FORMAT_R16_UINT, VK_FORMAT_R16_SINT, VK_FORMAT_R32_UINT, 或者 VK_FORMAT_R32_SINT，且该attachment的location 有最后的vkCmdSetCoverageToColorLocationNV设置的coverageToColorLocation决定
    115.如果一个shader object绑定到 VK_SHADER_STAGE_FRAGMENT_BIT stage，（1）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT动态state开启创建，且最近的vkCmdSetSampleLocationsEnableEXT设置sampleLocationsEnable为VK_TRUE，且该subpass含有depth/stencil attachment，则该附件必须以VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT创建
                                                                        （2）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT和VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT 动态state开启创建，且最近的vkCmdSetSampleLocationsEnableEXT设置sampleLocationsEnable为VK_TRUE，则 最后vkCmdSetSampleLocationsEXT设置的sampleLocationsInfo.sampleLocationGridSize.width以及height 必须等于被调用vkGetPhysicalDeviceMultisamplePropertiesEXT传入rasterizationSamples返回的VkMultisamplePropertiesEXT::sampleLocationGridSize.width以及height一一对应均匀整除
                                                                        （3）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT 动态state开启创建，且最近的vkCmdSetSampleLocationsEnableEXT设置sampleLocationsEnable为VK_TRUE，则fragment shader代码中不能静态使用扩展指令InterpolateAtSample
                                                                        （4）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT但不以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT 动态state开启创建，且绑定的pipeline的VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable为VK_TRUE 或者以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT动态state开启，则 最后vkCmdSetRasterizationSamplesEXT设置的sampleLocationsInfo.sampleLocationGridSize.width以及height 必须等于被调用vkGetPhysicalDeviceMultisamplePropertiesEXT传入和vkCmdSetRasterizationSamplesEXT设置的相同rasterizationSamples的samples返回的VkMultisamplePropertiesEXT::sampleLocationGridSize.width以及height一一对应均匀整除
    116.如果一个shader object绑定到任何graphics stage，（1）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV 动态state开启创建，且最近的vkCmdSetCoverageModulationTableEnableNV设置coverageModulationTableEnable为VK_TRUE，则最近的vkCmdSetCoverageModulationTableNV 设置的coverageModulationTableCount 必须等于当前rasterizationSamples除以当前subppas的color samples
                                                       （2）如果VK_NV_viewport_swizzle 拓展开启，则最后vkCmdSetViewportSwizzleNV设置的viewportCount 必须大于等于最后vkCmdSetViewportWithCount设置的viewportCount
    117.如果VK_NV_framebuffer_mixed_samples 拓展开启，且如果在绑定的graphics pipeline中当前subpass有一个depth/stencil attachment以及dep test, stencil test, 或depth bounds test 启用，则当前rasterizationSamples 必须等于depth/stencil attachment的sample count
    118.如果VK_NV_framebuffer_mixed_samples 拓展开启，且如果最后的vkCmdSetRasterizationSamplesEXT设置的当前subpass的任何color attachments的rasterizationSamples 都大于 color samples，则sampleShadingEnable 必须为VK_FALSE
    119.如果当前绑定的graphics pipeline以VkGraphicsPipelineCreateInfo::pStages中的元素的VkPipelineShaderStageCreateInfo::stage设置为VK_SHADER_STAGE_VERTEX_BIT, VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT, VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或者 VK_SHADER_STAGE_GEOMETRY_BIT创建，则Mesh Shader Queries 不能激活
    120.如果dynamic state继承自VkCommandBufferInheritanceViewportScissorInfoNV，则这些动态state的设置必须在该命令之前设置
    121.如果没有绑定graphics pipeline，则（1）vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_VERTEX_BIT
                                         （2）如果tessellationShader 特性开启，vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT，VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT
                                         （3）如果geometryShader 特性开启，vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_GEOMETRY_BIT
                                         （4）vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_FRAGMENT_BIT
                                         （5）如果taskShader 特性开启，vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_TASK_BIT_EXT
                                         （6）如果meshShader 特性开启，vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_MESH_BIT_EXT
                                         （8）如果至少taskShader 和 meshShader一个特性开启，VK_SHADER_STAGE_VERTEX_BIT 或者VK_SHADER_STAGE_MESH_BIT_EXT stages中的一个必须含有有效的VkShaderEXT绑定，另外一个则不含有VkShaderEXT绑定
                                         （9）如果taskShader 和 meshShader特性同时开启，且一个有效的VkShaderEXT 绑定到VK_SHADER_STAGE_MESH_BIT_EXT stage，且该VkShaderEXT不以VK_SHADER_CREATE_NO_TASK_SHADER_BIT_EXT 创建，则一个有效的VkShaderEXT必须绑定到VK_SHADER_STAGE_TASK_BIT_EXT stage
                                         （10）如果taskShader 和 meshShader特性同时开启，且一个有效的VkShaderEXT 绑定到VK_SHADER_STAGE_MESH_BIT_EXT stage，且该VkShaderEXT以VK_SHADER_CREATE_NO_TASK_SHADER_BIT_EXT 创建，则不能有VkShaderEXT绑定到VK_SHADER_STAGE_TASK_BIT_EXT stage
                                         （11）如果一个有效的VkShaderEXT 绑定到VK_SHADER_STAGE_VERTEX_BIT stage，则不能有VkShaderEXT绑定到VK_SHADER_STAGE_TASK_BIT_EXT stage或者VK_SHADER_STAGE_MESH_BIT_EXT stage中的一个
    122.如果任何绑定的graphics shader以VK_SHADER_CREATE_LINK_STAGE_BIT_EXT 创建，（1）所有在相同vkCreateShadersEXT中以VK_SHADER_CREATE_LINK_STAGE_BIT_EXT创建的shaders必须也要绑定
                                                                                 （2）任何相同vkCreateShadersEXT中不以VK_SHADER_CREATE_LINK_STAGE_BIT_EXT创建的shaders不能有任何VkShaderEXT绑定
    123.所有绑定的graphics shader objects 必须以相同或者相同定义的push constant ranges创建
    124.所有绑定的graphics shader objects 必须以相同或者相同定义的descriptor set layouts的数组创建
    125.如果当前的render pass instance以vkCmdBeginRendering开始，且VkRenderingInfo::colorAttachmentCount为1，且有一个resolve mode为 VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID 的color attachment，且绑定了fragment shader，则DepthReplacing 和 StencilRefReplacingEXT execution modes 不能声明
    126.如果一个shader object绑定到 VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则 （1）如果attachmentFeedbackLoopDynamicState 特性开启，则 vkCmdSetAttachmentFeedbackLoopEnableEXT 必须在该命令之前调用
    127.如果包含一个fragment shader stage的绑定的graphics pipeline，（1）且该pipeline以VkPipelineDynamicStateCreateInfo::pDynamicStates中设置有VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE创建，且该fragment shader声明了EarlyFragmentTests execution mode且使用了OpDepthAttachmentReadEXT，则最后vkCmdSetDepthWriteEnable 设置的 depthWriteEnable 必须为VK_FALSE
                                                                    （2）且该pipeline以VkPipelineDynamicStateCreateInfo::pDynamicStates中设置有VK_DYNAMIC_STATE_STENCIL_WRITE_MASK创建，且该fragment shader声明了EarlyFragmentTests execution mode且使用了OpStencilAttachmentReadEXT，则最后vkCmdSetStencilWriteMask 设置的 writeMask 必须为0
    128.如果一个shader object绑定到任何graphics stage 或者绑定的graphics pipeline 以VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT 动态state开启创建，且任何color attachment的format为VK_FORMAT_E5B9G9R9_UFLOAT_PACK32，则vkCmdSetColorWriteMaskEXT设置的pColorWriteMasks参数的对应元素必须包含VK_COLOR_COMPONENT_R_BIT, VK_COLOR_COMPONENT_G_BIT, 和 VK_COLOR_COMPONENT_B_BIT，或者都不包含
    129.如果任何附件开启了blending，且该附件的source 或者 destination blend factors使用第二个颜色输入，则该命令执行的Fragment Execution Model静态使用的任何输出output attachment的Location的最大值必须小于maxFragmentDualSrcAttachments
    130.如果当前的render pass instance以vkCmdBeginRendering开始，（1）如果没有任何shader object绑定到任何graphics stage，则vkCmdSetRenderingAttachmentLocationsKHR 设置的VkRenderingAttachmentLocationInfoKHR::pColorAttachmentLocations中的每个元素必须匹配设置在当前绑定的graphics pipeline中的对应元素
                                                                 （2）如果没有任何shader object绑定到任何graphics stage，绑定的graphics pipeline中的input attchment 索引中映射的附件必须匹配在当前render pass instance的VkRenderingInputAttachmentIndexInfoKHR中设置的
    131.如果当前的render pass instance以vkCmdBeginRendering开始且以VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT标志开始，则绑定的graphics pipeline必须以VK_PIPELINE_CREATE_2_ENABLE_LEGACY_DITHERING_BIT_EXT创建
    132.如果绑定的graphics pipeline以VK_PIPELINE_CREATE_2_ENABLE_LEGACY_DITHERING_BIT_EXT创建，则当前的render pass 必须以vkCmdBeginRendering开始且以VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT标志开始
    133.绑定的graphics pipeline不能以VkGraphicsPipelineCreateInfo::pStages中元素的VkPipelineShaderStageCreateInfo::stage设置为VK_SHADER_STAGE_VERTEX_BIT, VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT, VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或者 VK_SHADER_STAGE_GEOMETRY_BIT创建
    134.Transform Feedback Queries不能激活
    135.Primitives Generated Queries不能激活
    136.用于创建任何激活的Pipeline Statistics Query的pipelineStatistics 不能包含VK_QUERY_PIPELINE_STATISTIC_TASK_SHADER_INVOCATIONS_BIT_EXT, 或者 VK_QUERY_PIPELINE_STATISTIC_MESH_SHADER_INVOCATIONS_BIT_EXT
    137.groupCountX, groupCountY, groupCountZ必须一一小于等于VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI::maxWorkGroupCount[0], VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI::maxWorkGroupCount[1], VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI::maxWorkGroupCount[2]
    138.绑定到VK_PIPELINE_BIND_POINT_GRAPHICS绑定点的当前pipeline必须包含一个使用ClusterCullingHUAWEI Execution Model的shader stage
    */



    VkDispatchIndirectCommand  dispatchIndirectCommand{};//和vkCmdDrawClusterHUAWEI 对应参数等效
    dispatchIndirectCommand.x = 1;//是X维度dispatch的 local workgroups 数量
    dispatchIndirectCommand.y = 1;//是Y维度dispatch的 local workgroups 数量
    dispatchIndirectCommand.z = 1;//是Z维度dispatch的 local workgroups 数量
    /*
    VkDrawMeshTasksIndirectCommandEXT有效用法:
    1.如果绑定到VK_PIPELINE_BIND_POINT_GRAPHICS绑定点的当前pipeline，（1）如果该pipeline包含一个使用TaskEXT Execution Model的shader stage，则groupCountX, groupCountY, groupCountZ必须一一小于等于VkPhysicalDeviceMeshShaderPropertiesEXT::maxTaskWorkGroupCount[0], VkPhysicalDeviceMeshShaderPropertiesEXT::maxTaskWorkGroupCount[1], VkPhysicalDeviceMeshShaderPropertiesEXT::maxTaskWorkGroupCount[2]
                                                                     （2）如果该pipeline包含一个使用TaskEXT Execution Model的shader stage， 则groupCountX *  groupCountY * groupCountZ 必须小于等于VkPhysicalDeviceMeshShaderPropertiesEXT::maxTaskWorkGroupTotalCount
                                                                     （3）如果该pipeline不包含一个使用TaskEXT Execution Model的shader stage，则groupCountX, groupCountY, groupCountZ必须一一小于等于VkPhysicalDeviceMeshShaderPropertiesEXT::maxMeshWorkGroupCount[0], VkPhysicalDeviceMeshShaderPropertiesEXT::maxMeshWorkGroupCount[1], VkPhysicalDeviceMeshShaderPropertiesEXT::maxMeshWorkGroupCount[2]
                                                                     （4）如果该pipeline不包含一个使用TaskEXT Execution Model的shader stage，则groupCountX *  groupCountY * groupCountZ 必须小于等于VkPhysicalDeviceMeshShaderPropertiesEXT::maxMeshWorkGroupTotalCount
    
    */
    
    //记录一个间接的cluster culling 绘制命令   类似于vkCmdDrawClusterHUAWEI，只不过参数由buffer给出，buffer中从offset开始
    vkCmdDrawClusterIndirectHUAWEI(commandBuffer, VkBuffer{/*假设这是一个有效的VkBuffer*/ }/*buffer,包含绘制参数的的buffer.*/, 0/*offset，为buffer中起始参数的字节偏移量.*/);
    /*
    
      vkCmdDrawClusterIndirectHUAWEI有效用法:
     1.如果一个VkSampler以其magFilter或者minFilter等于VK_FILTER_LINEAR创建，则（1）如果reductionMode为VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE，如果用于采样一个VkImageView作为该命令的结果的compareEnable为VK_FALSE，则该image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT
                                                                              （2）如果reductionMode为VK_SAMPLER_REDUCTION_MODE_MIN 或者VK_SAMPLER_REDUCTION_MODE_MAX之一 用于采样一个VkImageView作为该命令的结果，则该image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT
     2.如果一个VkSampler以其mipmapMode 等于VK_SAMPLER_MIPMAP_MODE_LINEAR创建，则（1）如果reductionMode为VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE，如果用于采样一个VkImageView作为该命令的结果的compareEnable为VK_FALSE，则该image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT
                                                                              （2）如果reductionMode为VK_SAMPLER_REDUCTION_MODE_MIN 或者VK_SAMPLER_REDUCTION_MODE_MAX之一 用于采样一个VkImageView作为该命令的结果，则该image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT
     3.如果一个VkSampler以其unnormalizedCoordinates等于VK_TRUE用于采样一个VkImageView作为该命令的结果创建，则（1）该image view的levelCount以及layerCount必须为1
                                                                                                             （2）该image view的viewType必须为VK_IMAGE_VIEW_TYPE_1D 或者 VK_IMAGE_VIEW_TYPE_2D
     4.如果一个VkImageView的采样带depth comparison操作，则image view的format features必须包含VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT
     5.如果一个VkImageView使用atomic operations作为该命令的结果进行访问，则image view的format features必须包含VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT
     6.如果一个VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER类型的 descriptor使用atomic operations作为该命令的结果进行访问，则storage texel buffer的format features必须包含VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT
     7.如果一个以VK_FILTER_CUBIC_EXT进行采样的VkImageView作为该命令的结果，则image view的format features必须包含VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT
     8.如果VK_EXT_filter_cubic拓展没有开启，且有任何一个以VK_FILTER_CUBIC_EXT进行采样的VkImageView作为该命令的结果，则其VkImageViewType不能为VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, 或者 VK_IMAGE_VIEW_TYPE_CUBE_ARRAY
     9.任何一个以VK_FILTER_CUBIC_EXT进行采样的作为该命令的结果的VkImageView，其VkImageViewType和format 必须支持cubic filtering，参见vkGetPhysicalDeviceImageFormatProperties2返回的VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic
     10.任何一个以VK_FILTER_CUBIC_EXT进行采样且reduction mode为VK_SAMPLER_REDUCTION_MODE_MIN 或者 VK_SAMPLER_REDUCTION_MODE_MAX之一的作为该命令的结果的VkImageView，其VkImageViewType和format 必须支持带minmax filtering的cubic filtering，参见vkGetPhysicalDeviceImageFormatProperties2返回的VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax
     11.如果cubicRangeClamp特性没有开启，则有任何一个以VK_FILTER_CUBIC_EXT进行采样VkImageView的作为该命令的结果，VkSamplerReductionModeCreateInfo::reductionMode不能为VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM
     12.任何一个以VkSamplerReductionModeCreateInfo::reductionMode为VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM进行采样的作为该命令的结果的VkImageView必须以VK_FILTER_CUBIC_EXT进行采样
     13.如果selectableCubicWeights特性没有开启，则有任何一个以VK_FILTER_CUBIC_EXT进行采样VkImageView的作为该命令的结果，VkSamplerCubicWeightsCreateInfoQCOM::cubicWeights必须为VK_CUBIC_FILTER_WEIGHTS_CATMULL_ROM_QCOM
     14.任何一个以VkImageCreateInfo::flags含VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV创建的采样作为该命令结果的VkImage必须以VkSamplerAddressMode为VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE 进行采样
     15.对于任何作为storage image写入的VkImageView，且其OpTypeImage的format未知，则该image view的 format features必须包含VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT
     16.对于任何作为storage image读取的VkImageView，且其OpTypeImage的format未知，则该image view的 format features必须包含VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT
     17.对于任何作为storage storage texel buffer写入的VkBufferView，且其OpTypeImage的format未知，则该buffer view的 buffer features必须包含VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT
     18.对于任何作为storage storage texel buffer读取的VkBufferView，且其OpTypeImage的format未知，则该buffer view的 buffer features必须包含VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT
     19.对于每个在绑定的shader中静态使用的set n，一个descriptor set必须被绑定到相同pipeline bind point的set n处，该set n必须和创建当前VkPipeline的VkPipelineLayout或者和创建当前VkShaderEXT的VkDescriptorSetLayout 数组的set n处的布局兼容，参见Pipeline Layout Compatibility p1280
     20.对于每个在绑定的shader中静态使用的push constant，一个push constant值必须被绑定到相同pipeline bind point的对应处，该push constant必须和创建当前VkPipeline的VkPipelineLayout或者和创建当前VkShaderEXT的VkDescriptorSetLayout 数组中的对应处的布局兼容，参见Pipeline Layout Compatibility p1280
     21.如果maintenance4特性没有开启，则对于每个在绑定的shader中静态使用的push constant，一个push constant值必须被设置到相同pipeline bind point的对应处，该push constant必须和创建当前VkPipeline的VkPipelineLayout或者和创建当前VkShaderEXT的VkDescriptorSetLayout 数组中的对应处的布局兼容，参见Pipeline Layout Compatibility p1280
     22.每一个通过vkCmdBindDescriptorSets绑定的descriptor set的descriptors,如果是被不以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建的，且已经绑定到该命令使用的pipeline bind point的VkPipeline静态使用的，则这些descriptors必须是有效的，参见 descriptor validity p1328
     23.如果通过vkCmdBindDescriptorSets指定绑定到pipeline bind point的VkPipeline要使用的descriptors，则绑定的VkPipeline不能以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建
     24.在vkCmdSetDescriptorBufferOffsetsEXT中指定绑定的descriptor buffers的descriptors，则（1）如果绑定到pipeline bind point的该命令会使用的VkPipeline以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建，且这些descriptors是动态使用的，则这些descriptors必须是有效的
                                                                                           （2）如果绑定到pipeline bind point的对应stage的该命令会使用的VkShaderEXT，且这些descriptors是动态使用的，则这些descriptors必须是有效的
     25.在vkCmdSetDescriptorBufferOffsetsEXT中指定的descriptors在绑定到pipeline bind point的VkPipeline中使用，则VkPipeline必须以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建
     26.如果一个descriptor在以VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建的VkPipeline中动态使用，则descriptor memory必须是驻留内存
     27.如果一个descriptor在以其VkDescriptorSetLayout以VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT创建的VkShaderEXT中动态使用，则descriptor memory必须是驻留内存
     28.如果shaderObject 特性没有开启，一个有效的pipeline必须绑定到这个命令使用的绑定到pipeline bind point上
     29.如果一个pipeline绑定到该命令使用的pipeline bind point上，则不能有任何动态state 设置命令设置任何该VkPipeline 中没有指定的动态 state
     30.如果一个VkPipeline绑定到该命令使用的pipeline bind point上 或者任何一个会访问一个使用unnormalized coordinates的VkSampler的 VkShaderEXT绑定到该命令使用的pipeline bind point上的pipeline的对应stage，则
                                                                                 （1）在任何shader stage中，VkSampler不能用来采样任何类型为VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY 或者 VK_IMAGE_VIEW_TYPE_CUBE_ARRAY的VkImageView
                                                                                 （2）在任何shader stage中，该VkSampler不能和任何带有名字中带有ImplicitLod，Dref 或者 Proj 的SPIR-V OpImageSample* 或者 OpImageSparseSample*指令一起使用
                                                                                 （3）在任何shader stage中，该VkSampler不能和任何包含 LOD bias或者offset 值 的SPIR-V OpImageSample* or OpImageSparseSample*指令一起使用
     31.如果shaderObject开启，一个有效的pipeline必须绑定到该命令使用的pipeline bind point上或者一个有效的shader objects以及VK_NULL_HANDLE的组合必须绑定到该命令使用的pipeline bind point每一个支持的shader stage上
     32.如何绑定到该命令使用的pipeline bind point上的VkPipeline的任何stage会访问一个uniform buffer，且该stage对uniformBuffers不以启用VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT或者VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT 创建，且robustBufferAccess特性未开启，则该stage就不能访问绑定到相同pipeline bind point的descriptor set指定的buffer范围外的值
     33.如果robustBufferAccess特性未开启，且任何会访问uniform buffer的绑定到该命令使用的pipeline bind point上对应shader stage的VkShaderEXT，则其不能访问绑定到相同pipeline bind point的descriptor set指定的buffer范围外的值
     34.如何绑定到该命令使用的pipeline bind point上的VkPipeline的任何stage会访问一个storage buffer，且该stage对storageBuffers不以启用VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT或者VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT 创建，且robustBufferAccess特性未开启，则该stage就不能访问绑定到相同pipeline bind point的descriptor set指定的buffer范围外的值
     35.如果robustBufferAccess特性未开启，且任何会访问storage buffer的绑定到该命令使用的pipeline bind point上对应shader stage的VkShaderEXT，则其不能访问绑定到相同pipeline bind point的descriptor set指定的buffer范围外的值
     36.如果commandBuffer 是一个unprotected command buffer，且protectedNoFault 未支持，则任何绑定的shaders访问的资源不能是一个protected resource
     37.如果一个绑定的shader访问一个VkSampler 或者 VkImageView ，且启用了sampler Y′C BCR conversion，则只能使用OpImageSample* 或者 OpImageSparseSample*指令，不能使用ConstOffset 以及 Offset操作符
     38.如果一个VkImageView作为该命令的结果进行访问，则（1）image view 的viewType 必须匹配Instruction/Sampler/Image View Validation p1481中描述的OpTypeImage的Dim操作符
                                                       （2）image view 的foamrt的numeric type 必须匹配OpTypeImage的Sampled Type操作符
     39.如果一个VkImageView以一个不是VK_FORMAT_A8_UNORM_KHR的format创建且通过OpImageWrite作为该命令的结果进行访问，则该命令的Texel 操作符的Type必须至少包含和 image view的 format含有的components的个数相同的components个数
     40.如果一个VkImageView以VK_FORMAT_A8_UNORM_KHR的format创建且通过OpImageWrite作为该命令的结果进行访问，则该命令的Texel 操作符的Type必须包含4个components
     41.如果一个VkBufferView通过OpImageWrite作为该命令的结果进行访问，则该命令的Texel 操作符的Type必须至少包含和 buffer view的 format含有的components的个数相同的components个数
     42.如果一个带64-bit component的VkFormat的VkImageView作为该命令的结果进行访问，则该命令的OpTypeImage操作符的SampledType的宽度必须为64
     43.如果一个带少于64-bit component的VkFormat的VkImageView作为该命令的结果进行访问，则该命令的OpTypeImage操作符的SampledType的宽度必须为32
     44.如果一个带64-bit component的VkFormat的VkBufferView作为该命令的结果进行访问，则该命令的OpTypeImage操作符的SampledType的宽度必须为64位
     45.如果一个带少于64-bit component的VkFormat的VkBufferView作为该命令的结果进行访问，则该命令的OpTypeImage操作符的SampledType的宽度必须为32
     46.如果sparseImageInt64Atomics 特性未开启，则以VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT创建的VkImage对象不能被SampledType宽度为64位的OpTypeImage的atomic instructions访问
     47.如果sparseImageInt64Atomics 特性未开启，则以VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT创建的VkBuffer对象不能被SampledType宽度为64位的OpTypeImage的atomic instructions访问
     48.如果OpImageWeightedSampleQCOM用来采样一个作为该命令的结果的VkImageView，则该image view的format features必须包含VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM
     49.如果OpImageWeightedSampleQCOM用来采样一个作为该命令的结果的sample weight image的VkImageView，则该image view的format features必须包含VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM
     50.如果OpImageBoxFilterQCOM用来采样一个作为该命令的结果的VkImageView，则该image view的format features必须包含VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM
     51.如果OpImageBlockMatchSSDQCOM，或者 OpImageBlockMatchSADQCOM用来读取一个作为该命令的结果的VkImageView，则（1）该image view的format features必须包含VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM
                                                                                                                （2）如果是读取的reference image，指定的reference coordinates不能在integer texel coordinate validation 时候失败
     52.如果OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchWindowSSDQCOM, OpImageBlockMatchWindowSADQCOM, OpImageBlockMatchGatherSSDQCOM,
                                                 OpImageBlockMatchGatherSADQCOM, OpImageBlockMatchSSDQCOM, 或者 OpImageBlockMatchSADQCOM用来采样一个作为该命令的结果的VkImageView，则该VkSampler必须以VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM创建
     53.如果任何除了OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchWindowSSDQCOM, OpImageBlockMatchWindowSADQCOM, OpImageBlockMatchGatherSSDQCOM, OpImageBlockMatchGatherSADQCOM, OpImageBlockMatchSSDQCOM, 或者 OpImageBlockMatchSADQCOM之外的指令使用VkSampler进行采样作为该命令的结果，则该sampler不能以VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM 创建
     54.如果OpImageBlockMatchWindow*QCOM or OpImageBlockMatchGather*QCOM指令用来读取VkImageView作为该命令的结果，则（1）VkImageView的format features必须包含VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM
                                                                                                                   （2）VkImageView的format必须只含有一个component
     55.如果OpImageBlockMatchWindow*QCOM or OpImageBlockMatchGather*QCOM指令用来读取一个引用的image作为该命令的结果，则指定的 reference coordinates不能在integer texel coordinate validation 时候失败
     56.任何该命令执行的shader invocation必须已经终止
     57.如果有一个类型位为VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM, VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, 或者 VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT中任意一个的descriptor作为该命令的结果进行访问，则该descriptor所指的image subresource的layout必须和该descriptor被写入时的layout相同。
     58.当前的 render pass  必须和绑定到VK_PIPELINE_BIND_POINT_GRAPHICS上的VkPipeline 创建时候的VkGraphicsPipelineCreateInfo中指定的renderPass兼容
     59.当前的 render pass  的subpass index必须和绑定到VK_PIPELINE_BIND_POINT_GRAPHICS上的VkPipeline 创建时候的VkGraphicsPipelineCreateInfo中指定的subpass相同
     60.如果任何shader静态访问一个input attachment，则有效的descriptor必须通过VkDescriptorSet被绑定到该pipeline中
     61.如果任何该pipeline执行shader以SubpassData的Dim操作符访问一个OpTypeImage变量，则该变量必须被一个对应当前subpass的input attachment的InputAttachmentIndex修饰
     62.在subpass中访问的Input attachment views必须以和该subpass相同定义的VkFormat创建，且必须以一个和当前绑定的VkFramebuffer的该附件引用的subpass的pInputAttachments[InputAttachmentIndex]附件兼容的VkImageView创建，参见Fragment Input Attachment Compatibility p1408
     63.在动态render pass中访问以VkRenderingInputAttachmentIndexInfoKHR的InputAttachmentIndex，或者VkRenderingInputAttachmentIndexInfoKHR:pDepthInputAttachmentIndex 或者 VkRenderingInputAttachmentIndexInfoKHR:pStencilInputAttachmentIndex为NULL情况下不指定InputAttachmentIndex的引用的Input attachment views，必须以和VkRenderingInfo中对应color, depth, 或者 stencil attachment兼容的VkImageView创建
     64.如果VkRenderingInputAttachmentIndexInfoKHR::pDepthInputAttachmentIndex 以及 VkRenderingInputAttachmentIndexInfoKHR::pStencilInputAttachmentIndex不为NULL，则在动态render pass中通过shader object访问Input attachment views必须指明InputAttachmentIndex
     65.如果在动态render pass中通过shader object访问Input attachment views指明了InputAttachmentIndex，则InputAttachmentIndex必须匹配VkRenderingInputAttachmentIndexInfoKHR中的index
     66.当前render pass所用的附件对应的image subresource底层内存的写入只能作为该命令的一个附件写入
     67.如果一个color attachment在之前的该subpass的命令中以load, store, 或者 resolve operations进行了写入，则其layout不为VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT，且有当前绑定的pipeline设有VK_PIPELINE_CREATE_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT，或者
                                     最后的vkCmdSetAttachmentFeedbackLoopEnableEXT调用包含VK_IMAGE_ASPECT_COLOR_BIT以及 没有绑定的pipeline 或者绑定的pipeline以VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT创建，则该附件只能以附件进行访问的，这两种情况中之一
     68.如果一个depth attachment在之前的该subpass的命令中以load, store, 或者 resolve operations进行了写入，则其layout不为VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT，且有当前绑定的pipeline设有VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT，或者
                                     最后的vkCmdSetAttachmentFeedbackLoopEnableEXT调用包含VK_IMAGE_ASPECT_DEPTH_BIT以及 没有绑定的pipeline 或者绑定的pipeline以VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT创建，则该附件只能以附件进行访问的，这两种情况中之一
     69.如果一个stencil attachment在之前的该subpass的命令中以load, store, 或者 resolve operations进行了写入，则其layout不为VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT，且有当前绑定的pipeline设有VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT，或者
                                     最后的vkCmdSetAttachmentFeedbackLoopEnableEXT调用包含VK_IMAGE_ASPECT_STENCIL_BIT以及 没有绑定的pipeline 或者绑定的pipeline以VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT创建，则该附件只能以附件进行访问的，这两种情况中之一
     70.如果一个attachment在之前的该subpass的命令中以load, store, 或者 resolve operations进行了写入,则该附件就不能再以除作为一个附件，storage image或者sampled image被该命令访问
     71.如果在之前的命令的subpass中以用作附件外的方式访问访问了一个当权subpass的附件所对的image subresource，则该命令就不能再将该image subresource用作附件进行写入
     72.如果当前render pass使用一个depth/stencil attachment，则（1）如果depth aspect的layout为read-only的layout，则不能启用depth writes
                                                               （2）如果stencil aspect的layout为read-only的layout，front 以及 back writeMask不为0，且stencil 测试开启，则所有stencil 操作必须为VK_STENCIL_OP_KEEP
     73.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_VIEWPORT动态state开启创建，则vkCmdSetViewport必须在该命令之前设置
                                     （2）以VK_DYNAMIC_STATE_SCISSOR动态state开启创建，则vkCmdSetScissor必须在该命令之前设置
                                     （3）以VK_DYNAMIC_STATE_LINE_WIDTH动态state开启创建，则vkCmdSetLineWidth必须在该命令之前设置
                                     （4）以VK_DYNAMIC_STATE_DEPTH_BIAS动态state开启创建，则vkCmdSetDepthBias或者vkCmdSetDepthBias2EXT 必须在该命令之前设置
                                     （5）以VK_DYNAMIC_STATE_BLEND_CONSTANTS动态state开启创建，则vkCmdSetBlendConstants 必须在该命令之前设置
                                     （6）以VK_DYNAMIC_STATE_DEPTH_BOUNDS动态state开启创建，且如果当前depthBoundsTestEnable为VK_TRUE， 则vkCmdSetDepthBounds 必须在该命令之前设置
                                     （7）以VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK动态state开启创建，且如果当前stencilTestEnable为VK_TRUE， 则vkCmdSetStencilCompareMask 必须在该命令之前设置
                                     （8）以VK_DYNAMIC_STATE_STENCIL_WRITE_MASK动态state开启创建，且如果当前stencilTestEnable为VK_TRUE， 则vkCmdSetStencilWriteMask 必须在该命令之前设置
                                     （9）以VK_DYNAMIC_STATE_STENCIL_REFERENCE动态state开启创建，且如果当前stencilTestEnable为VK_TRUE， 则vkCmdSetStencilReference 必须在该命令之前设置
                                     （10）以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT动态state开启创建， 则vkCmdSetSampleLocationsEXT 必须在该命令之前设置
                                     （11）以VK_DYNAMIC_STATE_CULL_MODE动态state开启创建， 则vkCmdSetCullMode 必须在该命令之前设置
                                     （12）以VK_DYNAMIC_STATE_FRONT_FACE动态state开启创建， 则vkCmdSetFrontFace 必须在该命令之前设置
                                     （13）以VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE动态state开启创建， 则vkCmdSetDepthTestEnable 必须在该命令之前设置
                                     （14）以VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE动态state开启创建， 则vkCmdSetDepthWriteEnable 必须在该命令之前设置
                                     （15）以VK_DYNAMIC_STATE_DEPTH_COMPARE_OP动态state开启创建， 则vkCmdSetDepthCompareOp 必须在该命令之前设置
                                     （16）以VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE动态state开启创建， 则vkCmdSetDepthBoundsTestEnable 必须在该命令之前设置
                                     （17）以VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE动态state开启创建， 则vkCmdSetStencilTestEnable 必须在该命令之前设置
                                     （18）以VK_DYNAMIC_STATE_STENCIL_OP动态state开启创建， 则vkCmdSetStencilOp 必须在该命令之前设置
                                     （19）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT但不以VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT 动态state开启创建， 则vkCmdSetViewportWithCount 必须在该命令之前设置，且vkCmdSetViewportWithCount设置的viewportCount必须匹配pipeline的VkPipelineViewportStateCreateInfo::scissorCount
                                     （20）以VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT但不以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT 动态state开启创建， 则vkCmdSetScissorWithCount 必须在该命令之前设置，且vkCmdSetScissorWithCount设置的scissorCount必须匹配pipeline的VkPipelineViewportStateCreateInfo::viewportCount
                                     （21）以VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT和VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT 动态state同时开启创建， 则vkCmdSetViewportWithCount以及vkCmdSetScissorWithCount 必须在该命令之前设置，且vkCmdSetViewportWithCount设置的viewportCount必须匹配vkCmdSetScissorWithCount设置的scissorCount
                                     （22）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT但不以VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV 动态state开启创建， 则绑定的pipeline必须以VkPipelineViewportWScalingStateCreateInfoNV::viewportCount 大于等于最近vkCmdSetViewportWithCount设置的viewportCount创建
                                     （23）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT和VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV 动态state开启创建， 则最近调用的vkCmdSetViewportWScalingNV设置的viewportCount 必须大于等于最近vkCmdSetViewportWithCount设置的viewportCount
                                     （24）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT但不以VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV 动态state开启创建， 则绑定的pipeline必须以VkPipelineViewportShadingRateImageStateCreateInfoNV::viewportCount 大于等于最近vkCmdSetViewportWithCount设置的viewportCount创建
                                     （25）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT和VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV 动态state开启创建， 则最近调用的vkCmdSetViewportShadingRatePaletteNV设置的viewportCount 必须大于等于最近vkCmdSetViewportWithCount设置的viewportCount
                                     （26）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT动态state开启且VkPipelineViewportStateCreateInfo的pNext中含有一个VkPipelineViewportSwizzleStateCreateInfoNV 创建， 则绑定的pipeline必须以VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount 大于等于最近vkCmdSetViewportWithCount设置的viewportCount创建
                                     （27）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT动态state开启且VkPipelineViewportStateCreateInfo的pNext中含有一个VkPipelineViewportExclusiveScissorStateCreateInfoNV 创建， 则绑定的pipeline必须以VkPipelineViewportExclusiveScissorStateCreateInfoNV::exclusiveScissorCount 大于等于最近vkCmdSetViewportWithCount设置的viewportCount创建
                                     （28）以VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_ENABLE_NV动态state开启创建， 则vkCmdSetExclusiveScissorEnableNV 必须在该命令之前设置
                                     （29）以VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV动态state开启创建， 则vkCmdSetExclusiveScissorNV 必须在该命令之前设置
                                     （30）以VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE动态state开启创建， 则vkCmdSetRasterizerDiscardEnable 必须在该命令之前设置
                                     （31）以VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE动态state开启创建， 则vkCmdSetDepthBiasEnable 必须在该命令之前设置
                                     （32）以VK_DYNAMIC_STATE_LOGIC_OP_EXT动态state开启创建， 则vkCmdSetLogicOpEXT 必须在该命令之前设置且参数logicOp必须是一个有效的VkLogicOp值
     74.如果一个shader object绑定到任何graphics stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                     （1）如果最靠近当前命令的vkCmdSetPolygonModeEXT设置polygonMode为VK_POLYGON_MODE_LINE或者是任何line topology，则vkCmdSetLineWidth必须在该命令之前设置
                                     （2）如果最靠近当前命令的vkCmdSetDepthBiasEnable设置depthBiasEnable为VK_TRUE，则vkCmdSetDepthBias 或者 vkCmdSetDepthBias2EXT必须在该命令之前设置
                                     （3）如果最靠近当前命令的vkCmdSetDepthBoundsTestEnable设置depthBoundsTestEnable为VK_TRUE，则vkCmdSetDepthBounds必须在该命令之前设置
                                     （4）如果最靠近当前命令的vkCmdSetStencilTestEnable设置stencilTestEnable为VK_TRUE，则vkCmdSetStencilCompareMask必须在该命令之前设置
                                     （5）如果最靠近当前命令的vkCmdSetStencilTestEnable设置stencilTestEnable为VK_TRUE，则vkCmdSetStencilWriteMask必须在该命令之前设置
                                     （6）如果最靠近当前命令的vkCmdSetStencilTestEnable设置stencilTestEnable为VK_TRUE，则vkCmdSetStencilReference必须在该命令之前设置
                                     （7）如果最靠近当前命令的vkCmdSetSampleLocationsEnableEXT设置sampleLocationsEnable为VK_TRUE，则vkCmdSetSampleLocationsEXT必须在该命令之前设置
                                     （8）则vkCmdSetCullMode必须在该命令之前设置
                                     （9）则vkCmdSetFrontFace必须在该命令之前设置
                                     （10）则vkCmdSetDepthTestEnable 必须在该命令之前设置
                                     （11）则vkCmdSetDepthWriteEnable 必须在该命令之前设置
                                     （12）如果最靠近当前命令的vkCmdSetDepthTestEnable设置depthTestEnable为VK_TRUE，则vkCmdSetDepthCompareOp 必须在该命令之前设置
                                     （13）则vkCmdSetDepthBoundsTestEnable 必须在该命令之前设置
                                     （14）则vkCmdSetStencilTestEnable 必须在该命令之前设置
                                     （15）如果最靠近当前命令的vkCmdSetStencilTestEnable设置stencilTestEnable为VK_TRUE，则vkCmdSetStencilOp 必须在该命令之前设置
                                     （16）
                                     （17）如果shadingRateImage特性开启，则vkCmdSetCoarseSampleOrderNV 必须在该命令之前设置
                                     （18）如果shadingRateImage特性开启，且最靠近当前命令的vkCmdSetShadingRateImageEnableNV设置shadingRateImageEnable为VK_TRUE，则vkCmdSetViewportShadingRatePaletteNV 必须在该命令之前设置
                                     （19）如果shadingRateImage特性开启，且最靠近当前命令的vkCmdSetShadingRateImageEnableNV设置shadingRateImageEnable为VK_TRUE，则最近的vkCmdSetViewportShadingRatePaletteNV设置的viewportCount 必须大于等于vkCmdSetViewportWithCount设置的viewportCount
                                     （20）则vkCmdSetDepthBiasEnable必须在该命令之前设置
     75.如果一个输出line primitives的shader object绑定到VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或者 VK_SHADER_STAGE_GEOMETRY_BIT，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则vkCmdSetLineWidth必须在该命令之前设置
     76.如果一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最靠近当前命令的vkCmdSetColorBlendEnableEXT设置pColorBlendEnables任何元素为VK_TRUE，且
                         最靠近当前命令的vkCmdSetColorBlendEquationEXT设置pColorBlendEquations相同元素的VkColorBlendEquationEXT的VkBlendFactor成员为VK_BLEND_FACTOR_CONSTANT_COLOR, VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR, VK_BLEND_FACTOR_CONSTANT_ALPHA, 或者 VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA，则vkCmdSetBlendConstants必须在该命令之前设置
     77.如果该命令记录在开启了multiview的render pass instance中，则最大的instance 索引必须小于等于VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex
     78.如果绑定的graphics pipeline以VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable设置为VK_TRUE创建且当前的subpass含有一个 depth/stencil attachment，则该attachment必须以VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT创建
     >>78.5  .如果一个shader object绑定到任何graphics stage，则（1）vkCmdSetViewportWithCount 和vkCmdSetScissorWithCount 必须同时在该命令之前设置，且vkCmdSetViewportWithCount设置的viewportCount必须匹配vkCmdSetScissorWithCount设置的scissorCount
                                                               （2）则vkCmdSetRasterizerDiscardEnable 必须在该命令之前设置
     79.如果VK_NV_clip_space_w_scaling拓展开启，且shader object绑定到任何graphics stage，且最近的vkCmdSetViewportWScalingEnableNV设置viewportWScalingEnable为VK_TRUE，则（1）vkCmdSetViewportWScalingNV必须在该命令前设置
                                                                                                                                                                        （2）最近vkCmdSetViewportWScalingNV设置的viewportCount必须大于等于vkCmdSetViewportWithCount设置的viewportCount
     80.如果exclusiveScissor 特性开启，且shader object绑定到任何graphics stage，，则（1）vkCmdSetExclusiveScissorEnableNV必须在该命令前设置
                                                                                    （2）最近的vkCmdSetExclusiveScissorEnableNV调用设置的pExclusiveScissorEnables中的任何元素为VK_TRUE,则vkCmdSetExclusiveScissorNV必须在该命令前设置
     81.如果一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最靠近当前命令的vkCmdSetLogicOpEnableEXT设置logicOpEnable任何元素为VK_TRUE，则vkCmdSetLogicOpEXT 必须在该命令之前设置且参数logicOp必须是一个有效的VkLogicOp值
     82.如果primitiveFragmentShadingRateWithMultipleViewports限制不支持，则（1）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT动态state开启创建，且任何该pipeline的shader stage会写入PrimitiveShadingRateKHR built-in修饰的变量，则vkCmdSetViewportWithCount 必须在该命令之前设置且参数viewportCount必须是1
                                                                           （2）任何绑定的graphics pipeline的shader stage会写入PrimitiveShadingRateKHR built-in修饰的变量，则vkCmdSetViewportWithCount 必须在该命令之前设置且参数viewportCount必须是1
     83.如果graphics pipeline中未开启rasterization，则对subpass中的每个color attachment，如果其对应的image view 的format features不包含VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT，则pColorBlendState中其对应pAttachments中元素的blendEnable必须为VK_FALSE
     84.如果一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则对于render pass中的每个color attachment，如果其对应的image view 的format features不包含VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT， 则最近的vkCmdSetColorBlendEnableEXT设置的pColorBlendEnables中该附件的对应元素必须为VK_FALSE
     85.如果graphics pipeline中未开启rasterization，有VK_AMD_mixed_attachment_samples拓展未开启，VK_NV_framebuffer_mixed_samples拓展未开启，multisampledRenderToSingleSampled特性未开启，则当前绑定的pipeline的rasterizationSamples必须和当前subpass的color 以及/或者 depth/stencil attachments的相同
     86.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且有VK_AMD_mixed_attachment_samples拓展未开启，VK_NV_framebuffer_mixed_samples拓展未开启，multisampledRenderToSingleSampled特性未开启，则最近vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples必须和当前subpass的color 以及/或者 depth/stencil attachments的相同
     87.如果一个shader object绑定到任何graphics stage，则当前的render pass instance必须以vkCmdBeginRendering开始
     88.如果当前的render pass instance以vkCmdBeginRendering开始，（1）如果pDepthAttachment的imageView不为VK_NULL_HANDLE，且pDepthAttachment的layout不为VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL，则该命令不能写入任何值到depth attachment
                                                                 （2）如果pStencilAttachment的imageView不为VK_NULL_HANDLE，且pStencilAttachment的layout不为VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL，则该命令不能写入任何值到stencil attachment
                                                                 （3）如果pDepthAttachment的imageView不为VK_NULL_HANDLE，且pDepthAttachment的layout为VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL，则该命令不能写入任何值到depth attachment
                                                                 （4）如果pStencilAttachment的imageView不为VK_NULL_HANDLE，且pStencilAttachment的layout为VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL，则该命令不能写入任何值到stencil attachment
                                                                 （5）如果pDepthAttachment的imageView不为VK_NULL_HANDLE，且pDepthAttachment的layout为VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL，则该命令不能写入任何值到depth attachment
                                                                 （6）如果pStencilAttachment的imageView不为VK_NULL_HANDLE，且pStencilAttachment的layout为VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL，则该命令不能写入任何值到stencil attachment
                                                                 （7）则当前绑定的graphics pipeline必须以含VkPipelineRenderingCreateInfo::viewMask等于VkRenderingInfo::viewMask创建
                                                                 （8）如果带有VkRenderingInfo::colorAttachmentCount为1，则没有shader object绑定到任何graphics stage，且一个color attachment的 resolve mode为VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID，则VkRenderingInfo::pColorAttachments中每个resolveImageView不为VK_NULL_HANDLE的元素其对应image必须以和创建当前绑定的pipeline 相同的VkExternalFormatANDROID::externalFormat创建
                                                                 （9）如果没有shader object绑定到任何graphics stage，如果绑定的graphics pipeline以一个非零值VkExternalFormatANDROID::externalFormat创建且启用VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态设置，则vkCmdSetColorBlendEnableEXT必须在该命令前设置blend enable为VK_FALSE
                                                                 （10）如果没有shader object绑定到任何graphics stage，如果绑定的graphics pipeline以一个非零值VkExternalFormatANDROID::externalFormat创建且启用VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态设置，则vkCmdSetRasterizationSamplesEXT必须在该命令前设置rasterizationSamples为VK_SAMPLE_COUNT_1_BIT
                                                                 （11）如果没有shader object绑定到任何graphics stage，如果绑定的graphics pipeline以一个非零值VkExternalFormatANDROID::externalFormat创建且启用VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR动态设置，则vkCmdSetFragmentShadingRateKHR必须在该命令前设置pFragmentSize->width为1，pFragmentSize->height为1
     89.如果dynamicRenderingUnusedAttachments特性未开启，且当前的render pass instance以vkCmdBeginRendering开始，则
                                                             （1）当前绑定的graphics pipeline必须以含VkPipelineRenderingCreateInfo::colorAttachmentCount等于VkRenderingInfo::colorAttachmentCount创建
                                                             （2）如果VkRenderingInfo::colorAttachmentCount大于0，则VkRenderingInfo::pColorAttachments 中每一个其imageView不为VK_NULL_HANDLE的元素的VkImageView必须以VkFormat对应绑定的graphics pipeline的VkPipelineRenderingCreateInfo::pColorAttachmentFormats指明的format创建
                                                             （3）如果VkRenderingInfo::colorAttachmentCount大于0，则VkRenderingInfo::pColorAttachments 中每一个其imageView为VK_NULL_HANDLE的元素对应绑定的graphics pipeline的VkPipelineRenderingCreateInfo::pColorAttachmentFormats指明的format必须为VK_FORMAT_UNDEFINED
                                                             （4）如果VkRenderingInfo::pDepthAttachment->imageView为VK_NULL_HANDLE，则创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::depthAttachmentFormat必须为VK_FORMAT_UNDEFINED
                                                             （5）如果VkRenderingInfo::pDepthAttachment->imageView不为VK_NULL_HANDLE，则创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::depthAttachmentFormat必须和创建VkRenderingInfo::pDepthAttachment->imageView的VkFormat相同
                                                             （6）如果VkRenderingInfo::pStencilAttachment->imageView为VK_NULL_HANDLE，则创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::stencilAttachmentFormat必须为VK_FORMAT_UNDEFINED
                                                             （7）如果VkRenderingInfo::pStencilAttachment->imageView不为VK_NULL_HANDLE，则创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::stencilAttachmentFormat必须和创建VkRenderingInfo::pStencilAttachment->imageView的VkFormat相同
     90.如果dynamicRenderingUnusedAttachments特性开启，且当前的render pass instance以vkCmdBeginRendering开始，则
                                                             （1）如果VkRenderingInfo::colorAttachmentCount大于0，则VkRenderingInfo::pColorAttachments 中每一个其imageView不为VK_NULL_HANDLE的元素的VkImageView必须以VkFormat对应绑定的graphics pipeline的VkPipelineRenderingCreateInfo::pColorAttachmentFormats指明的format创建，或者是对应元素为VK_FORMAT_UNDEFINED创建
                                                             （2）如果VkRenderingInfo::pDepthAttachment->imageView不为VK_NULL_HANDLE，且创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::depthAttachmentFormat和创建VkRenderingInfo::pDepthAttachment->imageView的VkFormat不同，则该format必须为VK_FORMAT_UNDEFINED
                                                             （3）如果VkRenderingInfo::pStencilAttachment->imageView不为VK_NULL_HANDLE，且创建当前绑定的graphics pipeline的VkPipelineRenderingCreateInfo::stencilAttachmentFormat和创建VkRenderingInfo::pStencilAttachment->imageView的VkFormat不同，则该format必须为VK_FORMAT_UNDEFINED
     91.如果没有shader object绑定到任何graphics stage，且当前的render pass instance以vkCmdBeginRendering开始且VkRenderingInfo::colorAttachmentCount为1，且一个color attachment的 resolve mode为VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID，则VkRenderingInfo::pColorAttachments中每个resolveImageView不为VK_NULL_HANDLE的元素其对应image必须以和创建当前绑定的pipeline 相同的VkExternalFormatANDROID::externalFormat创建
     92.如果有一个shader object绑定到任何graphics stage，且当前的render pass 包含一个使用VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID resolve mode的color attachment，则（1）vkCmdSetColorBlendEnableEXT必须在该命令前设置blend enable为VK_FALSE
                                                                                                                                                                              （2）则vkCmdSetRasterizationSamplesEXT必须在该命令前设置rasterizationSamples为VK_SAMPLE_COUNT_1_BIT
                                                                                                                                                                              （3）则vkCmdSetFragmentShadingRateKHR必须在该命令前设置pFragmentSize->width为1，pFragmentSize->height为1
     93.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT动态state开启创建， 则vkCmdSetColorWriteEnableEXT 必须在该命令之前设置，且设置的attachmentCount必须大于等于创建当前绑定的pipeline的VkPipelineColorBlendStateCreateInfo::attachmentCount
                                     （2）以VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT动态state开启创建， 则vkCmdSetDiscardRectangleEXT 必须在该命令之前为每个VkPipelineDiscardRectangleStateCreateInfoEXT::discardRectangleCount指明的discard rectangle 设置
                                     （3）以VK_DYNAMIC_STATE_DISCARD_RECTANGLE_ENABLE_EXT动态state开启创建， 则vkCmdSetDiscardRectangleEnableEXT 必须在该命令之前设置
                                     （4）以VK_DYNAMIC_STATE_DISCARD_RECTANGLE_MODE_EXT动态state开启创建， 则vkCmdSetDiscardRectangleModeEXT 必须在该命令之前设置
     94.如果有一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最靠近当前命令的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                     （1）如果colorWriteEnable特性在device上开启，则vkCmdSetColorWriteEnableEXT 必须在该命令之前设置，且设置的attachmentCount必须大于等于当前render pass instance的color attachment的数量
                                     （2）如果VK_EXT_discard_rectangles拓展开启，且最近的vkCmdSetDiscardRectangleEnableEXT设置discardRectangleEnable为VK_TRUE， 则vkCmdSetDiscardRectangleEXT 必须在该命令之前设置
                                     （3）如果VK_EXT_discard_rectangles拓展开启， 则vkCmdSetDiscardRectangleEnableEXT 必须在该命令之前设置
                                     （4）如果VK_EXT_discard_rectangles拓展开启， 则最近的vkCmdSetDiscardRectangleEnableEXT设置discardRectangleEnable为VK_TRUE，则vkCmdSetDiscardRectangleModeEXT 必须在该命令之前设置
     95.如果当前的render pass instance以vkCmdBeginRendering开始，则（1）如果VkRenderingFragmentShadingRateAttachmentInfoKHR::imageView不为VK_NULL_HANDLE，则当前绑定的graphics pipeline必须以VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR创建
                                                                   （2）如果VkRenderingFragmentDensityMapAttachmentInfoEXT::imageView不为VK_NULL_HANDLE，则当前绑定的graphics pipeline必须以VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT创建
                                                                   （3）且含VkRenderingInfo::colorAttachmentCount大于0，如果当前的绑定的pipeline以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，则VkRenderingInfo::pColorAttachments中每个imageView不为VK_NULL_HANDLE的元素的imageView，必须以当前pipeline的VkAttachmentSampleCountInfoAMD 或者 VkAttachmentSampleCountInfoNV中的pColorAttachmentSamples中对应元素的sample count进行创建
                                                                   （4）如果当前的绑定的pipeline以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且VkRenderingInfo::pDepthAttachment中的imageView不为VK_NULL_HANDLE，则当前pipeline的VkAttachmentSampleCountInfoAMD 或者 VkAttachmentSampleCountInfoNV中的depthStencilAttachmentSamples必须等于创建VkRenderingInfo::pDepthAttachment->imageView的sample count
                                                                   （5）如果当前的绑定的pipeline以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且VkRenderingInfo::pStencilAttachment中的imageView不为VK_NULL_HANDLE，则当前pipeline的VkAttachmentSampleCountInfoAMD 或者 VkAttachmentSampleCountInfoNV中的depthStencilAttachmentSamples必须等于创建VkRenderingInfo::pStencilAttachment->imageView的sample count
                                                                   （6）且含VkRenderingInfo::colorAttachmentCount大于0，如果当前的绑定的pipeline不以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且multisampledRenderToSingleSampled特性没有开启，则VkRenderingInfo::pColorAttachments中每个imageView不为VK_NULL_HANDLE的元素的imageView，其创建的sample count必须等于当前绑定的graphics pipeline的rasterizationSamples
                                                                   （7）如果当前的绑定的pipeline不以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且VkRenderingInfo::pDepthAttachment中的imageView不为VK_NULL_HANDLE，且multisampledRenderToSingleSampled特性没有开启，则当前pipeline的rasterizationSamples 必须等于创建VkRenderingInfo::pDepthAttachment->imageView的sample count
                                                                   （8）如果当前的绑定的pipeline不以含有一个VkAttachmentSampleCountInfoAMD或者VkAttachmentSampleCountInfoNV创建，且VkRenderingInfo::pStencilAttachment中的imageView不为VK_NULL_HANDLE，且multisampledRenderToSingleSampled特性没有开启，则当前pipeline的rasterizationSamples 必须等于创建VkRenderingInfo::pStencilAttachment->imageView的sample count
                                                                   （9）当前绑定的pipeline必须VkGraphicsPipelineCreateInfo::renderPass为VK_NULL_HANDLE创建
                                                                   （10）如果绑定的pipeline的fragment shader静态写入一个color attachment，且color write mask不为0，启用了color writes，且该附件对应的VkRenderingInfo::pColorAttachments->imageView 不为VK_NULL_HANDLE，则对应的创建pipeline的VkPipelineRenderingCreateInfo::pColorAttachmentFormats中的元素不能为VK_FORMAT_UNDEFINED
                                                                   （11）如果绑定的pipeline启用了depth test，启用了depth writes，且VkRenderingInfo::pDepthAttachment->imageView 不为VK_NULL_HANDLE，则创建pipeline的VkPipelineRenderingCreateInfo::depthAttachmentFormat不能为VK_FORMAT_UNDEFINED
                                                                   （12）如果绑定的pipeline启用了stencil test，且VkRenderingInfo::pStencilAttachment->imageView 不为VK_NULL_HANDLE，则创建pipeline的VkPipelineRenderingCreateInfo::stencilAttachmentFormat不能为VK_FORMAT_UNDEFINED
     96.如果该命令在以vkCmdBeginRendering开始的render pass instance中调用，且VkRenderingInfo的pNext中包含一个multisampledRenderToSingleSampledEnable设为VK_TRUE的VkMultisampledRenderToSingleSampledInfoEXT，则当前绑定的graphics pipeline的rasterizationSamples必须等于VkMultisampledRenderToSingleSampledInfoEXT::rasterizationSamples
     97.如果primitivesGeneratedQueryWithRasterizerDiscard特性未开启，且VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query激活，则不能启用rasterization discard
     98.如果primitivesGeneratedQueryWithNonZeroStreams特性未开启，且VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query激活，则 绑定的graphics pipeline不能以VkPipelineRasterizationStateStreamCreateInfoEXT::rasterizationStream为非零值创建
     98.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_TESSELLATION_DOMAIN_ORIGIN_EXT动态state开启创建，则vkCmdSetTessellationDomainOriginEXT必须在该命令之前设置
                                     （2）以VK_DYNAMIC_STATE_DEPTH_CLAMP_ENABLE_EXT动态state开启创建，则vkCmdSetDepthClampEnableEXT必须在该命令之前设置
                                     （3）以VK_DYNAMIC_STATE_POLYGON_MODE_EXT动态state开启创建，则vkCmdSetPolygonModeEXT必须在该命令之前设置
                                     （4）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，则vkCmdSetRasterizationSamplesEXT必须在该命令之前设置
                                     （5）以VK_DYNAMIC_STATE_SAMPLE_MASK_EXT动态state开启创建，则vkCmdSetSampleMaskEXT必须在该命令之前设置
                                     （6）以VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT动态state开启创建，则vkCmdSetAlphaToCoverageEnableEXT必须在该命令之前设置
                                     （7）以VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT动态state开启创建，则最近的vkCmdSetAlphaToCoverageEnableEXT设置alphaToCoverageEnable为VK_TRUE，则Fragment Output Interface中 Index 0的Location 0必须有一个含alpha Component的变量
                                     （8）以VK_DYNAMIC_STATE_ALPHA_TO_ONE_ENABLE_EXT动态state开启创建，则vkCmdSetAlphaToOneEnableEXT必须在该命令之前设置
                                     （9）以VK_DYNAMIC_STATE_LOGIC_OP_ENABLE_EXT动态state开启创建，则vkCmdSetLogicOpEnableEXT必须在该命令之前设置
                                     （10）以VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态state开启创建，则vkCmdSetColorBlendEnableEXT必须在该命令之前设置
                                     （11）以VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT动态state开启创建，则vkCmdSetColorBlendEquationEXT必须在该命令之前设置
                                     （12）以VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT动态state开启创建，则vkCmdSetColorWriteMaskEXT必须在该命令之前设置
    
     99.如果一个shader object绑定到VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT stage，则vkCmdSetTessellationDomainOriginEXT必须在该命令之前设置
     100.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                                     （1）如果depthClamp特性启用，则vkCmdSetDepthClampEnableEXT必须在该命令之前设置
                                                     （2）则vkCmdSetPolygonModeEXT必须在该命令之前设置
                                                     （3）则vkCmdSetRasterizationSamplesEXT必须在该命令之前设置
                                                     （4）则vkCmdSetSampleMaskEXT必须在该命令之前设置
                                                     （5）则vkCmdSetAlphaToCoverageEnableEXT必须在该命令之前设置
                                                     （6）如果alphaToOne特性启用，则vkCmdSetAlphaToOneEnableEXT必须在该命令之前设置
    
     101.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetAlphaToCoverageEnableEXT设置alphaToCoverageEnable为VK_TRUE，则Fragment Output Interface中 Index 0的Location 0必须有一个含alpha Component的变量
     102.如果一个shader object绑定到VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                         （1）如果logicOp特性开启 ,vkCmdSetLogicOpEnableEXT必须在该命令之前设置
                                         （2）如果绑定了color attachments，则vkCmdSetColorBlendEnableEXT必须在该命令之前设置
                                         （3）如果最近的vkCmdSetColorBlendEnableEXT设置任何附件在pColorBlendEnables中的值为VK_TRUE ，则vkCmdSetColorBlendEquationEXT必须在该命令之前设置
                                         （4）如果绑定了color attachments，则vkCmdSetColorWriteMaskEXT必须在该命令之前设置
    
     103.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT动态state开启创建，则vkCmdSetRasterizationStreamEXT必须在该命令之前设置
                                      （2）以VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT动态state开启创建，则vkCmdSetConservativeRasterizationModeEXT必须在该命令之前设置
                                      （3）以VK_DYNAMIC_STATE_EXTRA_PRIMITIVE_OVERESTIMATION_SIZE_EXT动态state开启创建，则vkCmdSetExtraPrimitiveOverestimationSizeEXT必须在该命令之前设置
                                      （4）以VK_DYNAMIC_STATE_DEPTH_CLIP_ENABLE_EXT动态state开启创建，则vkCmdSetDepthClipEnableEXT必须在该命令之前设置
                                      （5）以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT动态state开启创建，则vkCmdSetSampleLocationsEnableEXT必须在该命令之前设置
                                      （6）以VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT动态state开启创建，则vkCmdSetColorBlendAdvancedEXT必须在该命令之前设置
                                      （7）以VK_DYNAMIC_STATE_PROVOKING_VERTEX_MODE_EXT动态state开启创建，则vkCmdSetProvokingVertexModeEXT必须在该命令之前设置
                                      （8）以VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT动态state开启创建，则vkCmdSetLineRasterizationModeEXT必须在该命令之前设置
                                      （9）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT动态state开启创建，则vkCmdSetLineStippleEnableEXT必须在该命令之前设置
                                      （10）以VK_DYNAMIC_STATE_LINE_STIPPLE_KHR动态state开启创建，则vkCmdSetLineStippleKHR必须在该命令之前设置
                                      （11）以VK_DYNAMIC_STATE_DEPTH_CLIP_NEGATIVE_ONE_TO_ONE_EXT动态state开启创建，则vkCmdSetDepthClipNegativeOneToOneEXT必须在该命令之前设置
                                      （12）以VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_ENABLE_NV动态state开启创建，则vkCmdSetViewportWScalingEnableNV必须在该命令之前设置
                                      （13）以VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV动态state开启创建，则vkCmdSetViewportSwizzleNV必须在该命令之前设置
                                      （14）以VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV动态state开启创建，则vkCmdSetCoverageToColorEnableNV必须在该命令之前设置
                                      （15）以VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_LOCATION_NV动态state开启创建，则vkCmdSetCoverageToColorLocationNV必须在该命令之前设置
                                      （16）以VK_DYNAMIC_STATE_COVERAGE_MODULATION_MODE_NV动态state开启创建，则vkCmdSetCoverageModulationModeNV必须在该命令之前设置
                                      （17）以VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV动态state开启创建，则vkCmdSetCoverageModulationTableEnableNV必须在该命令之前设置
                                      （18）以VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_NV动态state开启创建，则vkCmdSetCoverageModulationTableNV必须在该命令之前设置
                                      （19）以VK_DYNAMIC_STATE_SHADING_RATE_IMAGE_ENABLE_NV动态state开启创建，则vkCmdSetShadingRateImageEnableNV必须在该命令之前设置
                                      （20）以VK_DYNAMIC_STATE_REPRESENTATIVE_FRAGMENT_TEST_ENABLE_NV动态state开启创建，则vkCmdSetRepresentativeFragmentTestEnableNV必须在该命令之前设置
                                      （21）以VK_DYNAMIC_STATE_COVERAGE_REDUCTION_MODE_NV动态state开启创建，则vkCmdSetCoverageReductionModeNV必须在该命令之前设置
    
     104.如果一个shader object绑定到VK_SHADER_STAGE_GEOMETRY_BIT stage，且如果geometryStreams 特性开启，则vkCmdSetRasterizationStreamEXT必须在该命令之前设置
     105.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                             （1）如果VK_EXT_conservative_rasterization 拓展开启，vkCmdSetConservativeRasterizationModeEXT必须在该命令之前设置
                             （2）如果VK_EXT_conservative_rasterization 拓展开启，且最近的vkCmdSetConservativeRasterizationModeEXT设置conservativeRasterizationMode为VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT，则vkCmdSetExtraPrimitiveOverestimationSizeEXT必须在该命令之前设置
                             （3）如果VK_EXT_sample_locations 拓展开启，则vkCmdSetSampleLocationsEnableEXT必须在该命令之前设置
     106.如果一个shader object绑定到任何graphics stage，且depthClipEnable 特性开启，则vkCmdSetDepthClipEnableEXT必须在该命令之前设置
     107.如果如果一个shader object绑定到任何VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且如果VK_EXT_blend_operation_advanced 拓展开启，则vkCmdSetColorBlendEquationEXT 和 vkCmdSetColorBlendAdvancedEXT中至少一个必须在该命令之前设置
     108.如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，如果VK_EXT_provoking_vertex拓展开启， 则vkCmdSetProvokingVertexModeEXT必须在该命令之前设置
     109.如果VK_KHR_line_rasterization 或者 VK_EXT_line_rasterization拓展开启，则（1）如果一个shader object绑定到任意一个graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetPolygonModeEXT设置polygonMode 为VK_POLYGON_MODE_LINE ，则vkCmdSetLineRasterizationModeEXT必须在该命令之前设置
                                                                                 （2）如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetPrimitiveTopology设置primitiveTopology 为任何line topology ，则vkCmdSetLineRasterizationModeEXT必须在该命令之前设置
                                                                                 （3）如果一个输出为line primitive的shader object绑定到VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或 VK_SHADER_STAGE_GEOMETRY_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则vkCmdSetLineRasterizationModeEXT必须在该命令之前设置
                                                                                 （4）如果一个shader object绑定到任意一个graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetPolygonModeEXT设置polygonMode 为VK_POLYGON_MODE_LINE ，则vkCmdSetLineStippleEnableEXT必须在该命令之前设置
                                                                                 （5）如果一个shader object绑定到VK_SHADER_STAGE_VERTEX_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetPrimitiveTopology设置primitiveTopology 为任何line topology ，则vkCmdSetLineStippleEnableEXT必须在该命令之前设置
                                                                                 （6）如果一个输出为line primitive的shader object绑定到VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或 VK_SHADER_STAGE_GEOMETRY_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则vkCmdSetLineStippleEnableEXT必须在该命令之前设置
                                                                                 （7）如果一个shader object绑定到任意一个graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，且最近的vkCmdSetLineStippleEnableEXT设置stippledLineEnable 为VK_TRUE ，则vkCmdSetLineStippleEXT必须在该命令之前设置
     110.如果一个shader object绑定到任何graphics stage，（1）如果depthClipControl 特性开启，则vkCmdSetDepthClipNegativeOneToOneEXT必须在该命令之前设置
                                                        （2）VK_NV_clip_space_w_scaling 拓展开启，则vkCmdSetViewportWScalingEnableNV必须在该命令之前设置
                                                        （3）VK_NV_viewport_swizzle 拓展开启，则vkCmdSetViewportSwizzleNV必须在该命令之前设置
     111.如果如果一个shader object绑定到任何VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                         （1）如果VK_NV_fragment_coverage_to_color 拓展开启，则vkCmdSetCoverageToColorEnableNV 必须在该命令之前设置
                         （2）如果VK_NV_fragment_coverage_to_color 拓展开启，且最近的vkCmdSetCoverageToColorEnableNV 设置coverageToColorEnable 为VK_TRUE，则vkCmdSetCoverageToColorLocationNV 必须在该命令之前设置
                         （3）如果pipelineFragmentShadingRate 特性开启，则vkCmdSetFragmentShadingRateKHR 必须在该命令之前设置
     112.如果一个shader object绑定到任何graphics stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                 （1）如果VK_NV_framebuffer_mixed_samples 拓展开启，则vkCmdSetCoverageModulationModeNV 必须在该命令之前设置
                                 （2）如果VK_NV_framebuffer_mixed_samples 拓展开启，且最近的vkCmdSetCoverageModulationModeNV设置coverageModulationMode为任何除VK_COVERAGE_MODULATION_MODE_NONE_NV之外的值，则vkCmdSetCoverageModulationTableEnableNV 必须在该命令之前设置
                                 （3）如果VK_NV_framebuffer_mixed_samples 拓展开启，最近的vkCmdSetCoverageModulationTableEnableNV设置coverageModulationTableEnable为VK_TRUE，则vkCmdSetCoverageModulationTableNV 必须在该命令之前设置
                                 （4）如果shadingRateImage 特性开启，则vkCmdSetShadingRateImageEnableNV 必须在该命令之前设置
                                 （5）如果representativeFragmentTest 特性开启，则vkCmdSetRepresentativeFragmentTestEnableNV 必须在该命令之前设置
                                 （6）如果coverageReductionMode 特性开启，则vkCmdSetCoverageReductionModeNV 必须在该命令之前设置
     113.如果绑定的graphics pipeline，（1）以VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态state开启创建，且最近的vkCmdSetColorBlendEnableEXT设置任何附件在pColorBlendEnables中的值为VK_TRUE 则subpas中这些附件对应的image view的format features中必须包含VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT
                                      （2）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，且当前subpass不使用任何color和/或者 depth/stencil attachments，则最后的vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples必须符合zero￾attachment subpass的规则
                                      （3）以VK_DYNAMIC_STATE_SAMPLE_MASK_EXT不以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT 动态state开启创建，则最后调用的vkCmdSetSampleMaskEXT中设置的samples参数必须大于等于创建该pipeline的VkPipelineMultisampleStateCreateInfo::rasterizationSamples
                                      （4）以VK_DYNAMIC_STATE_SAMPLE_MASK_EXT和 VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT 动态state开启创建，则最后调用的vkCmdSetSampleMaskEXT中设置的samples参数必须大于等于最后的vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples
                                      （5）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，且VK_AMD_mixed_attachment_samples和VK_NV_framebuffer_mixed_samples拓展都没有开启，则最后的vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples必须等于subpass中color和/或者 depth/stencil attachments使用的相同
                                      （6）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，或者一个shader object绑定到任意graphics stage，且当前的subpass包含一个multisampledRenderToSingleSampledEnable 为VK_TRUE的VkMultisampledRenderToSingleSampledInfoEXT，则最后的vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples必须等于该VkMultisampledRenderToSingleSampledInfoEXT中的对应成员
                                      （7）以VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态state开启创建，则vkCmdSetColorBlendEnableEXT 必须在该命令之前设置，且vkCmdSetColorBlendEnableEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定值
                                      （8）以VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT动态state开启创建，则vkCmdSetColorBlendEquationEXT 必须在该命令之前设置，且vkCmdSetColorBlendEquationEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定blend equations
                                      （9）以VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT动态state开启创建，则vkCmdSetColorWriteMaskEXT 必须在该命令之前设置，且vkCmdSetColorWriteMaskEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定color write mask
                                      （10）以VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT动态state开启创建，则vkCmdSetColorBlendAdvancedEXT 必须在该命令之前设置，且vkCmdSetColorBlendAdvancedEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活blend的color attachments指定advanced blend equations
                                      （11）以VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT和VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT动态state开启创建，且最后的vkCmdSetColorBlendEnableEXT和vkCmdSetColorBlendAdvancedEXT设置启用了advanced blending，则当前subpass中激活的color attachments的数量不能超过advancedBlendMaxColorAttachments
                                      （12）以VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT动态state开启创建，且如果primitivesGeneratedQueryWithNonZeroStreams特性未开启且VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query已经激活，则最后的vkCmdSetRasterizationStreamEXT必须设置rasterizationStream为0
                                      （13）以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT但不以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，则最后的vkCmdSetSampleLocationsEXT设置的pSampleLocationsInfo->sampleLocationsPerPixel必须等于创建pipeline的VkPipelineMultisampleStateCreateInfo::rasterizationSamples
                                      （14）以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT和VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT动态state开启创建，则最后的vkCmdSetSampleLocationsEXT设置的pSampleLocationsInfo->sampleLocationsPerPixel必须等于最后vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples
                                      （15）以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT但不以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT动态state开启创建，且绑定的pipeline的VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable为VK_TRUE 或者以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT动态state开启，则sampleLocationsInfo.sampleLocationsPerPixel 必须等于最后vkCmdSetRasterizationSamplesEXT设置的rasterizationSamples
                                      （16）以VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV动态state开启创建，且最后的vkCmdSetCoverageToColorEnableNV设置coverageToColorEnable为VK_TRUE，则当前subpass必须有color attachment，且该attachment的format必须为VK_FORMAT_R8_UINT, VK_FORMAT_R8_SINT, VK_FORMAT_R16_UINT, VK_FORMAT_R16_SINT, VK_FORMAT_R32_UINT, 或者 VK_FORMAT_R32_SINT，且该attachment的location 有最后的vkCmdSetCoverageToColorLocationNV设置的coverageToColorLocation决定
                                      （17）以VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV和VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT 动态state开启创建，且如果VK_NV_coverage_reduction_mode 拓展开启，则当前的 coverageReductionMode，rasterizationSamples 以及color 以及 depth/stencil attachments（如果subpass有）的sample count必须是有效的返回值vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV的值的组合
                                      （18）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT但不以VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV 动态state开启创建，则绑定的graphics pipeline的VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount 必须大于等于最后vkCmdSetViewportWithCount设置的viewportCount
                                      （19）以VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT和VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV 动态state开启创建，则最后vkCmdSetViewportSwizzleNV设置的viewportCount 必须大于等于最后vkCmdSetViewportWithCount设置的viewportCount
                                      （20）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT或者 VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT 动态state开启创建，如果当前的stippledLineEnable为VK_TRUE，且当前的lineRasterizationMode为VK_LINE_RASTERIZATION_MODE_RECTANGULAR_KHR，则stippledRectangularLines 特性必须开启
                                      （21）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT或者 VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT 动态state开启创建，如果当前的stippledLineEnable为VK_TRUE，且当前的lineRasterizationMode为VK_LINE_RASTERIZATION_MODE_BRESENHAM_KHR，则stippledBresenhamLines 特性必须开启
                                      （22）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT或者 VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT 动态state开启创建，如果当前的stippledLineEnable为VK_TRUE，且当前的lineRasterizationMode为VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_KHR，则stippledSmoothLines 特性必须开启
                                      （23）以VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT或者 VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT 动态state开启创建，如果当前的stippledLineEnable为VK_TRUE，且当前的lineRasterizationMode为VK_LINE_RASTERIZATION_MODE_DEFAULT_KHR，则stippledRectangularLines 特性必须开启且VkPhysicalDeviceLimits::strictLines 必须为VK_TRUE
                                      （24）以VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT 动态state开启创建，且conservativePointAndLineRasterization不支持，最后的 pre-rasterization shader stage输出的有效图元拓扑为点或者线，则最后vkCmdSetConservativeRasterizationModeEXT设置的conservativeRasterizationMode 必须为VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT
                                      （25）以VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT 动态state开启创建，则vkCmdSetAttachmentFeedbackLoopEnableEXT 必须在该命令之前调用
     114.如果一个shader object绑定到 VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则
                                                                                         （1）则vkCmdSetColorBlendEnableEXT 必须在该命令之前设置，且vkCmdSetColorBlendEnableEXT指定的firstAttachment开始的attachmentCount的值必须为当前subpass所有激活的color attachments指定
                                                                                         （2）则vkCmdSetColorBlendEquationEXT 必须在该命令之前设置，且vkCmdSetColorBlendEquationEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定blend equations
                                                                                         （3）则vkCmdSetColorWriteMaskEXT 必须在该命令之前设置，且vkCmdSetColorWriteMaskEXT必须为从firstAttachment开始的attachmentCount个当前subpass所有激活的color attachments指定color write mask
                                                                                         （4）如果VK_NV_fragment_coverage_to_color拓展开启， 最后的vkCmdSetCoverageToColorEnableNV设置coverageToColorEnable为VK_TRUE，则当前subpass必须有color attachment，且该attachment的format必须为VK_FORMAT_R8_UINT, VK_FORMAT_R8_SINT, VK_FORMAT_R16_UINT, VK_FORMAT_R16_SINT, VK_FORMAT_R32_UINT, 或者 VK_FORMAT_R32_SINT，且该attachment的location 有最后的vkCmdSetCoverageToColorLocationNV设置的coverageToColorLocation决定
     115.如果一个shader object绑定到 VK_SHADER_STAGE_FRAGMENT_BIT stage，（1）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT动态state开启创建，且最近的vkCmdSetSampleLocationsEnableEXT设置sampleLocationsEnable为VK_TRUE，且该subpass含有depth/stencil attachment，则该附件必须以VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT创建
                                                                         （2）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT和VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT 动态state开启创建，且最近的vkCmdSetSampleLocationsEnableEXT设置sampleLocationsEnable为VK_TRUE，则 最后vkCmdSetSampleLocationsEXT设置的sampleLocationsInfo.sampleLocationGridSize.width以及height 必须等于被调用vkGetPhysicalDeviceMultisamplePropertiesEXT传入rasterizationSamples返回的VkMultisamplePropertiesEXT::sampleLocationGridSize.width以及height一一对应均匀整除
                                                                         （3）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT 动态state开启创建，且最近的vkCmdSetSampleLocationsEnableEXT设置sampleLocationsEnable为VK_TRUE，则fragment shader代码中不能静态使用扩展指令InterpolateAtSample
                                                                         （4）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT但不以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT 动态state开启创建，且绑定的pipeline的VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable为VK_TRUE 或者以VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT动态state开启，则 最后vkCmdSetRasterizationSamplesEXT设置的sampleLocationsInfo.sampleLocationGridSize.width以及height 必须等于被调用vkGetPhysicalDeviceMultisamplePropertiesEXT传入和vkCmdSetRasterizationSamplesEXT设置的相同rasterizationSamples的samples返回的VkMultisamplePropertiesEXT::sampleLocationGridSize.width以及height一一对应均匀整除
     116.如果一个shader object绑定到任何graphics stage，（1）如果绑定的graphics pipeline以VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV 动态state开启创建，且最近的vkCmdSetCoverageModulationTableEnableNV设置coverageModulationTableEnable为VK_TRUE，则最近的vkCmdSetCoverageModulationTableNV 设置的coverageModulationTableCount 必须等于当前rasterizationSamples除以当前subppas的color samples
                                                        （2）如果VK_NV_viewport_swizzle 拓展开启，则最后vkCmdSetViewportSwizzleNV设置的viewportCount 必须大于等于最后vkCmdSetViewportWithCount设置的viewportCount
     117.如果VK_NV_framebuffer_mixed_samples 拓展开启，且如果在绑定的graphics pipeline中当前subpass有一个depth/stencil attachment以及dep test, stencil test, 或depth bounds test 启用，则当前rasterizationSamples 必须等于depth/stencil attachment的sample count
     118.如果VK_NV_framebuffer_mixed_samples 拓展开启，且如果最后的vkCmdSetRasterizationSamplesEXT设置的当前subpass的任何color attachments的rasterizationSamples 都大于 color samples，则sampleShadingEnable 必须为VK_FALSE
     119.如果当前绑定的graphics pipeline以VkGraphicsPipelineCreateInfo::pStages中的元素的VkPipelineShaderStageCreateInfo::stage设置为VK_SHADER_STAGE_VERTEX_BIT, VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT, VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或者 VK_SHADER_STAGE_GEOMETRY_BIT创建，则Mesh Shader Queries 不能激活
     120.如果dynamic state继承自VkCommandBufferInheritanceViewportScissorInfoNV，则这些动态state的设置必须在该命令之前设置
     121.如果没有绑定graphics pipeline，则（1）vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_VERTEX_BIT
                                          （2）如果tessellationShader 特性开启，vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT，VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT
                                          （3）如果geometryShader 特性开启，vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_GEOMETRY_BIT
                                          （4）vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_FRAGMENT_BIT
                                          （5）如果taskShader 特性开启，vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_TASK_BIT_EXT
                                          （6）如果meshShader 特性开启，vkCmdBindShadersEXT必须在当前command buffer中调用，且参数pStages中含有一个VK_SHADER_STAGE_MESH_BIT_EXT
                                          （8）如果至少taskShader 和 meshShader一个特性开启，VK_SHADER_STAGE_VERTEX_BIT 或者VK_SHADER_STAGE_MESH_BIT_EXT stages中的一个必须含有有效的VkShaderEXT绑定，另外一个则不含有VkShaderEXT绑定
                                          （9）如果taskShader 和 meshShader特性同时开启，且一个有效的VkShaderEXT 绑定到VK_SHADER_STAGE_MESH_BIT_EXT stage，且该VkShaderEXT不以VK_SHADER_CREATE_NO_TASK_SHADER_BIT_EXT 创建，则一个有效的VkShaderEXT必须绑定到VK_SHADER_STAGE_TASK_BIT_EXT stage
                                          （10）如果taskShader 和 meshShader特性同时开启，且一个有效的VkShaderEXT 绑定到VK_SHADER_STAGE_MESH_BIT_EXT stage，且该VkShaderEXT以VK_SHADER_CREATE_NO_TASK_SHADER_BIT_EXT 创建，则不能有VkShaderEXT绑定到VK_SHADER_STAGE_TASK_BIT_EXT stage
                                          （11）如果一个有效的VkShaderEXT 绑定到VK_SHADER_STAGE_VERTEX_BIT stage，则不能有VkShaderEXT绑定到VK_SHADER_STAGE_TASK_BIT_EXT stage或者VK_SHADER_STAGE_MESH_BIT_EXT stage中的一个
     122.如果任何绑定的graphics shader以VK_SHADER_CREATE_LINK_STAGE_BIT_EXT 创建，（1）所有在相同vkCreateShadersEXT中以VK_SHADER_CREATE_LINK_STAGE_BIT_EXT创建的shaders必须也要绑定
                                                                                  （2）任何相同vkCreateShadersEXT中不以VK_SHADER_CREATE_LINK_STAGE_BIT_EXT创建的shaders不能有任何VkShaderEXT绑定
     123.所有绑定的graphics shader objects 必须以相同或者相同定义的push constant ranges创建
     124.所有绑定的graphics shader objects 必须以相同或者相同定义的descriptor set layouts的数组创建
     125.如果当前的render pass instance以vkCmdBeginRendering开始，且VkRenderingInfo::colorAttachmentCount为1，且有一个resolve mode为 VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID 的color attachment，且绑定了fragment shader，则DepthReplacing 和 StencilRefReplacingEXT execution modes 不能声明
     126.如果一个shader object绑定到 VK_SHADER_STAGE_FRAGMENT_BIT stage，且最近的vkCmdSetRasterizerDiscardEnable设置rasterizerDiscardEnable为VK_FALSE，则 （1）如果attachmentFeedbackLoopDynamicState 特性开启，则 vkCmdSetAttachmentFeedbackLoopEnableEXT 必须在该命令之前调用
     127.如果包含一个fragment shader stage的绑定的graphics pipeline，（1）且该pipeline以VkPipelineDynamicStateCreateInfo::pDynamicStates中设置有VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE创建，且该fragment shader声明了EarlyFragmentTests execution mode且使用了OpDepthAttachmentReadEXT，则最后vkCmdSetDepthWriteEnable 设置的 depthWriteEnable 必须为VK_FALSE
                                                                     （2）且该pipeline以VkPipelineDynamicStateCreateInfo::pDynamicStates中设置有VK_DYNAMIC_STATE_STENCIL_WRITE_MASK创建，且该fragment shader声明了EarlyFragmentTests execution mode且使用了OpStencilAttachmentReadEXT，则最后vkCmdSetStencilWriteMask 设置的 writeMask 必须为0
     128.如果一个shader object绑定到任何graphics stage 或者绑定的graphics pipeline 以VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT 动态state开启创建，且任何color attachment的format为VK_FORMAT_E5B9G9R9_UFLOAT_PACK32，则vkCmdSetColorWriteMaskEXT设置的pColorWriteMasks参数的对应元素必须包含VK_COLOR_COMPONENT_R_BIT, VK_COLOR_COMPONENT_G_BIT, 和 VK_COLOR_COMPONENT_B_BIT，或者都不包含
     129.如果任何附件开启了blending，且该附件的source 或者 destination blend factors使用第二个颜色输入，则该命令执行的Fragment Execution Model静态使用的任何输出output attachment的Location的最大值必须小于maxFragmentDualSrcAttachments
     130.如果当前的render pass instance以vkCmdBeginRendering开始，（1）如果没有任何shader object绑定到任何graphics stage，则vkCmdSetRenderingAttachmentLocationsKHR 设置的VkRenderingAttachmentLocationInfoKHR::pColorAttachmentLocations中的每个元素必须匹配设置在当前绑定的graphics pipeline中的对应元素
                                                                  （2）如果没有任何shader object绑定到任何graphics stage，绑定的graphics pipeline中的input attchment 索引中映射的附件必须匹配在当前render pass instance的VkRenderingInputAttachmentIndexInfoKHR中设置的
     131.如果当前的render pass instance以vkCmdBeginRendering开始且以VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT标志开始，则绑定的graphics pipeline必须以VK_PIPELINE_CREATE_2_ENABLE_LEGACY_DITHERING_BIT_EXT创建
     132.如果绑定的graphics pipeline以VK_PIPELINE_CREATE_2_ENABLE_LEGACY_DITHERING_BIT_EXT创建，则当前的render pass 必须以vkCmdBeginRendering开始且以VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT标志开始
     133.绑定的graphics pipeline不能以VkGraphicsPipelineCreateInfo::pStages中元素的VkPipelineShaderStageCreateInfo::stage设置为VK_SHADER_STAGE_VERTEX_BIT, VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT, VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT 或者 VK_SHADER_STAGE_GEOMETRY_BIT创建
     134.Transform Feedback Queries不能激活
     135.Primitives Generated Queries不能激活
     136.用于创建任何激活的Pipeline Statistics Query的pipelineStatistics 不能包含VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT,
                                                                                 VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT,
                                                                                 VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT,
                                                                                 VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT,
                                                                                 VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT,
                                                                                 VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT,
                                                                                 VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT,
                                                                                 VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT, 或者
                                                                                 VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT
     137.如果multiDrawIndirect 特性未开启，drawCount 必须为0 或 1
     138.绑定到VK_PIPELINE_BIND_POINT_GRAPHICS绑定点的当前pipeline必须包含一个使用ClusterCullingHUAWEI Execution Model的shader stage
     139.offset必须是VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI::indirectBufferOffsetAlignment的倍数
     */
}



NS_TEST_END