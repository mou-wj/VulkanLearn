#include "SyncronizationAndCacheControlTest.h"
#include <Windows.h>
#include <vulkan/vulkan_win32.h>
#include <winnt.h>
NS_TEST_BEGIN



//--------------------------------------------------------------------------
//管线阶段


//
//第一个同步域和第二个同步域的执行管线阶段和访问控制必须满足以下条件：
//在以一个同步域中执行的操作的管线阶段必须要为srcStage或者逻辑上早于该阶段的阶段，访问控制必须以srcAccessFlag所指定的进行
//，同理，目标阶段必须要为dstStage或者逻辑上晚于该阶段的阶段，访问控制必须以dstAccessFlag所指定的进行

enum class VkPipelineStageFlagBitsWithNotation {
	VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT = 0x00000001, //相当于在第二个同步作用域中指定时将VkAccessFlags设置为0的且管线阶段为VK_PIPELINE_STAGE_ALL_COMMANDS_BIT，但在第一个作用域中指定时不指定任何执行阶段
	VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT = 0x00000002, //指示VkDrawIndirect* / VkDispatchIndirect* / VkTraceRaysIndirect *这类型数据结构使用的管线阶段，也包括读取vkCmdExecuteGeneratedCommandsNV中记录的指令缓冲区的阶段
	VK_PIPELINE_STAGE_VERTEX_INPUT_BIT = 0x00000004, //指定管道的顶点输入阶段
	VK_PIPELINE_STAGE_VERTEX_SHADER_BIT = 0x00000008, //指示顶点着色器阶段
	VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT = 0x00000010, //指示曲面细分控制着色器
	VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT = 0x00000020, //指示曲面细分评估着色器
	VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT = 0x00000040, //指示几何着色器
	VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT = 0x00000080, //指示片段着色器
	VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT = 0x00000100, //指定执行在片段着色器阶段前的深度/模板测试的管道阶段（片段着色之前的深度和模板测试）。此阶段还包括对具有深度/模板格式的frame缓冲区附件的render pass加载操作。
	VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT = 0x00000200, //指定执行在片段着色器阶段后的深度/模板测试的管道阶段（片段着色之后的深度和模板测试）。此阶段还包括对具有深度/模板格式的frame缓冲区附件的render pass存储操作。
	VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT = 0x00000400, //指定混合后的管道阶段，其中最终颜色值从管道输出。这个阶段包括混合、逻辑操作、颜色附件的渲染传递加载和存储操作、render pass的resolve操作和vkCmdClearAttachments.。
	VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT = 0x00000800, //指示计算着色器
	VK_PIPELINE_STAGE_TRANSFER_BIT = 0x00001000, 
	/**
	 * 指示以下操作的管线阶段：
	 * 所有复制操作，包括vkCmdCopyQueryPoolResults
	 * vkCmdBlitImage2 和 vkCmdBlitImage
	 * vkCmdResolveImage2 和 vkCmdResolveImage
	 * 所有清除操作，除了vkCmdClearAttachments
	*/
	VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT = 0x00002000, //相当于在第一个同步作用域中指定时将VkAccessFlags设置为0的且管线阶段为VK_PIPELINE_STAGE_ALL_COMMANDS_BIT，但在第二个作用域中指定时不指定任何执行阶段
	VK_PIPELINE_STAGE_HOST_BIT = 0x00004000, //指定指示在设备内存的读写主机上执行的伪阶段。在命令缓冲区中记录的任何命令都不会触发此阶段。
	VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT = 0x00008000, 
	/**
	 * 指示所有图形管线阶段，等价于
	 * VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT | VK_PIPELINE_STAGE_TASK_SHADER_BIT_EXT | VK_PIPELINE_STAGE_MESH_SHADER_BIT_EXT
	 * | VK_PIPELINE_STAGE_VERTEX_INPUT_BIT | VK_PIPELINE_STAGE_VERTEX_SHADER_BIT | VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT
     * | VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT | VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT | VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT
     * | VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT | VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT | VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT
     * | VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT | VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT | VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR
     * | VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT
	*/
	VK_PIPELINE_STAGE_ALL_COMMANDS_BIT = 0x00010000, ////指定在它commandbuffer提交使用的队列上所支持的所有命令所执行的所有管线阶段。
	VK_PIPELINE_STAGE_NONE = 0, //指示不清楚管线阶段
	VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT = 0x01000000, //指定将顶点属性输出值写入转换反馈缓冲区的管道的阶段。
	VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT = 0x00040000, //指定使用条件呈现的谓词的管道的阶段。
	VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR = 0x02000000,
	/**
	 * 指示以下命令执行的管线阶段
	 * vkCmdBuildAccelerationStructureNV, vkCmdCopyAccelerationStructureNV,
     * vkCmdWriteAccelerationStructuresPropertiesNV , vkCmdBuildAccelerationStructuresKHR,
	 * vkCmdBuildAccelerationStructuresIndirectKHR, vkCmdCopyAccelerationStructureKHR,
	 * vkCmdCopyAccelerationStructureToMemoryKHR,
	 * vkCmdCopyMemoryToAccelerationStructureKHR,
	 * vkCmdWriteAccelerationStructuresPropertiesKHR.
	*/
	VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR = 0x00200000,//指示通过vkCmdTraceRaysNV , vkCmdTraceRaysKHR, 或者 vkCmdTraceRaysIndirectKHR执行的光线追踪着色器阶段
	VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT = 0x00800000,//指定读取片段着色速率附着或着色速率图像，以确定光栅格化原体部分的片段着色速率的管道的阶段。
	VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x00400000,// 指定读取片段密度映射以生成片段区域的管道的阶段。
	VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV = 0x00020000,//指定通过vkCmdPreprocessGeneratedCommandsNV处理设备生成命令的管道阶段
	VK_PIPELINE_STAGE_TASK_SHADER_BIT_EXT = 0x00080000,//指示任务着色器
	VK_PIPELINE_STAGE_MESH_SHADER_BIT_EXT = 0x00100000,//指示网格着色器
	VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV = VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR,//指示着色率图像
	VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV = VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR,//指示光线追踪着色器
	VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV = VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR,//指示加速结构构建
	VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV = VK_PIPELINE_STAGE_TASK_SHADER_BIT_EXT,//指示任务着色器
	VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV = VK_PIPELINE_STAGE_MESH_SHADER_BIT_EXT,//指示网格着色器
	VK_PIPELINE_STAGE_NONE_KHR = VK_PIPELINE_STAGE_NONE,//指示不确定管线状态
	VK_PIPELINE_STAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF//指示标志位的最大值

} ;



enum class VkPipelineStageFlagBits2WithNotation {
   VK_PIPELINE_STAGE_2_NONE = 0ULL,//指示不确定管线状态
   VK_PIPELINE_STAGE_2_NONE_KHR = 0ULL,
   VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT = 0x00000001ULL,//相当于在第二个同步作用域中指定时将VkAccessFlags2设置为0且管线阶段为VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT，以及相当于第一个同步作用域中的管线阶段为VK_PIPELINE_STAGE_2_NONE。
   VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT_KHR = 0x00000001ULL,
   VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT = 0x00000002ULL,//指定使用间接命令参数的管道的阶段。这个阶段还包括读取由vkCmdPreprocessGeneratedCommandsNV.编写的命令
   VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT_KHR = 0x00000002ULL,
   VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT = 0x00000004ULL,//指定管道的顶点输入阶段，相当于 VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT | VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT
   VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT_KHR = 0x00000004ULL,
   VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT = 0x00000008ULL,//顶点着色器阶段
   VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT_KHR = 0x00000008ULL,
   VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT = 0x00000010ULL,//曲面细分控制着色器阶段
   VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT_KHR = 0x00000010ULL,
   VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT = 0x00000020ULL,//曲面细分计算着色器阶段
   VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT_KHR = 0x00000020ULL,
   VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT = 0x00000040ULL,//几何着色器阶段
   VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT_KHR = 0x00000040ULL,
   VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT = 0x00000080ULL,//片段着色器阶段
   VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT_KHR = 0x00000080ULL,
   VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT = 0x00000100ULL,//指定执行在片段之前进行深度和模板测试的管道阶段（片段着色之前的深度和模板测试）
   VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT_KHR = 0x00000100ULL,
   VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT = 0x00000200ULL,//指定执行在片段之后进行深度和模板测试的管道阶段（片段着色之后的深度和模板测试）
   VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT_KHR = 0x00000200ULL,
   VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT = 0x00000400ULL,//指定从管道中输出最终颜色值的管道的阶段
   VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT_KHR = 0x00000400ULL,
   VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT = 0x00000800ULL,//计算着色器阶段
   VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT_KHR = 0x00000800ULL,
   VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT = 0x00001000ULL, 
	/**
    * 等价于
	*  VK_PIPELINE_STAGE_2_COPY_BIT | VK_PIPELINE_STAGE_2_BLIT_BIT | VK_PIPELINE_STAGE_2_RESOLVE_BIT
    *  VK_PIPELINE_STAGE_2_CLEAR_BIT | VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR
   */
   VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT_KHR = 0x00001000ULL,
   VK_PIPELINE_STAGE_2_TRANSFER_BIT = 0x00001000ULL,
   VK_PIPELINE_STAGE_2_TRANSFER_BIT_KHR = 0x00001000ULL,
   VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT = 0x00002000ULL,//相当于第一个同步作用域的管线阶段为VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT，并将VkAccessFlags2设置为0，以及将第二个作用域中的VK_PIPELINE_STAGE_2_NONE。
   VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT_KHR = 0x00002000ULL,
   VK_PIPELINE_STAGE_2_HOST_BIT = 0x00004000ULL,//指定指示在设备内存的读写主机上执行的伪阶段。在命令缓冲区中记录的任何命令都不会触发此阶段。
   VK_PIPELINE_STAGE_2_HOST_BIT_KHR = 0x00004000ULL,
   VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT = 0x00008000ULL,
   /**
	* 指定所有图形管道阶段，等价于
	* VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT | VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT |VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT
    * VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT | VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT | VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT
    * VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT | VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT
	* VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT | VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT | VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT
	* VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT | VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT | VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT
    * VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR | VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT | VK_PIPELINE_STAGE_2_SUBPASS_SHADER_BIT_HUAWEI
	* VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI | VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI
   */
   VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT_KHR = 0x00008000ULL,
   VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT = 0x00010000ULL,//指定在它commandbuffer提交使用的队列上所支持的所有命令所执行的所有管线阶段。
   VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT_KHR = 0x00010000ULL,
   VK_PIPELINE_STAGE_2_COPY_BIT = 0x100000000ULL,//指定使用复制命令的管道的阶段。包括vkCmdCopyQueryPoolResults
   VK_PIPELINE_STAGE_2_COPY_BIT_KHR = 0x100000000ULL,
   VK_PIPELINE_STAGE_2_RESOLVE_BIT = 0x200000000ULL,//指定vkCmdResolveImage执行的管线阶段
   VK_PIPELINE_STAGE_2_RESOLVE_BIT_KHR = 0x200000000ULL,
   VK_PIPELINE_STAGE_2_BLIT_BIT = 0x400000000ULL,//指定vkCmdBlitImage执行的管线阶段
   VK_PIPELINE_STAGE_2_BLIT_BIT_KHR = 0x400000000ULL,
   VK_PIPELINE_STAGE_2_CLEAR_BIT = 0x800000000ULL,//指定清除命令的管道的阶段，除了vkCmdClearAttachments
   VK_PIPELINE_STAGE_2_CLEAR_BIT_KHR = 0x800000000ULL,
   VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT = 0x1000000000ULL,// 指定使用索引缓冲区的管道的阶段。
   VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT_KHR = 0x1000000000ULL,
   VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT = 0x2000000000ULL,//指定使用顶点属性的管道的阶段。
   VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT_KHR = 0x2000000000ULL,
   VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT = 0x4000000000ULL,
   /**
    *  指定在光栅化之前运行的着色器的管道阶段。相当于 
    *  VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT | VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT | VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT | VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT
 |  *  VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT | VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT | VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI
   */
   VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT_KHR = 0x4000000000ULL,
   VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR = 0x04000000ULL,//指定将视频解码操作的管线阶段。
#ifdef VK_ENABLE_BETA_EXTENSIONS
   VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR = 0x08000000ULL,//指定将视频编码操作的管线阶段。
#endif
   VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT = 0x01000000ULL,//指定将顶点属性输出值写入转换反馈缓冲区的管道的阶段。
   VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT = 0x00040000ULL,//指定使用条件呈现的谓词的管道的阶段。
   VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV = 0x00020000ULL,//指定通过vkCmdPreprocessGeneratedCommandsNV处理设备生成命令的管道阶段
   VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x00400000ULL,//指定其中读取片段着色速率附着或着色速率图像，以确定光栅格化原体部分的片段着色速率的管道的阶段。
   VK_PIPELINE_STAGE_2_SHADING_RATE_IMAGE_BIT_NV = 0x00400000ULL,
   VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR = 0x02000000ULL,//指定加速结构命令或加速结构复制命令的执行管线阶段。
   VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR = 0x00200000ULL,//光线追踪着色器阶段
   VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_NV = 0x00200000ULL,
   VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_NV = 0x02000000ULL,
   VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT = 0x00800000ULL,//指定读取片段密度映射以生成片段区域的管道的阶段。
   VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_NV = 0x00080000ULL,
   VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_NV = 0x00100000ULL,
   VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT = 0x00080000ULL,//任务着色器阶段
   VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT = 0x00100000ULL,//Mesh着色器阶段
   VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI = 0x8000000000ULL,//指定在subpass执行的管道的阶段。
   VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI = 0x10000000000ULL,//指定由实现读取调用掩码图像以优化射线分派的管道的阶段。
   VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR = 0x10000000ULL,//指定加速结构复制命令的执行管线阶段。
   VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT = 0x40000000ULL,
   VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI = 0x20000000000ULL,//指定簇剔除着色器阶段。
   VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV = 0x20000000ULL//指定执行光流操作的管道的阶段
};



/**
 * @brief 检查某种类型的队列是否匹配指定的管线阶段
 * @param pipelineStageFlags2 待匹配的管线阶段标志
 * @param queueFamilyFlags 待匹配的队列类型标志
 * @return 
*/
bool CheckMatchPipelineStages2AndQueueFlags(VkPipelineStageFlags2 pipelineStageFlags2, VkQueueFlags queueFamilyFlags) {

	bool res = false;
	res |= (pipelineStageFlags2 == VK_PIPELINE_STAGE_2_NONE);
	res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT) == VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT;
	res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT) == VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT;
	res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_HOST_BIT) == VK_PIPELINE_STAGE_2_HOST_BIT;
	res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT) == VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT;
	if (queueFamilyFlags & VK_QUEUE_GRAPHICS_BIT) {
		//图形队列支持以下列举的阶段，就认为支持
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT) == VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT) == VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT) == VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT) == VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT) == VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT) == VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT) == VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT) == VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT) == VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT) == VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT) == VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT) == VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT;

		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_COPY_BIT) == VK_PIPELINE_STAGE_2_COPY_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_RESOLVE_BIT) == VK_PIPELINE_STAGE_2_RESOLVE_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_BLIT_BIT) == VK_PIPELINE_STAGE_2_BLIT_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_CLEAR_BIT) == VK_PIPELINE_STAGE_2_CLEAR_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT) == VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT) == VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT) == VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT;

		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT) == VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT) == VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV) == VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR) == VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR) == VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR;

		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT) == VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT) == VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT) == VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI) == VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI) == VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR) == VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI) == VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV) == VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV;


	}
	if (queueFamilyFlags & VK_QUEUE_COMPUTE_BIT) {
		//计算队列支持以下列举的阶段

		
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT) == VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT) == VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT) == VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_COPY_BIT) == VK_PIPELINE_STAGE_2_COPY_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_RESOLVE_BIT) == VK_PIPELINE_STAGE_2_RESOLVE_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_BLIT_BIT) == VK_PIPELINE_STAGE_2_BLIT_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_CLEAR_BIT) == VK_PIPELINE_STAGE_2_CLEAR_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT) == VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV) == VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR) == VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR) == VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR) == VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT) == VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT;

	}
	if (queueFamilyFlags & VK_QUEUE_TRANSFER_BIT) {

		//传输队列支持以下列举的阶段
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT) == VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_COPY_BIT) == VK_PIPELINE_STAGE_2_COPY_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_RESOLVE_BIT) == VK_PIPELINE_STAGE_2_RESOLVE_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_BLIT_BIT) == VK_PIPELINE_STAGE_2_BLIT_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_CLEAR_BIT) == VK_PIPELINE_STAGE_2_CLEAR_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR) == VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR;

	}
	if (queueFamilyFlags & VK_QUEUE_VIDEO_DECODE_BIT_KHR) {
		//视频解码队列支持以下列举的阶段
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR) == VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR;
	}
#ifdef VK_ENABLE_BETA_EXTENSIONS
	if (queueFamilyFlags & VK_QUEUE_VIDEO_ENCODE_BIT_KHR) {
		//视频解码队列支持以下列举的阶段
		res |= (pipelineStageFlags2 & VK_QUEUE_VIDEO_ENCODE_BIT_K) == VK_QUEUE_VIDEO_ENCODE_BIT_K;
}
#endif
	if (queueFamilyFlags & VK_QUEUE_OPTICAL_FLOW_BIT_NV) {
		//光流队列支持以下列举的阶段
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV) == VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV;
	}
	return res;
}


//------------------------------------------------------------------------------
// 访问控制


enum class VkAccessFlagBits2WithNotation
{
	VK_ACCESS_2_NONE = 0ULL,//未指定访问权限
	VK_ACCESS_2_NONE_KHR = 0ULL,
	VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT = 0x00000001ULL,//指定对从间接缓冲区读取的命令数据的读取访问，作为间接构建、跟踪、绘制或分派命令的一部分。发生在管线状态VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT
	VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT_KHR = 0x00000001ULL,
	VK_ACCESS_2_INDEX_READ_BIT = 0x00000002ULL,//指定对vkCmdBindIndexBuffer2KHR 和 vkCmdBindIndexBuffer绑定的索引缓冲区的读取访问,发生在管线状态VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT
	VK_ACCESS_2_INDEX_READ_BIT_KHR = 0x00000002ULL,
	VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT = 0x00000004ULL,//指定对vkCmdBindVertexBuffers.绑定的顶点缓冲区的读取访问,发生在管线状态VK_PIPELINE_STAGE_VERTEX_INPUT_BIT
	VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT_KHR = 0x00000004ULL,
	VK_ACCESS_2_UNIFORM_READ_BIT = 0x00000008ULL,//指定任何着色器阶段对uniform变量的读取访问,发生在管线状态VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT、VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT、VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT、VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT、VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT、VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT
	VK_ACCESS_2_UNIFORM_READ_BIT_KHR = 0x00000008ULL,
	VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT = 0x00000010ULL,//指定在render pass的subpass的渲染阶段或者片段着色器阶段对输入附件的读取访问,发生在管线状态VK_PIPELINE_STAGE_2_SUBPASS_SHADER_BIT_HUAWEI 或VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT
	VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT_KHR = 0x00000010ULL,
    VK_ACCESS_2_SHADER_READ_BIT = 0x00000020ULL,//指定对任何着色器管道阶段中的统一文本缓冲器、采样映像、存储缓冲器、物理存储缓冲器、着色器绑定表、存储文本缓冲器或存储映像的读取访问。
    VK_ACCESS_2_SHADER_READ_BIT_KHR = 0x00000020ULL,
    VK_ACCESS_2_SHADER_WRITE_BIT = 0x00000040ULL,//指定对任何着色器管道阶段中的存储缓冲区、物理存储缓冲区、存储文本缓冲区或存储映像的写入访问权限。
    VK_ACCESS_2_SHADER_WRITE_BIT_KHR = 0x00000040ULL,
    VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT = 0x00000080ULL,//指定对颜色附件的读取访问权限，例如通过混合（高级混合操作除外）、逻辑操作或VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT管道阶段中的某些render pass的加载操作或者在VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT阶段对tile image的读取
    VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT_KHR = 0x00000080ULL,
    VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT = 0x00000100ULL,//指定在render pass或通过特定render pass加载和存储操作期间对颜色、解析或深度/模板解析附件的写入访问权限。这种访问发生在VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT管道阶段。
    VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT_KHR = 0x00000100ULL,
    VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT = 0x00000200ULL,//指定在VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT ， VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT阶段的render pass加载或者在VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT的tile image的读取时 对深度/模板附件的读取访问
    VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT_KHR = 0x00000200ULL,
	VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = 0x00000400ULL,//指定在VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT ， VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT阶段的render pass的存储操作对深度/模板附件的写入访问权限。
    VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT_KHR = 0x00000400ULL,
    VK_ACCESS_2_TRANSFER_READ_BIT = 0x00000800ULL,//指定对复制操作中的图像或缓冲区的读取访问权限。这种访问发生在VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT管道阶段。
    VK_ACCESS_2_TRANSFER_READ_BIT_KHR = 0x00000800ULL,
    VK_ACCESS_2_TRANSFER_WRITE_BIT = 0x00001000ULL,//指定在清除或复制操作中对图像或缓冲区的写入访问权限。这种访问发生在VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT管道阶段
    VK_ACCESS_2_TRANSFER_WRITE_BIT_KHR = 0x00001000ULL,
    VK_ACCESS_2_HOST_READ_BIT = 0x00002000ULL,//指定主机操作的读取访问权限。这种类型的访问不是通过资源执行的，而是直接通过内存执行的。这种访问发生在VK_PIPELINE_STAGE_HOST_BIT管道阶段。
    VK_ACCESS_2_HOST_READ_BIT_KHR = 0x00002000ULL,
    VK_ACCESS_2_HOST_WRITE_BIT = 0x00004000ULL,//指定主机操作的写访问权限。这种类型的访问不是通过资源执行的，而是直接通过内存执行的。这种访问发生在VK_PIPELINE_STAGE_HOST_BIT管道阶段。
    VK_ACCESS_2_HOST_WRITE_BIT_KHR = 0x00004000ULL,
    VK_ACCESS_2_MEMORY_READ_BIT = 0x00008000ULL,//指定所有读取访问。它在任何访问掩码中始终有效，并且被视为等于设置在使用它时有效的所有读访问标志。（其他读标志的与）
    VK_ACCESS_2_MEMORY_READ_BIT_KHR = 0x00008000ULL,
    VK_ACCESS_2_MEMORY_WRITE_BIT = 0x00010000ULL,//指定所有写入访问。它在任何访问掩码中始终有效，并且被视为等同于在使用它的地方设置所有有效的写访问标志。（其他写标志的与）
    VK_ACCESS_2_MEMORY_WRITE_BIT_KHR = 0x00010000ULL,
    VK_ACCESS_2_SHADER_SAMPLED_READ_BIT = 0x100000000ULL,
    VK_ACCESS_2_SHADER_SAMPLED_READ_BIT_KHR = 0x100000000ULL,
    VK_ACCESS_2_SHADER_STORAGE_READ_BIT = 0x200000000ULL,
    VK_ACCESS_2_SHADER_STORAGE_READ_BIT_KHR = 0x200000000ULL,
    VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT = 0x400000000ULL,
    VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT_KHR = 0x400000000ULL,
    VK_ACCESS_2_VIDEO_DECODE_READ_BIT_KHR = 0x800000000ULL,
    VK_ACCESS_2_VIDEO_DECODE_WRITE_BIT_KHR = 0x1000000000ULL,
#ifdef VK_ENABLE_BETA_EXTENSIONS
    VK_ACCESS_2_VIDEO_ENCODE_READ_BIT_KHR = 0x2000000000ULL,
#endif
#ifdef VK_ENABLE_BETA_EXTENSIONS
    VK_ACCESS_2_VIDEO_ENCODE_WRITE_BIT_KHR = 0x4000000000ULL,
#endif
    VK_ACCESS_2_TRANSFORM_FEEDBACK_WRITE_BIT_EXT = 0x02000000ULL,//指定对传输反馈激活时进行的传输反馈缓冲区的写访问。这种访问发生在VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT管道阶段
    VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT = 0x04000000ULL,//指定对传输反馈计数器缓冲区的读取访问，它在vkCmdBeginTransformFeedbackEXT执行时被读取。这种访问发生在VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT管道阶段。
    VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT = 0x08000000ULL,//指定对在vkCmdEndTransformFeedbackEXT执行时写入的传输反馈计数器缓冲区的写入访问权限。这种访问发生在VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT管道阶段。
    VK_ACCESS_2_CONDITIONAL_RENDERING_READ_BIT_EXT = 0x00100000ULL,//指定对谓词的读取访问，作为条件呈现的一部分。这种访问发生在VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT管道阶段。
    VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_NV = 0x00020000ULL,//指定从缓冲区输入到vkCmdPreprocessGeneratedCommandsNV.的读取这种访问发生在VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV管道阶段。
	VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_NV = 0x00040000ULL,//指定目标命令缓冲区预处理输出对vkCmdPreprocessGeneratedCommandsNV.中的写入，这种访问发生在VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV管道阶段
    VK_ACCESS_2_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR = 0x00800000ULL,//指定在栅格化期间对碎片着色速率附着的读取访问权限。这种访问发生在VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR管道阶段。
    VK_ACCESS_2_SHADING_RATE_IMAGE_READ_BIT_NV = 0x00800000ULL,//指定在栅格化期间对着色速率图像的读取访问权限。这种访问发生在VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV管道阶段相当于在VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR阶段
    VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR = 0x00200000ULL,//指定对加速结构作为跟踪、构建或复制命令的一部分，或作为构建命令的一部分对加速结构划伤缓冲区的读取访问。这种访问发生在VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR管道阶段或VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR管道阶段。
    VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_KHR = 0x00400000ULL,//指定对加速结构或加速结构的写入存取，作为构建或复制命令的一部分。这种访问发生在VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR管道阶段。
    VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_NV = 0x00200000ULL,
    VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_NV = 0x00400000ULL,
    VK_ACCESS_2_FRAGMENT_DENSITY_MAP_READ_BIT_EXT = 0x01000000ULL,//指定在动态片段密度映射操作期间对片段密度映射附件的读取访问。这种访问发生在VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT管道阶段。
    VK_ACCESS_2_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT = 0x00080000ULL,//指定对颜色附件的读取访问权限，包括高级混合操作。这种访问发生在VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT管道阶段。
    VK_ACCESS_2_DESCRIPTOR_BUFFER_READ_BIT_EXT = 0x20000000000ULL,
    VK_ACCESS_2_INVOCATION_MASK_READ_BIT_HUAWEI = 0x8000000000ULL,//指定对VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI管道阶段中的调用掩码映像的读取访问权限。
    VK_ACCESS_2_SHADER_BINDING_TABLE_READ_BIT_KHR = 0x10000000000ULL,
    VK_ACCESS_2_MICROMAP_READ_BIT_EXT = 0x100000000000ULL,
    VK_ACCESS_2_MICROMAP_WRITE_BIT_EXT = 0x200000000000ULL,
    VK_ACCESS_2_OPTICAL_FLOW_READ_BIT_NV = 0x40000000000ULL,
    VK_ACCESS_2_OPTICAL_FLOW_WRITE_BIT_NV = 0x80000000000ULL
};


/**
 * @brief 检查accessFlags是否与pipelineStages2是否匹配
 * @param accessFlags 访问权限
 * @param pipelineStages2 管线阶段
 * @return 
*/
bool CheckMatchAccessFlagsAndPipelineStageFlags2(VkAccessFlags2 accessFlags, VkPipelineStageFlags2 pipelineStages2) {
	bool res = false;
	res |= (accessFlags == VK_ACCESS_2_NONE);
	res |= (accessFlags & VK_ACCESS_2_MEMORY_READ_BIT) == VK_ACCESS_2_MEMORY_READ_BIT;
	res |= (accessFlags & VK_ACCESS_2_MEMORY_WRITE_BIT) == VK_ACCESS_2_MEMORY_WRITE_BIT;
	if (accessFlags & VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT) == VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR) == VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR;
	}
	if (accessFlags & VK_ACCESS_2_INDEX_READ_BIT)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT) == VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT) == VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT;
	}
	if (accessFlags & VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT) == VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT) == VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT;
	}
	if ((accessFlags & VK_ACCESS_2_UNIFORM_READ_BIT) || (accessFlags & VK_ACCESS_2_SHADER_WRITE_BIT)
		|| (accessFlags & VK_ACCESS_2_SHADER_SAMPLED_READ_BIT) || (accessFlags & VK_ACCESS_2_SHADER_STORAGE_READ_BIT)
		|| (accessFlags & VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT) || (accessFlags & VK_ACCESS_2_DESCRIPTOR_BUFFER_READ_BIT_EXT))
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT) == VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT) == VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT) == VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT) == VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT) == VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT) == VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR) == VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT) == VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT) == VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI) == VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI) == VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI;
	}
	if (accessFlags & VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT) == VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI) == VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI;
	}

	if (accessFlags & VK_ACCESS_2_SHADER_READ_BIT)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR) == VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT) == VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT) == VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT) == VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT) == VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT) == VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT;

		res |= (accessFlags & VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT) == VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT) == VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR) == VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT) == VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT) == VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI) == VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI) == VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI;
	}


	if (accessFlags & VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT) == VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT) == VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT;
	}

	if (accessFlags & VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT) == VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT;

	}
	
	if (accessFlags & VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT) == VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT) == VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT) == VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT;
	}
	
	if (accessFlags & VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT) == VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT) == VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT;
	}

	if (accessFlags & VK_ACCESS_2_TRANSFER_READ_BIT)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT) == VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_COPY_BIT) == VK_PIPELINE_STAGE_2_COPY_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_RESOLVE_BIT) == VK_PIPELINE_STAGE_2_RESOLVE_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_BLIT_BIT) == VK_PIPELINE_STAGE_2_BLIT_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR) == VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR) == VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT) == VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT;
	}

	if (accessFlags & VK_ACCESS_2_TRANSFER_WRITE_BIT)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT) == VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_COPY_BIT) == VK_PIPELINE_STAGE_2_COPY_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_RESOLVE_BIT) == VK_PIPELINE_STAGE_2_RESOLVE_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_BLIT_BIT) == VK_PIPELINE_STAGE_2_BLIT_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_CLEAR_BIT) == VK_PIPELINE_STAGE_2_CLEAR_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR) == VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR) == VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT) == VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT;
	}

	if (accessFlags & VK_ACCESS_2_HOST_READ_BIT)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_HOST_BIT) == VK_PIPELINE_STAGE_2_HOST_BIT;

	}

	if (accessFlags & VK_ACCESS_2_HOST_WRITE_BIT)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_HOST_BIT) == VK_PIPELINE_STAGE_2_HOST_BIT;

	}

	if ((accessFlags & VK_ACCESS_2_VIDEO_DECODE_READ_BIT_KHR) || (accessFlags & VK_ACCESS_2_VIDEO_DECODE_WRITE_BIT_KHR))
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR) == VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR;
	}
		
#ifdef K_ENABLE_BETA_EXTENSIONS

	if ((accessFlags & VK_ACCESS_2_VIDEO_ENCODE_READ_BIT_KHR) || (accessFlags & VK_ACCESS_2_VIDEO_ENCODE_WRITE_BIT_KHR))
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR) == VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR;

	}
#endif
	
	if (accessFlags & VK_ACCESS_2_TRANSFORM_FEEDBACK_WRITE_BIT_EXT)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT) == VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT;

	}

	if (accessFlags & VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT) == VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT) == VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT;
	}

	if (accessFlags & VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT) == VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT;
	}

	if (accessFlags & VK_ACCESS_2_CONDITIONAL_RENDERING_READ_BIT_EXT)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT) == VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI) == VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI;
	}
	
	if ((accessFlags & VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_NV) || (accessFlags & VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_NV))
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV) == VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV;

	}

	if (accessFlags & VK_ACCESS_2_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR) == VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR;

	}

	if (accessFlags & VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT) == VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT) == VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT) == VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT) == VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT) == VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT) == VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR) == VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT) == VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT) == VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI) == VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR) == VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR) == VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI) == VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI;
	}
	
	if (accessFlags & VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_KHR)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR) == VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR) == VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR;
	}

	if (accessFlags & VK_ACCESS_2_FRAGMENT_DENSITY_MAP_READ_BIT_EXT)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT) == VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT;
	}

	if (accessFlags & VK_ACCESS_2_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT) == VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT;
		
	}


	if (accessFlags & VK_ACCESS_2_INVOCATION_MASK_READ_BIT_HUAWEI)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI) == VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI;

	}
	
	if (accessFlags & VK_ACCESS_2_MICROMAP_READ_BIT_EXT)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT) == VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR) == VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR;
	}
	
	if (accessFlags & VK_ACCESS_2_MICROMAP_WRITE_BIT_EXT)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT) == VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT;

	}
	
	if (accessFlags & VK_ACCESS_2_OPTICAL_FLOW_READ_BIT_NV)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV) == VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV;
	}
	
	if (accessFlags & VK_ACCESS_2_OPTICAL_FLOW_WRITE_BIT_NV)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV) == VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV;
	}
	return res;
}




SyncronizationAndCacheControlTest::SyncronizationAndCacheControlTest()
{
	PrepareContex();
}













void SyncronizationAndCacheControlTest::run()
{



	FenceTest();








}

SyncronizationAndCacheControlTest::~SyncronizationAndCacheControlTest()
{
	ClearContex();
}

enum class VkExternalFenceHandleTypeFlagBitsWithNotation {
	VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT = 0x00000001,
	VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT = 0x00000002,
	VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = 0x00000004,
	VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT = 0x00000008,
	VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT,
	VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT,
	VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
	VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR = VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT,
	VK_EXTERNAL_FENCE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
};


void SyncronizationAndCacheControlTest::FenceTest()
{
	//create
	VkFenceCreateInfo fenceCreateInfo = {};
	fenceCreateInfo.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;
	//fenceCreateInfo.flags = 0;//创建一个未signaled的fence
	fenceCreateInfo.flags = VK_FENCE_CREATE_SIGNALED_BIT;//创建一个signaled的fence
	//如果需要导出内部的资源，添加VkExportFenceCreateInfo到pnext中
	bool exportFence = false;
	VkExportFenceCreateInfo exportFenceCreateInfo{};
	const void** pnext = &fenceCreateInfo.pNext;
	VkExternalFenceHandleTypeFlags fenceCompatibleHandleTypes{};
	if (exportFence)
	{
		exportFenceCreateInfo.sType = VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO;
		//获取物理设备支持的导出fence类型
		VkExternalFenceProperties externalFenceProperties{};
		externalFenceProperties.sType = VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES;
		VkPhysicalDeviceExternalFenceInfo externalFenceInfo{};
		externalFenceInfo.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO;
		externalFenceInfo.pNext = nullptr;
		externalFenceInfo.handleType = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT;//查询支持的VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT导出fence类型属性
		vkGetPhysicalDeviceExternalFenceProperties(physicalDevice, &externalFenceInfo, &externalFenceProperties);
		//如果支持该类型且可以导出就设置exportFenceCreateInfo
		if ((externalFenceProperties.compatibleHandleTypes & VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT)
			&& (externalFenceProperties.externalFenceFeatures & VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT))
		{
			exportFenceCreateInfo.handleTypes = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT;
			
		}
		fenceCompatibleHandleTypes = externalFenceProperties.compatibleHandleTypes;
		*pnext = &exportFenceCreateInfo;
		pnext = &exportFenceCreateInfo.pNext;

		//如果需要加额外的属性描述，添加VkExportFenceWin32HandleInfoKHR到fenceCreateInfo.pNext中
		VkExportFenceWin32HandleInfoKHR exportFenceWin32HandleInfo{};
		exportFenceWin32HandleInfo.sType = VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR;
		exportFenceWin32HandleInfo.pNext = nullptr;
		exportFenceWin32HandleInfo.pAttributes = nullptr;//这个先设置为nullptr使用默认的属性
		
		*pnext = &exportFenceWin32HandleInfo;
		pnext = &exportFenceWin32HandleInfo.pNext;
		
		
	}


	VkFence fence{nullptr};
	VK_RESULT_CHECK_CALL(vkCreateFence(device, &fenceCreateInfo, nullptr, &fence));
	
	void* fenceNTHandle{ nullptr };
	if ((fenceCompatibleHandleTypes & VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT)
		|| (fenceCompatibleHandleTypes & VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT))
	{

		VkFenceGetWin32HandleInfoKHR fenceGetWin32HandleInfo{};
		fenceGetWin32HandleInfo.sType = VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR;
		fenceGetWin32HandleInfo.handleType = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT;
		fenceGetWin32HandleInfo.fence = fence;
		fenceGetWin32HandleInfo.pNext = nullptr;
		//获取fence的win32句柄
		
		//如果handletype是VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT或者VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,则说明这个fence是native handle
		//如果是NT handle则对于每一个handletype，该函数只能被调用一次,详情见vulkanspeci.pdf的p323
		VK_DEVICE_FUNCTION_GET_AND_CALL(device, vkGetFenceWin32HandleKHR,device, &fenceGetWin32HandleInfo, &fenceNTHandle);
		//获取的handle在不需要的时候需要关闭
	}
	int fd{ 0 };
	if ((fenceCompatibleHandleTypes & VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT)
		|| (fenceCompatibleHandleTypes & VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT))
	{
		VkFenceGetFdInfoKHR getFenceFD{};
		getFenceFD.sType = VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR;
		getFenceFD.pNext = nullptr;
		getFenceFD.fence = fence;
		getFenceFD.handleType = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT;
		
		//vkGetFenceFdKHR(device, &getFenceFD, &fd);
		VK_DEVICE_FUNCTION_GET_AND_CALL(device, vkGetFenceFdKHR,device,&getFenceFD,&fd)
		//获取的fd在不需要的时候需要关闭
	}
	
	auto status = vkGetFenceStatus(device, fence);//获取fence状态
	switch (status)
	{
	case VK_SUCCESS://fence已经signaled
		break;
	case VK_NOT_READY://fence未signaled
		break;
	case VK_ERROR_DEVICE_LOST:
	case VK_ERROR_OUT_OF_HOST_MEMORY:
	case VK_ERROR_OUT_OF_DEVICE_MEMORY:
		break;//失败

	default:
		break;
	}

	vkWaitForFences(device, 1, &fence, VK_TRUE, VK_TIMEOUT);//在VK_TIMEOUT纳秒超时时间内等待fence变为signaled状态
	
	vkResetFences(device, 1, &fence);//设置fence为未signaled状态

	

	VkDeviceEventInfoEXT deviceEventInfo{};
	deviceEventInfo.sType = VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT;
	deviceEventInfo.pNext = nullptr;
	deviceEventInfo.deviceEvent = VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT;//设置触发事件类型为插入或者拔出显示器，主要用作显示器热插拔事件的同步
	//设置额外的触发事件来触发fence（除了队列执行触发以及host触发外）
	VK_DEVICE_FUNCTION_GET_AND_CALL(device, vkRegisterDeviceEventEXT,device, &deviceEventInfo, nullptr, &fence);

	VkDisplayKHR display{};
	VkDisplayEventInfoEXT displayEventInfo{};
	displayEventInfo.sType = VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT;
	displayEventInfo.pNext = nullptr;
	displayEventInfo.displayEvent = VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT;//指定触发事件类型为第一个像素输出事件,即下一个显示周期的第一个像素输出时触发fence
	//设置额外的显示设备的事件来触发fence（除了队列执行触发以及host触发外）
	VK_DEVICE_FUNCTION_GET_AND_CALL(device, vkRegisterDisplayEventEXT,device, display, &displayEventInfo, nullptr, &fence);


	//导入payload
	

	VkImportFenceWin32HandleInfoKHR importFenceWin32HandleInfo{};
	importFenceWin32HandleInfo.sType = VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR;
	importFenceWin32HandleInfo.fence = fence;//fence不能是队列上且未执行的状态
	importFenceWin32HandleInfo.handle = fenceNTHandle;
	importFenceWin32HandleInfo.flags = VK_FENCE_IMPORT_TEMPORARY_BIT;
	importFenceWin32HandleInfo.pNext = nullptr;
	importFenceWin32HandleInfo.handleType = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT;
	//VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT以及VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT都是引用导入，都可以是临时的或者永久的
	if (importFenceWin32HandleInfo.handleType != VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT) {
		importFenceWin32HandleInfo.name = nullptr;
	}
	if (importFenceWin32HandleInfo.handle)
	{
		importFenceWin32HandleInfo.name = nullptr;
	}
	else {
		CONST WCHAR* name = L"tmp";//示例用法，可以设置一个名字来标识这个fence
		importFenceWin32HandleInfo.name = name;//示例用法，可以设置一个名字来标识这个fence
	}
	//导入fence可以多次导入同一个handle到vulkan的fence中,可以和原来的fence相同也可以不同
	VK_DEVICE_FUNCTION_GET_AND_CALL(device, vkImportFenceWin32HandleKHR,device, &importFenceWin32HandleInfo);


	VkImportFenceFdInfoKHR importFenceFDInfo {};
	importFenceFDInfo.sType = VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR;
	importFenceFDInfo.fd = fd;//导入的fd为 -1 且为VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT时表示引入一个已经触发的fence
	importFenceFDInfo.fence = fence;//fence不能是队列上且未执行的状态
	importFenceFDInfo.flags = VK_FENCE_IMPORT_TEMPORARY_BIT;
	importFenceFDInfo.handleType = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT;//VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT是引用，可以是临时或者永久的 ，VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT为复制fd，是临时性的，
	importFenceFDInfo.pNext = nullptr;
	//导入fence可以多次导入同一个handle到vulkan的fence中,可以和原来的fence相同也可以不同
	VK_DEVICE_FUNCTION_GET_AND_CALL(device,vkImportFenceFdKHR,device, &importFenceFDInfo);//导入fd到fence中

	//销毁fence
	vkDestroyFence(device, fence, nullptr);



}







































NS_TEST_END
