#include "SyncronizationAndCacheControlTest.h"
#include <Windows.h>
#include <vulkan/vulkan_win32.h>
#include <winnt.h>
#include <vulkan/vulkan_metal.h>
typedef uint32_t zx_handle_t;//因为zx_handle_t 是google的开源操作系统fuchsia的句柄类型，所以这里定义一个uint32_t类型的句柄类型zx_handle_t，不起实际作用只是为了通过编译
#include <vulkan/vulkan_fuchsia.h>
NS_TEST_BEGIN

//同步逻辑：
//第一个同步域 | 内存依赖（本节内容） | 第二个同步域

//--------------------------------------------------------------------------
//管线阶段


//
//第一个同步域和第二个同步域的执行管线阶段和访问控制必须满足以下条件：
//在以一个同步域中执行的操作的管线阶段必须要为srcStage或者逻辑上早于该阶段的阶段，访问控制必须以srcAccessFlag所指定的进行
//，同理，目标阶段必须要为dstStage或者逻辑上晚于该阶段的阶段，访问控制必须以dstAccessFlag所指定的进行

enum class VkPipelineStageFlagBitsWithNotation {
	VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT = 0x00000001, //相当于在第二个同步作用域中指定时将VkAccessFlags设置为0的且管线阶段为VK_PIPELINE_STAGE_ALL_COMMANDS_BIT，但在第一个作用域中指定时不指定任何执行阶段
	VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT = 0x00000002, //指示VkDrawIndirect* / VkDispatchIndirect* / VkTraceRaysIndirect *这类型数据结构使用的管线阶段，也包括读取vkCmdExecuteGeneratedCommandsNV中记录的指令缓冲区的阶段
	VK_PIPELINE_STAGE_VERTEX_INPUT_BIT = 0x00000004, //指定管道的顶点输入阶段
	VK_PIPELINE_STAGE_VERTEX_SHADER_BIT = 0x00000008, //指示顶点着色器阶段
	VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT = 0x00000010, //指示曲面细分控制着色器
	VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT = 0x00000020, //指示曲面细分评估着色器
	VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT = 0x00000040, //指示几何着色器
	VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT = 0x00000080, //指示片段着色器
	VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT = 0x00000100, //指定执行在片段着色器阶段前的深度/模板测试的管道阶段（片段着色之前的深度和模板测试）。此阶段还包括对具有深度/模板格式的frame缓冲区附件的render pass加载操作。
	VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT = 0x00000200, //指定执行在片段着色器阶段后的深度/模板测试的管道阶段（片段着色之后的深度和模板测试）。此阶段还包括对具有深度/模板格式的frame缓冲区附件的render pass存储操作。
	VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT = 0x00000400, //指定混合后的管道阶段，其中最终颜色值从管道输出。这个阶段包括混合、逻辑操作、颜色附件的渲染传递加载和存储操作、render pass的resolve操作和vkCmdClearAttachments.。
	VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT = 0x00000800, //指示计算着色器
	VK_PIPELINE_STAGE_TRANSFER_BIT = 0x00001000, 
	/**
	 * 指示以下操作的管线阶段：
	 * 所有复制操作，包括vkCmdCopyQueryPoolResults
	 * vkCmdBlitImage2 和 vkCmdBlitImage
	 * vkCmdResolveImage2 和 vkCmdResolveImage
	 * 所有清除操作，除了vkCmdClearAttachments
	*/
	VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT = 0x00002000, //相当于在第一个同步作用域中指定时将VkAccessFlags设置为0的且管线阶段为VK_PIPELINE_STAGE_ALL_COMMANDS_BIT，但在第二个作用域中指定时不指定任何执行阶段
	VK_PIPELINE_STAGE_HOST_BIT = 0x00004000, //指定指示在设备内存的读写主机上执行的伪阶段。在命令缓冲区中记录的任何命令都不会触发此阶段。
	VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT = 0x00008000, 
	/**
	 * 指示所有图形管线阶段，等价于
	 * VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT | VK_PIPELINE_STAGE_TASK_SHADER_BIT_EXT | VK_PIPELINE_STAGE_MESH_SHADER_BIT_EXT
	 * | VK_PIPELINE_STAGE_VERTEX_INPUT_BIT | VK_PIPELINE_STAGE_VERTEX_SHADER_BIT | VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT
     * | VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT | VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT | VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT
     * | VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT | VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT | VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT
     * | VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT | VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT | VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR
     * | VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT
	*/
	VK_PIPELINE_STAGE_ALL_COMMANDS_BIT = 0x00010000, ////指定在它commandbuffer提交使用的队列上所支持的所有命令所执行的所有管线阶段。
	VK_PIPELINE_STAGE_NONE = 0, //指示不清楚管线阶段
	VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT = 0x01000000, //指定将顶点属性输出值写入转换反馈缓冲区的管道的阶段。
	VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT = 0x00040000, //指定使用条件呈现的谓词的管道的阶段。
	VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR = 0x02000000,
	/**
	 * 指示以下命令执行的管线阶段
	 * vkCmdBuildAccelerationStructureNV, vkCmdCopyAccelerationStructureNV,
     * vkCmdWriteAccelerationStructuresPropertiesNV , vkCmdBuildAccelerationStructuresKHR,
	 * vkCmdBuildAccelerationStructuresIndirectKHR, vkCmdCopyAccelerationStructureKHR,
	 * vkCmdCopyAccelerationStructureToMemoryKHR,
	 * vkCmdCopyMemoryToAccelerationStructureKHR,
	 * vkCmdWriteAccelerationStructuresPropertiesKHR.
	*/
	VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR = 0x00200000,//指示通过vkCmdTraceRaysNV , vkCmdTraceRaysKHR, 或者 vkCmdTraceRaysIndirectKHR执行的光线追踪着色器阶段
	VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT = 0x00800000,//指定读取片段着色速率附着或着色速率图像，以确定光栅格化原体部分的片段着色速率的管道的阶段。
	VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x00400000,// 指定读取片段密度映射以生成片段区域的管道的阶段。
	VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV = 0x00020000,//指定通过vkCmdPreprocessGeneratedCommandsNV处理设备生成命令的管道阶段
	VK_PIPELINE_STAGE_TASK_SHADER_BIT_EXT = 0x00080000,//指示任务着色器
	VK_PIPELINE_STAGE_MESH_SHADER_BIT_EXT = 0x00100000,//指示网格着色器
	VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV = VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR,//指示着色率图像
	VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV = VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR,//指示光线追踪着色器
	VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV = VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR,//指示加速结构构建
	VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV = VK_PIPELINE_STAGE_TASK_SHADER_BIT_EXT,//指示任务着色器
	VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV = VK_PIPELINE_STAGE_MESH_SHADER_BIT_EXT,//指示网格着色器
	VK_PIPELINE_STAGE_NONE_KHR = VK_PIPELINE_STAGE_NONE,//指示不确定管线状态
	VK_PIPELINE_STAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF//指示标志位的最大值

} ;



enum class VkPipelineStageFlagBits2WithNotation {
   VK_PIPELINE_STAGE_2_NONE = 0ULL,//指示不确定管线状态
   VK_PIPELINE_STAGE_2_NONE_KHR = 0ULL,
   VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT = 0x00000001ULL,//相当于在第二个同步作用域中指定时将VkAccessFlags2设置为0且管线阶段为VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT，以及相当于第一个同步作用域中的管线阶段为VK_PIPELINE_STAGE_2_NONE。
   VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT_KHR = 0x00000001ULL,
   VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT = 0x00000002ULL,//指定使用间接命令参数的管道的阶段。这个阶段还包括读取由vkCmdPreprocessGeneratedCommandsNV.编写的命令
   VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT_KHR = 0x00000002ULL,
   VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT = 0x00000004ULL,//指定管道的顶点输入阶段，相当于 VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT | VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT
   VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT_KHR = 0x00000004ULL,
   VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT = 0x00000008ULL,//顶点着色器阶段
   VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT_KHR = 0x00000008ULL,
   VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT = 0x00000010ULL,//曲面细分控制着色器阶段
   VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT_KHR = 0x00000010ULL,
   VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT = 0x00000020ULL,//曲面细分计算着色器阶段
   VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT_KHR = 0x00000020ULL,
   VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT = 0x00000040ULL,//几何着色器阶段
   VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT_KHR = 0x00000040ULL,
   VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT = 0x00000080ULL,//片段着色器阶段
   VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT_KHR = 0x00000080ULL,
   VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT = 0x00000100ULL,//指定执行在片段之前进行深度和模板测试的管道阶段（片段着色之前的深度和模板测试）
   VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT_KHR = 0x00000100ULL,
   VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT = 0x00000200ULL,//指定执行在片段之后进行深度和模板测试的管道阶段（片段着色之后的深度和模板测试）
   VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT_KHR = 0x00000200ULL,
   VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT = 0x00000400ULL,//指定从管道中输出最终颜色值的管道的阶段
   VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT_KHR = 0x00000400ULL,
   VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT = 0x00000800ULL,//计算着色器阶段
   VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT_KHR = 0x00000800ULL,
   VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT = 0x00001000ULL, 
	/**
    * 等价于
	*  VK_PIPELINE_STAGE_2_COPY_BIT | VK_PIPELINE_STAGE_2_BLIT_BIT | VK_PIPELINE_STAGE_2_RESOLVE_BIT
    *  VK_PIPELINE_STAGE_2_CLEAR_BIT | VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR
   */
   VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT_KHR = 0x00001000ULL,
   VK_PIPELINE_STAGE_2_TRANSFER_BIT = 0x00001000ULL,
   VK_PIPELINE_STAGE_2_TRANSFER_BIT_KHR = 0x00001000ULL,
   VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT = 0x00002000ULL,//相当于第一个同步作用域的管线阶段为VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT，并将VkAccessFlags2设置为0，以及将第二个作用域中的VK_PIPELINE_STAGE_2_NONE。
   VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT_KHR = 0x00002000ULL,
   VK_PIPELINE_STAGE_2_HOST_BIT = 0x00004000ULL,//指定指示在设备内存的读写主机上执行的伪阶段。在命令缓冲区中记录的任何命令都不会触发此阶段。
   VK_PIPELINE_STAGE_2_HOST_BIT_KHR = 0x00004000ULL,
   VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT = 0x00008000ULL,
   /**
	* 指定所有图形管道阶段，等价于
	* VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT | VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT |VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT
    * VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT | VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT | VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT
    * VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT | VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT
	* VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT | VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT | VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT
	* VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT | VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT | VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT
    * VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR | VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT | VK_PIPELINE_STAGE_2_SUBPASS_SHADER_BIT_HUAWEI
	* VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI | VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI
   */
   VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT_KHR = 0x00008000ULL,
   VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT = 0x00010000ULL,//指定在它commandbuffer提交使用的队列上所支持的所有命令所执行的所有管线阶段。
   VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT_KHR = 0x00010000ULL,
   VK_PIPELINE_STAGE_2_COPY_BIT = 0x100000000ULL,//指定使用复制命令的管道的阶段。包括vkCmdCopyQueryPoolResults
   VK_PIPELINE_STAGE_2_COPY_BIT_KHR = 0x100000000ULL,
   VK_PIPELINE_STAGE_2_RESOLVE_BIT = 0x200000000ULL,//指定vkCmdResolveImage执行的管线阶段
   VK_PIPELINE_STAGE_2_RESOLVE_BIT_KHR = 0x200000000ULL,
   VK_PIPELINE_STAGE_2_BLIT_BIT = 0x400000000ULL,//指定vkCmdBlitImage执行的管线阶段
   VK_PIPELINE_STAGE_2_BLIT_BIT_KHR = 0x400000000ULL,
   VK_PIPELINE_STAGE_2_CLEAR_BIT = 0x800000000ULL,//指定清除命令的管道的阶段，除了vkCmdClearAttachments
   VK_PIPELINE_STAGE_2_CLEAR_BIT_KHR = 0x800000000ULL,
   VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT = 0x1000000000ULL,// 指定使用索引缓冲区的管道的阶段。
   VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT_KHR = 0x1000000000ULL,
   VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT = 0x2000000000ULL,//指定使用顶点属性的管道的阶段。
   VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT_KHR = 0x2000000000ULL,
   VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT = 0x4000000000ULL,
   /**
    *  指定在光栅化之前运行的着色器的管道阶段。相当于 
    *  VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT | VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT | VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT | VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT
 |  *  VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT | VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT | VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI
   */
   VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT_KHR = 0x4000000000ULL,
   VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR = 0x04000000ULL,//指定将视频解码操作的管线阶段。
#ifdef VK_ENABLE_BETA_EXTENSIONS
   VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR = 0x08000000ULL,//指定将视频编码操作的管线阶段。
#endif
   VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT = 0x01000000ULL,//指定将顶点属性输出值写入转换反馈缓冲区的管道的阶段。
   VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT = 0x00040000ULL,//指定使用条件呈现的谓词的管道的阶段。
   VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV = 0x00020000ULL,//指定通过vkCmdPreprocessGeneratedCommandsNV处理设备生成命令的管道阶段
   VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x00400000ULL,//指定其中读取片段着色速率附着或着色速率图像，以确定光栅格化原体部分的片段着色速率的管道的阶段。
   VK_PIPELINE_STAGE_2_SHADING_RATE_IMAGE_BIT_NV = 0x00400000ULL,
   VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR = 0x02000000ULL,//指定加速结构命令或加速结构复制命令的执行管线阶段。
   VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR = 0x00200000ULL,//光线追踪着色器阶段
   VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_NV = 0x00200000ULL,
   VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_NV = 0x02000000ULL,
   VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT = 0x00800000ULL,//指定读取片段密度映射以生成片段区域的管道的阶段。
   VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_NV = 0x00080000ULL,
   VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_NV = 0x00100000ULL,
   VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT = 0x00080000ULL,//任务着色器阶段
   VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT = 0x00100000ULL,//Mesh着色器阶段
   VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI = 0x8000000000ULL,//指定在subpass执行的管道的阶段。
   VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI = 0x10000000000ULL,//指定由实现读取调用掩码图像以优化射线分派的管道的阶段。
   VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR = 0x10000000ULL,//指定加速结构复制命令的执行管线阶段。
   VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT = 0x40000000ULL,
   VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI = 0x20000000000ULL,//指定簇剔除着色器阶段。
   VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV = 0x20000000ULL//指定执行光流操作的管道的阶段
};



/**
 * @brief 检查某种类型的队列是否匹配指定的管线阶段
 * @param pipelineStageFlags2 待匹配的管线阶段标志
 * @param queueFamilyFlags 待匹配的队列类型标志
 * @return 
*/
bool CheckMatchPipelineStages2AndQueueFlags(VkPipelineStageFlags2 pipelineStageFlags2, VkQueueFlags queueFamilyFlags) {

	bool res = false;
	res |= (pipelineStageFlags2 == VK_PIPELINE_STAGE_2_NONE);
	res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT) == VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT;
	res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT) == VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT;
	res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_HOST_BIT) == VK_PIPELINE_STAGE_2_HOST_BIT;
	res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT) == VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT;
	if (queueFamilyFlags & VK_QUEUE_GRAPHICS_BIT) {
		//图形队列支持以下列举的阶段，就认为支持
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT) == VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT) == VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT) == VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT) == VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT) == VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT) == VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT) == VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT) == VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT) == VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT) == VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT) == VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT) == VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT;

		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_COPY_BIT) == VK_PIPELINE_STAGE_2_COPY_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_RESOLVE_BIT) == VK_PIPELINE_STAGE_2_RESOLVE_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_BLIT_BIT) == VK_PIPELINE_STAGE_2_BLIT_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_CLEAR_BIT) == VK_PIPELINE_STAGE_2_CLEAR_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT) == VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT) == VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT) == VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT;

		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT) == VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT) == VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV) == VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR) == VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR) == VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR;

		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT) == VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT) == VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT) == VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI) == VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI) == VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR) == VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI) == VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV) == VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV;


	}
	if (queueFamilyFlags & VK_QUEUE_COMPUTE_BIT) {
		//计算队列支持以下列举的阶段

		
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT) == VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT) == VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT) == VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_COPY_BIT) == VK_PIPELINE_STAGE_2_COPY_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_RESOLVE_BIT) == VK_PIPELINE_STAGE_2_RESOLVE_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_BLIT_BIT) == VK_PIPELINE_STAGE_2_BLIT_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_CLEAR_BIT) == VK_PIPELINE_STAGE_2_CLEAR_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT) == VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV) == VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR) == VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR) == VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR) == VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT) == VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT;

	}
	if (queueFamilyFlags & VK_QUEUE_TRANSFER_BIT) {

		//传输队列支持以下列举的阶段
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT) == VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_COPY_BIT) == VK_PIPELINE_STAGE_2_COPY_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_RESOLVE_BIT) == VK_PIPELINE_STAGE_2_RESOLVE_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_BLIT_BIT) == VK_PIPELINE_STAGE_2_BLIT_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_CLEAR_BIT) == VK_PIPELINE_STAGE_2_CLEAR_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR) == VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR;

	}
	if (queueFamilyFlags & VK_QUEUE_VIDEO_DECODE_BIT_KHR) {
		//视频解码队列支持以下列举的阶段
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR) == VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR;
	}
#ifdef VK_ENABLE_BETA_EXTENSIONS
	if (queueFamilyFlags & VK_QUEUE_VIDEO_ENCODE_BIT_KHR) {
		//视频解码队列支持以下列举的阶段
		res |= (pipelineStageFlags2 & VK_QUEUE_VIDEO_ENCODE_BIT_K) == VK_QUEUE_VIDEO_ENCODE_BIT_K;
}
#endif
	if (queueFamilyFlags & VK_QUEUE_OPTICAL_FLOW_BIT_NV) {
		//光流队列支持以下列举的阶段
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV) == VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV;
	}
	return res;
}


//------------------------------------------------------------------------------
// 访问控制


enum class VkAccessFlagBits2WithNotation
{
	VK_ACCESS_2_NONE = 0ULL,//未指定访问权限
	VK_ACCESS_2_NONE_KHR = 0ULL,
	VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT = 0x00000001ULL,//指定对从间接缓冲区读取的命令数据的读取访问，作为间接构建、跟踪、绘制或分派命令的一部分。发生在管线状态VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT
	VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT_KHR = 0x00000001ULL,
	VK_ACCESS_2_INDEX_READ_BIT = 0x00000002ULL,//指定对vkCmdBindIndexBuffer2KHR 和 vkCmdBindIndexBuffer绑定的索引缓冲区的读取访问,发生在管线状态VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT
	VK_ACCESS_2_INDEX_READ_BIT_KHR = 0x00000002ULL,
	VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT = 0x00000004ULL,//指定对vkCmdBindVertexBuffers.绑定的顶点缓冲区的读取访问,发生在管线状态VK_PIPELINE_STAGE_VERTEX_INPUT_BIT
	VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT_KHR = 0x00000004ULL,
	VK_ACCESS_2_UNIFORM_READ_BIT = 0x00000008ULL,//指定任何着色器阶段对uniform变量的读取访问,发生在管线状态VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT、VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT、VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT、VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT、VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT、VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT
	VK_ACCESS_2_UNIFORM_READ_BIT_KHR = 0x00000008ULL,
	VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT = 0x00000010ULL,//指定在render pass的subpass的渲染阶段或者片段着色器阶段对输入附件的读取访问,发生在管线状态VK_PIPELINE_STAGE_2_SUBPASS_SHADER_BIT_HUAWEI 或VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT
	VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT_KHR = 0x00000010ULL,
    VK_ACCESS_2_SHADER_READ_BIT = 0x00000020ULL,//指定对任何着色器管道阶段中的统一文本缓冲器、采样映像、存储缓冲器、物理存储缓冲器、着色器绑定表、存储文本缓冲器或存储映像的读取访问。
    VK_ACCESS_2_SHADER_READ_BIT_KHR = 0x00000020ULL,
    VK_ACCESS_2_SHADER_WRITE_BIT = 0x00000040ULL,//指定对任何着色器管道阶段中的存储缓冲区、物理存储缓冲区、存储文本缓冲区或存储映像的写入访问权限。
    VK_ACCESS_2_SHADER_WRITE_BIT_KHR = 0x00000040ULL,
    VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT = 0x00000080ULL,//指定对颜色附件的读取访问权限，例如通过混合（高级混合操作除外）、逻辑操作或VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT管道阶段中的某些render pass的加载操作或者在VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT阶段对tile image的读取
    VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT_KHR = 0x00000080ULL,
    VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT = 0x00000100ULL,//指定在render pass或通过特定render pass加载和存储操作期间对颜色、解析或深度/模板解析附件的写入访问权限。这种访问发生在VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT管道阶段。
    VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT_KHR = 0x00000100ULL,
    VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT = 0x00000200ULL,//指定在VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT ， VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT阶段的render pass加载或者在VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT的tile image的读取时 对深度/模板附件的读取访问
    VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT_KHR = 0x00000200ULL,
	VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = 0x00000400ULL,//指定在VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT ， VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT阶段的render pass的存储操作对深度/模板附件的写入访问权限。
    VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT_KHR = 0x00000400ULL,
    VK_ACCESS_2_TRANSFER_READ_BIT = 0x00000800ULL,//指定对复制操作中的图像或缓冲区的读取访问权限。这种访问发生在VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT管道阶段。
    VK_ACCESS_2_TRANSFER_READ_BIT_KHR = 0x00000800ULL,
    VK_ACCESS_2_TRANSFER_WRITE_BIT = 0x00001000ULL,//指定在清除或复制操作中对图像或缓冲区的写入访问权限。这种访问发生在VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT管道阶段
    VK_ACCESS_2_TRANSFER_WRITE_BIT_KHR = 0x00001000ULL,
    VK_ACCESS_2_HOST_READ_BIT = 0x00002000ULL,//指定主机操作的读取访问权限。这种类型的访问不是通过资源执行的，而是直接通过内存执行的。这种访问发生在VK_PIPELINE_STAGE_HOST_BIT管道阶段。
    VK_ACCESS_2_HOST_READ_BIT_KHR = 0x00002000ULL,
    VK_ACCESS_2_HOST_WRITE_BIT = 0x00004000ULL,//指定主机操作的写访问权限。这种类型的访问不是通过资源执行的，而是直接通过内存执行的。这种访问发生在VK_PIPELINE_STAGE_HOST_BIT管道阶段。
    VK_ACCESS_2_HOST_WRITE_BIT_KHR = 0x00004000ULL,
    VK_ACCESS_2_MEMORY_READ_BIT = 0x00008000ULL,//指定所有读取访问。它在任何访问掩码中始终有效，并且被视为等于设置在使用它时有效的所有读访问标志。（其他读标志的与）
    VK_ACCESS_2_MEMORY_READ_BIT_KHR = 0x00008000ULL,
    VK_ACCESS_2_MEMORY_WRITE_BIT = 0x00010000ULL,//指定所有写入访问。它在任何访问掩码中始终有效，并且被视为等同于在使用它的地方设置所有有效的写访问标志。（其他写标志的与）
    VK_ACCESS_2_MEMORY_WRITE_BIT_KHR = 0x00010000ULL,
    VK_ACCESS_2_SHADER_SAMPLED_READ_BIT = 0x100000000ULL,
    VK_ACCESS_2_SHADER_SAMPLED_READ_BIT_KHR = 0x100000000ULL,
    VK_ACCESS_2_SHADER_STORAGE_READ_BIT = 0x200000000ULL,
    VK_ACCESS_2_SHADER_STORAGE_READ_BIT_KHR = 0x200000000ULL,
    VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT = 0x400000000ULL,
    VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT_KHR = 0x400000000ULL,
    VK_ACCESS_2_VIDEO_DECODE_READ_BIT_KHR = 0x800000000ULL,
    VK_ACCESS_2_VIDEO_DECODE_WRITE_BIT_KHR = 0x1000000000ULL,
#ifdef VK_ENABLE_BETA_EXTENSIONS
    VK_ACCESS_2_VIDEO_ENCODE_READ_BIT_KHR = 0x2000000000ULL,
#endif
#ifdef VK_ENABLE_BETA_EXTENSIONS
    VK_ACCESS_2_VIDEO_ENCODE_WRITE_BIT_KHR = 0x4000000000ULL,
#endif
    VK_ACCESS_2_TRANSFORM_FEEDBACK_WRITE_BIT_EXT = 0x02000000ULL,//指定对传输反馈激活时进行的传输反馈缓冲区的写访问。这种访问发生在VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT管道阶段
    VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT = 0x04000000ULL,//指定对传输反馈计数器缓冲区的读取访问，它在vkCmdBeginTransformFeedbackEXT执行时被读取。这种访问发生在VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT管道阶段。
    VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT = 0x08000000ULL,//指定对在vkCmdEndTransformFeedbackEXT执行时写入的传输反馈计数器缓冲区的写入访问权限。这种访问发生在VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT管道阶段。
    VK_ACCESS_2_CONDITIONAL_RENDERING_READ_BIT_EXT = 0x00100000ULL,//指定对谓词的读取访问，作为条件呈现的一部分。这种访问发生在VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT管道阶段。
    VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_NV = 0x00020000ULL,//指定从缓冲区输入到vkCmdPreprocessGeneratedCommandsNV.的读取这种访问发生在VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV管道阶段。
	VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_NV = 0x00040000ULL,//指定目标命令缓冲区预处理输出对vkCmdPreprocessGeneratedCommandsNV.中的写入，这种访问发生在VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV管道阶段
    VK_ACCESS_2_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR = 0x00800000ULL,//指定在栅格化期间对碎片着色速率附着的读取访问权限。这种访问发生在VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR管道阶段。
    VK_ACCESS_2_SHADING_RATE_IMAGE_READ_BIT_NV = 0x00800000ULL,//指定在栅格化期间对着色速率图像的读取访问权限。这种访问发生在VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV管道阶段相当于在VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR阶段
    VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR = 0x00200000ULL,//指定对加速结构作为跟踪、构建或复制命令的一部分，或作为构建命令的一部分对加速结构划伤缓冲区的读取访问。这种访问发生在VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR管道阶段或VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR管道阶段。
    VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_KHR = 0x00400000ULL,//指定对加速结构或加速结构的写入存取，作为构建或复制命令的一部分。这种访问发生在VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR管道阶段。
    VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_NV = 0x00200000ULL,
    VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_NV = 0x00400000ULL,
    VK_ACCESS_2_FRAGMENT_DENSITY_MAP_READ_BIT_EXT = 0x01000000ULL,//指定在动态片段密度映射操作期间对片段密度映射附件的读取访问。这种访问发生在VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT管道阶段。
    VK_ACCESS_2_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT = 0x00080000ULL,//指定对颜色附件的读取访问权限，包括高级混合操作。这种访问发生在VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT管道阶段。
    VK_ACCESS_2_DESCRIPTOR_BUFFER_READ_BIT_EXT = 0x20000000000ULL,
    VK_ACCESS_2_INVOCATION_MASK_READ_BIT_HUAWEI = 0x8000000000ULL,//指定对VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI管道阶段中的调用掩码映像的读取访问权限。
    VK_ACCESS_2_SHADER_BINDING_TABLE_READ_BIT_KHR = 0x10000000000ULL,
    VK_ACCESS_2_MICROMAP_READ_BIT_EXT = 0x100000000000ULL,
    VK_ACCESS_2_MICROMAP_WRITE_BIT_EXT = 0x200000000000ULL,
    VK_ACCESS_2_OPTICAL_FLOW_READ_BIT_NV = 0x40000000000ULL,
    VK_ACCESS_2_OPTICAL_FLOW_WRITE_BIT_NV = 0x80000000000ULL
};


/**
 * @brief 检查accessFlags是否与pipelineStages2是否匹配
 * @param accessFlags 访问权限
 * @param pipelineStages2 管线阶段
 * @return 
*/
bool CheckMatchAccessFlagsAndPipelineStageFlags2(VkAccessFlags2 accessFlags, VkPipelineStageFlags2 pipelineStages2) {
	//有些访问权限与管线阶段在有些特性没有开启的时候是无法使用的，这里仅仅只做访问控制和管线状态的匹配，不管特性是否开启是如何
	//影响这些访问权限和管线状态的细节，不过一般这种影响都满足如果一个特性没有开启，那么和它相关的访问权限以及管线状态都是无法使用的
	bool res = false;
	res |= (accessFlags == VK_ACCESS_2_NONE);
	res |= (accessFlags & VK_ACCESS_2_MEMORY_READ_BIT) == VK_ACCESS_2_MEMORY_READ_BIT;
	res |= (accessFlags & VK_ACCESS_2_MEMORY_WRITE_BIT) == VK_ACCESS_2_MEMORY_WRITE_BIT;
	if (accessFlags & VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT) == VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR) == VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR;
	}
	if (accessFlags & VK_ACCESS_2_INDEX_READ_BIT)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT) == VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT) == VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT;
	}
	if (accessFlags & VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT) == VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT) == VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT;
	}
	if ((accessFlags & VK_ACCESS_2_UNIFORM_READ_BIT) || (accessFlags & VK_ACCESS_2_SHADER_WRITE_BIT)
		|| (accessFlags & VK_ACCESS_2_SHADER_SAMPLED_READ_BIT) || (accessFlags & VK_ACCESS_2_SHADER_STORAGE_READ_BIT)
		|| (accessFlags & VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT) || (accessFlags & VK_ACCESS_2_DESCRIPTOR_BUFFER_READ_BIT_EXT))
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT) == VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT) == VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT) == VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT) == VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT) == VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT) == VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR) == VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT) == VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT) == VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI) == VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI) == VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI;
	}
	if (accessFlags & VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT) == VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI) == VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI;
	}

	if (accessFlags & VK_ACCESS_2_SHADER_READ_BIT)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR) == VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT) == VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT) == VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT) == VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT) == VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT) == VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT;

		res |= (accessFlags & VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT) == VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT) == VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR) == VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT) == VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT) == VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI) == VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI) == VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI;
	}


	if (accessFlags & VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT) == VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT) == VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT;
	}

	if (accessFlags & VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT) == VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT;

	}
	
	if (accessFlags & VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT) == VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT) == VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT) == VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT;
	}
	
	if (accessFlags & VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT) == VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT) == VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT;
	}

	if (accessFlags & VK_ACCESS_2_TRANSFER_READ_BIT)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT) == VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_COPY_BIT) == VK_PIPELINE_STAGE_2_COPY_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_RESOLVE_BIT) == VK_PIPELINE_STAGE_2_RESOLVE_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_BLIT_BIT) == VK_PIPELINE_STAGE_2_BLIT_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR) == VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR) == VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT) == VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT;
	}

	if (accessFlags & VK_ACCESS_2_TRANSFER_WRITE_BIT)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT) == VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_COPY_BIT) == VK_PIPELINE_STAGE_2_COPY_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_RESOLVE_BIT) == VK_PIPELINE_STAGE_2_RESOLVE_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_BLIT_BIT) == VK_PIPELINE_STAGE_2_BLIT_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_CLEAR_BIT) == VK_PIPELINE_STAGE_2_CLEAR_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR) == VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR) == VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT) == VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT;
	}

	if (accessFlags & VK_ACCESS_2_HOST_READ_BIT)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_HOST_BIT) == VK_PIPELINE_STAGE_2_HOST_BIT;

	}

	if (accessFlags & VK_ACCESS_2_HOST_WRITE_BIT)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_HOST_BIT) == VK_PIPELINE_STAGE_2_HOST_BIT;

	}

	if ((accessFlags & VK_ACCESS_2_VIDEO_DECODE_READ_BIT_KHR) || (accessFlags & VK_ACCESS_2_VIDEO_DECODE_WRITE_BIT_KHR))
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR) == VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR;
	}
		
#ifdef K_ENABLE_BETA_EXTENSIONS

	if ((accessFlags & VK_ACCESS_2_VIDEO_ENCODE_READ_BIT_KHR) || (accessFlags & VK_ACCESS_2_VIDEO_ENCODE_WRITE_BIT_KHR))
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR) == VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR;

	}
#endif
	
	if (accessFlags & VK_ACCESS_2_TRANSFORM_FEEDBACK_WRITE_BIT_EXT)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT) == VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT;

	}

	if (accessFlags & VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT) == VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT) == VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT;
	}

	if (accessFlags & VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT) == VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT;
	}

	if (accessFlags & VK_ACCESS_2_CONDITIONAL_RENDERING_READ_BIT_EXT)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT) == VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI) == VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI;
	}
	
	if ((accessFlags & VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_NV) || (accessFlags & VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_NV))
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV) == VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV;

	}

	if (accessFlags & VK_ACCESS_2_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR) == VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR;

	}

	if (accessFlags & VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT) == VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT) == VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT) == VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT) == VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT) == VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT) == VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR) == VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT) == VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT) == VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI) == VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR) == VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR) == VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI) == VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI;
	}
	
	if (accessFlags & VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_KHR)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR) == VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR) == VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR;
	}

	if (accessFlags & VK_ACCESS_2_FRAGMENT_DENSITY_MAP_READ_BIT_EXT)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT) == VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT;
	}

	if (accessFlags & VK_ACCESS_2_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT) == VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT;
		
	}


	if (accessFlags & VK_ACCESS_2_INVOCATION_MASK_READ_BIT_HUAWEI)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI) == VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI;

	}
	
	if (accessFlags & VK_ACCESS_2_MICROMAP_READ_BIT_EXT)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT) == VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR) == VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR;
	}
	
	if (accessFlags & VK_ACCESS_2_MICROMAP_WRITE_BIT_EXT)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT) == VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT;

	}
	
	if (accessFlags & VK_ACCESS_2_OPTICAL_FLOW_READ_BIT_NV)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV) == VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV;
	}
	
	if (accessFlags & VK_ACCESS_2_OPTICAL_FLOW_WRITE_BIT_NV)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV) == VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV;
	}
	return res;
}




SyncronizationAndCacheControlTest::SyncronizationAndCacheControlTest()
{
	PrepareContex();
}













void SyncronizationAndCacheControlTest::run()
{



	FenceTest();

	SemaphoreTest();

	EventTest();






}

SyncronizationAndCacheControlTest::~SyncronizationAndCacheControlTest()
{
	ClearContex();
}

enum class VkExternalFenceHandleTypeFlagBitsWithNotation {
	VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT = 0x00000001,
	VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT = 0x00000002,
	VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = 0x00000004,
	VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT = 0x00000008,
	VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT,
	VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT,
	VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
	VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR = VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT,
	VK_EXTERNAL_FENCE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
};


void SyncronizationAndCacheControlTest::FenceTest()
{
	//create
	VkFenceCreateInfo fenceCreateInfo = {};//queue与host间
	fenceCreateInfo.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;
	//fenceCreateInfo.flags = 0;//创建一个未signaled的fence
	fenceCreateInfo.flags = VK_FENCE_CREATE_SIGNALED_BIT;//创建一个signaled的fence
	//如果需要导出内部的资源，添加VkExportFenceCreateInfo到pnext中
	bool exportFence = false;
	VkExportFenceCreateInfo exportFenceCreateInfo{};
	const void** pnext = &fenceCreateInfo.pNext;
	VkExternalFenceHandleTypeFlags fenceCompatibleHandleTypes{};
	if (exportFence)
	{
		exportFenceCreateInfo.sType = VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO;
		//获取物理设备支持的导出fence类型
		VkExternalFenceProperties externalFenceProperties{};
		externalFenceProperties.sType = VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES;
		VkPhysicalDeviceExternalFenceInfo externalFenceInfo{};
		externalFenceInfo.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO;
		externalFenceInfo.pNext = nullptr;
		externalFenceInfo.handleType = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT;//查询支持的VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT导出fence类型属性
		vkGetPhysicalDeviceExternalFenceProperties(physicalDevice, &externalFenceInfo, &externalFenceProperties);
		//如果支持该类型且可以导出就设置exportFenceCreateInfo
		if ((externalFenceProperties.compatibleHandleTypes & VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT)
			&& (externalFenceProperties.externalFenceFeatures & VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT))
		{
			exportFenceCreateInfo.handleTypes = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT;
			
		}
		fenceCompatibleHandleTypes = externalFenceProperties.compatibleHandleTypes;
		*pnext = &exportFenceCreateInfo;
		pnext = &exportFenceCreateInfo.pNext;

		//如果需要加额外的属性描述，添加VkExportFenceWin32HandleInfoKHR到fenceCreateInfo.pNext中
		VkExportFenceWin32HandleInfoKHR exportFenceWin32HandleInfo{};
		exportFenceWin32HandleInfo.sType = VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR;
		exportFenceWin32HandleInfo.pNext = nullptr;
		exportFenceWin32HandleInfo.pAttributes = nullptr;//这个先设置为nullptr使用默认的属性
		
		*pnext = &exportFenceWin32HandleInfo;
		pnext = &exportFenceWin32HandleInfo.pNext;
		
		
	}


	VkFence fence{nullptr};
	VK_RESULT_CHECK_CALL(vkCreateFence(device, &fenceCreateInfo, nullptr, &fence));
	
	void* fenceNTHandle{ nullptr };
	if ((fenceCompatibleHandleTypes & VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT)
		|| (fenceCompatibleHandleTypes & VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT))
	{

		VkFenceGetWin32HandleInfoKHR fenceGetWin32HandleInfo{};
		fenceGetWin32HandleInfo.sType = VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR;
		fenceGetWin32HandleInfo.handleType = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT;
		fenceGetWin32HandleInfo.fence = fence;
		fenceGetWin32HandleInfo.pNext = nullptr;
		//获取fence的win32句柄
		
		//如果handletype是VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT或者VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,则说明这个fence是native handle
		//如果是NT handle则对于每一个handletype，该函数只能被调用一次,详情见vulkanspeci.pdf的p323
		VK_DEVICE_FUNCTION_GET_AND_CALL(device, vkGetFenceWin32HandleKHR,device, &fenceGetWin32HandleInfo, &fenceNTHandle);
		//获取的handle在不需要的时候需要关闭
	}
	int fd{ 0 };
	if ((fenceCompatibleHandleTypes & VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT)
		|| (fenceCompatibleHandleTypes & VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT))
	{
		VkFenceGetFdInfoKHR getFenceFD{};
		getFenceFD.sType = VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR;
		getFenceFD.pNext = nullptr;
		getFenceFD.fence = fence;
		getFenceFD.handleType = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT;
		
		//vkGetFenceFdKHR(device, &getFenceFD, &fd);
		VK_DEVICE_FUNCTION_GET_AND_CALL(device, vkGetFenceFdKHR,device,&getFenceFD,&fd)
		//获取的fd在不需要的时候需要关闭
	}
	
	auto status = vkGetFenceStatus(device, fence);//获取fence状态
	switch (status)
	{
	case VK_SUCCESS://fence已经signaled
		break;
	case VK_NOT_READY://fence未signaled
		break;
	case VK_ERROR_DEVICE_LOST:
	case VK_ERROR_OUT_OF_HOST_MEMORY:
	case VK_ERROR_OUT_OF_DEVICE_MEMORY:
		break;//失败

	default:
		break;
	}

	vkWaitForFences(device, 1, &fence, VK_TRUE, VK_TIMEOUT);//在VK_TIMEOUT纳秒超时时间内等待fence变为signaled状态
	
	vkResetFences(device, 1, &fence);//设置fence为未signaled状态

	

	VkDeviceEventInfoEXT deviceEventInfo{};
	deviceEventInfo.sType = VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT;
	deviceEventInfo.pNext = nullptr;
	deviceEventInfo.deviceEvent = VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT;//设置触发事件类型为插入或者拔出显示器，主要用作显示器热插拔事件的同步
	//设置额外的触发事件来触发fence（除了队列执行触发以及host触发外）
	VK_DEVICE_FUNCTION_GET_AND_CALL(device, vkRegisterDeviceEventEXT,device, &deviceEventInfo, nullptr, &fence);

	VkDisplayKHR display{};
	VkDisplayEventInfoEXT displayEventInfo{};
	displayEventInfo.sType = VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT;
	displayEventInfo.pNext = nullptr;
	displayEventInfo.displayEvent = VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT;//指定触发事件类型为第一个像素输出事件,即下一个显示周期的第一个像素输出时触发fence
	//设置额外的显示设备的事件来触发fence（除了队列执行触发以及host触发外）
	VK_DEVICE_FUNCTION_GET_AND_CALL(device, vkRegisterDisplayEventEXT,device, display, &displayEventInfo, nullptr, &fence);


	//导入payload
	

	VkImportFenceWin32HandleInfoKHR importFenceWin32HandleInfo{};
	importFenceWin32HandleInfo.sType = VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR;
	importFenceWin32HandleInfo.fence = fence;//fence不能是队列上且未执行的状态
	importFenceWin32HandleInfo.handle = fenceNTHandle;
	importFenceWin32HandleInfo.flags = VK_FENCE_IMPORT_TEMPORARY_BIT;
	importFenceWin32HandleInfo.pNext = nullptr;
	importFenceWin32HandleInfo.handleType = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT;
	//VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT以及VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT都是引用导入，都可以是临时的或者永久的
	if (importFenceWin32HandleInfo.handleType != VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT) {
		importFenceWin32HandleInfo.name = nullptr;
	}
	if (importFenceWin32HandleInfo.handle)
	{
		importFenceWin32HandleInfo.name = nullptr;
	}
	else {
		CONST WCHAR* name = L"tmp";//示例用法，可以设置一个名字来标识这个fence
		importFenceWin32HandleInfo.name = name;//示例用法，可以设置一个名字来标识这个fence
	}
	//导入fence可以多次导入同一个handle到vulkan的fence中,可以和原来的fence相同也可以不同
	VK_DEVICE_FUNCTION_GET_AND_CALL(device, vkImportFenceWin32HandleKHR,device, &importFenceWin32HandleInfo);


	VkImportFenceFdInfoKHR importFenceFDInfo {};
	importFenceFDInfo.sType = VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR;
	importFenceFDInfo.fd = fd;//导入的fd为 -1 且为VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT时表示引入一个已经触发的fence
	importFenceFDInfo.fence = fence;//fence不能是队列上且未执行的状态
	importFenceFDInfo.flags = VK_FENCE_IMPORT_TEMPORARY_BIT;
	importFenceFDInfo.handleType = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT;//VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT是引用，可以是临时或者永久的 ，VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT为复制fd，是临时性的，
	importFenceFDInfo.pNext = nullptr;
	//导入fence可以多次导入同一个handle到vulkan的fence中,可以和原来的fence相同也可以不同
	VK_DEVICE_FUNCTION_GET_AND_CALL(device,vkImportFenceFdKHR,device, &importFenceFDInfo);//导入fd到fence中

	//销毁fence
	vkDestroyFence(device, fence, nullptr);



}

struct SemaphoreCreateInfoExt
{
	VkExportMetalObjectCreateInfoEXT exportMetalObjectInfo{};
	VkExportSemaphoreCreateInfo exportSemaphoreInfo{};
	VkExportSemaphoreWin32HandleInfoKHR exportSemaphoreWin32HandleInfo{};
	VkImportMetalSharedEventInfoEXT importMetalSharedEventInfo{};
	VkQueryLowLatencySupportNV queryLowLatencySupportInfo{};
	VkSemaphoreTypeCreateInfo semaphoreTypeCreateInfo{};
	SemaphoreCreateInfoExt() {
		Init();
	}
	void Init() {
		exportMetalObjectInfo.sType = VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT;
		exportMetalObjectInfo.pNext = &exportSemaphoreInfo;
		exportSemaphoreInfo.sType = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO;
		exportSemaphoreInfo.pNext = &exportSemaphoreWin32HandleInfo;
		exportSemaphoreWin32HandleInfo.sType = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR;
		exportSemaphoreWin32HandleInfo.pNext = &importMetalSharedEventInfo;
		importMetalSharedEventInfo.sType = VK_STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT;
		importMetalSharedEventInfo.pNext = &queryLowLatencySupportInfo;
		queryLowLatencySupportInfo.sType = VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV;
		queryLowLatencySupportInfo.pNext = &semaphoreTypeCreateInfo;
		semaphoreTypeCreateInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO;
		semaphoreTypeCreateInfo.pNext = nullptr;
	}
};


void SyncronizationAndCacheControlTest::SemaphoreTest()
{
	VkSemaphore binarySemaphore{ nullptr }, timelineSemaphore{ nullptr };//queue间或queue与host间
	VkSemaphoreCreateInfo binarySemaphoreCreateInfo{};
	binarySemaphoreCreateInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;
	binarySemaphoreCreateInfo.flags = VK_FENCE_CREATE_SIGNALED_BIT;//创建一个触发的二状态信号量

	SemaphoreCreateInfoExt binarySemaphoreCreateInfoExt{};
	binarySemaphoreCreateInfo.pNext = &binarySemaphoreCreateInfoExt.exportMetalObjectInfo;//把扩展信息添加到信号量创建信息中
	//指定信号量的类型
	auto& binarySemaphoreTypeCreateInfoExt = binarySemaphoreCreateInfoExt.semaphoreTypeCreateInfo;
	binarySemaphoreTypeCreateInfoExt.semaphoreType = VK_SEMAPHORE_TYPE_BINARY;//VK_SEMAPHORE_TYPE_BINARY是二状态信号量（只有触发和未触发两种状态）,或者VK_SEMAPHORE_TYPE_TIMELINE是timeline信号量
	binarySemaphoreTypeCreateInfoExt.initialValue = 0;//如果是二状态信号量,初始值为0,如果是timeline信号量,初始值为一个指定的值

	//导出payload
	bool suportWin32HandleExport = false, surportFdHandleExport = false, surpotZircorExport = false;
	auto& exportSemaphoreInfo = binarySemaphoreCreateInfoExt.exportSemaphoreInfo;
	{
		//先获取可以导出payload的格式属性
		VkExternalSemaphoreProperties externalSemaphoreProperties{};
		VkPhysicalDeviceExternalSemaphoreInfo externalSemaphoreInfo{};//通过VkPhysicalDeviceExternalSemaphoreInfo指明要查询的导出句柄的类型
		externalSemaphoreInfo.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO;
		externalSemaphoreInfo.handleType = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT;
		//获取win32句柄的属性
		vkGetPhysicalDeviceExternalSemaphoreProperties(physicalDevice, &externalSemaphoreInfo, &externalSemaphoreProperties);
		suportWin32HandleExport = (externalSemaphoreProperties.externalSemaphoreFeatures & VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT) != 0;
		if (suportWin32HandleExport) {
			exportSemaphoreInfo.handleTypes |= VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT;

			auto& exportSemaphoreWin32HandleInfo = binarySemaphoreCreateInfoExt.exportSemaphoreWin32HandleInfo;//如果支持导出win32句柄就可以添加额外的属性描述信息,如果semaphoreCreateInfo的pNext中不含exportSemaphoreInfo，那么该结构体会被忽略
			exportSemaphoreWin32HandleInfo.sType = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR;//
			exportSemaphoreWin32HandleInfo.dwAccess = SEMAPHORE_ALL_ACCESS;//指定导出信号量的访问权限
			exportSemaphoreWin32HandleInfo.pAttributes = nullptr;//指定导出信号量的安全属性，先设置为nullptr即使用默认属性
			exportSemaphoreWin32HandleInfo.name = L"test";//指定导出信号量的名字，可以为空



		}
		externalSemaphoreInfo.handleType = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT;
		//获取fd的属性
		vkGetPhysicalDeviceExternalSemaphoreProperties(physicalDevice, &externalSemaphoreInfo, &externalSemaphoreProperties);
		surportFdHandleExport = (externalSemaphoreProperties.externalSemaphoreFeatures & VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT) != 0;

		if (surportFdHandleExport)
		{
			exportSemaphoreInfo.handleTypes |= VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT;
		}

		//获取Zircon共享内存导出
		externalSemaphoreInfo.handleType = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_ZIRCON_EVENT_BIT_FUCHSIA;
		//获取Zircon的属性
		vkGetPhysicalDeviceExternalSemaphoreProperties(physicalDevice, &externalSemaphoreInfo, &externalSemaphoreProperties);
		surpotZircorExport = (externalSemaphoreProperties.externalSemaphoreFeatures & VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT) != 0;

		if (surpotZircorExport)
		{
			exportSemaphoreInfo.handleTypes |= VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_ZIRCON_EVENT_BIT_FUCHSIA;
		}
	}

	//
	auto& queryLowLatencySupportNV = binarySemaphoreCreateInfoExt.queryLowLatencySupportInfo;
	queryLowLatencySupportNV.pQueriedLowLatencyData = nullptr;//这个结构体用于查询低延迟特性，如果不需要查询低延迟特性，可以设置为nullptr（待确认）

	//

	vkCreateSemaphore(device, &binarySemaphoreCreateInfo, nullptr, &binarySemaphore);//创建二状态信号

	//如果binarySemaphore已经导出了win32句柄，那么可以调用调用以下操作获取句柄
	HANDLE semaphoreHandle{ nullptr };
	if (suportWin32HandleExport)
	{
		
		VkSemaphoreGetWin32HandleInfoKHR getWin32HandleInfo{};
		getWin32HandleInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR;
		getWin32HandleInfo.pNext = nullptr;
		getWin32HandleInfo.semaphore = binarySemaphore;
		getWin32HandleInfo.handleType = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT;
		VK_DEVICE_FUNCTION_GET_AND_CALL(device, vkGetSemaphoreWin32HandleKHR, device, &getWin32HandleInfo, &semaphoreHandle);//同一个handle type的句柄只能导出一次，且不需要时需要关闭句柄
	}
	//如果binarySemaphore已经导出了fd句柄，那么可以调用以下操作获取句柄
	int fd{ -1 };
	if (surportFdHandleExport) {

		
		VkSemaphoreGetFdInfoKHR getFdInfo{};
		getFdInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR;
		getFdInfo.handleType = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT;
		getFdInfo.semaphore = binarySemaphore;
		getFdInfo.pNext = nullptr;
		VK_DEVICE_FUNCTION_GET_AND_CALL(device, vkGetSemaphoreFdKHR, device, &getFdInfo, &fd);//同一个handle type的fd只能导出一次，且不需要时需要关闭fd,相当于文件描述符，不需要时调用close(fd)关闭

	}

	//zircon句柄导出
	zx_handle_t zirconHandle;
	if (surpotZircorExport)
	{
		//zx_handle 主要出现在Fuchsia操作系统的Vulkan实现中。Fuchsia是Google开发的一个开源操作系统，旨在在广泛的设备上运行，包括手机、平板电脑、笔记本电脑和嵌入式设备。zx_handle 是Fuchsia中表示系统资源的一种通用句柄类型
		VkSemaphoreGetZirconHandleInfoFUCHSIA getZirconHandleInfo{};//用于获取Zircon共享内存句柄
		getZirconHandleInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA;
		getZirconHandleInfo.handleType = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_ZIRCON_EVENT_BIT_FUCHSIA;
		getZirconHandleInfo.semaphore = binarySemaphore;
		getZirconHandleInfo.pNext = nullptr;
		
		VK_DEVICE_FUNCTION_GET_AND_CALL(device, vkGetSemaphoreZirconHandleFUCHSIA, device, &getZirconHandleInfo, &zirconHandle);//同一个handle type的zircon handle只能导出一次，且不需要时需要关闭zircon handle
	}

	//导入payload
	//引入一个win32 handle
	//可以多次导入
	if (suportWin32HandleExport)
	{
		VkImportSemaphoreWin32HandleInfoKHR importSemaphoreWin32HandleInfo{};
		importSemaphoreWin32HandleInfo.sType = VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR;
		importSemaphoreWin32HandleInfo.flags = VK_SEMAPHORE_IMPORT_TEMPORARY_BIT;
		importSemaphoreWin32HandleInfo.handle = semaphoreHandle;//不需要时候主动关闭句柄
		importSemaphoreWin32HandleInfo.handleType = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT;//需要符合VkExternalSemaphoreProperties中的compitable的handle type
		//导入类型可以为VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT，VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT，VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT，都是引用导入，可以是临时或者永久的
		if (importSemaphoreWin32HandleInfo.handle || importSemaphoreWin32HandleInfo.handleType == VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT) {
			importSemaphoreWin32HandleInfo.name = nullptr;
		}
		else {
			importSemaphoreWin32HandleInfo.name = L"test";//如果handle无效就需要指定导入的信号量的名字
		}
		
		importSemaphoreWin32HandleInfo.pNext = nullptr;
		importSemaphoreWin32HandleInfo.semaphore = binarySemaphore;
		
		VK_DEVICE_FUNCTION_GET_AND_CALL(device, vkImportSemaphoreWin32HandleKHR, device, &importSemaphoreWin32HandleInfo);
	}
	
	//引入fd句柄
	if (surportFdHandleExport) {
		VkImportSemaphoreFdInfoKHR importSemaphoreFdInfo{};
		importSemaphoreFdInfo.sType = VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR;
		importSemaphoreFdInfo.fd = fd;//不需要时候主动关闭fd，如果类型是VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT，那么fd为-1可以表示一个已经触发的信号量
		importSemaphoreFdInfo.handleType = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT;//需要符合VkExternalSemaphoreProperties中的compitable的handle type
		//VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT是引用导入，可以是临时或者永久的，VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT是复制导入，是临时的
		importSemaphoreFdInfo.flags = VK_SEMAPHORE_IMPORT_TEMPORARY_BIT;//如果是VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT复制导入，那么flags必须为VK_SEMAPHORE_IMPORT_TEMPORARY_BIT，这里直接设置为临时导入
		importSemaphoreFdInfo.pNext = nullptr;
		importSemaphoreFdInfo.semaphore = binarySemaphore;
		VK_DEVICE_FUNCTION_GET_AND_CALL(device, vkImportSemaphoreFdKHR, device, &importSemaphoreFdInfo);


	}

	//引入zircon handle
	if (surpotZircorExport)
	{
		VkImportSemaphoreZirconHandleInfoFUCHSIA importSemaphoreZirconHandleInfo{};
		importSemaphoreZirconHandleInfo.sType = VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA;
		importSemaphoreZirconHandleInfo.flags = VK_SEMAPHORE_IMPORT_TEMPORARY_BIT;
		importSemaphoreZirconHandleInfo.pNext = nullptr;
		importSemaphoreZirconHandleInfo.semaphore = binarySemaphore;//不能是timeline信号量
		importSemaphoreZirconHandleInfo.handleType = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_ZIRCON_EVENT_BIT_FUCHSIA;//需要符合VkExternalSemaphoreProperties中的compitable的handle type,VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_ZIRCON_EVENT_BIT_FUCHSIA是引用导入，可以是临时或者永久的
		importSemaphoreZirconHandleInfo.zirconHandle = zirconHandle;
		
		VK_DEVICE_FUNCTION_GET_AND_CALL(device, vkImportSemaphoreZirconHandleFUCHSIA, device, &importSemaphoreZirconHandleInfo);



	}


	vkDestroySemaphore(device, binarySemaphore, nullptr);//销毁信号量







	//创建一个timeline信号量

	SemaphoreCreateInfoExt timelineSemaphoreCreateInfoExt{};
	VkSemaphoreCreateInfo timelineSemaphoreCreateInfo{};
	timelineSemaphoreCreateInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;;
	timelineSemaphoreCreateInfo.pNext = &timelineSemaphoreCreateInfoExt.exportMetalObjectInfo;
	timelineSemaphoreCreateInfo.flags = 0;//创建一个未触发的信号量
	auto& timelineSemaphoreTypeInfo = timelineSemaphoreCreateInfoExt.semaphoreTypeCreateInfo;
	timelineSemaphoreTypeInfo.initialValue = 0;//初始值为0
	timelineSemaphoreTypeInfo.semaphoreType = VK_SEMAPHORE_TYPE_TIMELINE_KHR;//创建timeline信号量
	VK_RESULT_CHECK_CALL(vkCreateSemaphore(device, &timelineSemaphoreCreateInfo, nullptr, &timelineSemaphore));

	uint64_t counterValue{ 0 };
	//获取当前时间线值
	vkGetSemaphoreCounterValue(device, timelineSemaphore, &counterValue);

	//触发timeline类型信号量
	VkSemaphoreSignalInfo semaphoreSignalInfo{
		.sType = VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO,
		.pNext = nullptr,
		.semaphore = timelineSemaphore,
		.value = 1000,//这个值必须大于当前时间线值且小于在pending状态下信号量触发操作的值，且差值不能大于maxTimelineSemaphoreValueDifference
		//.sType = VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO,
	};//无序初始化，顺序需要和定义的时候一样，不然会报错
	vkSignalSemaphore(device, &semaphoreSignalInfo);//触发timeline信号量，并且直接将信号量的当前值设置为value的值

	//等待timeline类型信号量触发
	VkSemaphoreWaitInfo semapheWaitInfo{};
	semapheWaitInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO;
	semapheWaitInfo.flags = VK_SEMAPHORE_WAIT_ANY_BIT;//VK_SEMAPHORE_WAIT_ANY_BIT表示等待任意信号量触发，如果没有设置则是表示等待所有信号量触发
	semapheWaitInfo.pNext = nullptr;
	semapheWaitInfo.pSemaphores = &timelineSemaphore;//这里的信号量都必须是timeline信号量
	semapheWaitInfo.semaphoreCount = 1;
	uint64_t signalValue = 1000;//触发需要的值
	semapheWaitInfo.pValues = &signalValue;//这里的值是触发信号量需要的值，不是等待时间
	vkWaitSemaphores(device, &semapheWaitInfo, VK_TIMEOUT);



	vkDestroySemaphore(device,timelineSemaphore, nullptr);//销毁信号量

	
}

//event这一节的内容先就这样，不再细究了，后面有实践机会再补充和深入理解
void SyncronizationAndCacheControlTest::EventTest()
{
	//如果VK_KHR_portability_subset 拓展开启且VkPhysicalDevicePortabilitySubsetFeaturesKHR::events 是 VK_FALSE,那么不支持使用event
	VkEvent vEvent{nullptr};//queue内或queue与host间
	VkEventCreateInfo eventCreateInfo{};
	eventCreateInfo.sType = VK_STRUCTURE_TYPE_EVENT_CREATE_INFO;
	//eventCreateInfo.pNext = nullptr;
	eventCreateInfo.flags = VK_EVENT_CREATE_DEVICE_ONLY_BIT;//创建一个只在device内部使用的event，如果为0则host也能用

	//pnext中只能含有两种结构体中的一种VkExportMetalObjectCreateInfoEXT和VkImportMetalSharedEventInfoEXT
	VkExportMetalObjectCreateInfoEXT exportMetalObjectInfo{};
	exportMetalObjectInfo.sType = VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT;
	exportMetalObjectInfo.pNext = nullptr;
	exportMetalObjectInfo.exportObjectType = VK_EXPORT_METAL_OBJECT_TYPE_METAL_SHARED_EVENT_BIT_EXT;
	eventCreateInfo.pNext = &exportMetalObjectInfo;

	

	VK_RESULT_CHECK_CALL(vkCreateEvent(device, &eventCreateInfo, nullptr, &vEvent));


	//获取event状态
	auto res = vkGetEventStatus(device, vEvent);
	switch (res)
	{
	case VK_EVENT_SET: break;//event成功触发
	case VK_EVENT_RESET:break;//event未触发
	default:
		break;//查询失败返回VK_ERROR_OUT_OF_HOST_MEMORY VK_ERROR_OUT_OF_DEVICE_MEMORY VK_ERROR_DEVICE_LOST
	}

	//触发event
	vkSetEvent(device, vEvent);//如果队列中执行的命令需要等待host端的event，那么必须保证在提交命令前host端的event已经触发，该event就不能以VK_EVENT_CREATE_DEVICE_ONLY_BIT创建

	//重置event到未触发状态
	vkResetEvent(device, vEvent);//该event就不能以VK_EVENT_CREATE_DEVICE_ONLY_BIT创建

	//如果在命令缓冲区中触发event
	if (0)//这里没有cmdbuf的创建，所以这里的代码不会执行，只是为了展示
	{
		VkCommandBuffer cmdBuf{};
		VkDependencyInfo eventDependencyInfo{};
		eventDependencyInfo.sType = VK_STRUCTURE_TYPE_DEPENDENCY_INFO;
		eventDependencyInfo.pNext = nullptr;
		eventDependencyInfo.dependencyFlags = 0;//这里目前还不怎么清楚，直接先设置为0
		eventDependencyInfo.memoryBarrierCount = 0;
		eventDependencyInfo.pMemoryBarriers = nullptr;
		eventDependencyInfo.bufferMemoryBarrierCount = 0;
		eventDependencyInfo.pBufferMemoryBarriers = nullptr;
		eventDependencyInfo.imageMemoryBarrierCount = 0;
		eventDependencyInfo.pImageMemoryBarriers = nullptr;
		vkCmdSetEvent2(cmdBuf, vEvent, &eventDependencyInfo);//必须在命令的render pass实例外调用
	
		vkCmdResetEvent2(cmdBuf, vEvent, VkPipelineStageFlagBits::VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT);//必须在命令的render pass实例外调用

		vkCmdWaitEvents2(cmdBuf, 1, &vEvent, &eventDependencyInfo);//可以和vkCmdSetEvent2和vkCmdResetEvent之间有内存依赖,和vkCmdSetEvent2有内存依赖，且不能等待vkCmdSetEvent触发的event

		vkCmdSetEvent(cmdBuf, vEvent, VkPipelineStageFlagBits::VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT);//必须在命令的render pass实例外调用
	

		vkCmdResetEvent(cmdBuf, vEvent, VkPipelineStageFlagBits::VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT);//必须在命令的render pass实例外调用

		vkCmdWaitEvents(cmdBuf, 1, &vEvent, VkPipelineStageFlagBits::VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT, VkPipelineStageFlagBits::VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT, 0, nullptr, 0, nullptr, 0, nullptr);//只能等待vkCmdSetEvent触发的event
	}



	vkDestroyEvent(device, vEvent, nullptr);
	VkImportMetalSharedEventInfoEXT importMetalSharedEventInfo{};
	importMetalSharedEventInfo.sType = VK_STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT;
	importMetalSharedEventInfo.pNext = nullptr;
	//importMetalSharedEventInfo.mtlSharedEvent = metalSharedEvent;


}

enum class  VkDependencyFlagBitsWithNotation {
	VK_DEPENDENCY_BY_REGION_BIT = 0x00000001,//指明依赖是framebuffer-local的
	// Provided by VK_VERSION_1_1
	VK_DEPENDENCY_DEVICE_GROUP_BIT = 0x00000004,//指明依赖不是device-local的
	// Provided by VK_VERSION_1_1
	VK_DEPENDENCY_VIEW_LOCAL_BIT = 0x00000002,//指明依赖是view-local的
	// Provided by VK_EXT_attachment_feedback_loop_layout
	VK_DEPENDENCY_FEEDBACK_LOOP_BIT_EXT = 0x00000008,//指明render pass将通过 VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT布局从同一个image中读取或写入数据
	// Provided by VK_KHR_multiview
	VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR = VK_DEPENDENCY_VIEW_LOCAL_BIT,
	// Provided by VK_KHR_device_group
	VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR = VK_DEPENDENCY_DEVICE_GROUP_BIT
};


void SyncronizationAndCacheControlTest::PipelineBarrierTest()
{
	VkCommandBuffer cmdBuf;
	VkDependencyInfo dependencyInfo{};
	dependencyInfo.sType = VK_STRUCTURE_TYPE_DEPENDENCY_INFO;
	dependencyInfo.dependencyFlags = 0;
	dependencyInfo.pNext = nullptr;
	dependencyInfo.memoryBarrierCount = 0;
	dependencyInfo.pMemoryBarriers = nullptr;
	dependencyInfo.bufferMemoryBarrierCount = 0;
	dependencyInfo.pBufferMemoryBarriers = nullptr;
	dependencyInfo.imageMemoryBarrierCount = 0;
	dependencyInfo.pImageMemoryBarriers = nullptr;

	//vkCmdPipelineBarrier2和vkCmdPipelineBarrier定义在该命令之前的所有命令后在该命令后的所有命令的内存依赖
	//cmd
	{
		//开始render pass实例的命令用法如下，以下命令不能交叉使用，只能单独使用
		{
			vkCmdBeginRendering(cmdBuf, nullptr);
			{
				//这里是render pass实例的范围
			}
			vkCmdEndRendering(cmdBuf);

			vkCmdBeginRenderPass(cmdBuf, nullptr, VK_SUBPASS_CONTENTS_INLINE);
			{
				//这里是render pass实例的范围
			}
			vkCmdEndRenderPass(cmdBuf);

			vkCmdBeginRenderPass2(cmdBuf, nullptr, nullptr);
			{
				//这里是render pass实例的范围
			}
			vkCmdEndRenderPass2(cmdBuf, nullptr);
		
		
		}
		





		vkCmdPipelineBarrier2(cmdBuf, &dependencyInfo);
		/*
		  framebuffer-space管线状态包括：
		  >VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT
		  >VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT
		  >VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT
		  >VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT
		 
		有效用法：
		1.如果该命令没有在render pass实例内调用，且该实例至少有一个subpass依赖，那么该命令的dependenceFlags就不能包括
		VK_DEPENDENCY_BY_REGION_BIT 或者 VK_DEPENDENCY_VIEW_LOCAL_BIT
		2.如果该命令没有在render pass实例内调用，那么就不能有任何的buffer memory barriers
		3.如果该命令在render pass实例内调用，那么任何的image memory barriers都必须是作为当前子传递中使用的附件，既作为输入附件，也作为颜色、color resolve或深度/模板附件
		4.如果该命令在render pass实例内调用，且image memory barriers是用作color resolve附件，那么对应的颜色附件必须是 VK_ATTACHMENT_UNUSED
		5.如果该命令在render pass实例内调用，且image memory barriers是用作color resolve附件，那么该附件必须是以非零的VkExternalFormatANDROID：：externalFormat值创建的
		6.如果该命令在render pass实例内调用，则image memory barriers的oldLayout和newLayout必须相同
		7.如果该命令在render pass实例内调用，则任何memory barriers的srcQueueFamilyIndex和dstQueueFamilyIndex必须相同
		8.如果该命令在render pass实例内调用，且任何memory barriers的source stage masks包含"framebuffer-space管线状态"，那么destination stage masks必须只包括"framebuffer-space管线状态"
		9.如果该命令在render pass实例内调用，且任何memory barriers的source stage masks包含"framebuffer-space管线状态"，那么dependenceFlags必须包括VK_DEPENDENCY_BY_REGION_BIT
		10.如果该命令在render pass实例内调用，则source 和destination stage masks必须只能包含图形管线的管线状态
		11.如果该命令在render pass实例外调用，那么dependenceFlags不能包括 VK_DEPENDENCY_VIEW_LOCAL_BIT
		12.如果该命令在render pass实例内调用，且在当前的subpass内有多个view，那么dependenceFlags必须包括 VK_DEPENDENCY_VIEW_LOCAL_BIT
		13.如果shaderTileImageColorReadAccess, shaderTileImageStencilReadAccess,或者shaderTileImageDepthReadAccess 特性开启且 dynamicRenderingLocalRead特性为开启，则不能在render pass实例内调用该命令
		14.如果 dynamicRenderingLocalRea未开启，且该命令在 vkCmdBeginRendering开始的render pass实例内调用，那么就不能有buffer或者image memory barriers
		15.如果 dynamicRenderingLocalRea未开启，且该命令在 vkCmdBeginRendering开始的render pass实例内调用，那么memory barriers的访问控制只能是VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT, VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT,
			VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT, 或者VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT
		16.如果该命令在vkCmdBeginRendering开始的render pass实例中调用，那么用在当前render pass的附件的image的布局必须是VK_IMAGE_LAYOUT_RENDERING_LOCAL_READ_KHR 或者 VK_IMAGE_LAYOUT_GENERAL
		17.如果该命令在vkCmdBeginRendering开始的render pass实例中调用，那么memory barriers的srcStageMask 和 dstStageMask只能是"framebuffer-space管线状态"中的
		18. synchronization2特性必须开启
		19.无论是在memory，image memory还是buffer memory barriers中的srcPipelineStages以及dstPipelineStages管线状态都必须是当前cmdbuffer所在的cmdPool创建时的queueFamily支持的

		***** 附录：管线状态和访问控制的匹配参考之前的内容 
		*/


		vkCmdPipelineBarrier(cmdBuf, VK_PIPELINE_STAGE_ALL_COMMANDS_BIT, VK_PIPELINE_STAGE_ALL_COMMANDS_BIT, 0, 0, nullptr, 0, nullptr, 0, nullptr);
		//// Provided by VK_VERSION_1_0
		//void vkCmdPipelineBarrier(
		//	VkCommandBuffer commandBuffer,
		//	VkPipelineStageFlags srcStageMask,
		//	VkPipelineStageFlags dstStageMask,
		//	VkDependencyFlags dependencyFlags,
		//	uint32_t memoryBarrierCount,
		//	const VkMemoryBarrier * pMemoryBarriers,
		//	uint32_t bufferMemoryBarrierCount,
		//	const VkBufferMemoryBarrier * pBufferMemoryBarriers,
		//	uint32_t imageMemoryBarrierCount,
		//	const VkImageMemoryBarrier * pImageMemoryBarriers);
		
		/*
		合法用法：
		1.srcStageMask以及dstStageMask是否能使用或者是否能合法使用可以部分参考文档中pipeline stages合法用法的内容
		2.memory barriers中的srcAccessMask和dstAccessMask必须是和srcStageMask以及dstStageMask相匹配的合法的访问控制
		3.buffer memory barriers中，如果 srcQueueFamilyIndex和dstQueueFamilyIndex相等，那么srcAccessMask和dstAccessMask必须是和srcStageMask以及dstStageMask相匹配的合法的访问控制
		4.image memory barriers中，如果 srcQueueFamilyIndex和dstQueueFamilyIndex相等，那么srcAccessMask和dstAccessMask必须是和srcStageMask以及dstStageMask相匹配的合法的访问控制
		5.如果该命令没有在render pass实例内调用，且该实例至少有一个subpass依赖，那么该命令的dependenceFlags就不能包括
		VK_DEPENDENCY_BY_REGION_BIT 或者 VK_DEPENDENCY_VIEW_LOCAL_BIT
		6.如果该命令没有在render pass实例内调用，那么就不能有任何的buffer memory barriers
		7.如果该命令在render pass实例内调用，那么任何的image memory barriers都必须是作为当前子传递中使用的附件，既作为输入附件，也作为颜色、color resolve或深度/模板附件
		8.如果该命令在render pass实例内调用，且image memory barriers是用作color resolve附件，那么对应的颜色附件必须是 VK_ATTACHMENT_UNUSED
		9.如果该命令在render pass实例内调用，且image memory barriers是用作color resolve附件，那么该附件必须是以非零的VkExternalFormatANDROID：：externalFormat值创建的
		10.如果该命令在render pass实例内调用，则image memory barriers的oldLayout和newLayout必须相同
		11.如果该命令在render pass实例内调用，则任何memory barriers的srcQueueFamilyIndex和dstQueueFamilyIndex必须相同
		12.如果该命令在render pass实例内调用，且任何memory barriers的source stage masks包含"framebuffer-space管线状态"，那么destination stage masks必须只包括"framebuffer-space管线状态"
		13.如果该命令在render pass实例内调用，且任何memory barriers的source stage masks包含"framebuffer-space管线状态"，那么dependenceFlags必须包括VK_DEPENDENCY_BY_REGION_BIT
		14.如果该命令在render pass实例内调用，则source 和destination stage masks必须只能包含图形管线的管线状态
		15.如果该命令在render pass实例外调用，那么dependenceFlags不能包括 VK_DEPENDENCY_VIEW_LOCAL_BIT
		16.如果该命令在render pass实例内调用，且在当前的subpass内有多个view，那么dependenceFlags必须包括 VK_DEPENDENCY_VIEW_LOCAL_BIT
		17.如果shaderTileImageColorReadAccess, shaderTileImageStencilReadAccess,或者shaderTileImageDepthReadAccess 特性开启且 dynamicRenderingLocalRead特性为开启，则不能在render pass实例内调用该命令
		18.如果 dynamicRenderingLocalRea未开启，且该命令在 vkCmdBeginRendering开始的render pass实例内调用，那么就不能有buffer或者image memory barriers
		19.如果 dynamicRenderingLocalRea未开启，且该命令在 vkCmdBeginRendering开始的render pass实例内调用，那么memory barriers的访问控制只能是VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT, VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT,
			VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT, 或者VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT
		20.如果该命令在vkCmdBeginRendering开始的render pass实例中调用，那么用在当前render pass的附件的image的布局必须是VK_IMAGE_LAYOUT_RENDERING_LOCAL_READ_KHR 或者 VK_IMAGE_LAYOUT_GENERAL
		21.如果该命令在vkCmdBeginRendering开始的render pass实例中调用，那么memory barriers的srcStageMask 和 dstStageMask只能是"framebuffer-space管线状态"中的
		22.任何srcStageMask以及dstStageMask都必须是该命令所在的cmdbuffer所在的cmdPool创建时的queueFamily支持的
		23.如果srcStageMask以及dstStageMask包含VK_PIPELINE_STAGE_HOST_BIT,那么pImageMemoryBarriers的任何元素， pBufferMemoryBarriers的任何元素，srcQueueFamilyIndex 和 dstQueueFamilyIndex必须相等



		
		*/
	}

	//memory barriers
	//访问权限和管线阶段的匹配见之前的函数CheckMatchAccessFlagsAndPipelineStageFlags2里面的实例
	VkMemoryBarrier2 memoryBarrier2;//用在pipeline barrier中作为全局的内存栅栏，控制执行过程中所有内存对象的访问
	memoryBarrier2.sType = VK_STRUCTURE_TYPE_MEMORY_BARRIER_2;
	memoryBarrier2.srcAccessMask = VK_ACCESS_2_SHADER_WRITE_BIT_KHR;
	memoryBarrier2.srcStageMask = VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT_KHR;
	memoryBarrier2.dstAccessMask = VK_ACCESS_2_SHADER_READ_BIT_KHR;
	memoryBarrier2.dstStageMask = VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT_KHR;
	memoryBarrier2.pNext = nullptr;

	VkMemoryBarrier memoryBarrier;//用在pipeline barrier中作为全局的内存栅栏，控制执行过程中单个内存对象的访问
	memoryBarrier.sType = VK_STRUCTURE_TYPE_MEMORY_BARRIER;
	memoryBarrier.pNext = nullptr;
	memoryBarrier.srcAccessMask = VK_ACCESS_SHADER_WRITE_BIT;
	memoryBarrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;


	//buffer memory barriers
	//1.如果srcQueueFamilyIndex和dstQueueFamilyIndex不相等，且srcQueueFamilyIndex和当前执行的cmdbuffer的queueFamilyIndex相等，那么
	//该buffer memory barriers将会定义一个所有权释放操作，这样dstAccessMask，dstStageMask则是会被忽略的；
	//2.如果srcQueueFamilyIndex和dstQueueFamilyIndex不相等，且dstQueueFamilyIndex和当前执行的cmdbuffer的queueFamilyIndex相等，那么
	//该buffer memory barriers将会定义一个所有权获取操作，这样srcAccessMask，srcStageMask则是会被忽略的；
	VkBufferMemoryBarrier2 bufferMemoryBarrier2;//用在pipeline barrier中控制buffer memory某个范围的访问以及所有权转换
	bufferMemoryBarrier2.sType = VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2;
	bufferMemoryBarrier2.pNext = nullptr;
	bufferMemoryBarrier2.buffer = nullptr;
	bufferMemoryBarrier2.offset = 0;
	bufferMemoryBarrier2.size = VK_WHOLE_SIZE;//VK_WHOLE_SIZE表示从offset开始，直到buffer末尾的所有字节都将被栅栏操作影响,一个确定的值则表示从offset开始的size个字节将被栅栏操作影响
	bufferMemoryBarrier2.srcAccessMask = VK_ACCESS_2_SHADER_WRITE_BIT_KHR;
	bufferMemoryBarrier2.srcStageMask = VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT_KHR;
	bufferMemoryBarrier2.srcQueueFamilyIndex = 0;
	bufferMemoryBarrier2.dstAccessMask = VK_ACCESS_2_SHADER_READ_BIT_KHR;
	bufferMemoryBarrier2.dstStageMask = VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT_KHR;
	bufferMemoryBarrier2.dstQueueFamilyIndex = 0;
	/*
	合法用法
	1.访问权限和管线阶段的匹配见之前的函数CheckMatchAccessFlagsAndPipelineStageFlags2里面的实例
	2.如果buffer以VK_SHARING_MODE_EXCLUSIVE模式创建，且srcQueueFamilyIndex和dstQueueFamilyIndex不相等，那么srcQueueFamilyIndex和dstQueueFamilyIndex必须是
	VK_QUEUE_FAMILY_EXTERNAL或者 VK_QUEUE_FAMILY_FOREIGN_EXT或者一个合法的queueFamilyIndex，且srcQueueFamilyIndex和dstQueueFamilyIndex至少有一个是VK_QUEUE_FAMILY_EXTERNAL或者 VK_QUEUE_FAMILY_FOREIGN_EXT，
	另一个是一个合法的queueFamilyIndex
	3.如果VK_KHR_external_memory特性未开启，则srcQueueFamilyIndex和dstQueueFamilyIndex就不能是VK_QUEUE_FAMILY_EXTERNAL
	4.如果 VK_EXT_queue_family_foreign特性未开启，则srcQueueFamilyIndex和dstQueueFamilyIndex就不能是VK_QUEUE_FAMILY_FOREIGN_EXT
	5.如果srcStageMask 或者 dstStageMask 含有 VK_PIPELINE_STAGE_2_HOST_BIT，则srcQueueFamilyIndex和dstQueueFamilyIndex必须相等

	*/




	//1.如果srcQueueFamilyIndex和dstQueueFamilyIndex不相等，且srcQueueFamilyIndex和当前执行的cmdbuffer的queueFamilyIndex相等，那么
	//该buffer memory barriers将会定义一个所有权释放操作，这样dstAccessMask，dstStageMask则是会被忽略的；
	//2.如果srcQueueFamilyIndex和dstQueueFamilyIndex不相等，且dstQueueFamilyIndex和当前执行的cmdbuffer的queueFamilyIndex相等，那么
	//该buffer memory barriers将会定义一个所有权获取操作，这样srcAccessMask，srcStageMask则是会被忽略的；
	//3.如果srcAccessFlags中或者dstAccessFlags中包含VK_ACCESS_HOST_WRITE_BIT或者VK_ACCESS_HOST_READ_BIT,那么即是host端可访问的内存，也是device端可访问的内存
	VkBufferMemoryBarrier bufferMemoryBarrier;//用在pipeline barrier中控制buffer memory某个范围的访问以及所有权转换
	bufferMemoryBarrier.sType = VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER;
	bufferMemoryBarrier.pNext = nullptr;
	bufferMemoryBarrier.srcAccessMask = VK_ACCESS_SHADER_WRITE_BIT;
	bufferMemoryBarrier.srcQueueFamilyIndex = 0;
	bufferMemoryBarrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;
	bufferMemoryBarrier.dstQueueFamilyIndex = 0;
	bufferMemoryBarrier.buffer = nullptr;
	bufferMemoryBarrier.offset = 0;
	bufferMemoryBarrier.size = VK_WHOLE_SIZE;//VK_WHOLE_SIZE表示从offset开始，直到buffer末尾的所有字节都将被栅栏操作影响,一个确定的值则表示从offset开始的size个字节将被栅栏操作影响
	/*
	合法用法
	1.访问权限和管线阶段的匹配见之前的函数CheckMatchAccessFlagsAndPipelineStageFlags2里面的实例
	2.如果buffer以VK_SHARING_MODE_EXCLUSIVE模式创建，且srcQueueFamilyIndex和dstQueueFamilyIndex不相等，那么srcQueueFamilyIndex和dstQueueFamilyIndex必须是
	VK_QUEUE_FAMILY_EXTERNAL或者 VK_QUEUE_FAMILY_FOREIGN_EXT或者一个合法的queueFamilyIndex，且srcQueueFamilyIndex和dstQueueFamilyIndex至少有一个是VK_QUEUE_FAMILY_EXTERNAL或者 VK_QUEUE_FAMILY_FOREIGN_EXT，
	另一个是一个合法的queueFamilyIndex
	3.如果VK_KHR_external_memory特性未开启，则srcQueueFamilyIndex和dstQueueFamilyIndex就不能是VK_QUEUE_FAMILY_EXTERNAL
	4.如果 VK_EXT_queue_family_foreign特性未开启，则srcQueueFamilyIndex和dstQueueFamilyIndex就不能是VK_QUEUE_FAMILY_FOREIGN_EXT
	5.如果 synchronization2特性未开启且buffer是以VK_SHARING_MODE_CONCURRENT创建的，那么srcQueueFamilyIndex和dstQueueFamilyIndex必须是VK_QUEUE_FAMILY_IGNORED 或者 VK_QUEUE_FAMILY_EXTERNAL
		
	
	*/



	//image memory barriers
	//1.如果image以VK_SHARING_MODE_EXCLUSIVE创建，且srcQueueFamilyIndex和dstQueueFamilyIndex不相等，且srcQueueFamilyIndex和当前执行的cmdbuffer的queueFamilyIndex相等，那么
	//该image memory barriers将会定义一个所有权释放操作，且第二个同步域不应用这个释放操作(即dstAccessMask，dstStageMask则是会被忽略的)；如果dstQueueFamilyIndex和当前执行的cmdbuffer的queueFamilyIndex相等，那么
	//该image memory barriers将会定义一个所有权获取操作，且第一个同步域不应用这个获取操作(即srcAccessMask，srcStageMask则是会被忽略的)；除了srcQueueFamilyIndex和dstQueueFamilyIndex不相等导致所有权转换的情况
	// 还有一些srcQueueFamilyIndex和dstQueueFamilyIndex中含有保留的特殊的用于转换的队列也会触发所有权转换操作
	//2.如果image是disjointed,那么subresourceRange里面的aspectMask含有VK_IMAGE_ASPECT_COLOR_BIT相当于包含
	//VK_IMAGE_ASPECT_PLANE_0_BIT & VK_IMAGE_ASPECT_PLANE_1_BIT & VK_IMAGE_ASPECT_PLANE_2_BIT
	VkImageMemoryBarrier2 imageMemoryBarrier2;//用在pipeline barrier中控制image memory某个范围(layer，mip等)的访问，布局转换以及所有权转换
	imageMemoryBarrier2.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2;
	imageMemoryBarrier2.pNext = nullptr;//pnext可以链接 VkExternalMemoryAcquireUnmodifiedEXT 或者VkSampleLocationsInfoEXT 结构体
	imageMemoryBarrier2.image = nullptr;
	imageMemoryBarrier2.srcAccessMask = VK_ACCESS_2_SHADER_WRITE_BIT_KHR;
	imageMemoryBarrier2.srcStageMask = VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT_KHR;
	imageMemoryBarrier2.srcQueueFamilyIndex = 0;
	imageMemoryBarrier2.dstAccessMask = VK_ACCESS_2_SHADER_READ_BIT_KHR;
	imageMemoryBarrier2.dstStageMask = VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT_KHR;
	imageMemoryBarrier2.dstQueueFamilyIndex = 0;
	imageMemoryBarrier2.newLayout = VK_IMAGE_LAYOUT_UNDEFINED;
	imageMemoryBarrier2.newLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
	imageMemoryBarrier2.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
	imageMemoryBarrier2.subresourceRange.baseArrayLayer = 0;
	imageMemoryBarrier2.subresourceRange.layerCount = 1;
	imageMemoryBarrier2.subresourceRange.baseMipLevel = 0;
	imageMemoryBarrier2.subresourceRange.levelCount = 1;
	/*
	合法用法
	1.访问权限和管线阶段的匹配见之前的函数CheckMatchAccessFlagsAndPipelineStageFlags2里面的实例
	2.布局需要和创建image时候的用法标志匹配，即如果oldLayout或者newLayout是
		.oldLayout只能是VK_IMAGE_LAYOUT_UNDEFINED或者当前的layout，newLayout不能是VK_IMAGE_LAYOUT_UNDEFINED或者 VK_IMAGE_LAYOUT_PREINITIALIZED
		.VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL 那么image创建时的用法标志必须包含VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT
		.VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL，那么image创建时的用法标志必须包含VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT
		.VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL ，那么image创建时的用法标志必须包含VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT
		.VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL ，那么image创建时的用法标志必须包含VK_IMAGE_USAGE_SAMPLED_BIT或者VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT
		.VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL，那么image创建时的用法标志必须包含VK_IMAGE_USAGE_TRANSFER_SRC_BIT
		.VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL，那么image创建时的用法标志必须包含VK_IMAGE_USAGE_TRANSFER_DST_BIT
		.VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL，那么image创建时的用法标志必须包含 VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT
		.VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL，那么image创建时的用法标志必须包含VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT
		.VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL，那么image创建时的用法标志必须包含VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, VK_IMAGE_USAGE_SAMPLED_BIT,或者VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT其中之一
		.VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL，那么image创建时的用法标志必须包含VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT
		.VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL，那么image创建时的用法标志必须包含VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, VK_IMAGE_USAGE_SAMPLED_BIT,或者VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT其中之一
		.VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL，那么image创建时的用法标志必须包含VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT
		.VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL，那么image创建时的用法标志必须包含VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT 或者 VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT
		.VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL，那么image创建时的用法标志必须包含VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, VK_IMAGE_USAGE_SAMPLED_BIT,或者VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT其中之一
		.VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR，那么image创建时的用法标志必须包含 VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR
		.VK_IMAGE_LAYOUT_VIDEO_DECODE_SRC_KHR,那么image创建时的用法标志必须包含VK_IMAGE_USAGE_VIDEO_DECODE_SRC_BIT_KHR
		.VK_IMAGE_LAYOUT_VIDEO_DECODE_DST_KHR,那么image创建时的用法标志必须包含VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR
		.VK_IMAGE_LAYOUT_VIDEO_DECODE_DPB_KHR,那么image创建时的用法标志必须包含VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR
		.VK_IMAGE_LAYOUT_VIDEO_ENCODE_SRC_KHR,那么image创建时的用法标志必须包含VK_IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR
		.VK_IMAGE_LAYOUT_VIDEO_ENCODE_DST_KHR,那么image创建时的用法标志必顶包含VK_IMAGE_USAGE_VIDEO_ENCODE_DST_BIT_KHR
		.VK_IMAGE_LAYOUT_VIDEO_ENCODE_DPB_KHR,那么image创建时的用法标志必须包含VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR
		.VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT,那么image创建时的用法标志必须包含VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT 或者VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT 其中之一, 以及
			VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT 或者 VK_IMAGE_USAGE_SAMPLED_BIT其中之一,以及VK_IMAGE_USAGE_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT
		.VK_IMAGE_LAYOUT_RENDERING_LOCAL_READ_KHR，那么image创建时的用法标志必须包含VK_IMAGE_USAGE_STORAGE_BIT, 或者 VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT 和 VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT ， VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT两者其中一个
	3.如果synchronization2特性没有开启，那么oldLayout和newLayout不能是VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL_KHR 或者 VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR
	4.如果image以VK_SHARING_MODE_EXCLUSIVE模式创建，且srcQueueFamilyIndex和dstQueueFamilyIndex不相等，那么srcQueueFamilyIndex和dstQueueFamilyIndex必须是
	VK_QUEUE_FAMILY_EXTERNAL或者 VK_QUEUE_FAMILY_FOREIGN_EXT或者一个合法的queueFamilyIndex，且srcQueueFamilyIndex和dstQueueFamilyIndex至少有一个是VK_QUEUE_FAMILY_EXTERNAL或者 VK_QUEUE_FAMILY_FOREIGN_EXT，
	另一个是一个合法的queueFamilyIndex
	5.如果VK_KHR_external_memory特性未开启，则srcQueueFamilyIndex和dstQueueFamilyIndex就不能是VK_QUEUE_FAMILY_EXTERNAL
	6.如果 VK_EXT_queue_family_foreign特性未开启，则srcQueueFamilyIndex和dstQueueFamilyIndex就不能是VK_QUEUE_FAMILY_FOREIGN_EXT
	7.如果attachmentFeedbackLoopLayout特性未开启，oldLayout不能是VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT
	8.如果 dynamicRenderingLocalRead特性未开启，oldLayout不能是VK_IMAGE_LAYOUT_RENDERING_LOCAL_READ_KHR，newLayout不能是VK_IMAGE_LAYOUT_RENDERING_LOCAL_READ_KHR
	9.subresourceRange中的base层数和mipmap级别必须在image的层数和mipmap级别范围内，且加起来层数和mipmap的计数count不能超过image的层数和mipmap级别
	10.如果image有color format，且是single-plane或者不能disjoint的，那么subresourceRange.aspectMask必须包含 VK_IMAGE_ASPECT_COLOR_BIT
	11.如果separateDepthStencilLayouts未开启且image有depth/stencil format，那么subresourceRange.aspectMask必须包含 VK_IMAGE_ASPECT_DEPTH_BIT 以及 VK_IMAGE_ASPECT_STENCIL_BIT，如果separateDepthStencilLayouts开启
		那么subresourceRange.aspectMask必须包含 VK_IMAGE_ASPECT_DEPTH_BIT 或者 VK_IMAGE_ASPECT_STENCIL_BIT
	12.如果subresourceRange.aspectMask包含VK_IMAGE_ASPECT_DEPTH_BIT，那么oldLayout或者newLayout不能是VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL或者VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL
	13.如果subresourceRange.aspectMask包含VK_IMAGE_ASPECT_STENCIL_BIT，那么oldLayout或者newLayout不能是 VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL 或者VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL
	14.subresourceRange.aspectMask必须和image的format兼容
	15.如果srcStageMask 或者 dstStageMask包含VK_PIPELINE_STAGE_2_HOST_BIT,srcQueueFamilyIndex 和dstQueueFamilyIndex 必须相等
	16.如果srcStageMask包含VK_PIPELINE_STAGE_2_HOST_BIT，oldLayout必须是VK_IMAGE_LAYOUT_PREINITIALIZED, VK_IMAGE_LAYOUT_UNDEFINED,或者 VK_IMAGE_LAYOUT_GENERAL其中之一
	*/

	

	//
	//1.如果srcAccessMask中含有 VK_ACCESS_HOST_WRITE_BIT,那么由该访问类型执行的内存写也会可见，因为该访问类型不是通过资源执行的。如果dstAccessMask中含有VK_ACCESS_HOST_WRITE_BIT 或者 VK_ACCESS_HOST_READ_BIT
	// 可用的内存写入也对这些类型的访问可见，因为这些访问类型不是通过资源执行的。
	//2.如果srcQueueFamilyIndex和dstQueueFamilyIndex不相等，且srcQueueFamilyIndex和当前执行的cmdbuffer的queueFamilyIndex相等，那么
	//该image memory barriers将会定义一个所有权释放操作，且第二个同步域不应用这个释放操作(即dstAccessMask，dstStageMask则是会被忽略的)；如果dstQueueFamilyIndex和当前执行的cmdbuffer的queueFamilyIndex相等，那么
	//该image memory barriers将会定义一个所有权获取操作，且第一个同步域不应用这个获取操作(即srcAccessMask，srcStageMask则是会被忽略的)；除了srcQueueFamilyIndex和dstQueueFamilyIndex不相等导致所有权转换的情况
	// 还有一些srcQueueFamilyIndex和dstQueueFamilyIndex中含有保留的特殊的用于转换的队列也会触发所有权转换操作
	//3.如果image是disjointed且是multi-plane的, 那么subresourceRange里面的aspectMask含有VK_IMAGE_ASPECT_COLOR_BIT相当于包含
	//VK_IMAGE_ASPECT_PLANE_0_BIT & VK_IMAGE_ASPECT_PLANE_1_BIT & VK_IMAGE_ASPECT_PLANE_2_BIT
	VkImageMemoryBarrier imageMemoryBarrier = {};
	imageMemoryBarrier.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
	imageMemoryBarrier.pNext = nullptr;//pnext可以链接 VkExternalMemoryAcquireUnmodifiedEXT 或者VkSampleLocationsInfoEXT 结构体
	imageMemoryBarrier.srcAccessMask = VK_ACCESS_SHADER_WRITE_BIT;
	imageMemoryBarrier.srcQueueFamilyIndex = 0;
	imageMemoryBarrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;
	imageMemoryBarrier.dstQueueFamilyIndex = 0;
	imageMemoryBarrier.image = nullptr;
	imageMemoryBarrier.oldLayout = VK_IMAGE_LAYOUT_UNDEFINED;
	imageMemoryBarrier.newLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
	imageMemoryBarrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
	imageMemoryBarrier.subresourceRange.baseArrayLayer = 0;
	imageMemoryBarrier.subresourceRange.layerCount = 1;
	imageMemoryBarrier.subresourceRange.baseMipLevel = 0;
	imageMemoryBarrier.subresourceRange.levelCount = 1;
	/*
	合法用法
	1.布局需要和创建image时候的用法标志匹配，即如果oldLayout或者newLayout是
		.oldLayout只能是VK_IMAGE_LAYOUT_UNDEFINED或者当前的layout，newLayout不能是VK_IMAGE_LAYOUT_UNDEFINED或者 VK_IMAGE_LAYOUT_PREINITIALIZED
		.VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL 那么image创建时的用法标志必须包含VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT
		.VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL，那么image创建时的用法标志必须包含VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT
		.VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL ，那么image创建时的用法标志必须包含VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT
		.VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL ，那么image创建时的用法标志必须包含VK_IMAGE_USAGE_SAMPLED_BIT或者VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT
		.VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL，那么image创建时的用法标志必须包含VK_IMAGE_USAGE_TRANSFER_SRC_BIT
		.VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL，那么image创建时的用法标志必须包含VK_IMAGE_USAGE_TRANSFER_DST_BIT
		.VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL，那么image创建时的用法标志必须包含 VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT
		.VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL，那么image创建时的用法标志必须包含VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT
		.VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL，那么image创建时的用法标志必须包含VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, VK_IMAGE_USAGE_SAMPLED_BIT,或者VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT其中之一
		.VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL，那么image创建时的用法标志必须包含VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT
		.VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL，那么image创建时的用法标志必须包含VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, VK_IMAGE_USAGE_SAMPLED_BIT,或者VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT其中之一
		.VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL，那么image创建时的用法标志必须包含VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT
		.VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL，那么image创建时的用法标志必须包含VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT 或者 VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT
		.VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL，那么image创建时的用法标志必须包含VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, VK_IMAGE_USAGE_SAMPLED_BIT,或者VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT其中之一
		.VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR，那么image创建时的用法标志必须包含 VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR
		.VK_IMAGE_LAYOUT_VIDEO_DECODE_SRC_KHR,那么image创建时的用法标志必须包含VK_IMAGE_USAGE_VIDEO_DECODE_SRC_BIT_KHR
		.VK_IMAGE_LAYOUT_VIDEO_DECODE_DST_KHR,那么image创建时的用法标志必须包含VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR
		.VK_IMAGE_LAYOUT_VIDEO_DECODE_DPB_KHR,那么image创建时的用法标志必须包含VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR
		.VK_IMAGE_LAYOUT_VIDEO_ENCODE_SRC_KHR,那么image创建时的用法标志必须包含VK_IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR
		.VK_IMAGE_LAYOUT_VIDEO_ENCODE_DST_KHR,那么image创建时的用法标志必顶包含VK_IMAGE_USAGE_VIDEO_ENCODE_DST_BIT_KHR
		.VK_IMAGE_LAYOUT_VIDEO_ENCODE_DPB_KHR,那么image创建时的用法标志必须包含VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR
		.VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT,那么image创建时的用法标志必须包含VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT 或者VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT 其中之一, 以及
			VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT 或者 VK_IMAGE_USAGE_SAMPLED_BIT其中之一,以及VK_IMAGE_USAGE_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT
		.VK_IMAGE_LAYOUT_RENDERING_LOCAL_READ_KHR，那么image创建时的用法标志必须包含VK_IMAGE_USAGE_STORAGE_BIT, 或者 VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT 和 VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT ， VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT两者其中一个
	2.如果synchronization2特性没有开启，那么oldLayout和newLayout不能是VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL_KHR 或者 VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR
	3.如果image以VK_SHARING_MODE_EXCLUSIVE模式创建，且srcQueueFamilyIndex和dstQueueFamilyIndex不相等，那么srcQueueFamilyIndex和dstQueueFamilyIndex必须是
	VK_QUEUE_FAMILY_EXTERNAL或者 VK_QUEUE_FAMILY_FOREIGN_EXT或者一个合法的queueFamilyIndex，且srcQueueFamilyIndex和dstQueueFamilyIndex至少有一个是VK_QUEUE_FAMILY_EXTERNAL或者 VK_QUEUE_FAMILY_FOREIGN_EXT，
	另一个是一个合法的queueFamilyIndex
	4.如果VK_KHR_external_memory特性未开启，则srcQueueFamilyIndex和dstQueueFamilyIndex就不能是VK_QUEUE_FAMILY_EXTERNAL
	5.如果 VK_EXT_queue_family_foreign特性未开启，则srcQueueFamilyIndex和dstQueueFamilyIndex就不能是VK_QUEUE_FAMILY_FOREIGN_EXT
	6.如果attachmentFeedbackLoopLayout特性未开启，oldLayout不能是VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT
	7.如果 dynamicRenderingLocalRead特性未开启，oldLayout不能是VK_IMAGE_LAYOUT_RENDERING_LOCAL_READ_KHR，newLayout不能是VK_IMAGE_LAYOUT_RENDERING_LOCAL_READ_KHR
	8.subresourceRange中的base层数和mipmap级别必须在image的层数和mipmap级别范围内，且加起来层数和mipmap的计数count不能超过image的层数和mipmap级别
	9.如果image有color format，且是single-plane或者不能disjoint的，那么subresourceRange.aspectMask必须包含 VK_IMAGE_ASPECT_COLOR_BIT
	10.如果separateDepthStencilLayouts未开启且image有depth/stencil format，那么subresourceRange.aspectMask必须包含 VK_IMAGE_ASPECT_DEPTH_BIT 以及 VK_IMAGE_ASPECT_STENCIL_BIT，如果separateDepthStencilLayouts开启
		那么subresourceRange.aspectMask必须包含 VK_IMAGE_ASPECT_DEPTH_BIT 或者 VK_IMAGE_ASPECT_STENCIL_BIT
	11.如果subresourceRange.aspectMask包含VK_IMAGE_ASPECT_DEPTH_BIT，那么oldLayout或者newLayout不能是VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL或者VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL
	12.如果subresourceRange.aspectMask包含VK_IMAGE_ASPECT_STENCIL_BIT，那么oldLayout或者newLayout不能是 VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL 或者VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL
	13.subresourceRange.aspectMask必须和image的format兼容
	14.如果 synchronization2特性没有开启，且image以 VK_SHARING_MODE_CONCURREN创建，那么srcQueueFamilyIndex 以及 dstQueueFamilyIndex必须是  VK_QUEUE_FAMILY_IGNORED 或者VK_QUEUE_FAMILY_EXTERNAL，且至少有一个为VK_QUEUE_FAMILY_IGNORED
	*/







	//图像的布局转换（layout tranfer）可以直接在host端进行，但是该操作不会检查是否有队列正在使用该图像，所以可能会导致未定义行为
	// Provided by VK_EXT_host_image_copy
	typedef struct {
		VkStructureType sType;
		const void* pNext;
		VkImage image;
		VkImageLayout oldLayout;
		VkImageLayout newLayout;
		VkImageSubresourceRange subresourceRange;
	} VkHostImageLayoutTransitionInfoEXT;//这个接口和相关的机构体目前安装的vulkan里没有定义，这里定义用作示例
	auto  vkTransitionImageLayoutEXT = [](
		VkDevice device,
		uint32_t transitionCount,
		const VkHostImageLayoutTransitionInfoEXT* pTransitions)->VkResult {

			return VkResult::VK_SUCCESS;
	};

	
	VkHostImageLayoutTransitionInfoEXT layoutTransitionInfo = {};
	uint32_t VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO_EXT = 0;//这个类型也没有定义，这里定义用作示例
	layoutTransitionInfo.sType = (VkStructureType)VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO_EXT;
	layoutTransitionInfo.image = nullptr;
	layoutTransitionInfo.oldLayout = VK_IMAGE_LAYOUT_UNDEFINED;
	layoutTransitionInfo.newLayout = VK_IMAGE_LAYOUT_GENERAL;
	layoutTransitionInfo.pNext = nullptr;
	layoutTransitionInfo.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
	layoutTransitionInfo.subresourceRange.baseArrayLayer = 0;
	layoutTransitionInfo.subresourceRange.layerCount = 1;
	layoutTransitionInfo.subresourceRange.baseMipLevel = 0;
	layoutTransitionInfo.subresourceRange.levelCount = 1;
	/*
	合法用法可以参考前面的image memory barrier的用法
	*/
	vkTransitionImageLayoutEXT(device, 1,&layoutTransitionInfo);
	
	//外部队列
	VK_QUEUE_FAMILY_EXTERNAL;//这个外部队列表示用同一套底层设备组或者物理设备，相同的通过 VkPhysicalDeviceIDProperties::driverUUID.指明的驱动版本，但是在不同VkInstance中的队列族
	VK_QUEUE_FAMILY_FOREIGN_EXT;//这个外部队列表示不管底层的物理设备以及驱动版本是否相同都行，但是在不同VkInstance中的队列族
	//1.所有权释放：通过buffer 和image memory barriers指定，pipeline barrriers命令执行，dstAccessFlags会被忽略，触发semaphore，在VK_PIPELINE_STAGE_ALL_COMMANDS_BIT管线时期
	//2.所有权获取：通过buffer 和image memory barriers指定，pipeline barrriers命令执行，srcAccessFlags会被忽略，接受semaphore，在VK_PIPELINE_STAGE_ALL_COMMANDS_BIT管线时期
	//3.所有权释放和获取定义的两个buffer 或者 image memory barrier的 oldLayout 和 newLayout必须相同，虽然这两个barrier提交两次，但操作只会执行一次，
	//如果不需要所有权转换就设置 srcQueueFamilyIndex 和 dstQueueFamilyIndex为相同的或者为VK_QUEUE_FAMILY_IGNORED.
	//4.资源所有权被释放后，所有对资源的操作都是未定义的，只有当所有权被获取了，获取了资源的队列才能正确访问该资源
	
	typedef struct {
		VkStructureType sType;
		const void* pNext;
		VkBool32 acquireUnmodifiedMemory;//如果是VK_FALSE,则表明获取的内存在源queueFamily释放后可能被修改，如果是VK_TRUE，则表明获取的内存不会被修改
	} VkExternalMemoryAcquireUnmodifiedEXT;//这个结构体没有定义，所以这里定义用作示例，这个结构体可以添加在VkImageMemoryBarrier2或者VkImageMemoryBarrier的pnext中，主要用在获取保留的用于转换的外部队列的获取操作中
}

void SyncronizationAndCacheControlTest::AnotherTest()
{
	//等待队列空闲
	VkQueue queue;//示例用queue
	
	vkQueueWaitIdle(queue);//等待queue执行完所有的命令，然后返回，相当于等待该队列上的所有fence触发


	vkDeviceWaitIdle(device);//等待设备控空闲，相当于等待所有的队列执行完所有的命令

	//notation:
	//1.当命令提交到队列后，相当于建立了一个memory dependence,其中第一个同步域是host端的操作，第二个同步域是提交的命令操作
	//2.event只能在同一个物理设备内使用，不能在不同物理设备之间使用，semaphore可以跨物理设备使用，fence可以跨物理设备使用，但是不能跨VkInstance使用

	//获取某个操作的时间戳
	VkCalibratedTimestampInfoEXT timestampInfo{};//描述精确的时间戳信息应该从哪里捕获
	timestampInfo.sType = VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT;
	timestampInfo.pNext = nullptr;
	
	//获取支持的domain类型
	auto vkGetPhysicalDeviceCalibrateableTimeDomainsKHR = []() {};//示例用vkGetPhysicalDeviceCalibrateableTimeDomainsKHR

	timestampInfo.timeDomain = VK_TIME_DOMAIN_DEVICE_EXT;//应该是通过vkGetPhysicalDeviceCalibrateableTimeDomainsKHR获取的VkTimeDomainKHR的值的一部分
	/*
		VK_TIME_DOMAIN_DEVICE_KHR ：指定设备的时域。此时域中的时间戳值使用相同的单位，并且与使用vkCmdWriteTimestamp 或者 vkCmdWriteTimestamp2 捕获的设备时间戳值相当，并被定义为根据设备的时间戳周期递增。
		VK_TIME_DOMAIN_CLOCK_MONOTONIC_KHR ： 指定在POSIX平台上可用的CLOCK_MONOTONIC时域。此时域中的时间戳值以纳秒为单位。
		VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_KHR ：指定在POSIX平台上可用的CLOCK_MONOTONIC_RAW时域。此时域中的时间戳值以纳秒为单位。
		VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_KHR ： 指定Windows上可用的性能计数器（QPC）时域。此时域中的时间戳值与Windows查询性能计算器API提供的单位相同。
	*/
	
	uint64_t timeStampValue = 0,//返回的时间戳值
		maxDeviation = 0;//用于计算时间戳的最大偏差
	VK_DEVICE_FUNCTION_GET_AND_CALL(device, vkGetCalibratedTimestampsEXT, device, 1, &timestampInfo, &timeStampValue, &maxDeviation);

}








































NS_TEST_END
