#include "SyncronizationAndCacheControlTest.h"
#include <Windows.h>
#include <vulkan/vulkan_win32.h>
#include <winnt.h>
#include <vulkan/vulkan_metal.h>
typedef uint32_t zx_handle_t;//因为zx_handle_t 是google的开源操作系统fuchsia的句柄类型，所以这里定义一个uint32_t类型的句柄类型zx_handle_t，不起实际作用只是为了通过编译
#include <vulkan/vulkan_fuchsia.h>
NS_TEST_BEGIN



//--------------------------------------------------------------------------
//管线阶段


//
//第一个同步域和第二个同步域的执行管线阶段和访问控制必须满足以下条件：
//在以一个同步域中执行的操作的管线阶段必须要为srcStage或者逻辑上早于该阶段的阶段，访问控制必须以srcAccessFlag所指定的进行
//，同理，目标阶段必须要为dstStage或者逻辑上晚于该阶段的阶段，访问控制必须以dstAccessFlag所指定的进行

enum class VkPipelineStageFlagBitsWithNotation {
	VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT = 0x00000001, //相当于在第二个同步作用域中指定时将VkAccessFlags设置为0的且管线阶段为VK_PIPELINE_STAGE_ALL_COMMANDS_BIT，但在第一个作用域中指定时不指定任何执行阶段
	VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT = 0x00000002, //指示VkDrawIndirect* / VkDispatchIndirect* / VkTraceRaysIndirect *这类型数据结构使用的管线阶段，也包括读取vkCmdExecuteGeneratedCommandsNV中记录的指令缓冲区的阶段
	VK_PIPELINE_STAGE_VERTEX_INPUT_BIT = 0x00000004, //指定管道的顶点输入阶段
	VK_PIPELINE_STAGE_VERTEX_SHADER_BIT = 0x00000008, //指示顶点着色器阶段
	VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT = 0x00000010, //指示曲面细分控制着色器
	VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT = 0x00000020, //指示曲面细分评估着色器
	VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT = 0x00000040, //指示几何着色器
	VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT = 0x00000080, //指示片段着色器
	VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT = 0x00000100, //指定执行在片段着色器阶段前的深度/模板测试的管道阶段（片段着色之前的深度和模板测试）。此阶段还包括对具有深度/模板格式的frame缓冲区附件的render pass加载操作。
	VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT = 0x00000200, //指定执行在片段着色器阶段后的深度/模板测试的管道阶段（片段着色之后的深度和模板测试）。此阶段还包括对具有深度/模板格式的frame缓冲区附件的render pass存储操作。
	VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT = 0x00000400, //指定混合后的管道阶段，其中最终颜色值从管道输出。这个阶段包括混合、逻辑操作、颜色附件的渲染传递加载和存储操作、render pass的resolve操作和vkCmdClearAttachments.。
	VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT = 0x00000800, //指示计算着色器
	VK_PIPELINE_STAGE_TRANSFER_BIT = 0x00001000, 
	/**
	 * 指示以下操作的管线阶段：
	 * 所有复制操作，包括vkCmdCopyQueryPoolResults
	 * vkCmdBlitImage2 和 vkCmdBlitImage
	 * vkCmdResolveImage2 和 vkCmdResolveImage
	 * 所有清除操作，除了vkCmdClearAttachments
	*/
	VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT = 0x00002000, //相当于在第一个同步作用域中指定时将VkAccessFlags设置为0的且管线阶段为VK_PIPELINE_STAGE_ALL_COMMANDS_BIT，但在第二个作用域中指定时不指定任何执行阶段
	VK_PIPELINE_STAGE_HOST_BIT = 0x00004000, //指定指示在设备内存的读写主机上执行的伪阶段。在命令缓冲区中记录的任何命令都不会触发此阶段。
	VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT = 0x00008000, 
	/**
	 * 指示所有图形管线阶段，等价于
	 * VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT | VK_PIPELINE_STAGE_TASK_SHADER_BIT_EXT | VK_PIPELINE_STAGE_MESH_SHADER_BIT_EXT
	 * | VK_PIPELINE_STAGE_VERTEX_INPUT_BIT | VK_PIPELINE_STAGE_VERTEX_SHADER_BIT | VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT
     * | VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT | VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT | VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT
     * | VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT | VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT | VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT
     * | VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT | VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT | VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR
     * | VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT
	*/
	VK_PIPELINE_STAGE_ALL_COMMANDS_BIT = 0x00010000, ////指定在它commandbuffer提交使用的队列上所支持的所有命令所执行的所有管线阶段。
	VK_PIPELINE_STAGE_NONE = 0, //指示不清楚管线阶段
	VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT = 0x01000000, //指定将顶点属性输出值写入转换反馈缓冲区的管道的阶段。
	VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT = 0x00040000, //指定使用条件呈现的谓词的管道的阶段。
	VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR = 0x02000000,
	/**
	 * 指示以下命令执行的管线阶段
	 * vkCmdBuildAccelerationStructureNV, vkCmdCopyAccelerationStructureNV,
     * vkCmdWriteAccelerationStructuresPropertiesNV , vkCmdBuildAccelerationStructuresKHR,
	 * vkCmdBuildAccelerationStructuresIndirectKHR, vkCmdCopyAccelerationStructureKHR,
	 * vkCmdCopyAccelerationStructureToMemoryKHR,
	 * vkCmdCopyMemoryToAccelerationStructureKHR,
	 * vkCmdWriteAccelerationStructuresPropertiesKHR.
	*/
	VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR = 0x00200000,//指示通过vkCmdTraceRaysNV , vkCmdTraceRaysKHR, 或者 vkCmdTraceRaysIndirectKHR执行的光线追踪着色器阶段
	VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT = 0x00800000,//指定读取片段着色速率附着或着色速率图像，以确定光栅格化原体部分的片段着色速率的管道的阶段。
	VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x00400000,// 指定读取片段密度映射以生成片段区域的管道的阶段。
	VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV = 0x00020000,//指定通过vkCmdPreprocessGeneratedCommandsNV处理设备生成命令的管道阶段
	VK_PIPELINE_STAGE_TASK_SHADER_BIT_EXT = 0x00080000,//指示任务着色器
	VK_PIPELINE_STAGE_MESH_SHADER_BIT_EXT = 0x00100000,//指示网格着色器
	VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV = VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR,//指示着色率图像
	VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV = VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR,//指示光线追踪着色器
	VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV = VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR,//指示加速结构构建
	VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV = VK_PIPELINE_STAGE_TASK_SHADER_BIT_EXT,//指示任务着色器
	VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV = VK_PIPELINE_STAGE_MESH_SHADER_BIT_EXT,//指示网格着色器
	VK_PIPELINE_STAGE_NONE_KHR = VK_PIPELINE_STAGE_NONE,//指示不确定管线状态
	VK_PIPELINE_STAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF//指示标志位的最大值

} ;



enum class VkPipelineStageFlagBits2WithNotation {
   VK_PIPELINE_STAGE_2_NONE = 0ULL,//指示不确定管线状态
   VK_PIPELINE_STAGE_2_NONE_KHR = 0ULL,
   VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT = 0x00000001ULL,//相当于在第二个同步作用域中指定时将VkAccessFlags2设置为0且管线阶段为VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT，以及相当于第一个同步作用域中的管线阶段为VK_PIPELINE_STAGE_2_NONE。
   VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT_KHR = 0x00000001ULL,
   VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT = 0x00000002ULL,//指定使用间接命令参数的管道的阶段。这个阶段还包括读取由vkCmdPreprocessGeneratedCommandsNV.编写的命令
   VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT_KHR = 0x00000002ULL,
   VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT = 0x00000004ULL,//指定管道的顶点输入阶段，相当于 VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT | VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT
   VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT_KHR = 0x00000004ULL,
   VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT = 0x00000008ULL,//顶点着色器阶段
   VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT_KHR = 0x00000008ULL,
   VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT = 0x00000010ULL,//曲面细分控制着色器阶段
   VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT_KHR = 0x00000010ULL,
   VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT = 0x00000020ULL,//曲面细分计算着色器阶段
   VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT_KHR = 0x00000020ULL,
   VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT = 0x00000040ULL,//几何着色器阶段
   VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT_KHR = 0x00000040ULL,
   VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT = 0x00000080ULL,//片段着色器阶段
   VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT_KHR = 0x00000080ULL,
   VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT = 0x00000100ULL,//指定执行在片段之前进行深度和模板测试的管道阶段（片段着色之前的深度和模板测试）
   VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT_KHR = 0x00000100ULL,
   VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT = 0x00000200ULL,//指定执行在片段之后进行深度和模板测试的管道阶段（片段着色之后的深度和模板测试）
   VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT_KHR = 0x00000200ULL,
   VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT = 0x00000400ULL,//指定从管道中输出最终颜色值的管道的阶段
   VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT_KHR = 0x00000400ULL,
   VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT = 0x00000800ULL,//计算着色器阶段
   VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT_KHR = 0x00000800ULL,
   VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT = 0x00001000ULL, 
	/**
    * 等价于
	*  VK_PIPELINE_STAGE_2_COPY_BIT | VK_PIPELINE_STAGE_2_BLIT_BIT | VK_PIPELINE_STAGE_2_RESOLVE_BIT
    *  VK_PIPELINE_STAGE_2_CLEAR_BIT | VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR
   */
   VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT_KHR = 0x00001000ULL,
   VK_PIPELINE_STAGE_2_TRANSFER_BIT = 0x00001000ULL,
   VK_PIPELINE_STAGE_2_TRANSFER_BIT_KHR = 0x00001000ULL,
   VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT = 0x00002000ULL,//相当于第一个同步作用域的管线阶段为VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT，并将VkAccessFlags2设置为0，以及将第二个作用域中的VK_PIPELINE_STAGE_2_NONE。
   VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT_KHR = 0x00002000ULL,
   VK_PIPELINE_STAGE_2_HOST_BIT = 0x00004000ULL,//指定指示在设备内存的读写主机上执行的伪阶段。在命令缓冲区中记录的任何命令都不会触发此阶段。
   VK_PIPELINE_STAGE_2_HOST_BIT_KHR = 0x00004000ULL,
   VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT = 0x00008000ULL,
   /**
	* 指定所有图形管道阶段，等价于
	* VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT | VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT |VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT
    * VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT | VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT | VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT
    * VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT | VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT
	* VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT | VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT | VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT
	* VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT | VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT | VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT
    * VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR | VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT | VK_PIPELINE_STAGE_2_SUBPASS_SHADER_BIT_HUAWEI
	* VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI | VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI
   */
   VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT_KHR = 0x00008000ULL,
   VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT = 0x00010000ULL,//指定在它commandbuffer提交使用的队列上所支持的所有命令所执行的所有管线阶段。
   VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT_KHR = 0x00010000ULL,
   VK_PIPELINE_STAGE_2_COPY_BIT = 0x100000000ULL,//指定使用复制命令的管道的阶段。包括vkCmdCopyQueryPoolResults
   VK_PIPELINE_STAGE_2_COPY_BIT_KHR = 0x100000000ULL,
   VK_PIPELINE_STAGE_2_RESOLVE_BIT = 0x200000000ULL,//指定vkCmdResolveImage执行的管线阶段
   VK_PIPELINE_STAGE_2_RESOLVE_BIT_KHR = 0x200000000ULL,
   VK_PIPELINE_STAGE_2_BLIT_BIT = 0x400000000ULL,//指定vkCmdBlitImage执行的管线阶段
   VK_PIPELINE_STAGE_2_BLIT_BIT_KHR = 0x400000000ULL,
   VK_PIPELINE_STAGE_2_CLEAR_BIT = 0x800000000ULL,//指定清除命令的管道的阶段，除了vkCmdClearAttachments
   VK_PIPELINE_STAGE_2_CLEAR_BIT_KHR = 0x800000000ULL,
   VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT = 0x1000000000ULL,// 指定使用索引缓冲区的管道的阶段。
   VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT_KHR = 0x1000000000ULL,
   VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT = 0x2000000000ULL,//指定使用顶点属性的管道的阶段。
   VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT_KHR = 0x2000000000ULL,
   VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT = 0x4000000000ULL,
   /**
    *  指定在光栅化之前运行的着色器的管道阶段。相当于 
    *  VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT | VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT | VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT | VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT
 |  *  VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT | VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT | VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI
   */
   VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT_KHR = 0x4000000000ULL,
   VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR = 0x04000000ULL,//指定将视频解码操作的管线阶段。
#ifdef VK_ENABLE_BETA_EXTENSIONS
   VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR = 0x08000000ULL,//指定将视频编码操作的管线阶段。
#endif
   VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT = 0x01000000ULL,//指定将顶点属性输出值写入转换反馈缓冲区的管道的阶段。
   VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT = 0x00040000ULL,//指定使用条件呈现的谓词的管道的阶段。
   VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV = 0x00020000ULL,//指定通过vkCmdPreprocessGeneratedCommandsNV处理设备生成命令的管道阶段
   VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x00400000ULL,//指定其中读取片段着色速率附着或着色速率图像，以确定光栅格化原体部分的片段着色速率的管道的阶段。
   VK_PIPELINE_STAGE_2_SHADING_RATE_IMAGE_BIT_NV = 0x00400000ULL,
   VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR = 0x02000000ULL,//指定加速结构命令或加速结构复制命令的执行管线阶段。
   VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR = 0x00200000ULL,//光线追踪着色器阶段
   VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_NV = 0x00200000ULL,
   VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_NV = 0x02000000ULL,
   VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT = 0x00800000ULL,//指定读取片段密度映射以生成片段区域的管道的阶段。
   VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_NV = 0x00080000ULL,
   VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_NV = 0x00100000ULL,
   VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT = 0x00080000ULL,//任务着色器阶段
   VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT = 0x00100000ULL,//Mesh着色器阶段
   VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI = 0x8000000000ULL,//指定在subpass执行的管道的阶段。
   VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI = 0x10000000000ULL,//指定由实现读取调用掩码图像以优化射线分派的管道的阶段。
   VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR = 0x10000000ULL,//指定加速结构复制命令的执行管线阶段。
   VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT = 0x40000000ULL,
   VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI = 0x20000000000ULL,//指定簇剔除着色器阶段。
   VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV = 0x20000000ULL//指定执行光流操作的管道的阶段
};



/**
 * @brief 检查某种类型的队列是否匹配指定的管线阶段
 * @param pipelineStageFlags2 待匹配的管线阶段标志
 * @param queueFamilyFlags 待匹配的队列类型标志
 * @return 
*/
bool CheckMatchPipelineStages2AndQueueFlags(VkPipelineStageFlags2 pipelineStageFlags2, VkQueueFlags queueFamilyFlags) {

	bool res = false;
	res |= (pipelineStageFlags2 == VK_PIPELINE_STAGE_2_NONE);
	res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT) == VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT;
	res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT) == VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT;
	res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_HOST_BIT) == VK_PIPELINE_STAGE_2_HOST_BIT;
	res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT) == VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT;
	if (queueFamilyFlags & VK_QUEUE_GRAPHICS_BIT) {
		//图形队列支持以下列举的阶段，就认为支持
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT) == VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT) == VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT) == VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT) == VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT) == VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT) == VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT) == VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT) == VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT) == VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT) == VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT) == VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT) == VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT;

		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_COPY_BIT) == VK_PIPELINE_STAGE_2_COPY_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_RESOLVE_BIT) == VK_PIPELINE_STAGE_2_RESOLVE_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_BLIT_BIT) == VK_PIPELINE_STAGE_2_BLIT_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_CLEAR_BIT) == VK_PIPELINE_STAGE_2_CLEAR_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT) == VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT) == VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT) == VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT;

		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT) == VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT) == VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV) == VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR) == VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR) == VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR;

		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT) == VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT) == VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT) == VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI) == VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI) == VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR) == VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI) == VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV) == VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV;


	}
	if (queueFamilyFlags & VK_QUEUE_COMPUTE_BIT) {
		//计算队列支持以下列举的阶段

		
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT) == VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT) == VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT) == VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_COPY_BIT) == VK_PIPELINE_STAGE_2_COPY_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_RESOLVE_BIT) == VK_PIPELINE_STAGE_2_RESOLVE_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_BLIT_BIT) == VK_PIPELINE_STAGE_2_BLIT_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_CLEAR_BIT) == VK_PIPELINE_STAGE_2_CLEAR_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT) == VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV) == VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR) == VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR) == VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR) == VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT) == VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT;

	}
	if (queueFamilyFlags & VK_QUEUE_TRANSFER_BIT) {

		//传输队列支持以下列举的阶段
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT) == VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_COPY_BIT) == VK_PIPELINE_STAGE_2_COPY_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_RESOLVE_BIT) == VK_PIPELINE_STAGE_2_RESOLVE_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_BLIT_BIT) == VK_PIPELINE_STAGE_2_BLIT_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_CLEAR_BIT) == VK_PIPELINE_STAGE_2_CLEAR_BIT;
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR) == VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR;

	}
	if (queueFamilyFlags & VK_QUEUE_VIDEO_DECODE_BIT_KHR) {
		//视频解码队列支持以下列举的阶段
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR) == VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR;
	}
#ifdef VK_ENABLE_BETA_EXTENSIONS
	if (queueFamilyFlags & VK_QUEUE_VIDEO_ENCODE_BIT_KHR) {
		//视频解码队列支持以下列举的阶段
		res |= (pipelineStageFlags2 & VK_QUEUE_VIDEO_ENCODE_BIT_K) == VK_QUEUE_VIDEO_ENCODE_BIT_K;
}
#endif
	if (queueFamilyFlags & VK_QUEUE_OPTICAL_FLOW_BIT_NV) {
		//光流队列支持以下列举的阶段
		res |= (pipelineStageFlags2 & VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV) == VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV;
	}
	return res;
}


//------------------------------------------------------------------------------
// 访问控制


enum class VkAccessFlagBits2WithNotation
{
	VK_ACCESS_2_NONE = 0ULL,//未指定访问权限
	VK_ACCESS_2_NONE_KHR = 0ULL,
	VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT = 0x00000001ULL,//指定对从间接缓冲区读取的命令数据的读取访问，作为间接构建、跟踪、绘制或分派命令的一部分。发生在管线状态VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT
	VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT_KHR = 0x00000001ULL,
	VK_ACCESS_2_INDEX_READ_BIT = 0x00000002ULL,//指定对vkCmdBindIndexBuffer2KHR 和 vkCmdBindIndexBuffer绑定的索引缓冲区的读取访问,发生在管线状态VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT
	VK_ACCESS_2_INDEX_READ_BIT_KHR = 0x00000002ULL,
	VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT = 0x00000004ULL,//指定对vkCmdBindVertexBuffers.绑定的顶点缓冲区的读取访问,发生在管线状态VK_PIPELINE_STAGE_VERTEX_INPUT_BIT
	VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT_KHR = 0x00000004ULL,
	VK_ACCESS_2_UNIFORM_READ_BIT = 0x00000008ULL,//指定任何着色器阶段对uniform变量的读取访问,发生在管线状态VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT、VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT、VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT、VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT、VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT、VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT
	VK_ACCESS_2_UNIFORM_READ_BIT_KHR = 0x00000008ULL,
	VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT = 0x00000010ULL,//指定在render pass的subpass的渲染阶段或者片段着色器阶段对输入附件的读取访问,发生在管线状态VK_PIPELINE_STAGE_2_SUBPASS_SHADER_BIT_HUAWEI 或VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT
	VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT_KHR = 0x00000010ULL,
    VK_ACCESS_2_SHADER_READ_BIT = 0x00000020ULL,//指定对任何着色器管道阶段中的统一文本缓冲器、采样映像、存储缓冲器、物理存储缓冲器、着色器绑定表、存储文本缓冲器或存储映像的读取访问。
    VK_ACCESS_2_SHADER_READ_BIT_KHR = 0x00000020ULL,
    VK_ACCESS_2_SHADER_WRITE_BIT = 0x00000040ULL,//指定对任何着色器管道阶段中的存储缓冲区、物理存储缓冲区、存储文本缓冲区或存储映像的写入访问权限。
    VK_ACCESS_2_SHADER_WRITE_BIT_KHR = 0x00000040ULL,
    VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT = 0x00000080ULL,//指定对颜色附件的读取访问权限，例如通过混合（高级混合操作除外）、逻辑操作或VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT管道阶段中的某些render pass的加载操作或者在VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT阶段对tile image的读取
    VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT_KHR = 0x00000080ULL,
    VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT = 0x00000100ULL,//指定在render pass或通过特定render pass加载和存储操作期间对颜色、解析或深度/模板解析附件的写入访问权限。这种访问发生在VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT管道阶段。
    VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT_KHR = 0x00000100ULL,
    VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT = 0x00000200ULL,//指定在VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT ， VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT阶段的render pass加载或者在VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT的tile image的读取时 对深度/模板附件的读取访问
    VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT_KHR = 0x00000200ULL,
	VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = 0x00000400ULL,//指定在VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT ， VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT阶段的render pass的存储操作对深度/模板附件的写入访问权限。
    VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT_KHR = 0x00000400ULL,
    VK_ACCESS_2_TRANSFER_READ_BIT = 0x00000800ULL,//指定对复制操作中的图像或缓冲区的读取访问权限。这种访问发生在VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT管道阶段。
    VK_ACCESS_2_TRANSFER_READ_BIT_KHR = 0x00000800ULL,
    VK_ACCESS_2_TRANSFER_WRITE_BIT = 0x00001000ULL,//指定在清除或复制操作中对图像或缓冲区的写入访问权限。这种访问发生在VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT管道阶段
    VK_ACCESS_2_TRANSFER_WRITE_BIT_KHR = 0x00001000ULL,
    VK_ACCESS_2_HOST_READ_BIT = 0x00002000ULL,//指定主机操作的读取访问权限。这种类型的访问不是通过资源执行的，而是直接通过内存执行的。这种访问发生在VK_PIPELINE_STAGE_HOST_BIT管道阶段。
    VK_ACCESS_2_HOST_READ_BIT_KHR = 0x00002000ULL,
    VK_ACCESS_2_HOST_WRITE_BIT = 0x00004000ULL,//指定主机操作的写访问权限。这种类型的访问不是通过资源执行的，而是直接通过内存执行的。这种访问发生在VK_PIPELINE_STAGE_HOST_BIT管道阶段。
    VK_ACCESS_2_HOST_WRITE_BIT_KHR = 0x00004000ULL,
    VK_ACCESS_2_MEMORY_READ_BIT = 0x00008000ULL,//指定所有读取访问。它在任何访问掩码中始终有效，并且被视为等于设置在使用它时有效的所有读访问标志。（其他读标志的与）
    VK_ACCESS_2_MEMORY_READ_BIT_KHR = 0x00008000ULL,
    VK_ACCESS_2_MEMORY_WRITE_BIT = 0x00010000ULL,//指定所有写入访问。它在任何访问掩码中始终有效，并且被视为等同于在使用它的地方设置所有有效的写访问标志。（其他写标志的与）
    VK_ACCESS_2_MEMORY_WRITE_BIT_KHR = 0x00010000ULL,
    VK_ACCESS_2_SHADER_SAMPLED_READ_BIT = 0x100000000ULL,
    VK_ACCESS_2_SHADER_SAMPLED_READ_BIT_KHR = 0x100000000ULL,
    VK_ACCESS_2_SHADER_STORAGE_READ_BIT = 0x200000000ULL,
    VK_ACCESS_2_SHADER_STORAGE_READ_BIT_KHR = 0x200000000ULL,
    VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT = 0x400000000ULL,
    VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT_KHR = 0x400000000ULL,
    VK_ACCESS_2_VIDEO_DECODE_READ_BIT_KHR = 0x800000000ULL,
    VK_ACCESS_2_VIDEO_DECODE_WRITE_BIT_KHR = 0x1000000000ULL,
#ifdef VK_ENABLE_BETA_EXTENSIONS
    VK_ACCESS_2_VIDEO_ENCODE_READ_BIT_KHR = 0x2000000000ULL,
#endif
#ifdef VK_ENABLE_BETA_EXTENSIONS
    VK_ACCESS_2_VIDEO_ENCODE_WRITE_BIT_KHR = 0x4000000000ULL,
#endif
    VK_ACCESS_2_TRANSFORM_FEEDBACK_WRITE_BIT_EXT = 0x02000000ULL,//指定对传输反馈激活时进行的传输反馈缓冲区的写访问。这种访问发生在VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT管道阶段
    VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT = 0x04000000ULL,//指定对传输反馈计数器缓冲区的读取访问，它在vkCmdBeginTransformFeedbackEXT执行时被读取。这种访问发生在VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT管道阶段。
    VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT = 0x08000000ULL,//指定对在vkCmdEndTransformFeedbackEXT执行时写入的传输反馈计数器缓冲区的写入访问权限。这种访问发生在VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT管道阶段。
    VK_ACCESS_2_CONDITIONAL_RENDERING_READ_BIT_EXT = 0x00100000ULL,//指定对谓词的读取访问，作为条件呈现的一部分。这种访问发生在VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT管道阶段。
    VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_NV = 0x00020000ULL,//指定从缓冲区输入到vkCmdPreprocessGeneratedCommandsNV.的读取这种访问发生在VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV管道阶段。
	VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_NV = 0x00040000ULL,//指定目标命令缓冲区预处理输出对vkCmdPreprocessGeneratedCommandsNV.中的写入，这种访问发生在VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV管道阶段
    VK_ACCESS_2_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR = 0x00800000ULL,//指定在栅格化期间对碎片着色速率附着的读取访问权限。这种访问发生在VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR管道阶段。
    VK_ACCESS_2_SHADING_RATE_IMAGE_READ_BIT_NV = 0x00800000ULL,//指定在栅格化期间对着色速率图像的读取访问权限。这种访问发生在VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV管道阶段相当于在VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR阶段
    VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR = 0x00200000ULL,//指定对加速结构作为跟踪、构建或复制命令的一部分，或作为构建命令的一部分对加速结构划伤缓冲区的读取访问。这种访问发生在VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR管道阶段或VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR管道阶段。
    VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_KHR = 0x00400000ULL,//指定对加速结构或加速结构的写入存取，作为构建或复制命令的一部分。这种访问发生在VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR管道阶段。
    VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_NV = 0x00200000ULL,
    VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_NV = 0x00400000ULL,
    VK_ACCESS_2_FRAGMENT_DENSITY_MAP_READ_BIT_EXT = 0x01000000ULL,//指定在动态片段密度映射操作期间对片段密度映射附件的读取访问。这种访问发生在VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT管道阶段。
    VK_ACCESS_2_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT = 0x00080000ULL,//指定对颜色附件的读取访问权限，包括高级混合操作。这种访问发生在VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT管道阶段。
    VK_ACCESS_2_DESCRIPTOR_BUFFER_READ_BIT_EXT = 0x20000000000ULL,
    VK_ACCESS_2_INVOCATION_MASK_READ_BIT_HUAWEI = 0x8000000000ULL,//指定对VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI管道阶段中的调用掩码映像的读取访问权限。
    VK_ACCESS_2_SHADER_BINDING_TABLE_READ_BIT_KHR = 0x10000000000ULL,
    VK_ACCESS_2_MICROMAP_READ_BIT_EXT = 0x100000000000ULL,
    VK_ACCESS_2_MICROMAP_WRITE_BIT_EXT = 0x200000000000ULL,
    VK_ACCESS_2_OPTICAL_FLOW_READ_BIT_NV = 0x40000000000ULL,
    VK_ACCESS_2_OPTICAL_FLOW_WRITE_BIT_NV = 0x80000000000ULL
};


/**
 * @brief 检查accessFlags是否与pipelineStages2是否匹配
 * @param accessFlags 访问权限
 * @param pipelineStages2 管线阶段
 * @return 
*/
bool CheckMatchAccessFlagsAndPipelineStageFlags2(VkAccessFlags2 accessFlags, VkPipelineStageFlags2 pipelineStages2) {
	bool res = false;
	res |= (accessFlags == VK_ACCESS_2_NONE);
	res |= (accessFlags & VK_ACCESS_2_MEMORY_READ_BIT) == VK_ACCESS_2_MEMORY_READ_BIT;
	res |= (accessFlags & VK_ACCESS_2_MEMORY_WRITE_BIT) == VK_ACCESS_2_MEMORY_WRITE_BIT;
	if (accessFlags & VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT) == VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR) == VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR;
	}
	if (accessFlags & VK_ACCESS_2_INDEX_READ_BIT)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT) == VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT) == VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT;
	}
	if (accessFlags & VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT) == VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT) == VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT;
	}
	if ((accessFlags & VK_ACCESS_2_UNIFORM_READ_BIT) || (accessFlags & VK_ACCESS_2_SHADER_WRITE_BIT)
		|| (accessFlags & VK_ACCESS_2_SHADER_SAMPLED_READ_BIT) || (accessFlags & VK_ACCESS_2_SHADER_STORAGE_READ_BIT)
		|| (accessFlags & VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT) || (accessFlags & VK_ACCESS_2_DESCRIPTOR_BUFFER_READ_BIT_EXT))
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT) == VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT) == VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT) == VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT) == VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT) == VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT) == VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR) == VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT) == VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT) == VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI) == VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI) == VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI;
	}
	if (accessFlags & VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT) == VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI) == VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI;
	}

	if (accessFlags & VK_ACCESS_2_SHADER_READ_BIT)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR) == VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT) == VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT) == VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT) == VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT) == VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT) == VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT;

		res |= (accessFlags & VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT) == VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT) == VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR) == VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT) == VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT) == VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI) == VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI) == VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI;
	}


	if (accessFlags & VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT) == VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT) == VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT;
	}

	if (accessFlags & VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT) == VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT;

	}
	
	if (accessFlags & VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT) == VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT) == VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT) == VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT;
	}
	
	if (accessFlags & VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT) == VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT) == VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT;
	}

	if (accessFlags & VK_ACCESS_2_TRANSFER_READ_BIT)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT) == VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_COPY_BIT) == VK_PIPELINE_STAGE_2_COPY_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_RESOLVE_BIT) == VK_PIPELINE_STAGE_2_RESOLVE_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_BLIT_BIT) == VK_PIPELINE_STAGE_2_BLIT_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR) == VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR) == VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT) == VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT;
	}

	if (accessFlags & VK_ACCESS_2_TRANSFER_WRITE_BIT)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT) == VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_COPY_BIT) == VK_PIPELINE_STAGE_2_COPY_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_RESOLVE_BIT) == VK_PIPELINE_STAGE_2_RESOLVE_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_BLIT_BIT) == VK_PIPELINE_STAGE_2_BLIT_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_CLEAR_BIT) == VK_PIPELINE_STAGE_2_CLEAR_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR) == VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR) == VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT) == VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT;
	}

	if (accessFlags & VK_ACCESS_2_HOST_READ_BIT)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_HOST_BIT) == VK_PIPELINE_STAGE_2_HOST_BIT;

	}

	if (accessFlags & VK_ACCESS_2_HOST_WRITE_BIT)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_HOST_BIT) == VK_PIPELINE_STAGE_2_HOST_BIT;

	}

	if ((accessFlags & VK_ACCESS_2_VIDEO_DECODE_READ_BIT_KHR) || (accessFlags & VK_ACCESS_2_VIDEO_DECODE_WRITE_BIT_KHR))
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR) == VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR;
	}
		
#ifdef K_ENABLE_BETA_EXTENSIONS

	if ((accessFlags & VK_ACCESS_2_VIDEO_ENCODE_READ_BIT_KHR) || (accessFlags & VK_ACCESS_2_VIDEO_ENCODE_WRITE_BIT_KHR))
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR) == VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR;

	}
#endif
	
	if (accessFlags & VK_ACCESS_2_TRANSFORM_FEEDBACK_WRITE_BIT_EXT)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT) == VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT;

	}

	if (accessFlags & VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT) == VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT) == VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT;
	}

	if (accessFlags & VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT) == VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT;
	}

	if (accessFlags & VK_ACCESS_2_CONDITIONAL_RENDERING_READ_BIT_EXT)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT) == VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI) == VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI;
	}
	
	if ((accessFlags & VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_NV) || (accessFlags & VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_NV))
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV) == VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV;

	}

	if (accessFlags & VK_ACCESS_2_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR) == VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR;

	}

	if (accessFlags & VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT) == VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT) == VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT) == VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT) == VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT) == VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT) == VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR) == VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT) == VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT) == VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI) == VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR) == VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR) == VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI) == VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI;
	}
	
	if (accessFlags & VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_KHR)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR) == VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR) == VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR;
	}

	if (accessFlags & VK_ACCESS_2_FRAGMENT_DENSITY_MAP_READ_BIT_EXT)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT) == VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT;
	}

	if (accessFlags & VK_ACCESS_2_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT) == VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT;
		
	}


	if (accessFlags & VK_ACCESS_2_INVOCATION_MASK_READ_BIT_HUAWEI)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI) == VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI;

	}
	
	if (accessFlags & VK_ACCESS_2_MICROMAP_READ_BIT_EXT)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT) == VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT;
		res |= (accessFlags & VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR) == VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR;
	}
	
	if (accessFlags & VK_ACCESS_2_MICROMAP_WRITE_BIT_EXT)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT) == VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT;

	}
	
	if (accessFlags & VK_ACCESS_2_OPTICAL_FLOW_READ_BIT_NV)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV) == VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV;
	}
	
	if (accessFlags & VK_ACCESS_2_OPTICAL_FLOW_WRITE_BIT_NV)
	{
		res |= (accessFlags & VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV) == VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV;
	}
	return res;
}




SyncronizationAndCacheControlTest::SyncronizationAndCacheControlTest()
{
	PrepareContex();
}













void SyncronizationAndCacheControlTest::run()
{



	FenceTest();

	SemaphoreTest();

	EventTest();






}

SyncronizationAndCacheControlTest::~SyncronizationAndCacheControlTest()
{
	ClearContex();
}

enum class VkExternalFenceHandleTypeFlagBitsWithNotation {
	VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT = 0x00000001,
	VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT = 0x00000002,
	VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = 0x00000004,
	VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT = 0x00000008,
	VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT,
	VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT,
	VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
	VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR = VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT,
	VK_EXTERNAL_FENCE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
};


void SyncronizationAndCacheControlTest::FenceTest()
{
	//create
	VkFenceCreateInfo fenceCreateInfo = {};//queue与host间
	fenceCreateInfo.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;
	//fenceCreateInfo.flags = 0;//创建一个未signaled的fence
	fenceCreateInfo.flags = VK_FENCE_CREATE_SIGNALED_BIT;//创建一个signaled的fence
	//如果需要导出内部的资源，添加VkExportFenceCreateInfo到pnext中
	bool exportFence = false;
	VkExportFenceCreateInfo exportFenceCreateInfo{};
	const void** pnext = &fenceCreateInfo.pNext;
	VkExternalFenceHandleTypeFlags fenceCompatibleHandleTypes{};
	if (exportFence)
	{
		exportFenceCreateInfo.sType = VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO;
		//获取物理设备支持的导出fence类型
		VkExternalFenceProperties externalFenceProperties{};
		externalFenceProperties.sType = VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES;
		VkPhysicalDeviceExternalFenceInfo externalFenceInfo{};
		externalFenceInfo.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO;
		externalFenceInfo.pNext = nullptr;
		externalFenceInfo.handleType = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT;//查询支持的VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT导出fence类型属性
		vkGetPhysicalDeviceExternalFenceProperties(physicalDevice, &externalFenceInfo, &externalFenceProperties);
		//如果支持该类型且可以导出就设置exportFenceCreateInfo
		if ((externalFenceProperties.compatibleHandleTypes & VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT)
			&& (externalFenceProperties.externalFenceFeatures & VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT))
		{
			exportFenceCreateInfo.handleTypes = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT;
			
		}
		fenceCompatibleHandleTypes = externalFenceProperties.compatibleHandleTypes;
		*pnext = &exportFenceCreateInfo;
		pnext = &exportFenceCreateInfo.pNext;

		//如果需要加额外的属性描述，添加VkExportFenceWin32HandleInfoKHR到fenceCreateInfo.pNext中
		VkExportFenceWin32HandleInfoKHR exportFenceWin32HandleInfo{};
		exportFenceWin32HandleInfo.sType = VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR;
		exportFenceWin32HandleInfo.pNext = nullptr;
		exportFenceWin32HandleInfo.pAttributes = nullptr;//这个先设置为nullptr使用默认的属性
		
		*pnext = &exportFenceWin32HandleInfo;
		pnext = &exportFenceWin32HandleInfo.pNext;
		
		
	}


	VkFence fence{nullptr};
	VK_RESULT_CHECK_CALL(vkCreateFence(device, &fenceCreateInfo, nullptr, &fence));
	
	void* fenceNTHandle{ nullptr };
	if ((fenceCompatibleHandleTypes & VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT)
		|| (fenceCompatibleHandleTypes & VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT))
	{

		VkFenceGetWin32HandleInfoKHR fenceGetWin32HandleInfo{};
		fenceGetWin32HandleInfo.sType = VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR;
		fenceGetWin32HandleInfo.handleType = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT;
		fenceGetWin32HandleInfo.fence = fence;
		fenceGetWin32HandleInfo.pNext = nullptr;
		//获取fence的win32句柄
		
		//如果handletype是VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT或者VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,则说明这个fence是native handle
		//如果是NT handle则对于每一个handletype，该函数只能被调用一次,详情见vulkanspeci.pdf的p323
		VK_DEVICE_FUNCTION_GET_AND_CALL(device, vkGetFenceWin32HandleKHR,device, &fenceGetWin32HandleInfo, &fenceNTHandle);
		//获取的handle在不需要的时候需要关闭
	}
	int fd{ 0 };
	if ((fenceCompatibleHandleTypes & VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT)
		|| (fenceCompatibleHandleTypes & VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT))
	{
		VkFenceGetFdInfoKHR getFenceFD{};
		getFenceFD.sType = VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR;
		getFenceFD.pNext = nullptr;
		getFenceFD.fence = fence;
		getFenceFD.handleType = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT;
		
		//vkGetFenceFdKHR(device, &getFenceFD, &fd);
		VK_DEVICE_FUNCTION_GET_AND_CALL(device, vkGetFenceFdKHR,device,&getFenceFD,&fd)
		//获取的fd在不需要的时候需要关闭
	}
	
	auto status = vkGetFenceStatus(device, fence);//获取fence状态
	switch (status)
	{
	case VK_SUCCESS://fence已经signaled
		break;
	case VK_NOT_READY://fence未signaled
		break;
	case VK_ERROR_DEVICE_LOST:
	case VK_ERROR_OUT_OF_HOST_MEMORY:
	case VK_ERROR_OUT_OF_DEVICE_MEMORY:
		break;//失败

	default:
		break;
	}

	vkWaitForFences(device, 1, &fence, VK_TRUE, VK_TIMEOUT);//在VK_TIMEOUT纳秒超时时间内等待fence变为signaled状态
	
	vkResetFences(device, 1, &fence);//设置fence为未signaled状态

	

	VkDeviceEventInfoEXT deviceEventInfo{};
	deviceEventInfo.sType = VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT;
	deviceEventInfo.pNext = nullptr;
	deviceEventInfo.deviceEvent = VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT;//设置触发事件类型为插入或者拔出显示器，主要用作显示器热插拔事件的同步
	//设置额外的触发事件来触发fence（除了队列执行触发以及host触发外）
	VK_DEVICE_FUNCTION_GET_AND_CALL(device, vkRegisterDeviceEventEXT,device, &deviceEventInfo, nullptr, &fence);

	VkDisplayKHR display{};
	VkDisplayEventInfoEXT displayEventInfo{};
	displayEventInfo.sType = VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT;
	displayEventInfo.pNext = nullptr;
	displayEventInfo.displayEvent = VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT;//指定触发事件类型为第一个像素输出事件,即下一个显示周期的第一个像素输出时触发fence
	//设置额外的显示设备的事件来触发fence（除了队列执行触发以及host触发外）
	VK_DEVICE_FUNCTION_GET_AND_CALL(device, vkRegisterDisplayEventEXT,device, display, &displayEventInfo, nullptr, &fence);


	//导入payload
	

	VkImportFenceWin32HandleInfoKHR importFenceWin32HandleInfo{};
	importFenceWin32HandleInfo.sType = VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR;
	importFenceWin32HandleInfo.fence = fence;//fence不能是队列上且未执行的状态
	importFenceWin32HandleInfo.handle = fenceNTHandle;
	importFenceWin32HandleInfo.flags = VK_FENCE_IMPORT_TEMPORARY_BIT;
	importFenceWin32HandleInfo.pNext = nullptr;
	importFenceWin32HandleInfo.handleType = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT;
	//VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT以及VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT都是引用导入，都可以是临时的或者永久的
	if (importFenceWin32HandleInfo.handleType != VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT) {
		importFenceWin32HandleInfo.name = nullptr;
	}
	if (importFenceWin32HandleInfo.handle)
	{
		importFenceWin32HandleInfo.name = nullptr;
	}
	else {
		CONST WCHAR* name = L"tmp";//示例用法，可以设置一个名字来标识这个fence
		importFenceWin32HandleInfo.name = name;//示例用法，可以设置一个名字来标识这个fence
	}
	//导入fence可以多次导入同一个handle到vulkan的fence中,可以和原来的fence相同也可以不同
	VK_DEVICE_FUNCTION_GET_AND_CALL(device, vkImportFenceWin32HandleKHR,device, &importFenceWin32HandleInfo);


	VkImportFenceFdInfoKHR importFenceFDInfo {};
	importFenceFDInfo.sType = VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR;
	importFenceFDInfo.fd = fd;//导入的fd为 -1 且为VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT时表示引入一个已经触发的fence
	importFenceFDInfo.fence = fence;//fence不能是队列上且未执行的状态
	importFenceFDInfo.flags = VK_FENCE_IMPORT_TEMPORARY_BIT;
	importFenceFDInfo.handleType = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT;//VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT是引用，可以是临时或者永久的 ，VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT为复制fd，是临时性的，
	importFenceFDInfo.pNext = nullptr;
	//导入fence可以多次导入同一个handle到vulkan的fence中,可以和原来的fence相同也可以不同
	VK_DEVICE_FUNCTION_GET_AND_CALL(device,vkImportFenceFdKHR,device, &importFenceFDInfo);//导入fd到fence中

	//销毁fence
	vkDestroyFence(device, fence, nullptr);



}

struct SemaphoreCreateInfoExt
{
	VkExportMetalObjectCreateInfoEXT exportMetalObjectInfo{};
	VkExportSemaphoreCreateInfo exportSemaphoreInfo{};
	VkExportSemaphoreWin32HandleInfoKHR exportSemaphoreWin32HandleInfo{};
	VkImportMetalSharedEventInfoEXT importMetalSharedEventInfo{};
	VkQueryLowLatencySupportNV queryLowLatencySupportInfo{};
	VkSemaphoreTypeCreateInfo semaphoreTypeCreateInfo{};
	SemaphoreCreateInfoExt() {
		Init();
	}
	void Init() {
		exportMetalObjectInfo.sType = VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT;
		exportMetalObjectInfo.pNext = &exportSemaphoreInfo;
		exportSemaphoreInfo.sType = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO;
		exportSemaphoreInfo.pNext = &exportSemaphoreWin32HandleInfo;
		exportSemaphoreWin32HandleInfo.sType = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR;
		exportSemaphoreWin32HandleInfo.pNext = &importMetalSharedEventInfo;
		importMetalSharedEventInfo.sType = VK_STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT;
		importMetalSharedEventInfo.pNext = &queryLowLatencySupportInfo;
		queryLowLatencySupportInfo.sType = VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV;
		queryLowLatencySupportInfo.pNext = &semaphoreTypeCreateInfo;
		semaphoreTypeCreateInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO;
		semaphoreTypeCreateInfo.pNext = nullptr;
	}
};


void SyncronizationAndCacheControlTest::SemaphoreTest()
{
	VkSemaphore binarySemaphore{ nullptr }, timelineSemaphore{ nullptr };//queue间或queue与host间
	VkSemaphoreCreateInfo binarySemaphoreCreateInfo{};
	binarySemaphoreCreateInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;
	binarySemaphoreCreateInfo.flags = VK_FENCE_CREATE_SIGNALED_BIT;//创建一个触发的二状态信号量

	SemaphoreCreateInfoExt binarySemaphoreCreateInfoExt{};
	binarySemaphoreCreateInfo.pNext = &binarySemaphoreCreateInfoExt.exportMetalObjectInfo;//把扩展信息添加到信号量创建信息中
	//指定信号量的类型
	auto& binarySemaphoreTypeCreateInfoExt = binarySemaphoreCreateInfoExt.semaphoreTypeCreateInfo;
	binarySemaphoreTypeCreateInfoExt.semaphoreType = VK_SEMAPHORE_TYPE_BINARY;//VK_SEMAPHORE_TYPE_BINARY是二状态信号量（只有触发和未触发两种状态）,或者VK_SEMAPHORE_TYPE_TIMELINE是timeline信号量
	binarySemaphoreTypeCreateInfoExt.initialValue = 0;//如果是二状态信号量,初始值为0,如果是timeline信号量,初始值为一个指定的值

	//导出payload
	bool suportWin32HandleExport = false, surportFdHandleExport = false, surpotZircorExport = false;
	auto& exportSemaphoreInfo = binarySemaphoreCreateInfoExt.exportSemaphoreInfo;
	{
		//先获取可以导出payload的格式属性
		VkExternalSemaphoreProperties externalSemaphoreProperties{};
		VkPhysicalDeviceExternalSemaphoreInfo externalSemaphoreInfo{};//通过VkPhysicalDeviceExternalSemaphoreInfo指明要查询的导出句柄的类型
		externalSemaphoreInfo.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO;
		externalSemaphoreInfo.handleType = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT;
		//获取win32句柄的属性
		vkGetPhysicalDeviceExternalSemaphoreProperties(physicalDevice, &externalSemaphoreInfo, &externalSemaphoreProperties);
		suportWin32HandleExport = (externalSemaphoreProperties.externalSemaphoreFeatures & VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT) != 0;
		if (suportWin32HandleExport) {
			exportSemaphoreInfo.handleTypes |= VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT;

			auto& exportSemaphoreWin32HandleInfo = binarySemaphoreCreateInfoExt.exportSemaphoreWin32HandleInfo;//如果支持导出win32句柄就可以添加额外的属性描述信息,如果semaphoreCreateInfo的pNext中不含exportSemaphoreInfo，那么该结构体会被忽略
			exportSemaphoreWin32HandleInfo.sType = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR;//
			exportSemaphoreWin32HandleInfo.dwAccess = SEMAPHORE_ALL_ACCESS;//指定导出信号量的访问权限
			exportSemaphoreWin32HandleInfo.pAttributes = nullptr;//指定导出信号量的安全属性，先设置为nullptr即使用默认属性
			exportSemaphoreWin32HandleInfo.name = L"test";//指定导出信号量的名字，可以为空



		}
		externalSemaphoreInfo.handleType = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT;
		//获取fd的属性
		vkGetPhysicalDeviceExternalSemaphoreProperties(physicalDevice, &externalSemaphoreInfo, &externalSemaphoreProperties);
		surportFdHandleExport = (externalSemaphoreProperties.externalSemaphoreFeatures & VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT) != 0;

		if (surportFdHandleExport)
		{
			exportSemaphoreInfo.handleTypes |= VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT;
		}

		//获取Zircon共享内存导出
		externalSemaphoreInfo.handleType = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_ZIRCON_EVENT_BIT_FUCHSIA;
		//获取Zircon的属性
		vkGetPhysicalDeviceExternalSemaphoreProperties(physicalDevice, &externalSemaphoreInfo, &externalSemaphoreProperties);
		surpotZircorExport = (externalSemaphoreProperties.externalSemaphoreFeatures & VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT) != 0;

		if (surpotZircorExport)
		{
			exportSemaphoreInfo.handleTypes |= VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_ZIRCON_EVENT_BIT_FUCHSIA;
		}
	}

	//
	auto& queryLowLatencySupportNV = binarySemaphoreCreateInfoExt.queryLowLatencySupportInfo;
	queryLowLatencySupportNV.pQueriedLowLatencyData = nullptr;//这个结构体用于查询低延迟特性，如果不需要查询低延迟特性，可以设置为nullptr（待确认）

	//

	vkCreateSemaphore(device, &binarySemaphoreCreateInfo, nullptr, &binarySemaphore);//创建二状态信号

	//如果binarySemaphore已经导出了win32句柄，那么可以调用调用以下操作获取句柄
	HANDLE semaphoreHandle{ nullptr };
	if (suportWin32HandleExport)
	{
		
		VkSemaphoreGetWin32HandleInfoKHR getWin32HandleInfo{};
		getWin32HandleInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR;
		getWin32HandleInfo.pNext = nullptr;
		getWin32HandleInfo.semaphore = binarySemaphore;
		getWin32HandleInfo.handleType = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT;
		VK_DEVICE_FUNCTION_GET_AND_CALL(device, vkGetSemaphoreWin32HandleKHR, device, &getWin32HandleInfo, &semaphoreHandle);//同一个handle type的句柄只能导出一次，且不需要时需要关闭句柄
	}
	//如果binarySemaphore已经导出了fd句柄，那么可以调用以下操作获取句柄
	int fd{ -1 };
	if (surportFdHandleExport) {

		
		VkSemaphoreGetFdInfoKHR getFdInfo{};
		getFdInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR;
		getFdInfo.handleType = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT;
		getFdInfo.semaphore = binarySemaphore;
		getFdInfo.pNext = nullptr;
		VK_DEVICE_FUNCTION_GET_AND_CALL(device, vkGetSemaphoreFdKHR, device, &getFdInfo, &fd);//同一个handle type的fd只能导出一次，且不需要时需要关闭fd,相当于文件描述符，不需要时调用close(fd)关闭

	}

	//zircon句柄导出
	zx_handle_t zirconHandle;
	if (surpotZircorExport)
	{
		//zx_handle 主要出现在Fuchsia操作系统的Vulkan实现中。Fuchsia是Google开发的一个开源操作系统，旨在在广泛的设备上运行，包括手机、平板电脑、笔记本电脑和嵌入式设备。zx_handle 是Fuchsia中表示系统资源的一种通用句柄类型
		VkSemaphoreGetZirconHandleInfoFUCHSIA getZirconHandleInfo{};//用于获取Zircon共享内存句柄
		getZirconHandleInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA;
		getZirconHandleInfo.handleType = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_ZIRCON_EVENT_BIT_FUCHSIA;
		getZirconHandleInfo.semaphore = binarySemaphore;
		getZirconHandleInfo.pNext = nullptr;
		
		VK_DEVICE_FUNCTION_GET_AND_CALL(device, vkGetSemaphoreZirconHandleFUCHSIA, device, &getZirconHandleInfo, &zirconHandle);//同一个handle type的zircon handle只能导出一次，且不需要时需要关闭zircon handle
	}

	//导入payload
	//引入一个win32 handle
	//可以多次导入
	if (suportWin32HandleExport)
	{
		VkImportSemaphoreWin32HandleInfoKHR importSemaphoreWin32HandleInfo{};
		importSemaphoreWin32HandleInfo.sType = VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR;
		importSemaphoreWin32HandleInfo.flags = VK_SEMAPHORE_IMPORT_TEMPORARY_BIT;
		importSemaphoreWin32HandleInfo.handle = semaphoreHandle;//不需要时候主动关闭句柄
		importSemaphoreWin32HandleInfo.handleType = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT;//需要符合VkExternalSemaphoreProperties中的compitable的handle type
		//导入类型可以为VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT，VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT，VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT，都是引用导入，可以是临时或者永久的
		if (importSemaphoreWin32HandleInfo.handle || importSemaphoreWin32HandleInfo.handleType == VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT) {
			importSemaphoreWin32HandleInfo.name = nullptr;
		}
		else {
			importSemaphoreWin32HandleInfo.name = L"test";//如果handle无效就需要指定导入的信号量的名字
		}
		
		importSemaphoreWin32HandleInfo.pNext = nullptr;
		importSemaphoreWin32HandleInfo.semaphore = binarySemaphore;
		
		VK_DEVICE_FUNCTION_GET_AND_CALL(device, vkImportSemaphoreWin32HandleKHR, device, &importSemaphoreWin32HandleInfo);
	}
	
	//引入fd句柄
	if (surportFdHandleExport) {
		VkImportSemaphoreFdInfoKHR importSemaphoreFdInfo{};
		importSemaphoreFdInfo.sType = VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR;
		importSemaphoreFdInfo.fd = fd;//不需要时候主动关闭fd，如果类型是VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT，那么fd为-1可以表示一个已经触发的信号量
		importSemaphoreFdInfo.handleType = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT;//需要符合VkExternalSemaphoreProperties中的compitable的handle type
		//VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT是引用导入，可以是临时或者永久的，VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT是复制导入，是临时的
		importSemaphoreFdInfo.flags = VK_SEMAPHORE_IMPORT_TEMPORARY_BIT;//如果是VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT复制导入，那么flags必须为VK_SEMAPHORE_IMPORT_TEMPORARY_BIT，这里直接设置为临时导入
		importSemaphoreFdInfo.pNext = nullptr;
		importSemaphoreFdInfo.semaphore = binarySemaphore;
		VK_DEVICE_FUNCTION_GET_AND_CALL(device, vkImportSemaphoreFdKHR, device, &importSemaphoreFdInfo);


	}

	//引入zircon handle
	if (surpotZircorExport)
	{
		VkImportSemaphoreZirconHandleInfoFUCHSIA importSemaphoreZirconHandleInfo{};
		importSemaphoreZirconHandleInfo.sType = VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA;
		importSemaphoreZirconHandleInfo.flags = VK_SEMAPHORE_IMPORT_TEMPORARY_BIT;
		importSemaphoreZirconHandleInfo.pNext = nullptr;
		importSemaphoreZirconHandleInfo.semaphore = binarySemaphore;//不能是timeline信号量
		importSemaphoreZirconHandleInfo.handleType = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_ZIRCON_EVENT_BIT_FUCHSIA;//需要符合VkExternalSemaphoreProperties中的compitable的handle type,VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_ZIRCON_EVENT_BIT_FUCHSIA是引用导入，可以是临时或者永久的
		importSemaphoreZirconHandleInfo.zirconHandle = zirconHandle;
		
		VK_DEVICE_FUNCTION_GET_AND_CALL(device, vkImportSemaphoreZirconHandleFUCHSIA, device, &importSemaphoreZirconHandleInfo);



	}


	vkDestroySemaphore(device, binarySemaphore, nullptr);//销毁信号量







	//创建一个timeline信号量

	SemaphoreCreateInfoExt timelineSemaphoreCreateInfoExt{};
	VkSemaphoreCreateInfo timelineSemaphoreCreateInfo{};
	timelineSemaphoreCreateInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;;
	timelineSemaphoreCreateInfo.pNext = &timelineSemaphoreCreateInfoExt.exportMetalObjectInfo;
	timelineSemaphoreCreateInfo.flags = 0;//创建一个未触发的信号量
	auto& timelineSemaphoreTypeInfo = timelineSemaphoreCreateInfoExt.semaphoreTypeCreateInfo;
	timelineSemaphoreTypeInfo.initialValue = 0;//初始值为0
	timelineSemaphoreTypeInfo.semaphoreType = VK_SEMAPHORE_TYPE_TIMELINE_KHR;//创建timeline信号量
	VK_RESULT_CHECK_CALL(vkCreateSemaphore(device, &timelineSemaphoreCreateInfo, nullptr, &timelineSemaphore));

	uint64_t counterValue{ 0 };
	//获取当前时间线值
	vkGetSemaphoreCounterValue(device, timelineSemaphore, &counterValue);

	//触发timeline类型信号量
	VkSemaphoreSignalInfo semaphoreSignalInfo{
		.sType = VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO,
		.pNext = nullptr,
		.semaphore = timelineSemaphore,
		.value = 1000,//这个值必须大于当前时间线值且小于在pending状态下信号量触发操作的值，且差值不能大于maxTimelineSemaphoreValueDifference
		//.sType = VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO,
	};//无序初始化，顺序需要和定义的时候一样，不然会报错
	vkSignalSemaphore(device, &semaphoreSignalInfo);//触发timeline信号量，并且直接将信号量的当前值设置为value的值

	//等待timeline类型信号量触发
	VkSemaphoreWaitInfo semapheWaitInfo{};
	semapheWaitInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO;
	semapheWaitInfo.flags = VK_SEMAPHORE_WAIT_ANY_BIT;//VK_SEMAPHORE_WAIT_ANY_BIT表示等待任意信号量触发，如果没有设置则是表示等待所有信号量触发
	semapheWaitInfo.pNext = nullptr;
	semapheWaitInfo.pSemaphores = &timelineSemaphore;//这里的信号量都必须是timeline信号量
	semapheWaitInfo.semaphoreCount = 1;
	uint64_t signalValue = 1000;//触发需要的值
	semapheWaitInfo.pValues = &signalValue;//这里的值是触发信号量需要的值，不是等待时间
	vkWaitSemaphores(device, &semapheWaitInfo, VK_TIMEOUT);



	vkDestroySemaphore(device,timelineSemaphore, nullptr);//销毁信号量

	
}

//event这一节的内容先就这样，不再细究了，后面有实践机会再补充和深入理解
void SyncronizationAndCacheControlTest::EventTest()
{
	//如果VK_KHR_portability_subset 拓展开启且VkPhysicalDevicePortabilitySubsetFeaturesKHR::events 是 VK_FALSE,那么不支持使用event
	VkEvent vEvent{nullptr};//queue内或queue与host间
	VkEventCreateInfo eventCreateInfo{};
	eventCreateInfo.sType = VK_STRUCTURE_TYPE_EVENT_CREATE_INFO;
	//eventCreateInfo.pNext = nullptr;
	eventCreateInfo.flags = VK_EVENT_CREATE_DEVICE_ONLY_BIT;//创建一个只在device内部使用的event，如果为0则host也能用

	//pnext中只能含有两种结构体中的一种VkExportMetalObjectCreateInfoEXT和VkImportMetalSharedEventInfoEXT
	VkExportMetalObjectCreateInfoEXT exportMetalObjectInfo{};
	exportMetalObjectInfo.sType = VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT;
	exportMetalObjectInfo.pNext = nullptr;
	exportMetalObjectInfo.exportObjectType = VK_EXPORT_METAL_OBJECT_TYPE_METAL_SHARED_EVENT_BIT_EXT;
	eventCreateInfo.pNext = &exportMetalObjectInfo;

	

	VK_RESULT_CHECK_CALL(vkCreateEvent(device, &eventCreateInfo, nullptr, &vEvent));


	//获取event状态
	auto res = vkGetEventStatus(device, vEvent);
	switch (res)
	{
	case VK_EVENT_SET: break;//event成功触发
	case VK_EVENT_RESET:break;//event未触发
	default:
		break;//查询失败返回VK_ERROR_OUT_OF_HOST_MEMORY VK_ERROR_OUT_OF_DEVICE_MEMORY VK_ERROR_DEVICE_LOST
	}

	//触发event
	vkSetEvent(device, vEvent);//如果队列中执行的命令需要等待host端的event，那么必须保证在提交命令前host端的event已经触发，该event就不能以VK_EVENT_CREATE_DEVICE_ONLY_BIT创建

	//重置event到未触发状态
	vkResetEvent(device, vEvent);//该event就不能以VK_EVENT_CREATE_DEVICE_ONLY_BIT创建

	//如果在命令缓冲区中触发event
	if (0)//这里没有cmdbuf的创建，所以这里的代码不会执行，只是为了展示
	{
		VkCommandBuffer cmdBuf{};
		VkDependencyInfo eventDependencyInfo{};
		eventDependencyInfo.sType = VK_STRUCTURE_TYPE_DEPENDENCY_INFO;
		eventDependencyInfo.pNext = nullptr;
		eventDependencyInfo.dependencyFlags = 0;//这里目前还不怎么清楚，直接先设置为0
		eventDependencyInfo.memoryBarrierCount = 0;
		eventDependencyInfo.pMemoryBarriers = nullptr;
		eventDependencyInfo.bufferMemoryBarrierCount = 0;
		eventDependencyInfo.pBufferMemoryBarriers = nullptr;
		eventDependencyInfo.imageMemoryBarrierCount = 0;
		eventDependencyInfo.pImageMemoryBarriers = nullptr;
		vkCmdSetEvent2(cmdBuf, vEvent, &eventDependencyInfo);//必须在命令的render pass实例外调用
	
		vkCmdResetEvent2(cmdBuf, vEvent, VkPipelineStageFlagBits::VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT);//必须在命令的render pass实例外调用

		vkCmdWaitEvents2(cmdBuf, 1, &vEvent, &eventDependencyInfo);//可以和vkCmdSetEvent2和vkCmdResetEvent之间有内存依赖,和vkCmdSetEvent2有内存依赖，且不能等待vkCmdSetEvent触发的event

		vkCmdSetEvent(cmdBuf, vEvent, VkPipelineStageFlagBits::VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT);//必须在命令的render pass实例外调用
	

		vkCmdResetEvent(cmdBuf, vEvent, VkPipelineStageFlagBits::VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT);//必须在命令的render pass实例外调用

		vkCmdWaitEvents(cmdBuf, 1, &vEvent, VkPipelineStageFlagBits::VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT, VkPipelineStageFlagBits::VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT, 0, nullptr, 0, nullptr, 0, nullptr);//只能等待vkCmdSetEvent触发的event
	}



	vkDestroyEvent(device, vEvent, nullptr);
	VkImportMetalSharedEventInfoEXT importMetalSharedEventInfo{};
	importMetalSharedEventInfo.sType = VK_STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT;
	importMetalSharedEventInfo.pNext = nullptr;
	//importMetalSharedEventInfo.mtlSharedEvent = metalSharedEvent;


}

void SyncronizationAndCacheControlTest::MemoryBarrierTest()
{
}

void SyncronizationAndCacheControlTest::BufferMemoryBarrierTest()
{
}

void SyncronizationAndCacheControlTest::ImageMemoryBarrierTest()
{
}







































NS_TEST_END
